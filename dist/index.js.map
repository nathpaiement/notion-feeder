{"version":3,"file":"index.js","mappings":";;;;;;;AAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,mBAAO,CAAC,IAAW;AACrC,iBAAiB,mBAAO,CAAC,IAAU;AACnC,kBAAkB,mBAAO,CAAC,IAAW;AACrC,wBAAwB,mBAAO,CAAC,GAAiB;AACjD,qBAAqB,mBAAO,CAAC,IAAY;AACzC,uBAAuB,mBAAO,CAAC,IAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,uBAAuB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kCAAkC;AACtD,6DAA6D,cAAc;AAC3E;AACA;AACA;AACA;AACA,+BAA+B,qDAAqD,EAAE,KAAK;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,mEAAmE,cAAc;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA,kBAAe;AACf;AACA;AACA;;;;;;;;ACnXa;AACb;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,GAAG,sBAAsB,GAAG,qBAAqB,GAAG,qBAAqB,GAAG,sBAAsB,GAAG,mBAAmB,GAAG,2BAA2B,GAAG,yBAAyB,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,gBAAgB,GAAG,uBAAuB,GAAG,kBAAkB,GAAG,eAAe,GAAG,kBAAkB,GAAG,iBAAiB,GAAG,eAAe,GAAG,eAAe;AAC7Y,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,0BAA0B,UAAU,cAAc,cAAc;AAChE;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/Ja;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,GAAG,wBAAwB,GAAG,gCAAgC,GAAG,2BAA2B,GAAG,2BAA2B,GAAG,2BAA2B,GAAG,uBAAuB,GAAG,oBAAoB;AAClO,kBAAkB,mBAAO,CAAC,IAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C,oBAAoB,KAAK;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD,uBAAuB,KAAK;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,gBAAgB,qCAAqC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uHAAuH,YAAY;AACnI,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1Ma;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,YAAY,GAAG,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,MAAM;AAClE;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;;;ACvBa;AACb,6BAA6C,EAAE,aAAa,CAAC;AAC7D,yBAA2B,GAAG,yBAA2B,GAAG,yBAAgC,GAAG,yBAAwB,GAAG,yBAAuB,GAAG,yBAAoB,GAAG,aAAgB,GAAG,UAAc;AAC5M,eAAe,mBAAO,CAAC,IAAU;AACjC,sCAAyC,EAAE,qCAAqC,4BAA4B,EAAC;AAC7G,gBAAgB,mBAAO,CAAC,IAAW;AACnC,sCAA2C,EAAE,qCAAqC,8BAA8B,EAAC;AACjH,eAAe,mBAAO,CAAC,IAAU;AACjC,6BAA+C,EAAE,qCAAqC,iCAAiC,CAAC;AACxH,6BAAkD,EAAE,qCAAqC,oCAAoC,CAAC;AAC9H,6BAAmD,EAAE,qCAAqC,qCAAqC,CAAC;AAChI,6BAA2D,EAAE,qCAAqC,6CAA6C,CAAC;AAChJ,6BAAsD,EAAE,qCAAqC,wCAAwC,CAAC;AACtI;AACA,6BAAsD,EAAE,qCAAqC,wCAAwC,CAAC;AACtI;;;;;;;;ACfa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,wBAAwB,GAAG,yBAAyB,GAAG,gBAAgB;AACvE,kBAAkB,mBAAO,CAAC,IAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC,gBAAgB,KAAK;AACxD;AACA;AACA,0BAA0B,MAAM,EAAE,MAAM;AACxC;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;;;;;;;ACnCa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,0BAA0B,GAAG,wBAAwB;AACrD,kCAAkC,mBAAO,CAAC,IAAS;AACnD,uCAAuC,mBAAO,CAAC,IAAc;AAC7D,mBAAmB,mBAAO,CAAC,IAAmB;AAC9C,qCAAqC,mBAAO,CAAC,EAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;;;;;;;AC3Ca;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,gBAAgB,GAAG,aAAa,GAAG,YAAY,GAAG,wBAAwB,GAAG,wBAAwB,GAAG,oBAAoB,GAAG,kBAAkB,GAAG,kBAAkB,GAAG,yBAAyB,GAAG,aAAa,GAAG,kBAAkB,GAAG,YAAY,GAAG,iBAAiB;AAC9R;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iBAAiB;AACjB;;;;;;;;ACrJa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,gBAAgB;AAChB;;;;;;;;AC7Ba;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa,mBAAO,CAAC,IAAU;AAC/B,aAAa,mBAAO,CAAC,EAAU;AAC/B;;;;;;;;ACda;AACb;AACA;AACA,mCAAmC,oCAAoC,gBAAgB;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,qBAAqB,GAAG,mBAAmB;AAC3C,4BAA4B,mBAAO,CAAC,IAAW;AAC/C,cAAc,mBAAO,CAAC,IAAK;AAC3B;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,gIAAgI;AAChI,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,yDAAyD,qBAAqB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB;AACrB;;;;;;;;ACpMY;;AAEZ;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;ACRY;;AAEZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;ACrBa;AACb,gBAAgB,mBAAO,CAAC,IAAa;;AAErC;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C;AAC5C;AACA,IAAI;AACJ;AACA;AACA,iBAAiB;AACjB;AACA,2BAA2B;AAC3B;AACA;AACA,GAAG;AACH,wBAAwB;AACxB;AACA;AACA;;AAEA,oBAAoB;;AAEpB;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA,2BAA2B;AAC3B,+BAA+B;AAC/B;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,YAAY;AACZ;AACA;AACA;AACA,IAAI;;AAEJ,UAAU;AACV;AACA;AACA;AACA,IAAI;;AAEJ,sBAAsB;AACtB;AACA;AACA,IAAI;;AAEJ,yBAAyB;AACzB;AACA;AACA,IAAI;;AAEJ,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ,sBAAsB;AACtB;AACA,IAAI;;AAEJ,yBAAyB;AACzB;AACA,IAAI;;AAEJ,oBAAoB;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;AClkBA;AACa;AACb;;AAEA,WAAW,mBAAO,CAAC,IAAQ;AAC3B,YAAY,mBAAO,CAAC,IAAS;AAC7B,gBAAgB,mBAAO,CAAC,IAAa;AACrC,+BAA+B,mBAAO,CAAC,IAA4B;;AAEnE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,gBAAgB;AAChB,gCAAgC;AAChC;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,aAAa;AACb;AACA,IAAI;;AAEJ,YAAY,kBAAkB;;AAE9B,CAAC;;AAED;AACA;;;;;;;;;ACvHa;;AAEb,WAAW,mBAAO,CAAC,IAAQ;AAC3B,iBAAiB,mBAAO,CAAC,GAAc;;AAEvC;AACA;;AAEA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,+BAA+B;AAC/B,mCAAmC;AACnC,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA;;AAEA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,+BAA+B;AAC/B,mCAAmC;AACnC,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,iBAAiB;AACjB;AACA;AACA,+BAA+B;AAC/B,mCAAmC;AACnC,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;;;;;;;;;ACtHa;AACb;;AAEA,WAAW,mBAAO,CAAC,IAAQ;AAC3B,oBAAoB,mBAAO,CAAC,IAAiB;;AAE7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,oBAAoB;AACxC;AACA,yCAAyC,UAAU,OAAO;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,WAAW;AACX;AACA,IAAI;AACJ,CAAC;;;;;;;;;ACtCY;AACb;;AAEA,WAAW,mBAAO,CAAC,IAAQ;AAC3B,eAAe,mBAAO,CAAC,IAAY;;AAEnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,IAAI;;AAEJ,gBAAgB;AAChB;AACA;AACA,IAAI;;AAEJ,gBAAgB;AAChB;AACA;AACA;AACA;AACA,IAAI;;AAEJ,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,mCAAmC;AACnC,IAAI;;AAEJ,uBAAuB;AACvB,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,uBAAuB;AAC7B,6BAA6B;AAC7B,IAAI;;AAEJ;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,mBAAmB;AACnB,IAAI;;AAEJ,CAAC;;;;;;;;;AC/EY;AACb;;AAEA,YAAY,mBAAO,CAAC,GAAS;;AAE7B;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,CAAC;;;;;;;;;ACXY;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;;;;;;;;;ACrIa;AACb;;AAEA,eAAe,mBAAO,CAAC,IAAY;AACnC,mBAAmB,mBAAO,CAAC,IAAgB;AAC3C,iBAAiB,mBAAO,CAAC,IAAc;AACvC,YAAY,mBAAO,CAAC,IAAS;AAC7B,UAAU,mBAAO,CAAC,IAAY;;AAE9B;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,YAAY,uBAAuB;AACnC,YAAY,oCAAoC;AAChD,aAAa,oCAAoC;AACjD;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;AC7Fa;AACb;AACA,YAAY,mBAAO,CAAC,IAAS;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,kBAAkB,wBAAwB;AACtD,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,cAAc;AACd,2BAA2B;AAC3B;AACA;AACA,IAAI;;AAEJ,SAAS;AACT;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,YAAY;AACZ;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,aAAa;AACb;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,cAAc;AACd;AACA,IAAI;;AAEJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,aAAa;AACb;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA,SAAS,eAAe;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;ACzLa;AACb;;AAEA,WAAW,mBAAO,CAAC,IAAQ;AAC3B,eAAe,mBAAO,CAAC,IAAY;AACnC,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,cAAc,mBAAO,CAAC,IAAW;AACjC,WAAW,mBAAO,CAAC,IAAQ;AAC3B,cAAc,mBAAO,CAAC,IAAW;AACjC,YAAY,mBAAO,CAAC,GAAS;AAC7B,uBAAuB,mBAAO,CAAC,IAAoB;AACnD,4BAA4B,mBAAO,CAAC,IAAyB;AAC7D,wBAAwB,mBAAO,CAAC,IAAqB;AACrD,iBAAiB,mBAAO,CAAC,IAAc;AACvC,mBAAmB,mBAAO,CAAC,IAAgB;AAC3C,iBAAiB,mBAAO,CAAC,IAAc;AACvC,UAAU,mBAAO,CAAC,IAAO;AACzB,aAAa,mBAAO,CAAC,IAAU;AAC/B,aAAa,mBAAO,CAAC,IAAU;AAC/B,UAAU,mBAAO,CAAC,IAAY;AAC9B,WAAW,mBAAO,CAAC,IAAY;AAC/B,UAAU,mBAAO,CAAC,IAAO;AACzB,YAAY,mBAAO,CAAC,IAAS;AAC7B,aAAa,mBAAO,CAAC,IAAqB;AAC1C;AACA,oBAAoB,kDAAiC;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,KAAK;AACL;AACA;AACA,eAAe;AACf,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,IAAI;;AAEJ;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,IAAI;;AAEJ,cAAc,mBAAmB;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA,iBAAiB,kBAAkB,uBAAuB,kBAAkB;AAC5E,gBAAgB;AAChB;AACA;AACA,IAAI;;AAEJ,oBAAoB;AACpB;AACA,IAAI;AACJ,mBAAmB;AACnB;AACA,IAAI;AACJ,4BAA4B;AAC5B;AACA,IAAI;AACJ,iCAAiC;AACjC;AACA;AACA;AACA,IAAI;;AAEJ,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,GAAG,2BAA2B;;AAE9B,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,2BAA2B;;AAE9B;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;AAEJ,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,qBAAqB;AACrB,iBAAiB;AACjB,mCAAmC;AACnC;AACA;;AAEA;AACA,IAAI;;AAEJ;AACA,uBAAuB;AACvB,iBAAiB;AACjB,mCAAmC;AACnC;AACA;;AAEA;AACA,IAAI;;AAEJ,yBAAyB;AACzB;AACA,gCAAgC;AAChC;AACA,IAAI;;AAEJ,yBAAyB;AACzB;AACA;AACA;AACA,IAAI;;AAEJ,6BAA6B;AAC7B;AACA,iDAAiD,6BAA6B;AAC9E;AACA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,kBAAkB;AAClB;AACA;AACA;AACA,IAAI;;AAEJ,kBAAkB;AAClB;AACA;AACA;AACA,IAAI;;AAEJ,iBAAiB;AACjB;AACA;AACA;AACA,IAAI;;AAEJ,oBAAoB;AACpB;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,IAAI;;AAEJ,gCAAgC;AAChC;AACA;AACA,IAAI;;AAEJ;AACA,uBAAuB,4CAA4C;AACnE,0BAA0B,+CAA+C;AACzE,4BAA4B,iDAAiD;AAC7E,4BAA4B,iDAAiD;;AAE7E,eAAe;AACf;AACA,iDAAiD;;AAEjD;;AAEA;AACA;;AAEA;AACA,IAAI;;AAEJ,gBAAgB;AAChB;AACA,GAAG,2BAA2B;;AAE9B;AACA,YAAY,yBAAyB,gBAAgB;AACrD,kBAAkB,+BAA+B,mBAAmB;AACpE,iBAAiB,8BAA8B,6BAA6B;AAC5E,SAAS,sBAAsB,yBAAyB;AACxD,YAAY,gCAAgC;AAC5C,cAAc,gBAAgB;AAC9B,YAAY,gCAAgC;AAC5C,kBAAkB,gBAAgB;AAClC;AACA;AACA,+DAA+D;AAC/D,EAAE;AACF;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,yDAAyD;AACzD,GAAG;AACH,mCAAmC,mBAAmB;AACtD,qCAAqC,mBAAmB;AACxD,sCAAsC,mBAAmB;AACzD,sCAAsC,mBAAmB;AACzD,mCAAmC,mBAAmB;;AAEtD;AACA,aAAa,kBAAkB,6BAA6B;AAC5D,mBAAmB,kBAAkB,6BAA6B;;AAElE;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA,UAAU;AACV;AACA,IAAI;AACJ,YAAY,gBAAgB;AAC5B,YAAY,gBAAgB;AAC5B,aAAa,gBAAgB;AAC7B,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,aAAa,gBAAgB;AAC7B,aAAa,kBAAkB,cAAc;AAC7C,mBAAmB,kBAAkB,gBAAgB;AACrD;AACA,sBAAsB,0BAA0B;AAChD;AACA,GAAG;AACH;AACA,sBAAsB,0BAA0B;AAChD;AACA,GAAG;;AAEH,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ,aAAa;AACb;AACA,IAAI;;AAEJ,UAAU;AACV;AACA,IAAI;;AAEJ,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,eAAe;AACf;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,aAAa;AACb;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;;AAEJ;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;;AAEJ;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;;AAEJ;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI;;;AAGJ;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,cAAc;AACd;AACA;AACA,IAAI;;AAEJ,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA,IAAI;;AAEJ,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,mBAAmB;AACnB;AACA,IAAI;;AAEJ,sBAAsB;AACtB;AACA;AACA;;AAEA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;AACA,+BAA+B;AAC/B;AACA,kCAAkC,cAAc;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACn3Ba;AACb;;AAEA,WAAW,mBAAO,CAAC,IAAQ;AAC3B,eAAe,mBAAO,CAAC,IAAY;AACnC,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,cAAc,mBAAO,CAAC,IAAW;AACjC,aAAa,mBAAO,CAAC,IAAU;AAC/B,YAAY,mBAAO,CAAC,IAAS;;AAE7B;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,6BAA6B;AAC3C;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA,IAAI;AACJ,sBAAsB;AACtB;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,WAAW;AACX;AACA,IAAI;AACJ,aAAa;AACb;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA,GAAG;AACH;AACA,sBAAsB,0BAA0B;AAChD;AACA,GAAG;;AAEH,CAAC;;;;;;;;;ACnEY;AACb;;AAEA,WAAW,mBAAO,CAAC,IAAQ;AAC3B,WAAW,mBAAO,CAAC,IAAQ;AAC3B,gBAAgB,mBAAO,CAAC,IAAa;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,kBAAkB,oBAAoB;AACpD;AACA,sBAAsB,cAAc;AACpC;AACA,GAAG;;AAEH;AACA,WAAW;AACX;AACA,IAAI;;AAEJ,aAAa;AACb;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;ACnCa;AACb;;AAEA,UAAU,mBAAO,CAAC,IAAY;AAC9B,YAAY,mBAAO,CAAC,IAAS;AAC7B;AACA,iBAAiB,mBAAO,CAAC,IAAc;AACvC,WAAW,mBAAO,CAAC,IAAQ;AAC3B,eAAe,mBAAO,CAAC,IAAY;AACnC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,0BAA0B,mBAAO,CAAC,IAAuB;AACzD,mBAAmB,mBAAO,CAAC,IAAgB;AAC3C,mBAAmB,mBAAO,CAAC,IAAgB;AAC3C,aAAa,mBAAO,CAAC,IAAU;AAC/B,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,gBAAgB,mBAAO,CAAC,IAAa;AACrC,+BAA+B,mBAAO,CAAC,IAA4B;AACnE,mBAAmB,mBAAO,CAAC,IAAgB;;AAE3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4CAA4C;AAC5C,4CAA4C;AAC5C,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA,IAAI;AACJ,aAAa;AACb;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,cAAc,kBAAkB,uBAAuB;AACvD;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD,KAAK;AACL;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,cAAc;AACd;AACA;AACA;AACA;AACA,IAAI;;AAEJ,gBAAgB;AAChB;AACA;AACA;AACA;AACA,IAAI;;;AAGJ,uBAAuB;AACvB,oCAAoC,cAAc;AAClD;AACA;AACA;AACA,IAAI;;AAEJ,sBAAsB;AACtB,mCAAmC,cAAc;AACjD;AACA;AACA;AACA,IAAI;;AAEJ,uBAAuB;AACvB;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA,IAAI;;AAEJ,4BAA4B;AAC5B;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;AAEJ,4BAA4B;AAC5B;AACA;AACA,mCAAmC;AACnC;AACA;AACA,0CAA0C;AAC1C;AACA,IAAI;;AAEJ,uBAAuB;AACvB;AACA,IAAI;;AAEJ;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;AAEJ,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,wBAAwB;AACxB,iDAAiD;AACjD;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA,yDAAyD,IAAI;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA,IAAI;;AAEJ,oBAAoB;AACpB;AACA;AACA,IAAI;;AAEJ,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;;AAE9B;AACA,IAAI;;AAEJ,wBAAwB;AACxB;AACA;AACA;AACA;AACA,IAAI;;AAEJ,kBAAkB;AAClB;AACA;AACA;AACA;AACA,IAAI;;AAEJ,oBAAoB;AACpB;AACA;AACA;AACA;AACA,IAAI;;AAEJ,mBAAmB;AACnB;AACA,IAAI;;AAEJ,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK,yBAAyB,EAYtC;AACL,wBAAwB;AACxB;AACA,IAAI;;AAEJ;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;AAEJ,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,sCAAsC,kBAAkB;AACxD;AACA,QAAQ;AACR;AACA;AACA,qCAAqC,8BAA8B;AACnE;AACA;AACA;AACA;AACA,IAAI;;AAEJ,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,uBAAuB;AACvB;AACA;AACA;AACA,KAAK;AACL,IAAI;;AAEJ;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,eAAe,kBAAkB,gCAAgC;AACjE;AACA,WAAW;AACX;AACA,IAAI;;AAEJ;AACA;AACA,2BAA2B,WAAW;;AAEtC;AACA;AACA,kCAAkC,cAAc;;AAEhD,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,qBAAqB,sBAAsB;;AAE9C,aAAa;AACb;AACA,IAAI;;AAEJ,aAAa;AACb;AACA;AACA,6CAA6C;AAC7C;AACA,GAAG;AACH;AACA,IAAI;;AAEJ,mBAAmB;AACnB;AACA,IAAI;;AAEJ,sBAAsB;AACtB;AACA;AACA;;AAEA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C;AAC9C;AACA;AACA,sBAAsB,4BAA4B;AAClD,GAAG;AACH,sBAAsB;AACtB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;;AAEJ,UAAU;AACV;AACA,IAAI;;AAEJ,eAAe;AACf;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH,eAAe;AACf;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,cAAc,kBAAkB,+BAA+B;AAC/D,cAAc,kBAAkB,qBAAqB;AACrD;AACA,sBAAsB,oBAAoB;AAC1C,uBAAuB,iBAAiB;AACxC,GAAG;AACH;AACA,sBAAsB,oBAAoB;AAC1C;AACA,2CAA2C;AAC3C;AACA,KAAK;AACL,GAAG;AACH,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,GAAG,oBAAoB,gBAAgB;AACvC,UAAU;AACV;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,yBAAyB;AACzB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA,KAAK;AACL,UAAU;AACV;AACA;AACA,KAAK;;AAEL,eAAe;AACf;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,KAAK;;AAEL,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,qBAAqB,OAAO;AAC5B;AACA;;AAEA;AACA;;AAEA,4CAA4C,YAAY;AACxD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,iCAAiC;AACtE;AACA;;AAEA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;;;;;;;;;ACjrCa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,cAAc;AAC/B,qBAAqB;AACrB;AACA,IAAI;;AAEJ,8BAA8B;AAC9B;AACA;AACA,IAAI;;AAEJ,oBAAoB;AACpB;AACA,IAAI;;AAEJ,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,CAAC;;;;;;;;;ACjEY;AACb,YAAY,mBAAO,CAAC,GAAS;AAC7B,iBAAiB,mBAAO,CAAC,IAAc;AACvC,YAAY,mBAAO,CAAC,IAAS;;AAE7B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,GAAG;AACpC;;AAEA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;;;;;;;;ACzSa;AACb;;AAEA,WAAW,mBAAO,CAAC,IAAQ;;AAE3B;AACA;AACA;AACA;AACA;AACA,IAAI,iBAAiB,eAAe,mBAAmB,KAAK;AAC5D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA,KAAK;;AAEL,UAAU;AACV;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA,KAAK;;AAEL,gBAAgB;AAChB;AACA;AACA,wCAAwC,MAAM;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA,UAAU;AACV;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;AC3FY;AACb;;AAEA,eAAe,mBAAO,CAAC,IAAY;AACnC,mBAAmB,mBAAO,CAAC,IAAgB;AAC3C,WAAW,mBAAO,CAAC,IAAQ;AAC3B,gBAAgB,qCAA4B;AAC5C,WAAW,mBAAO,CAAC,IAAY;AAC/B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,mBAAmB;AACnB,yBAAyB;AACzB,UAAU;AACV,SAAS,aAAa;AACtB,OAAO;AACP,UAAU,eAAe;AACzB,SAAS,cAAc;AACvB,SAAS,eAAe;AACxB,iBAAiB;AACjB,SAAS,cAAc;AACvB,UAAU;AACV,UAAU;AACV,QAAQ,mBAAmB;AAC3B,QAAQ,kBAAkB;AAC1B,OAAO,kBAAkB;AACzB,cAAc,gBAAgB;AAC9B,OAAO,yBAAyB;AAChC,SAAS,eAAe;AACxB,UAAU,gBAAgB;AAC1B,qBAAqB;AACrB,UAAU,cAAc;AACxB,wBAAwB,mBAAmB;AAC3C,UAAU;AACV,UAAU,eAAe;AACzB,WAAW,gBAAgB;AAC3B,WAAW,mBAAmB;AAC9B,OAAO,eAAe;AACtB,aAAa,uBAAuB;AACpC,cAAc,uBAAuB;AACrC,4BAA4B,iCAAiC;AAC7D,mBAAmB,iBAAiB;AACpC,UAAU,qBAAqB;AAC/B,UAAU,2BAA2B;AACrC,QAAQ,qBAAqB;AAC7B,mCAAmC,iBAAiB;AACpD,QAAQ,wBAAwB;AAChC,UAAU,cAAc;AACxB,YAAY,gBAAgB;AAC5B,QAAQ,eAAe;AACvB,UAAU,gBAAgB;AAC1B,SAAS,kBAAkB;AAC3B,OAAO,cAAc;AACrB,SAAS,cAAc;AACvB,oBAAoB,wBAAwB;AAC5C,0BAA0B,2BAA2B;AACrD,oBAAoB,kBAAkB;AACtC,iBAAiB,gBAAgB;AACjC,OAAO,gBAAgB;AACvB,YAAY,iCAAiC;AAC7C,aAAa,yBAAyB;AACtC,mBAAmB,gCAAgC;AACnD,iBAAiB,+BAA+B;AAChD,4BAA4B,gCAAgC;AAC5D,oBAAoB,0BAA0B;AAC9C,iBAAiB,6BAA6B;AAC9C,qBAAqB,qBAAqB;AAC1C,gBAAgB,4BAA4B;AAC5C,aAAa,8BAA8B;AAC3C,qBAAqB,0BAA0B;AAC/C,qBAAqB,8BAA8B;AACnD,mBAAmB,8BAA8B;AACjD,WAAW,wBAAwB;AACnC,aAAa,gBAAgB;AAC7B,UAAU,cAAc;AACxB,mBAAmB;AACnB,yBAAyB;AACzB,UAAU;AACV,SAAS,aAAa;AACtB,QAAQ,cAAc;AACtB,yBAAyB;AACzB,WAAW,iBAAiB;AAC5B,oBAAoB,gCAAgC;AACpD,SAAS,eAAe;AACxB,WAAW,gBAAgB;AAC3B,cAAc,uBAAuB;AACrC,QAAQ,gBAAgB;AACxB,OAAO;AACP,QAAQ,gBAAgB;AACxB,gBAAgB,eAAe;AAC/B,OAAO,sCAAsC;AAC7C,yBAAyB,gBAAgB;AACzC,UAAU,sBAAsB;AAChC,QAAQ,gBAAgB;AACxB,iBAAiB;AACjB,SAAS,iBAAiB;AAC1B,UAAU,iBAAiB;AAC3B,SAAS,cAAc;AACvB,QAAQ,cAAc;AACtB,MAAM,gBAAgB;AACtB,gBAAgB,4BAA4B;AAC5C,oBAAoB,0BAA0B;AAC9C,eAAe,6BAA6B;AAC5C,gBAAgB,gBAAgB;AAChC,MAAM,kBAAkB;AACxB,SAAS,cAAc;AACvB,SAAS,cAAc;AACvB,gBAAgB,gBAAgB;AAChC,kBAAkB,gBAAgB;AAClC,UAAU,uBAAuB;AACjC,aAAa,gBAAgB;AAC7B,SAAS,eAAe;AACxB,yBAAyB;AACzB,uBAAuB;AACvB,OAAO,eAAe;AACtB,OAAO;AACP,UAAU,YAAY;AACtB,SAAS,qBAAqB;AAC9B,WAAW,eAAe;AAC1B,YAAY,wBAAwB;AACpC,kBAAkB,0BAA0B;AAC5C,SAAS,eAAe;AACxB,QAAQ,eAAe;AACvB,UAAU,gBAAgB;AAC1B,qBAAqB;AACrB,SAAS,cAAc;AACvB,OAAO,yBAAyB;AAChC,QAAQ,2BAA2B;AACnC,SAAS,eAAe;AACxB,QAAQ,gBAAgB;AACxB,UAAU,cAAc;AACxB,OAAO,yBAAyB;AAChC,QAAQ,yBAAyB;AACjC,iBAAiB;AACjB,UAAU,iBAAiB;AAC3B,QAAQ,sBAAsB;AAC9B,QAAQ,kBAAkB;AAC1B,UAAU,cAAc;AACxB,oBAAoB,qBAAqB;AACzC,gBAAgB,+BAA+B;AAC/C,eAAe,6BAA6B;AAC5C,qBAAqB,0BAA0B;AAC/C,qBAAqB,qBAAqB;AAC1C,kBAAkB,2BAA2B;AAC7C,WAAW,wBAAwB;AACnC,iBAAiB,wBAAwB;AACzC,mBAAmB,6BAA6B;AAChD,oBAAoB,2BAA2B;AAC/C,gBAAgB,2BAA2B;AAC3C,cAAc,yBAAyB;AACvC,aAAa,0BAA0B;AACvC,oBAAoB,yBAAyB;AAC7C,eAAe,oBAAoB;AACnC,kBAAkB,qBAAqB;AACvC,OAAO,uBAAuB;AAC9B,cAAc,kBAAkB;AAChC,iBAAiB,8BAA8B;AAC/C,kBAAkB,yBAAyB;AAC3C,sBAAsB,0BAA0B;AAChD,QAAQ,mCAAmC;AAC3C,mBAAmB,gBAAgB;AACnC,OAAO,kBAAkB;AACzB,MAAM,eAAe;AACrB,OAAO,sBAAsB;AAC7B,aAAa,eAAe;AAC5B,aAAa,gBAAgB;AAC7B,QAAQ,cAAc;AACtB,QAAQ,iBAAiB;AACzB,UAAU,iBAAiB;AAC3B,OAAO,8BAA8B;AACrC,sBAAsB,6BAA6B;AACnD,yBAAyB,gCAAgC;AACzD,kBAAkB,mBAAmB;AACrC,OAAO,4BAA4B;AACnC,oBAAoB,cAAc;AAClC,OAAO,wBAAwB;AAC/B,aAAa,gCAAgC;AAC7C,cAAc,oBAAoB;AAClC,iBAAiB,6BAA6B;AAC9C,cAAc,2BAA2B;AACzC,uBAAuB,qCAAqC;AAC5D,kBAAkB,gCAAgC;AAClD,mBAAmB,2BAA2B;AAC9C,gBAAgB,mCAAmC;AACnD,sBAAsB,wCAAwC;AAC9D,WAAW,wBAAwB;AACnC,kBAAkB,uBAAuB;AACzC,qBAAqB,gCAAgC;AACrD,2BAA2B,qCAAqC;AAChE,eAAe,4BAA4B;AAC3C,yBAAyB,6BAA6B;AACtD,oBAAoB,+BAA+B;AACnD,yBAAyB,2BAA2B;AACpD,wBAAwB,6BAA6B;AACrD,0BAA0B,qBAAqB;AAC/C,kBAAkB,uBAAuB;AACzC,oBAAoB,yCAAyC;AAC7D,oBAAoB,+BAA+B;AACnD,oBAAoB,oBAAoB;AACxC,iBAAiB,6BAA6B;AAC9C,iBAAiB,0BAA0B;AAC3C,QAAQ;AACR,UAAU,YAAY;AACtB,SAAS;AACT,UAAU;AACV,SAAS,aAAa;AACtB,UAAU,cAAc;AACxB,yBAAyB;AACzB,SAAS,gBAAgB;AACzB,WAAW,eAAe;AAC1B,wBAAwB,0BAA0B;AAClD,MAAM,gBAAgB;AACtB,yBAAyB;AACzB,yBAAyB;AACzB,UAAU;AACV,QAAQ,iBAAiB;AACzB,aAAa,uBAAuB;AACpC,mBAAmB,oBAAoB;AACvC,OAAO,cAAc;AACrB,OAAO,aAAa;AACpB,aAAa,uBAAuB;AACpC,QAAQ,cAAc;AACtB,YAAY,yBAAyB;AACrC,sBAAsB,yBAAyB;AAC/C,SAAS,mBAAmB;AAC5B,cAAc,wBAAwB;AACtC,QAAQ,wBAAwB;AAChC,qBAAqB;AACrB,OAAO,yBAAyB;AAChC,QAAQ,0BAA0B;AAClC,mBAAmB;AACnB,UAAU,eAAe;AACzB,QAAQ,kBAAkB;AAC1B,UAAU,iBAAiB;AAC3B,OAAO,aAAa;AACpB,kBAAkB,8BAA8B;AAChD,wBAAwB,eAAe;AACvC,OAAO,4BAA4B;AACnC,cAAc,yBAAyB;AACvC,uBAAuB,wBAAwB;AAC/C,sBAAsB,8BAA8B;AACpD,mBAAmB,8BAA8B;AACjD,cAAc,oBAAoB;AAClC,iBAAiB,0BAA0B;AAC3C,iBAAiB,4BAA4B;AAC7C,sBAAsB,6BAA6B;AACnD,oBAAoB,yBAAyB;AAC7C,oBAAoB,uBAAuB;AAC3C,kBAAkB,sBAAsB;AACxC,QAAQ,wBAAwB;AAChC,eAAe,gBAAgB;AAC/B,OAAO,uBAAuB;AAC9B,UAAU,eAAe;AACzB,UAAU,iBAAiB;AAC3B,MAAM,kBAAkB;AACxB,UAAU,gBAAgB;AAC1B,OAAO,cAAc;AACrB,kBAAkB,0BAA0B;AAC5C,mBAAmB,wBAAwB;AAC3C,SAAS,sBAAsB;AAC/B,QAAQ,yBAAyB;AACjC,UAAU,8BAA8B;AACxC,gBAAgB,6BAA6B;AAC7C,kBAAkB,+BAA+B;AACjD,eAAe,gBAAgB;AAC/B,QAAQ,eAAe;AACvB,UAAU,uBAAuB;AACjC,YAAY,yBAAyB;AACrC,sBAAsB,yBAAyB;AAC/C,YAAY,eAAe;AAC3B,OAAO,oBAAoB;AAC3B,iBAAiB,kBAAkB;AACnC,uBAAuB;AACvB,SAAS,iBAAiB;AAC1B,QAAQ,cAAc;AACtB,OAAO,iBAAiB;AACxB,UAAU,cAAc;AACxB,OAAO,8BAA8B;AACrC,SAAS,qBAAqB;AAC9B,aAAa,iBAAiB;AAC9B,cAAc,0BAA0B;AACxC,cAAc,gBAAgB;AAC9B,aAAa,gBAAgB;AAC7B,UAAU;AACV,UAAU,cAAc;AACxB,YAAY,iBAAiB;AAC7B,UAAU;AACV,SAAS,aAAa;AACtB,UAAU,cAAc;AACxB,yBAAyB;AACzB,SAAS,mBAAmB;AAC5B,cAAc,wBAAwB;AACtC,oBAAoB,iBAAiB;AACrC,aAAa,iBAAiB;AAC9B,QAAQ,4BAA4B;AACpC,cAAc,4BAA4B;AAC1C,eAAe,yBAAyB;AACxC,SAAS,sBAAsB;AAC/B,WAAW,uBAAuB;AAClC,kBAAkB,2BAA2B;AAC7C,QAAQ,kBAAkB;AAC1B,SAAS,eAAe;AACxB,UAAU;AACV,QAAQ,eAAe;AACvB,QAAQ,eAAe;AACvB,SAAS,kBAAkB;AAC3B,OAAO,kBAAkB;AACzB,QAAQ,uBAAuB;AAC/B,gBAAgB,2BAA2B;AAC3C,iBAAiB,yBAAyB;AAC1C,OAAO,yBAAyB;AAChC,QAAQ,2BAA2B;AACnC,SAAS,gBAAgB;AACzB,OAAO,yBAAyB;AAChC,QAAQ,wBAAwB;AAChC,MAAM,eAAe;AACrB,QAAQ,yBAAyB;AACjC,QAAQ,eAAe;AACvB,yBAAyB;AACzB,SAAS,cAAc;AACvB,OAAO,yBAAyB;AAChC,QAAQ,yBAAyB;AACjC,QAAQ,iBAAiB;AACzB,UAAU,cAAc;AACxB,QAAQ,yBAAyB;AACjC,QAAQ,cAAc;AACtB,QAAQ,gBAAgB;AACxB,yBAAyB;AACzB,UAAU,aAAa;AACvB,OAAO,uBAAuB;AAC9B,uBAAuB;AACvB,uBAAuB;AACvB,OAAO;AACP,SAAS,YAAY;AACrB,OAAO;AACP,UAAU,iBAAiB;AAC3B,SAAS,iBAAiB;AAC1B,SAAS,gBAAgB;AACzB,mBAAmB;AACnB,OAAO,kBAAkB;AACzB,QAAQ,oBAAoB;AAC5B,QAAQ,eAAe;AACvB,QAAQ,iBAAiB;AACzB,UAAU,oBAAoB;AAC9B,YAAY,oBAAoB;AAChC,YAAY,oBAAoB;AAChC,YAAY,oBAAoB;AAChC,YAAY,iBAAiB;AAC7B,WAAW,oBAAoB;AAC/B,UAAU,iBAAiB;AAC3B,WAAW,iBAAiB;AAC5B,QAAQ,uBAAuB;AAC/B,OAAO,kBAAkB;AACzB,OAAO,gBAAgB;AACvB,QAAQ,gBAAgB;AACxB,YAAY;AACZ,SAAS,cAAc;AACvB,OAAO,eAAe;AACtB,WAAW;AACX,UAAU;AACV,QAAQ,kBAAkB;AAC1B,SAAS,gBAAgB;AACzB,YAAY,uBAAuB;AACnC,aAAa,mBAAmB;AAChC,aAAa,kBAAkB;AAC/B,UAAU,oBAAoB;AAC9B,QAAQ,oBAAoB;AAC5B,SAAS,eAAe;AACxB,SAAS,kBAAkB;AAC3B,WAAW,mBAAmB;AAC9B,SAAS,iBAAiB;AAC1B,QAAQ,eAAe;AACvB,WAAW,eAAe;AAC1B,UAAU,mBAAmB;AAC7B,UAAU,mBAAmB;AAC7B,YAAY,qBAAqB;AACjC,YAAY,mBAAmB;AAC/B,mBAAmB,yBAAyB;AAC5C,YAAY,kBAAkB;AAC9B,YAAY,kBAAkB;AAC9B,gBAAgB,uBAAuB;AACvC,iBAAiB,6BAA6B;AAC9C,qBAAqB,8BAA8B;AACnD,SAAS,iBAAiB;AAC1B,SAAS,iBAAiB;AAC1B,SAAS,eAAe;AACxB,WAAW,yBAAyB;AACpC,QAAQ,wBAAwB;AAChC,UAAU,kBAAkB;AAC5B,SAAS,iBAAiB;AAC1B,SAAS,iBAAiB;AAC1B,QAAQ,iBAAiB;AACzB,SAAS,iBAAiB;AAC1B,SAAS,iBAAiB;AAC1B,SAAS,iBAAiB;AAC1B,SAAS,gBAAgB;AACzB,SAAS,iBAAiB;AAC1B,SAAS,iBAAiB;AAC1B,SAAS,iBAAiB;AAC1B,UAAU,iBAAiB;AAC3B,SAAS,iBAAiB;AAC1B,SAAS,gBAAgB;AACzB,SAAS,iBAAiB;AAC1B,SAAS,iBAAiB;AAC1B,YAAY,mBAAmB;AAC/B,YAAY,iBAAiB;AAC7B,SAAS,iBAAiB;AAC1B,SAAS,gBAAgB;AACzB,SAAS,iBAAiB;AAC1B,SAAS,iBAAiB;AAC1B,SAAS,iBAAiB;AAC1B,UAAU,iBAAiB;AAC3B,yBAAyB;AACzB,QAAQ,0BAA0B;AAClC,QAAQ,iBAAiB;AACzB,QAAQ,eAAe;AACvB,YAAY,gBAAgB;AAC5B,UAAU,gBAAgB;AAC1B,SAAS,iBAAiB;AAC1B,UAAU,kBAAkB;AAC5B,OAAO,kBAAkB;AACzB,YAAY,kBAAkB;AAC9B,UAAU,kBAAkB;AAC5B,QAAQ,0BAA0B;AAClC,SAAS,gBAAgB;AACzB,UAAU;AACV,UAAU,eAAe;AACzB,SAAS,mBAAmB;AAC5B,QAAQ;AACR,SAAS,iBAAiB;AAC1B,qBAAqB;AACrB,aAAa,aAAa;AAC1B,QAAQ,gBAAgB;AACxB,aAAa,eAAe;AAC5B,OAAO,gBAAgB;AACvB,QAAQ,iBAAiB;AACzB,mBAAmB,4BAA4B;AAC/C,YAAY,kBAAkB;AAC9B,cAAc,uBAAuB;AACrC,eAAe,gBAAgB;AAC/B,YAAY,kBAAkB;AAC9B,WAAW,iBAAiB;AAC5B,YAAY,iBAAiB;AAC7B,UAAU,mBAAmB;AAC7B,SAAS,gBAAgB;AACzB,QAAQ,kBAAkB;AAC1B,cAAc,qBAAqB;AACnC,QAAQ,mBAAmB;AAC3B,UAAU,gBAAgB;AAC1B,UAAU;AACV,QAAQ,gBAAgB;AACxB,SAAS,iBAAiB;AAC1B,QAAQ,yBAAyB;AACjC,SAAS,gBAAgB;AACzB,SAAS,iBAAiB;AAC1B,WAAW,mBAAmB;AAC9B,SAAS,iBAAiB;AAC1B,UAAU,mBAAmB;AAC7B,OAAO,oBAAoB;AAC3B,UAAU,kBAAkB;AAC5B,UAAU,iBAAiB;AAC3B,QAAQ,2BAA2B;AACnC,WAAW,uBAAuB;AAClC,eAAe,oBAAoB;AACnC,cAAc;AACd,UAAU,wBAAwB;AAClC,mBAAmB,iBAAiB;AACpC,SAAS,oBAAoB;AAC7B,SAAS,kBAAkB;AAC3B,QAAQ,gBAAgB;AACxB,UAAU,kBAAkB;AAC5B,QAAQ,gBAAgB;AACxB,SAAS,mBAAmB;AAC5B,SAAS,iBAAiB;AAC1B,OAAO,aAAa;AACpB,WAAW,iBAAiB;AAC5B,WAAW;AACX,OAAO,eAAe;AACtB,WAAW,kBAAkB;AAC7B,OAAO,0BAA0B;AACjC,SAAS,gBAAgB;AACzB,WAAW,uBAAuB;AAClC,SAAS,eAAe;AACxB,WAAW,gBAAgB;AAC3B,OAAO;AACP,UAAU,uBAAuB;AACjC,UAAU,gBAAgB;AAC1B,UAAU,kBAAkB;AAC5B,UAAU,cAAc;AACxB,OAAO,gBAAgB;AACvB,YAAY,oBAAoB;AAChC,WAAW,qBAAqB;AAChC,kBAAkB,qBAAqB;AACvC,kBAAkB,2BAA2B;AAC7C,oBAAoB,oBAAoB;AACxC,UAAU,kBAAkB;AAC5B,QAAQ,yBAAyB;AACjC,QAAQ,kBAAkB;AAC1B,SAAS,gBAAgB;AACzB,SAAS,iBAAiB;AAC1B,SAAS,mBAAmB;AAC5B,QAAQ,mBAAmB;AAC3B,SAAS,gBAAgB;AACzB,yBAAyB;AACzB,UAAU,kBAAkB;AAC5B,QAAQ;AACR,SAAS,gBAAgB;AACzB,OAAO,eAAe;AACtB,MAAM,iBAAiB;AACvB,OAAO,uBAAuB;AAC9B,yBAAyB;AACzB,OAAO,kBAAkB;AACzB,MAAM,oBAAoB;AAC1B,OAAO,eAAe;AACtB,UAAU,iBAAiB;AAC3B,SAAS,oBAAoB;AAC7B,UAAU,kBAAkB;AAC5B,UAAU,gBAAgB;AAC1B,OAAO,eAAe;AACtB,SAAS,eAAe;AACxB,QAAQ,kBAAkB;AAC1B,SAAS,gBAAgB;AACzB,WAAW,gBAAgB;AAC3B,UAAU,mBAAmB;AAC7B,SAAS,sBAAsB;AAC/B,eAAe,kBAAkB;AACjC,UAAU,iBAAiB;AAC3B,WAAW,oBAAoB;AAC/B,SAAS,iBAAiB;AAC1B,QAAQ,iBAAiB;AACzB,QAAQ,eAAe;AACvB,mBAAmB;AACnB,qBAAqB;AACrB,QAAQ,gBAAgB;AACxB,SAAS,uBAAuB;AAChC,gBAAgB,yBAAyB;AACzC,OAAO,iBAAiB;AACxB,UAAU,iBAAiB;AAC3B,UAAU,eAAe;AACzB,SAAS,iBAAiB;AAC1B,QAAQ,iBAAiB;AACzB,SAAS,gBAAgB;AACzB,QAAQ,2BAA2B;AACnC,QAAQ,iBAAiB;AACzB,YAAY;AACZ,UAAU,gBAAgB;AAC1B,yBAAyB;AACzB,UAAU,kBAAkB;AAC5B,UAAU,kBAAkB;AAC5B,UAAU;AACV,UAAU,gBAAgB;AAC1B,UAAU,kBAAkB;AAC5B,UAAU,kBAAkB;AAC5B,UAAU,iBAAiB;AAC3B,SAAS,gBAAgB;AACzB,MAAM,eAAe;AACrB,UAAU,gBAAgB;AAC1B,UAAU,cAAc;AACxB,UAAU,gBAAgB;AAC1B,OAAO,eAAe;AACtB,MAAM,eAAe;AACrB,OAAO,gBAAgB;AACvB,YAAY,eAAe;AAC3B,SAAS,kBAAkB;AAC3B,WAAW,oBAAoB;AAC/B,QAAQ,2BAA2B;AACnC,OAAO,uBAAuB;AAC9B,OAAO,iBAAiB;AACxB,QAAQ,aAAa;AACrB,OAAO,eAAe;AACtB,OAAO,eAAe;AACtB,QAAQ,oBAAoB;AAC5B,OAAO,gBAAgB;AACvB,SAAS,iBAAiB;AAC1B,QAAQ,0BAA0B;AAClC,QAAQ,gBAAgB;AACxB,SAAS,iBAAiB;AAC1B,iBAAiB;AACjB,QAAQ,iBAAiB;AACzB,SAAS,kBAAkB;AAC3B,WAAW,qBAAqB;AAChC,UAAU,kBAAkB;AAC5B,aAAa,sBAAsB;AACnC,WAAW,kBAAkB;AAC7B,aAAa,yBAAyB;AACtC,QAAQ,kBAAkB;AAC1B,QAAQ,gBAAgB;AACxB,UAAU,eAAe;AACzB,WAAW,iBAAiB;AAC5B,QAAQ,iBAAiB;AACzB,UAAU,qBAAqB;AAC/B,UAAU,kBAAkB;AAC5B,OAAO,6BAA6B;AACpC,YAAY,iBAAiB;AAC7B,UAAU,yBAAyB;AACnC,kBAAkB,gBAAgB;AAClC,UAAU,gBAAgB;AAC1B,UAAU,kBAAkB;AAC5B,UAAU,kBAAkB;AAC5B,yBAAyB;AACzB,MAAM;AACN,SAAS,aAAa;AACtB,QAAQ;AACR,SAAS,aAAa;AACtB,OAAO;AACP,UAAU,YAAY;AACtB,UAAU,iBAAiB;AAC3B,UAAU,iBAAiB;AAC3B,SAAS,gBAAgB;AACzB,SAAS,oBAAoB;AAC7B,YAAY,iBAAiB;AAC7B,QAAQ,iBAAiB;AACzB,MAAM,kBAAkB;AACxB,SAAS,oBAAoB;AAC7B,UAAU,cAAc;AACxB,UAAU,oBAAoB;AAC9B,YAAY,oBAAoB;AAChC,WAAW,gBAAgB;AAC3B,SAAS,eAAe;AACxB,QAAQ,gBAAgB;AACxB,yBAAyB;AACzB,QAAQ,yBAAyB;AACjC,SAAS,mBAAmB;AAC5B,SAAS,kBAAkB;AAC3B,SAAS,cAAc;AACvB,UAAU,gBAAgB;AAC1B,qBAAqB;AACrB,SAAS,cAAc;AACvB,OAAO,0BAA0B;AACjC,QAAQ,yBAAyB;AACjC,UAAU,gBAAgB;AAC1B,SAAS,iBAAiB;AAC1B,UAAU,cAAc;AACxB,OAAO,2BAA2B;AAClC,QAAQ,eAAe;AACvB,QAAQ,yBAAyB;AACjC,SAAS,gBAAgB;AACzB,UAAU,iBAAiB;AAC3B,MAAM,eAAe;AACrB,QAAQ,kBAAkB;AAC1B,YAAY,kBAAkB;AAC9B,UAAU,eAAe;AACzB,SAAS,kBAAkB;AAC3B,OAAO;AACP,SAAS,cAAc;AACvB,SAAS,mBAAmB;AAC5B,UAAU,kBAAkB;AAC5B,UAAU,kBAAkB;AAC5B,WAAW,kBAAkB;AAC7B,OAAO,kBAAkB;AACzB,QAAQ,iBAAiB;AACzB,SAAS,iBAAiB;AAC1B,UAAU,gBAAgB;AAC1B,SAAS,mBAAmB;AAC5B,WAAW,kBAAkB;AAC7B,UAAU,gBAAgB;AAC1B,QAAQ,aAAa;AACrB,QAAQ,iBAAiB;AACzB,UAAU,mBAAmB;AAC7B,YAAY,gBAAgB;AAC5B,MAAM,qBAAqB;AAC3B,iBAAiB,2BAA2B;AAC5C,iBAAiB,0BAA0B;AAC3C,kBAAkB,2BAA2B;AAC7C,qBAAqB,+BAA+B;AACpD,kBAAkB,eAAe;AACjC,OAAO,gBAAgB;AACvB,YAAY,eAAe;AAC3B,SAAS,kBAAkB;AAC3B,WAAW,oBAAoB;AAC/B,QAAQ,2BAA2B;AACnC,cAAc,mBAAmB;AACjC,aAAa,sBAAsB;AACnC,WAAW,mBAAmB;AAC9B,UAAU,kBAAkB;AAC5B,OAAO,uBAAuB;AAC9B,OAAO,iBAAiB;AACxB,SAAS,kBAAkB;AAC3B,SAAS,gBAAgB;AACzB,MAAM,iBAAiB;AACvB,YAAY,kBAAkB;AAC9B,SAAS,kBAAkB;AAC3B,UAAU,sBAAsB;AAChC,OAAO,gBAAgB;AACvB,YAAY,eAAe;AAC3B,QAAQ,iBAAiB;AACzB,SAAS,iBAAiB;AAC1B,SAAS,iBAAiB;AAC1B,iBAAiB,8BAA8B;AAC/C,cAAc,0BAA0B;AACxC,iBAAiB,0BAA0B;AAC3C,SAAS,gBAAgB;AACzB,UAAU,mBAAmB;AAC7B,UAAU,kBAAkB;AAC5B,OAAO,mBAAmB;AAC1B,QAAQ,gBAAgB;AACxB,UAAU,iBAAiB;AAC3B,YAAY,iBAAiB;AAC7B,UAAU,eAAe;AACzB,SAAS,kBAAkB;AAC3B,QAAQ,wBAAwB;AAChC,QAAQ,iBAAiB;AACzB,SAAS,gBAAgB;AACzB,SAAS,kBAAkB;AAC3B,UAAU;AACV,MAAM,cAAc;AACpB,SAAS,iBAAiB;AAC1B,UAAU,kBAAkB;AAC5B,UAAU,mBAAmB;AAC7B,UAAU,gBAAgB;AAC1B,SAAS,iBAAiB;AAC1B,YAAY,mBAAmB;AAC/B,aAAa,yBAAyB;AACtC,SAAS;AACT,QAAQ,cAAc;AACtB,QAAQ,mBAAmB;AAC3B,OAAO,kBAAkB;AACzB,cAAc,sBAAsB;AACpC,YAAY,kBAAkB;AAC9B,UAAU,eAAe;AACzB,SAAS,yBAAyB;AAClC,OAAO,wBAAwB;AAC/B,uBAAuB;AACvB,OAAO,kBAAkB;AACzB,UAAU;AACV,UAAU,eAAe;AACzB,UAAU,kBAAkB;AAC5B,WAAW,gBAAgB;AAC3B,QAAQ,kBAAkB;AAC1B,UAAU,gBAAgB;AAC1B,MAAM,gBAAgB;AACtB,UAAU,cAAc;AACxB,YAAY,iBAAiB;AAC7B,OAAO,uBAAuB;AAC9B,QAAQ,8BAA8B;AACtC,mBAAmB,eAAe;AAClC,OAAO,yBAAyB;AAChC,eAAe,kBAAkB;AACjC,UAAU,iBAAiB;AAC3B,UAAU,eAAe;AACzB,OAAO,gBAAgB;AACvB,SAAS,yBAAyB;AAClC,WAAW,iBAAiB;AAC5B,WAAW,oBAAoB;AAC/B,qBAAqB;AACrB,SAAS,0BAA0B;AACnC,QAAQ,kBAAkB;AAC1B,UAAU,gBAAgB;AAC1B,YAAY,wBAAwB;AACpC,OAAO,gBAAgB;AACvB,MAAM,iBAAiB;AACvB,UAAU,iBAAiB;AAC3B,WAAW,iBAAiB;AAC5B,UAAU,kBAAkB;AAC5B,SAAS,0BAA0B;AACnC,WAAW,eAAe;AAC1B,OAAO,uBAAuB;AAC9B,QAAQ,iBAAiB;AACzB,aAAa,wBAAwB;AACrC,SAAS,eAAe;AACxB,QAAQ,iBAAiB;AACzB,SAAS,iBAAiB;AAC1B,MAAM,eAAe;AACrB,QAAQ,eAAe;AACvB,QAAQ,gBAAgB;AACxB,OAAO,yBAAyB;AAChC,QAAQ,eAAe;AACvB,cAAc,2BAA2B;AACzC,QAAQ,iBAAiB;AACzB,aAAa,wBAAwB;AACrC,SAAS,iBAAiB;AAC1B,OAAO,iBAAiB;AACxB,UAAU,gBAAgB;AAC1B,QAAQ;AACR,OAAO,eAAe;AACtB,UAAU,4BAA4B;AACtC,WAAW,mBAAmB;AAC9B,WAAW,iBAAiB;AAC5B,WAAW,mBAAmB;AAC9B,WAAW,gBAAgB;AAC3B,aAAa,kBAAkB;AAC/B,SAAS,2BAA2B;AACpC,OAAO,kBAAkB;AACzB,QAAQ,yBAAyB;AACjC,WAAW,yBAAyB;AACpC,SAAS,kBAAkB;AAC3B,UAAU,+BAA+B;AACzC,SAAS,kBAAkB;AAC3B,OAAO,kBAAkB;AACzB,QAAQ,wBAAwB;AAChC,aAAa,0BAA0B;AACvC,QAAQ,iBAAiB;AACzB,UAAU,iBAAiB;AAC3B,SAAS,mBAAmB;AAC5B,WAAW,gBAAgB;AAC3B,SAAS,yBAAyB;AAClC,WAAW,8BAA8B;AACzC,cAAc,yBAAyB;AACvC,WAAW,wBAAwB;AACnC,SAAS,yBAAyB;AAClC,WAAW,8BAA8B;AACzC,cAAc,wBAAwB;AACtC,yBAAyB;AACzB,QAAQ,yBAAyB;AACjC,mBAAmB,0BAA0B;AAC7C,oBAAoB,cAAc;AAClC,OAAO,gBAAgB;AACvB,SAAS,kBAAkB;AAC3B,UAAU,gBAAgB;AAC1B,UAAU,gBAAgB;AAC1B,QAAQ,0BAA0B;AAClC,UAAU,gBAAgB;AAC1B,QAAQ,0BAA0B;AAClC,UAAU,mBAAmB;AAC7B,SAAS,0BAA0B;AACnC,UAAU,iBAAiB;AAC3B,WAAW,kBAAkB;AAC7B,MAAM;AACN,UAAU,cAAc;AACxB,QAAQ;AACR,SAAS,aAAa;AACtB,SAAS,kBAAkB;AAC3B,QAAQ,gBAAgB;AACxB,UAAU,iBAAiB;AAC3B,SAAS,eAAe;AACxB,QAAQ;AACR,UAAU,aAAa;AACvB,SAAS,eAAe;AACxB,QAAQ,iBAAiB;AACzB,SAAS,mBAAmB;AAC5B,SAAS,eAAe;AACxB,SAAS,gBAAgB;AACzB,WAAW,eAAe;AAC1B,UAAU,gBAAgB;AAC1B,QAAQ,iBAAiB;AACzB,SAAS,cAAc;AACvB,SAAS,eAAe;AACxB,SAAS,mBAAmB;AAC5B,qBAAqB;AACrB,qBAAqB;AACrB,UAAU,gBAAgB;AAC1B,WAAW,eAAe;AAC1B,QAAQ;AACR,UAAU,cAAc;AACxB,yBAAyB;AACzB,UAAU,oBAAoB;AAC9B,qBAAqB;AACrB,SAAS,eAAe;AACxB,qBAAqB;AACrB,YAAY,kBAAkB;AAC9B,SAAS,gBAAgB;AACzB,OAAO,iBAAiB;AACxB,UAAU,gBAAgB;AAC1B,QAAQ,mBAAmB;AAC3B,OAAO,wBAAwB;AAC/B,QAAQ,iBAAiB;AACzB,SAAS,cAAc;AACvB,aAAa,eAAe;AAC5B,UAAU,mBAAmB;AAC7B,UAAU,gBAAgB;AAC1B,YAAY,iBAAiB;AAC7B,WAAW,kBAAkB;AAC7B,UAAU,iBAAiB;AAC3B,yBAAyB;AACzB,WAAW,mBAAmB;AAC9B,MAAM,kBAAkB;AACxB,QAAQ;AACR,SAAS,YAAY;AACrB,OAAO,gBAAgB;AACvB,SAAS,eAAe;AACxB,QAAQ,sBAAsB;AAC9B,eAAe,kBAAkB;AACjC,eAAe,oBAAoB;AACnC,YAAY,mBAAmB;AAC/B,SAAS,kBAAkB;AAC3B,QAAQ,iBAAiB;AACzB,UAAU,gBAAgB;AAC1B,YAAY,oBAAoB;AAChC,YAAY,gBAAgB;AAC5B,UAAU,iBAAiB;AAC3B,UAAU,gBAAgB;AAC1B,OAAO,iBAAiB;AACxB,OAAO,yBAAyB;AAChC,QAAQ,2BAA2B;AACnC,QAAQ,gCAAgC;AACxC,WAAW,iBAAiB;AAC5B,WAAW;AACX,QAAQ,eAAe;AACvB,QAAQ,kBAAkB;AAC1B,SAAS,gBAAgB;AACzB,QAAQ,0BAA0B;AAClC,SAAS,oBAAoB;AAC7B,QAAQ,iBAAiB;AACzB,SAAS,kBAAkB;AAC3B,uBAAuB;AACvB,QAAQ,kBAAkB;AAC1B,SAAS,mBAAmB;AAC5B,SAAS,kBAAkB;AAC3B,UAAU,kBAAkB;AAC5B,UAAU,mBAAmB;AAC7B,UAAU,iBAAiB;AAC3B,UAAU,iBAAiB;AAC3B,aAAa,iBAAiB;AAC9B,SAAS,kBAAkB;AAC3B,UAAU,eAAe;AACzB,WAAW,mBAAmB;AAC9B,UAAU,iBAAiB;AAC3B,SAAS,gBAAgB;AACzB,OAAO,eAAe;AACtB,WAAW,iBAAiB;AAC5B,UAAU,gBAAgB;AAC1B,QAAQ,mBAAmB;AAC3B,YAAY,iBAAiB;AAC7B,QAAQ;AACR,OAAO,gBAAgB;AACvB,UAAU,eAAe;AACzB,SAAS,iBAAiB;AAC1B,UAAU,eAAe;AACzB,QAAQ,qBAAqB;AAC7B,kBAAkB,4BAA4B;AAC9C,kBAAkB,2BAA2B;AAC7C,qBAAqB,4BAA4B;AACjD,mBAAmB,2BAA2B;AAC9C,QAAQ,uBAAuB;AAC/B,SAAS,iBAAiB;AAC1B,OAAO,kBAAkB;AACzB,cAAc,iBAAiB;AAC/B,SAAS,iBAAiB;AAC1B,SAAS,iBAAiB;AAC1B,QAAQ,2BAA2B;AACnC,WAAW,gBAAgB;AAC3B,UAAU,oBAAoB;AAC9B,SAAS,kBAAkB;AAC3B,QAAQ,wBAAwB;AAChC,QAAQ,eAAe;AACvB,UAAU,kBAAkB;AAC5B,UAAU,gBAAgB;AAC1B,SAAS,iBAAiB;AAC1B,YAAY,mBAAmB;AAC/B,MAAM,kBAAkB;AACxB,SAAS,cAAc;AACvB,OAAO,gBAAgB;AACvB,UAAU,gBAAgB;AAC1B,OAAO,kBAAkB;AACzB,SAAS,eAAe;AACxB,SAAS,kBAAkB;AAC3B,YAAY,iBAAiB;AAC7B,OAAO,eAAe;AACtB,SAAS,iBAAiB;AAC1B,SAAS,kBAAkB;AAC3B,SAAS,mBAAmB;AAC5B,qBAAqB;AACrB,QAAQ,gBAAgB;AACxB,YAAY,iBAAiB;AAC7B,QAAQ,eAAe;AACvB,UAAU,iBAAiB;AAC3B,UAAU,eAAe;AACzB,YAAY,yBAAyB;AACrC,mBAAmB;AACnB,SAAS,iBAAiB;AAC1B,UAAU,cAAc;AACxB,UAAU,gBAAgB;AAC1B,SAAS,gBAAgB;AACzB,SAAS,gBAAgB;AACzB,SAAS,iBAAiB;AAC1B,WAAW,mBAAmB;AAC9B,SAAS,yBAAyB;AAClC,UAAU,oBAAoB;AAC9B,QAAQ,iBAAiB;AACzB,OAAO,gBAAgB;AACvB,SAAS,2BAA2B;AACpC,OAAO,cAAc;AACrB,UAAU,gBAAgB;AAC1B,UAAU,qBAAqB;AAC/B,QAAQ,iBAAiB;AACzB,UAAU,0BAA0B;AACpC,UAAU,0BAA0B;AACpC,UAAU,oBAAoB;AAC9B,cAAc,iBAAiB;AAC/B,UAAU,oBAAoB;AAC9B,cAAc,eAAe;AAC7B,UAAU,kBAAkB;AAC5B,QAAQ,iBAAiB;AACzB,QAAQ,2BAA2B;AACnC,UAAU,kBAAkB;AAC5B,QAAQ,iBAAiB;AACzB,mBAAmB,sBAAsB;AACzC,SAAS,aAAa;AACtB,QAAQ,kBAAkB;AAC1B,QAAQ,mBAAmB;AAC3B,WAAW,iBAAiB;AAC5B,SAAS,mBAAmB;AAC5B,WAAW,kBAAkB;AAC7B,YAAY,qBAAqB;AACjC,aAAa,sBAAsB;AACnC,UAAU,kBAAkB;AAC5B,UAAU,gBAAgB;AAC1B,cAAc,uBAAuB;AACrC,UAAU,uBAAuB;AACjC,YAAY,oBAAoB;AAChC,WAAW,eAAe;AAC1B,QAAQ;AACR,QAAQ;AACR,QAAQ;AACR,QAAQ,aAAa;AACrB,QAAQ,kBAAkB;AAC1B,WAAW,gBAAgB;AAC3B,WAAW,mBAAmB;AAC9B,WAAW,mBAAmB;AAC9B,WAAW,iBAAiB;AAC5B,SAAS,mBAAmB;AAC5B,UAAU,oBAAoB;AAC9B,aAAa,qBAAqB;AAClC,cAAc,kBAAkB;AAChC,UAAU,kBAAkB;AAC5B,SAAS,kBAAkB;AAC3B,SAAS,mBAAmB;AAC5B,UAAU;AACV,SAAS,gBAAgB;AACzB,OAAO,eAAe;AACtB,UAAU,iBAAiB;AAC3B,OAAO,eAAe;AACtB,UAAU,eAAe;AACzB,UAAU,qBAAqB;AAC/B,SAAS,mBAAmB;AAC5B,UAAU,sBAAsB;AAChC,YAAY,kBAAkB;AAC9B,SAAS,kBAAkB;AAC3B,uBAAuB;AACvB,SAAS;AACT,SAAS,gBAAgB;AACzB,YAAY,kBAAkB;AAC9B,QAAQ,gBAAgB;AACxB,OAAO,kBAAkB;AACzB,UAAU,gBAAgB;AAC1B,WAAW,gBAAgB;AAC3B,UAAU,iBAAiB;AAC3B,YAAY,wBAAwB;AACpC,gBAAgB,0BAA0B;AAC1C,aAAa,yBAAyB;AACtC,mBAAmB,kBAAkB;AACrC,QAAQ,oBAAoB;AAC5B,WAAW,iBAAiB;AAC5B,WAAW,oBAAoB;AAC/B,QAAQ,yBAAyB;AACjC,SAAS,iBAAiB;AAC1B,SAAS,4BAA4B;AACrC,qBAAqB,gBAAgB;AACrC,QAAQ;AACR,UAAU,cAAc;AACxB,SAAS,iBAAiB;AAC1B,uBAAuB;AACvB,OAAO,gBAAgB;AACvB,UAAU,gBAAgB;AAC1B,UAAU,eAAe;AACzB,yBAAyB;AACzB,SAAS,iBAAiB;AAC1B,SAAS,kBAAkB;AAC3B,YAAY,kBAAkB;AAC9B,SAAS,iBAAiB;AAC1B,mBAAmB;AACnB,SAAS,eAAe;AACxB,WAAW,uBAAuB;AAClC,iBAAiB,0BAA0B;AAC3C,SAAS,gBAAgB;AACzB,SAAS,kBAAkB;AAC3B,cAAc,kBAAkB;AAChC,YAAY,kBAAkB;AAC9B,SAAS,gBAAgB;AACzB,QAAQ,0BAA0B;AAClC,UAAU,eAAe;AACzB,SAAS,iBAAiB;AAC1B,qBAAqB;AACrB,WAAW,gBAAgB;AAC3B,QAAQ,iBAAiB;AACzB,SAAS,kBAAkB;AAC3B,cAAc,mBAAmB;AACjC,cAAc,kBAAkB;AAChC,SAAS,oBAAoB;AAC7B,QAAQ,kBAAkB;AAC1B,YAAY,uBAAuB;AACnC,iBAAiB,iCAAiC;AAClD,iBAAiB,6BAA6B;AAC9C,mBAAmB,4BAA4B;AAC/C,OAAO,gBAAgB;AACvB,OAAO,kBAAkB;AACzB,SAAS,kBAAkB;AAC3B,UAAU,cAAc;AACxB,OAAO,0BAA0B;AACjC,SAAS,0BAA0B;AACnC,QAAQ,0BAA0B;AAClC,SAAS,gBAAgB;AACzB,UAAU,2BAA2B;AACrC,UAAU,2BAA2B;AACrC,WAAW,iBAAiB;AAC5B,UAAU,iBAAiB;AAC3B,UAAU,kBAAkB;AAC5B,OAAO,yBAAyB;AAChC,MAAM,cAAc;AACpB,UAAU,gBAAgB;AAC1B,QAAQ,iBAAiB;AACzB,QAAQ,iBAAiB;AACzB,OAAO,0BAA0B;AACjC,SAAS,cAAc;AACvB,SAAS,iBAAiB;AAC1B,QAAQ,gBAAgB;AACxB,SAAS,gBAAgB;AACzB,UAAU,kBAAkB;AAC5B,SAAS,iBAAiB;AAC1B,QAAQ,2BAA2B;AACnC,UAAU,iBAAiB;AAC3B,QAAQ,kBAAkB;AAC1B,yBAAyB;AACzB,QAAQ,gBAAgB;AACxB,OAAO;AACP,OAAO,aAAa;AACpB,QAAQ,eAAe;AACvB,QAAQ,yBAAyB;AACjC,qBAAqB;AACrB,UAAU,iBAAiB;AAC3B,OAAO,eAAe;AACtB,UAAU,gBAAgB;AAC1B,OAAO,yBAAyB;AAChC,WAAW,gBAAgB;AAC3B,QAAQ,wBAAwB;AAChC,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK,QAAQ,QAAQ,SAAS,IAAI,KAAK,OAAO,OAAO,MAAM,IAAI,SAAS,IAAI,eAAe,MAAM,SAAS,MAAM,QAAQ,MAAM,mBAAmB,OAAO,KAAK,MAAM,WAAW,UAAU,IAAI,KAAK,KAAK,MAAM,KAAK,OAAO,UAAU,KAAK,WAAW,MAAM,mBAAmB,QAAQ,WAAW,MAAM,MAAM,OAAO,MAAM,WAAW,SAAS,KAAK,IAAI,aAAa,OAAO,MAAM,OAAO,6BAA6B,uBAAuB,OAAO,cAAc,GAAG,aAAa,KAAK,cAAc,QAAQ,QAAQ,gCAAgC,OAAO,KAAK,OAAO,KAAK,YAAY,QAAQ,MAAM,KAAK,KAAK,UAAU,IAAI,KAAK,WAAW,GAAG,QAAQ,IAAI,KAAK,0BAA0B,QAAQ,WAAW,QAAQ,OAAO,OAAO,cAAc,SAAS,MAAM,KAAK,OAAO,yBAAyB,QAAQ,SAAS,kBAAkB,YAAY,KAAK,qBAAqB,YAAY,aAAa,iBAAiB,KAAK,aAAa,WAAW,cAAc,gBAAgB,KAAK,SAAS,QAAQ,oBAAoB,WAAW,WAAW,KAAK,qBAAqB,WAAW,KAAK,UAAU,OAAO,QAAQ,UAAU,MAAM,UAAU,IAAI,QAAQ,WAAW,KAAK,IAAI,MAAM,IAAI,OAAO,SAAS,SAAS,mBAAmB,iBAAiB,WAAW,IAAI,SAAS,YAAY,OAAO,WAAW,SAAS,IAAI,KAAK,KAAK,WAAW,YAAY,UAAU,IAAI,qBAAqB,iBAAiB,SAAS,MAAM,UAAU,MAAM,UAAU,GAAG,UAAU,GAAG,QAAQ,UAAU,KAAK,GAAG,MAAM,IAAI,GAAG,KAAK,mBAAmB,MAAM,YAAY,SAAS,MAAM,YAAY,OAAO,MAAM,GAAG,YAAY,SAAS,GAAG,OAAO,IAAI,aAAa,QAAQ,cAAc,SAAS,MAAM,iBAAiB,OAAO,WAAW,MAAM,KAAK,OAAO,UAAU,IAAI,MAAM,IAAI,OAAO,OAAO,QAAQ,SAAS,QAAQ,WAAW,UAAU,UAAU,mBAAmB,OAAO,WAAW,IAAI,IAAI,MAAM,OAAO,SAAS,IAAI,gBAAgB,GAAG,KAAK,KAAK,QAAQ,MAAM,OAAO,UAAU,KAAK,MAAM,UAAU,GAAG,KAAK,KAAK,KAAK,UAAU,GAAG,WAAW,MAAM,IAAI,UAAU,IAAI,WAAW,MAAM,GAAG,2BAA2B,SAAS,KAAK,YAAY,WAAW,kBAAkB,gBAAgB,WAAW,KAAK,UAAU,eAAe,QAAQ,YAAY,OAAO,QAAQ,aAAa,KAAK,OAAO,mBAAmB,WAAW,WAAW,KAAK,aAAa,KAAK,QAAQ,YAAY,oBAAoB,WAAW,SAAS,MAAM,YAAY,OAAO,MAAM,MAAM,UAAU,QAAQ,uBAAuB,YAAY,aAAa,cAAc,YAAY,aAAa,KAAK,iBAAiB,YAAY,UAAU,GAAG,MAAM,IAAI,SAAS,IAAI,eAAe,SAAS,KAAK,UAAU,KAAK,KAAK,GAAG,UAAU,OAAO,UAAU,MAAM,GAAG,2BAA2B,eAAe,QAAQ,gBAAgB,wBAAwB,UAAU,QAAQ,KAAK,WAAW,gBAAgB,IAAI,MAAM,cAAc,OAAO,oBAAoB,YAAY,SAAS,OAAO,QAAQ,aAAa,OAAO,WAAW,SAAS,MAAM,YAAY,OAAO,kBAAkB,OAAO,qBAAqB,KAAK,OAAO,QAAQ,OAAO,SAAS,MAAM,YAAY,OAAO,2BAA2B,UAAU,cAAc,OAAO,YAAY,oBAAoB,iBAAiB,KAAK,OAAO,yBAAyB,OAAO,YAAY,OAAO,eAAe,OAAO,YAAY,OAAO,YAAY,OAAO,YAAY,OAAO,aAAa,OAAO,WAAW,OAAO,cAAc,OAAO,OAAO,IAAI,WAAW,OAAO,UAAU,IAAI,QAAQ,IAAI,OAAO,UAAU,KAAK,OAAO,MAAM,wBAAwB,OAAO,IAAI,QAAQ,MAAM,YAAY,MAAM,MAAM,eAAe,SAAS,KAAK,eAAe,eAAe,IAAI,IAAI,IAAI,GAAG,UAAU,iBAAiB,IAAI,OAAO,WAAW,OAAO,YAAY,OAAO,MAAM,UAAU,YAAY,IAAI,WAAW,GAAG,WAAW,KAAK,KAAK,KAAK,WAAW,IAAI,WAAW,IAAI,OAAO,IAAI,YAAY,MAAM,GAAG,OAAO,oBAAoB,YAAY,gBAAgB,MAAM,IAAI,wBAAwB,SAAS,KAAK,WAAW,WAAW,kBAAkB,gBAAgB,WAAW,KAAK,UAAU,WAAW,OAAO,QAAQ,aAAa,KAAK,OAAO,mBAAmB,WAAW,WAAW,KAAK,aAAa,KAAK,QAAQ,SAAS,YAAY,aAAa,QAAQ,GAAG,aAAa,eAAe,IAAI,QAAQ,OAAO,MAAM,MAAM,MAAM,KAAK,GAAG,KAAK,kBAAkB,WAAW,YAAY,SAAS,OAAO,YAAY,KAAK,QAAQ,SAAS,cAAc,cAAc,OAAO,YAAY,OAAO,SAAS,OAAO,KAAK,UAAU,QAAQ,OAAO,gBAAgB,OAAO,YAAY,OAAO,QAAQ,IAAI,MAAM,UAAU,OAAO,MAAM,aAAa,OAAO,SAAS,IAAI,QAAQ,GAAG,WAAW,MAAM,GAAG,KAAK,gBAAgB,IAAI,cAAc,QAAQ,WAAW,OAAO,WAAW,OAAO,MAAM,UAAU,QAAQ,MAAM,gBAAgB,QAAQ,MAAM,WAAW,KAAK,UAAU,IAAI,QAAQ,IAAI,OAAO,OAAO,kBAAkB,SAAS,KAAK,eAAe,SAAS,MAAM,WAAW,IAAI,eAAe,KAAK,WAAW,YAAY,aAAa,QAAQ,OAAO,QAAQ,WAAW,iBAAiB,YAAY,QAAQ,KAAK,QAAQ,KAAK,OAAO,KAAK,YAAY,KAAK,IAAI,SAAS,GAAG,QAAQ,SAAS,MAAM,YAAY,MAAM,WAAW,OAAO,cAAc,MAAM,KAAK,KAAK,OAAO,WAAW,MAAM,IAAI,KAAK,KAAK,SAAS,GAAG,KAAK,KAAK,UAAU,KAAK,KAAK,OAAO,UAAU,GAAG,KAAK,KAAK,KAAK,KAAK,UAAU,OAAO,UAAU,GAAG,MAAM,kBAAkB,IAAI,KAAK,KAAK,KAAK,YAAY,QAAQ,MAAM,GAAG,GAAG,KAAK,MAAM,IAAI,OAAO,OAAO,GAAG,QAAQ,eAAe,IAAI,MAAM,aAAa,IAAI,IAAI,YAAY,KAAK,GAAG,OAAO,GAAG,OAAO,GAAG,IAAI,QAAQ,OAAO,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,SAAS,OAAO,GAAG,UAAU,GAAG,OAAO,WAAW,IAAI,OAAO,GAAG,MAAM,GAAG,IAAI,IAAI,SAAS,IAAI,QAAQ,SAAS,GAAG,QAAQ,IAAI,SAAS,MAAM,aAAa,KAAK,WAAW,eAAe,SAAS,OAAO,QAAQ,IAAI,WAAW,QAAQ,IAAI,WAAW,MAAM,UAAU,GAAG,OAAO,aAAa,GAAG,QAAQ,KAAK,MAAM,OAAO,GAAG,MAAM,MAAM,aAAa,KAAK,IAAI,UAAU,MAAM,OAAO,WAAW,KAAK,kBAAkB,IAAI,QAAQ,KAAK,OAAO,QAAQ,sBAAsB,QAAQ,aAAa,MAAM,MAAM,OAAO,MAAM,YAAY,GAAG,KAAK,MAAM,WAAW,MAAM,KAAK,SAAS,MAAM,KAAK,OAAO,WAAW,GAAG,GAAG,GAAG,OAAO,GAAG,GAAG,GAAG,GAAG,QAAQ,GAAG,GAAG,GAAG,OAAO,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,MAAM,OAAO,GAAG,GAAG,GAAG,OAAO,GAAG,GAAG,GAAG,GAAG,QAAQ,MAAM,OAAO,OAAO,GAAG,GAAG,GAAG,OAAO,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,UAAU,SAAS,MAAM,UAAU,KAAK,OAAO,GAAG,QAAQ,GAAG,MAAM,aAAa,IAAI,QAAQ,GAAG,MAAM,GAAG,kBAAkB,MAAM,KAAK,OAAO,QAAQ,IAAI,MAAM,GAAG,SAAS,IAAI,cAAc,KAAK,OAAO,MAAM,QAAQ,IAAI,OAAO,SAAS,QAAQ,OAAO,OAAO,OAAO,QAAQ,QAAQ,MAAM,IAAI,QAAQ,GAAG,MAAM,IAAI,mBAAmB,OAAO,QAAQ,GAAG,KAAK,MAAM,MAAM,MAAM,OAAO,KAAK,MAAM,UAAU,KAAK,aAAa,MAAM,GAAG,aAAa,GAAG,OAAO,IAAI,WAAW,KAAK,aAAa,KAAK,MAAM,QAAQ,KAAK,MAAM,IAAI,aAAa,KAAK,SAAS,UAAU,GAAG,OAAO,GAAG,SAAS,cAAc,GAAG,SAAS,IAAI,UAAU,GAAG,OAAO,OAAO,QAAQ,IAAI,MAAM,IAAI,GAAG,aAAa,GAAG,iBAAiB,MAAM,MAAM,OAAO,MAAM,iBAAiB,OAAO,OAAO,KAAK,aAAa,KAAK,QAAQ,UAAU,KAAK,UAAU,MAAM,IAAI,OAAO,GAAG,aAAa,KAAK,WAAW,GAAG,OAAO,UAAU,IAAI,QAAQ,QAAQ,MAAM,OAAO,WAAW,GAAG,UAAU,GAAG,YAAY,QAAQ,MAAM,IAAI,IAAI,OAAO,KAAK,MAAM,QAAQ,SAAS,OAAO,OAAO,UAAU,KAAK,WAAW,IAAI,MAAM,OAAO,KAAK,QAAQ,MAAM,QAAQ,eAAe,YAAY,YAAY,gBAAgB,OAAO,eAAe,SAAS,KAAK,aAAa,GAAG,KAAK,MAAM,UAAU,OAAO,GAAG,WAAW,KAAK,SAAS,QAAQ,QAAQ,eAAe,IAAI,WAAW,OAAO,WAAW,OAAO,GAAG,QAAQ,GAAG,MAAM,GAAG,SAAS,GAAG,OAAO,MAAM,OAAO,KAAK,QAAQ,QAAQ,GAAG,MAAM,KAAK,WAAW,QAAQ,KAAK,GAAG,aAAa,GAAG,GAAG,SAAS,IAAI,UAAU,IAAI,YAAY,IAAI,MAAM,OAAO,KAAK,GAAG,eAAe,MAAM,SAAS,YAAY,MAAM,WAAW,KAAK,OAAO,IAAI,UAAU,UAAU,KAAK,SAAS,KAAK,IAAI,QAAQ,GAAG,UAAU,KAAK,SAAS,KAAK,cAAc,WAAW,qBAAqB,IAAI,OAAO,UAAU,QAAQ,KAAK,IAAI,OAAO,MAAM,QAAQ,KAAK,KAAK,MAAM,QAAQ,SAAS,MAAM,GAAG,YAAY,mBAAmB,IAAI,GAAG,IAAI,GAAG,GAAG,QAAQ,GAAG,QAAQ,IAAI,GAAG,KAAK,OAAO,GAAG,KAAK,KAAK,MAAM,MAAM,WAAW,GAAG,WAAW,QAAQ,GAAG,IAAI,QAAQ,SAAS,GAAG,MAAM,MAAM,GAAG,MAAM,GAAG,OAAO,OAAO,IAAI,QAAQ,MAAM,GAAG,QAAQ,IAAI,OAAO,MAAM,GAAG,OAAO,KAAK,MAAM,GAAG,GAAG,GAAG,QAAQ,OAAO,MAAM,OAAO,MAAM,GAAG,OAAO,MAAM,MAAM,QAAQ,OAAO,GAAG,GAAG,QAAQ,OAAO,IAAI,MAAM,MAAM,OAAO,eAAe,IAAI,MAAM,WAAW,OAAO,OAAO,KAAK,gBAAgB,IAAI,WAAW,UAAU,IAAI,MAAM,SAAS,MAAM,KAAK,GAAG,QAAQ,MAAM,aAAa,KAAK,OAAO,MAAM,KAAK,YAAY,OAAO,UAAU,MAAM,gBAAgB,YAAY,KAAK,MAAM,SAAS,MAAM,MAAM,WAAW,MAAM,aAAa,OAAO,KAAK,IAAI,SAAS,KAAK,SAAS,GAAG,QAAQ,OAAO,SAAS,IAAI,OAAO,KAAK,OAAO,YAAY,OAAO,MAAM,MAAM,KAAK,KAAK,KAAK,OAAO,MAAM,QAAQ,KAAK,OAAO,MAAM,KAAK,UAAU,MAAM,QAAQ,MAAM,UAAU,KAAK,IAAI,IAAI,OAAO,OAAO,SAAS,OAAO,GAAG,KAAK,MAAM,GAAG,IAAI,QAAQ,MAAM,UAAU,IAAI,gBAAgB,GAAG,KAAK,MAAM,KAAK,QAAQ,MAAM,OAAO,cAAc,GAAG,WAAW,GAAG,KAAK,OAAO,KAAK,KAAK,KAAK,KAAK,cAAc,IAAI,MAAM,OAAO,MAAM,GAAG,MAAM,UAAU,QAAQ,MAAM,MAAM,OAAO,GAAG,IAAI,IAAI,KAAK,QAAQ,MAAM,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,OAAO,KAAK,MAAM,GAAG,YAAY,KAAK,YAAY,GAAG,QAAQ,QAAQ,GAAG,cAAc,SAAS,IAAI,KAAK,GAAG,SAAS,QAAQ,GAAG,WAAW,OAAO,KAAK,OAAO,eAAe,MAAM,iBAAiB,IAAI,aAAa,kBAAkB,GAAG,WAAW,YAAY,aAAa,IAAI,MAAM,GAAG,OAAO,OAAO,IAAI,QAAQ,MAAM,GAAG,QAAQ,IAAI,aAAa,KAAK,UAAU,MAAM,MAAM,KAAK,aAAa,MAAM,GAAG,OAAO,GAAG,aAAa,MAAM,GAAG,OAAO,MAAM,MAAM,KAAK,QAAQ,MAAM,KAAK,WAAW,SAAS,MAAM,SAAS,OAAO,MAAM,OAAO,MAAM,GAAG,OAAO,aAAa,IAAI,MAAM,mBAAmB,YAAY,SAAS,YAAY,iBAAiB,OAAO,SAAS,GAAG,KAAK,QAAQ,SAAS,KAAK,OAAO,MAAM,GAAG,UAAU,IAAI,UAAU,QAAQ,QAAQ,GAAG,IAAI,KAAK,WAAW,IAAI,GAAG,OAAO,GAAG,GAAG,QAAQ,OAAO,GAAG,QAAQ,OAAO,OAAO,IAAI,MAAM,MAAM,MAAM,MAAM,OAAO,SAAS,MAAM,GAAG,GAAG,gBAAgB,MAAM,cAAc,IAAI,YAAY,QAAQ,QAAQ,MAAM,KAAK,QAAQ,QAAQ,MAAM,MAAM,IAAI,QAAQ,WAAW,GAAG,OAAO,cAAc,IAAI,IAAI,SAAS,OAAO,KAAK,KAAK,KAAK,UAAU,GAAG,MAAM,GAAG,WAAW,IAAI,QAAQ,UAAU,IAAI,IAAI,QAAQ,MAAM,OAAO,QAAQ,KAAK,aAAa,MAAM,GAAG,mBAAmB,YAAY,IAAI,MAAM,GAAG,cAAc,UAAU,MAAM,UAAU,MAAM,IAAI,MAAM,GAAG,IAAI,IAAI,MAAM,SAAS,OAAO,GAAG,WAAW,SAAS,GAAG,aAAa,KAAK,OAAO,QAAQ,KAAK,KAAK,GAAG,OAAO,MAAM,KAAK,SAAS,MAAM,IAAI,OAAO,MAAM,SAAS,IAAI,UAAU,GAAG,MAAM,OAAO,MAAM,MAAM,GAAG,OAAO,IAAI,MAAM,MAAM,GAAG,WAAW,KAAK,KAAK,OAAO,MAAM,GAAG,IAAI,MAAM,SAAS,GAAG,KAAK,IAAI,MAAM,YAAY,YAAY,OAAO,GAAG,OAAO,OAAO,GAAG,OAAO,MAAM,OAAO,GAAG,QAAQ,QAAQ,MAAM,OAAO,GAAG,KAAK,OAAO,GAAG,GAAG,SAAS,OAAO,GAAG,GAAG,gBAAgB,OAAO,IAAI,GAAG,QAAQ,MAAM,KAAK,MAAM,MAAM,IAAI,aAAa,QAAQ,GAAG,GAAG,YAAY,QAAQ,GAAG,YAAY,KAAK,GAAG,GAAG,aAAa,UAAU,QAAQ,MAAM,GAAG,OAAO,KAAK,UAAU,IAAI,WAAW,GAAG,GAAG,QAAQ,OAAO,GAAG,UAAU,IAAI,OAAO,GAAG,GAAG,QAAQ,OAAO,GAAG,aAAa,MAAM,KAAK,mBAAmB,IAAI,WAAW,IAAI,SAAS,MAAM,KAAK,IAAI,YAAY,MAAM,IAAI,MAAM,OAAO,GAAG,QAAQ,SAAS,GAAG,MAAM,KAAK,WAAW,MAAM,MAAM,UAAU,SAAS,MAAM,IAAI,QAAQ,SAAS,UAAU,KAAK,YAAY,GAAG,KAAK,UAAU,MAAM,IAAI,IAAI,MAAM,OAAO,SAAS,GAAG,SAAS,MAAM,IAAI,UAAU,GAAG,MAAM,SAAS,QAAQ,MAAM,MAAM,GAAG,UAAU,KAAK,UAAU,GAAG,KAAK,OAAO,QAAQ,KAAK,KAAK,OAAO,KAAK,MAAM,OAAO,IAAI,IAAI,IAAI,QAAQ,IAAI,OAAO,GAAG,SAAS,MAAM,KAAK,WAAW,SAAS,IAAI,OAAO,OAAO,YAAY,MAAM,MAAM,UAAU,GAAG,IAAI,KAAK,UAAU,KAAK,KAAK,GAAG,MAAM,KAAK,UAAU,GAAG,OAAO,KAAK,OAAO,SAAS,GAAG,iBAAiB,GAAG,KAAK,QAAQ,MAAM,GAAG,KAAK,OAAO,GAAG,IAAI,IAAI,MAAM,KAAK,KAAK,YAAY,IAAI,KAAK,QAAQ,GAAG,IAAI,KAAK,MAAM,MAAM,QAAQ,SAAS,IAAI,YAAY,KAAK,KAAK,MAAM,UAAU,GAAG,QAAQ,IAAI,KAAK,QAAQ,UAAU,MAAM,MAAM,OAAO,IAAI,OAAO,MAAM,SAAS,GAAG,QAAQ,SAAS,KAAK,KAAK,OAAO,KAAK,kBAAkB,KAAK,SAAS,IAAI,KAAK,gBAAgB,IAAI,MAAM,OAAO,KAAK,WAAW,KAAK,MAAM,QAAQ,OAAO,GAAG,GAAG,IAAI,MAAM,QAAQ,IAAI,MAAM,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,KAAK,IAAI,GAAG,UAAU,OAAO,MAAM,YAAY,KAAK,YAAY,GAAG,QAAQ,QAAQ,GAAG,cAAc,SAAS,IAAI,KAAK,GAAG,SAAS,OAAO,QAAQ,GAAG,KAAK,YAAY,KAAK,MAAM,GAAG,KAAK,GAAG,YAAY,MAAM,GAAG,aAAa,MAAM,GAAG,QAAQ,GAAG,sBAAsB,MAAM,iBAAiB,IAAI,gBAAgB,UAAU,cAAc,YAAY,YAAY,KAAK,YAAY,UAAU,KAAK,GAAG,WAAW,MAAM,OAAO,YAAY,IAAI,MAAM,QAAQ,GAAG,KAAK,QAAQ,YAAY,IAAI,SAAS,OAAO,UAAU,IAAI,GAAG,OAAO,OAAO,GAAG,aAAa,MAAM,OAAO,GAAG,GAAG,MAAM,UAAU,GAAG,YAAY,MAAM,MAAM,GAAG,OAAO,KAAK,MAAM,MAAM,KAAK,MAAM,OAAO,IAAI,KAAK,SAAS,KAAK,GAAG,SAAS,GAAG,GAAG,UAAU,SAAS,MAAM,IAAI,MAAM,KAAK,MAAM,WAAW,GAAG,KAAK,QAAQ,KAAK,UAAU,SAAS,GAAG,YAAY,UAAU,IAAI,cAAc,GAAG,GAAG,OAAO,KAAK,MAAM,GAAG,OAAO,GAAG,OAAO,GAAG,KAAK,MAAM,MAAM,QAAQ,oBAAoB,KAAK,SAAS,OAAO,IAAI,OAAO,MAAM,GAAG,aAAa,MAAM,MAAM,IAAI,MAAM,cAAc,KAAK,IAAI,gBAAgB,GAAG,QAAQ,GAAG,aAAa,GAAG,QAAQ,IAAI,QAAQ,GAAG,QAAQ,IAAI,SAAS,QAAQ,GAAG,IAAI,QAAQ,QAAQ,MAAM,MAAM,MAAM,YAAY,GAAG,sBAAsB,KAAK,KAAK,YAAY,GAAG,KAAK,MAAM,KAAK,OAAO,OAAO,GAAG,OAAO,MAAM,WAAW,OAAO,GAAG,SAAS,GAAG,MAAM,OAAO,GAAG,UAAU,QAAQ,SAAS,IAAI,YAAY,KAAK,KAAK,MAAM,IAAI,IAAI,OAAO,IAAI,IAAI,GAAG,GAAG,QAAQ,KAAK,OAAO,KAAK,UAAU,IAAI,OAAO,MAAM,OAAO,GAAG,OAAO,WAAW,OAAO,GAAG,SAAS,GAAG,MAAM,OAAO,GAAG,aAAa,SAAS,MAAM,IAAI,QAAQ,OAAO,gBAAgB,GAAG,MAAM,UAAU,MAAM,GAAG,MAAM,OAAO,IAAI,gBAAgB,MAAM,QAAQ,KAAK,GAAG,mBAAmB,KAAK,MAAM,SAAS,KAAK,MAAM,WAAW,QAAQ,MAAM,IAAI,IAAI,MAAM,SAAS,MAAM,KAAK,KAAK,MAAM,KAAK,MAAM,QAAQ,SAAS,cAAc,MAAM,SAAS,IAAI,IAAI,UAAU,IAAI,OAAO,GAAG,OAAO,MAAM,IAAI,MAAM,SAAS,YAAY,GAAG,MAAM,MAAM,UAAU,mBAAmB,YAAY,YAAY,KAAK,UAAU,KAAK,UAAU,KAAK,UAAU,IAAI,UAAU,MAAM,KAAK,WAAW,GAAG,QAAQ,aAAa,GAAG,MAAM,iBAAiB,IAAI,MAAM,MAAM,UAAU,GAAG,WAAW,IAAI,YAAY,WAAW,gBAAgB,OAAO,MAAM,OAAO,GAAG,KAAK,WAAW,iBAAiB,IAAI,MAAM,MAAM,KAAK,MAAM,SAAS,MAAM,OAAO,GAAG,WAAW,IAAI,UAAU,UAAU,QAAQ,GAAG,OAAO,UAAU,aAAa,OAAO,SAAS,QAAQ,GAAG,OAAO,OAAO,IAAI,WAAW,gBAAgB,GAAG,aAAa,GAAG,aAAa,gBAAgB,OAAO,QAAQ,MAAM,UAAU,KAAK,IAAI,OAAO,SAAS,GAAG,MAAM,MAAM,SAAS,GAAG,MAAM,MAAM,MAAM,QAAQ,YAAY,GAAG,SAAS,GAAG,WAAW,WAAW,aAAa,OAAO,GAAG,QAAQ,KAAK,KAAK,GAAG,MAAM,MAAM,MAAM,aAAa,KAAK,IAAI,OAAO,IAAI,SAAS,KAAK,IAAI,SAAS,KAAK,MAAM,KAAK,SAAS,OAAO,KAAK,OAAO,UAAU,KAAK,SAAS,MAAM,WAAW,KAAK,MAAM,OAAO,eAAe,IAAI,UAAU,GAAG,KAAK,KAAK,KAAK,KAAK,KAAK,QAAQ,IAAI,cAAc,UAAU,GAAG,MAAM,UAAU,IAAI,KAAK,KAAK,QAAQ,KAAK,KAAK,OAAO,IAAI;;AAElxe;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C;AAC3C,iDAAiD;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,oBAAoB;AACrD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,mBAAmB;AACnB;;AAEA,yDAAyD;;AAEzD;AACA;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,oBAAoB;AACpB,8BAA8B;AAC9B,oCAAoC;AACpC;AACA;AACA;AACA;AACA,kBAAkB;;;AAGlB;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B,oCAAoC;AACpC,mCAAmC;AACnC,6CAA6C;AAC7C,uDAAuD;AACvD,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;AAC5B,6BAA6B;AAC7B,8BAA8B;AAC9B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,oCAAoC;AACpC,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iCAAiC;AACpE,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,+BAA+B;AAClE,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC,iDAAiD,8BAA8B;AAC/E;AACA;AACA;;AAEA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B;;AAE/B;AACA;AACA;AACA,4DAA4D;AAC5D;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,sCAAsC;AACtC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,sCAAsC;AACtC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,sCAAsC;AACtC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA,yCAAyC;AACzC,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C,oCAAoC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;AC/lOa;AACb;;AAEA,WAAW,mBAAO,CAAC,IAAQ;AAC3B,eAAe,mBAAO,CAAC,IAAY;AACnC,YAAY,mBAAO,CAAC,IAAS;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,oBAAoB,gBAAgB;AACvD,gBAAgB,aAAa;AAC7B,eAAe,aAAa;AAC5B,kBAAkB;AAClB;AACA;AACA,IAAI;AACJ,kBAAkB;AAClB;AACA;AACA,IAAI;AACJ,iBAAiB;AACjB;AACA;AACA,IAAI;AACJ,oBAAoB,oBAAoB,cAAc;AACtD,gBAAgB;AAChB;AACA;AACA;AACA,CAAC;;;;;;;;;ACpCY;AACb,YAAY,mBAAO,CAAC,IAAS;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC3Ca;AACb,UAAU,mBAAO,CAAC,IAAO;AACzB,eAAe,mBAAO,CAAC,IAAY;;AAEnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;;AAElC;AACA;AACA,sBAAsB,oBAAoB;AAC1C,uBAAuB;AACvB,GAAG;;AAEH,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,aAAa;AACb;AACA;AACA;AACA,IAAI;;AAEJ,YAAY;AACZ;AACA;AACA;AACA,IAAI;;AAEJ,cAAc;AACd;AACA;;AAEA,CAAC;;;;;;;;;ACvDY;AACb,cAAc,mBAAO,CAAC,IAAW;;AAEjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,+BAA+B;AAC/B;AACA;AACA,IAAI;;AAEJ,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;ACnDY;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACRa;AACb;;AAEA,YAAY,mBAAO,CAAC,IAAS;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC,UAAU,6BAA6B;;AAEvC,kBAAkB;AAClB;AACA,KAAK;AACL,oBAAoB;AACpB;AACA,KAAK;AACL,kBAAkB,kBAAkB;AACpC,oBAAoB,kBAAkB;AACtC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;ACxCY;;AAEb;AACA;AACA,iBAAiB,kBAAkB;AACnC,aAAa,mBAAmB;AAChC,gBAAgB,cAAc;AAC9B,cAAc,WAAW;AACzB,aAAa,gBAAgB;AAC7B,gBAAgB,mBAAmB;AACnC,eAAe,WAAW;AAC1B,YAAY,WAAW;AACvB,eAAe,WAAW;AAC1B,kBAAkB,oBAAoB;AACtC,CAAC;;AAED;;;;;;;;;AChBa;AACb;;AAEA,kBAAkB,mBAAO,CAAC,IAAe;AACzC,iBAAiB,mBAAO,CAAC,GAAc;AACvC,gBAAgB,mBAAO,CAAC,IAAa;AACrC,YAAY,mBAAO,CAAC,IAAS;;AAE7B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,gBAAgB;;AAE7B,mBAAmB;AACnB;AACA,IAAI;;AAEJ,mBAAmB,6BAA6B;;AAEhD,gBAAgB,2BAA2B;;AAE3C,eAAe,2BAA2B;;AAE1C,qBAAqB;AACrB;AACA;AACA;AACA;AACA,IAAI;;AAEJ,iBAAiB;AACjB;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,sBAAsB,cAAc;AACpC,uBAAuB,kBAAkB;AACzC,GAAG;;AAEH,0BAA0B;AAC1B;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA,IAAI;;AAEJ,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,cAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;;AAEJ,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ,iBAAiB;AACjB;AACA;AACA,IAAI;;AAEJ,kBAAkB;AAClB;AACA,IAAI;;AAEJ,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,cAAc;AACd,yBAAyB;AACzB,yBAAyB,aAAa;AACtC;AACA;AACA;AACA,IAAI;;AAEJ,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,YAAY;AAClC,kBAAkB,YAAY;AAC9B,sBAAsB;AACtB;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,eAAe;AACf;AACA,IAAI;;;AAGJ;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA,sCAAsC,cAAc;AACpD;AACA;AACA;;AAEA;AACA,IAAI;;AAEJ,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ,uBAAuB;AACvB,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,wBAAwB;AACxB,yCAAyC;AACzC;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;AACA,WAAW;AACX;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,GAAG;AACzB;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,oBAAoB,6BAA6B;;AAEjD;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,MAAM;AACN,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,6BAA6B;AAC7B;AACA,wBAAwB,GAAG;AAC3B;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,IAAI;;;AAGJ;AACA,YAAY;AACZ;AACA,IAAI;;AAEJ,eAAe;AACf;AACA,oCAAoC,gBAAgB;AACpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,4CAA4C,aAAa;AACzD,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA,iCAAiC,qBAAqB;AACtD,iCAAiC,uBAAuB;AACxD,iCAAiC,kBAAkB;AACnD,iCAAiC,2BAA2B;AAC5D,iCAAiC,8BAA8B;AAC/D,iCAAiC,oBAAoB;AACrD,iCAAiC,oCAAoC;AACrE,iCAAiC,qBAAqB;AACtD,iCAAiC,sBAAsB;AACvD,iCAAiC,2BAA2B;AAC5D,iCAAiC,+BAA+B;AAChE,iCAAiC,sBAAsB;;AAEvD,oCAAoC,uCAAuC;AAC3E,oCAAoC,oCAAoC;AACxE,oCAAoC,oCAAoC;AACxE,oCAAoC,mCAAmC;AACvE,oCAAoC,uCAAuC;AAC3E,+CAA+C,kDAAkD;AACjG,CAAC;;;;;;;;;ACjuBY;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACvBa;AACb;;AAEA,iBAAiB,mBAAO,CAAC,IAAc;AACvC,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,YAAY,mBAAO,CAAC,IAAS;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,eAAe;AACzB,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,KAAK;AACL,mBAAmB;AACnB;AACA,KAAK;AACL,gCAAgC;AAChC;AACA,KAAK;AACL,gBAAgB;AAChB;AACA,KAAK;AACL,YAAY;AACZ;AACA,KAAK;;AAEL;AACA;AACA,aAAa,MAAM;AACnB,cAAc,QAAQ;AACtB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,4DAA4D;AAC5D,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,KAAK;;AAEL;AACA;AACA;AACA,cAAc;AACd;AACA,kBAAkB;AAClB;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,cAAc;AACd;AACA,KAAK;AACL,CAAC;;;;;;;;;ACxNY;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACdA;AACa;;AAEb;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,cAAc;AACd;;;;;;;;;ACXa;;AAEb;;AAEA;AACA;AACA,eAAe,mBAAO,CAAC,GAAmB;AAC1C,EAAE;AACF;AACA,eAAe,mBAAO,CAAC,GAAmB;AAC1C;;AAEA;;;;;;;;;ACZa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,IAAS;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B;AAC3B,0BAA0B;AAC1B,0BAA0B;AAC1B,iCAAiC;AACjC;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,+BAA+B;AAC/B,gCAAgC;AAChC,qCAAqC;AACrC;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,KAAK,EAAE,EASV;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvKa;AACb,WAAW,mBAAO,CAAC,IAAQ;;AAE3B;;AAEA,wBAAwB;AACxB;AACA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA,IAAI;;AAEJ,4BAA4B;AAC5B;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;;ACzBa;AACb;;AAEA,WAAW,mBAAO,CAAC,IAAQ;AAC3B,oBAAoB,mBAAO,CAAC,IAAiB;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,oBAAoB;AACxC;AACA,yCAAyC,UAAU,OAAO;AAC1D;AACA;AACA;AACA;;AAEA;AACA,cAAc,kBAAkB,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,WAAW;AACX;AACA,IAAI;AACJ,aAAa;AACb;AACA;;AAEA,CAAC;;;;;;;;;AC1CY;AACb;;AAEA,YAAY,mBAAO,CAAC,IAAS;AAC7B,WAAW,mBAAO,CAAC,IAAQ;AAC3B,oBAAoB,mBAAO,CAAC,IAAiB;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,oBAAoB;AACxC;AACA,yCAAyC,UAAU,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH,eAAe;AACf;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;;AAEJ,eAAe;AACf;AACA,sCAAsC,MAAM;AAC5C,8CAA8C;AAC9C;AACA;AACA;AACA,IAAI;AACJ;AACA,sBAAsB,kBAAkB;;AAExC;AACA,WAAW;AACX;AACA,IAAI;;AAEJ,CAAC;;;;;;;;;ACzEY;AACb;;AAEA,WAAW,mBAAO,CAAC,IAAQ;AAC3B,iBAAiB,mBAAO,CAAC,IAAc;AACvC,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,YAAY,mBAAO,CAAC,IAAS;;AAE7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,kBAAkB,sBAAsB;AAClD,gBAAgB,kBAAkB,4BAA4B;AAC9D,YAAY,kBAAkB,wBAAwB;;AAEtD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,aAAa,MAAM;AACnB,cAAc,QAAQ;AACtB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,cAAc;AACd;AACA,gBAAgB;AAChB;AACA,IAAI;;AAEJ;AACA;AACA;AACA,cAAc;AACd;AACA,eAAe;AACf;AACA,IAAI;;AAEJ;AACA;AACA;AACA,cAAc;AACd;AACA,qBAAqB;AACrB;AACA,IAAI;;AAEJ;AACA;AACA;AACA,cAAc;AACd;AACA,iBAAiB;AACjB;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA,cAAc;AACd;AACA,IAAI;AACJ,CAAC;;;;;;;;;AC/UY;AACb,YAAY,mBAAO,CAAC,GAAS;;AAE7B;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;AClBY;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,+BAA+B;AAC/B,+BAA+B;AAC/B,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;;;;;;;;ACjMa;AACb,UAAU,mBAAO,CAAC,IAAO;;AAEzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA,UAAU;AACV;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;;AAEA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH,YAAY;AACZ;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,GAAG;AACH;;;;;;;;;AC7Qa;AACb,wBAAwB,mBAAO,CAAC,IAAqB;AACrD,kBAAkB,mBAAO,CAAC,IAAe;AACzC,eAAe,mBAAO,CAAC,GAAY;AACnC,aAAa,mBAAO,CAAC,IAAU;AAC/B,YAAY,mBAAO,CAAC,IAAS;;AAE7B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,0BAA0B;AACpC,aAAa,gBAAgB;AAC7B,aAAa;AACb;AACA;AACA;AACA,IAAI;AACJ,eAAe,OAAO,mBAAO,CAAC,GAAe,GAAG;;AAEhD;AACA,YAAY,kBAAkB,eAAe;AAC7C,UAAU,kBAAkB,eAAe;AAC3C,YAAY,kBAAkB,eAAe;;AAE7C;AACA,YAAY,kBAAkB,eAAe;AAC7C,SAAS,kBAAkB,eAAe;;AAE1C;AACA,YAAY,UAAU;AACtB,kBAAkB,aAAa;AAC/B,YAAY,aAAa;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA,sBAAsB;AACtB;AACA;;AAEA,CAAC;;AAED,aAAa,mBAAO,CAAC,IAAgB;AACrC,aAAa,mBAAO,CAAC,IAAQ;;;;;;;;;AC7DhB;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACVa;AACb,YAAY,mBAAO,CAAC,IAAS;;AAE7B,gBAAgB;AAChB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,2CAA2C;AAC3C;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wCAAwC;AAChE;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,iBAAiB;AACjB;AACA;AACA,KAAK;AACL;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,QAAQ;AACR;AACA,iBAAiB;AACjB,QAAQ;AACR;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;;AAEA,SAAqB;;;;;;;;;ACNrB;AACa,CAAC;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,eAAe;AAC9B;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,UAAU;AACzB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,IAAI;;;AAG5C;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,eAAe,KAAK;AACpB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA,qBAAqB;AACrB;AACA,eAAe,eAAe;AAC9B;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,KAAK;;;AAGL;AACA;AACA;AACA,eAAe,KAAK;AACpB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,wDAAwD;AACxD,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,WAAW;;AAElC,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA,eAAe,SAAS;AACxB;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,sCAAsC;AACtC,eAAe,WAAW;AAC1B;AACA;AACA,eAAe,SAAS;AACxB;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA,eAAe,SAAS;AACxB;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,cAAc;AACd;AACA;;AAEA,UAAU;AACV;AACA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,KAAK;AACpB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,UAAU;AACV;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;;AAErC;AACA;AACA;AACA,oDAAoD;AACpD;;AAEA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA,aAAa;;AAEb;AACA;AACA;AACA,iFAAiF;AACjF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA,aAAa;;AAEb;AACA;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;;;AAGb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC,oCAAoC;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB,aAAa;;AAEb;AACA;AACA;AACA;AACA,sCAAsC,kBAAkB,uBAAuB;AAC/E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB,sBAAsB;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;;AAEb;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB,uBAAuB;AACtE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB,uBAAuB;AACtE;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;;AAEA;;AAEA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA,kBAAkB;;AAElB;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;;AAEzB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,oCAAoC,IAAI;AACxC;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2DAA2D,sBAAsB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA,yBAAyB,qBAAqB,sBAAsB;AACpE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA,uBAAuB,SAAS;AAChC;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB,sBAAsB;AACnE;AACA,wBAAwB,mCAAmC,oCAAoC;AAC/F;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa;;;AAGb;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA,uBAAuB,QAAQ;AAC/B,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B,wBAAwB;AACxB;AACA;AACA;AACA,2BAA2B,GAAG;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;;AAGD;AACA;AACA,8BAA8B,GAAG;AACjC,+BAA+B,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8BAA8B;AACtE,wCAAwC,0CAA0C;AAClF,wCAAwC,8BAA8B;AACtE,wCAAwC,0DAA0D;AAClG,wCAAwC,2CAA2C;AACnF,wCAAwC,sCAAsC;AAC9E,wCAAwC,wCAAwC;AAChF;;AAEA;AACA,6CAA6C,8BAA8B;AAC3E,6CAA6C,0CAA0C;AACvF,6CAA6C,8BAA8B;AAC3E,6CAA6C,2CAA2C;AACxF,6CAA6C,sCAAsC;AACnF,6CAA6C,wCAAwC;;AAErF,4CAA4C,8BAA8B;AAC1E,4CAA4C,0CAA0C;AACtF,4CAA4C,8BAA8B;AAC1E,4CAA4C,2CAA2C;AACvF,4CAA4C,sCAAsC;AAClF,4CAA4C,wCAAwC;;AAEpF,gDAAgD,8BAA8B;AAC9E,gDAAgD,0CAA0C;AAC1F,gDAAgD,8BAA8B;AAC9E,gDAAgD,0DAA0D;AAC1G,gDAAgD,2CAA2C;AAC3F,gDAAgD,sCAAsC;AACtF,gDAAgD,wCAAwC;;AAExF,2CAA2C,8BAA8B;AACzE,2CAA2C,0CAA0C;AACrF,2CAA2C,8BAA8B;AACzE,2CAA2C,2CAA2C;AACtF,2CAA2C,sCAAsC;AACjF,2CAA2C,wCAAwC;;AAEnF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,wCAAwC,oCAAoC;AAC5E,wCAAwC,6BAA6B;AACrE;AACA,wCAAwC,kCAAkC;AAC1E,wCAAwC,6BAA6B;AACrE,wCAAwC,qCAAqC;AAC7E,wCAAwC,yBAAyB;AACjE,wCAAwC,iCAAiC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,oCAAoC;AAC5E;AACA,wCAAwC,sCAAsC;AAC9E,wCAAwC,2CAA2C;AACnF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd,+EAA+E,KAAK;AACpF;AACA;AACA,KAAK;AACL;AACA,wCAAwC,4DAA4D;AACpG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wCAAwC,qCAAqC;AAC7E,wCAAwC,iCAAiC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iCAAiC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,2CAA2C;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,4CAA4C;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+BAA+B;AACvE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,WAAW,UAAU;AACrB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,iCAAiC;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,iCAAiC;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,iCAAiC;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C;AAC/C,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,mDAAmD;AACnD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,MAAM,6CAA6C;AACnD;AACA;AACA,MAAM,wCAAwC;AAC9C;AACA;AACA,MAAM,4CAA4C;AAClD;AACA;;AAEA,MAAM,sBAAsB,IAAI,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM,qEAAqE;AAC3E;AACA;AACA;AACA;AACA,MAAM,wEAAwE;AAC9E;AACA;AACA;AACA;AACA,MAAM,sFAAsF;AAC5F;AACA;AACA;AACA;AACA;AACA,MAAM,yFAAyF;AAC/F;AACA;AACA;AACA;AACA;AACA,MAAM,uEAAuE;AAC7E;AACA;AACA;AACA;AACA,MAAM,wFAAwF;AAC9F;AACA;AACA;AACA;AACA;AACA,MAAM,sDAAsD;AAC5D;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM,0DAA0D,IAAI,yCAAyC;AAC7G;AACA;AACA,MAAM,0DAA0D,IAAI,yCAAyC;AAC7G;AACA;AACA,MAAM,uCAAuC;AAC7C;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,6CAA6C;AAC7C,2BAA2B,IAAI;AAC/B;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,IAAI;AACzD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,iCAAiC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe,aAAa;AAC5B,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,SAAS;AAC7C;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,wBAAwB;AACnC,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA,wDAAwD,SAAS;AACjE;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB,eAAe,QAAQ;AACvB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,iCAAiC;AACjC,eAAe,QAAQ;AACvB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,iCAAiC;AACjC,eAAe,QAAQ;AACvB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU,kCAAkC;;AAE5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,yCAAyC;AACzC;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;;AAGA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;;AAEA,UAAU;AACV;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;;AAEd;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,KAAK;AACpB,eAAe,KAAK;AACpB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,KAAK;;;;;AAKL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;;AAEA;AACA,MAAM,YAAY;AAClB,MAAM,YAAY;;AAElB;AACA,MAAM,+CAA+C;AACrD,MAAM,gEAAgE;;AAEtE;AACA,MAAM,6BAA6B;AACnC,MAAM,8BAA8B;AACpC,MAAM,gCAAgC;AACtC,MAAM,gCAAgC;AACtC,MAAM,mCAAmC;;AAEzC;AACA,MAAM,eAAe;AACrB,MAAM,cAAc;AACpB,MAAM,aAAa;;AAEnB;AACA,MAAM,oCAAoC;AAC1C,MAAM,gCAAgC;AACtC,MAAM,kCAAkC;AACxC,MAAM,0CAA0C;AAChD,MAAM,sCAAsC;AAC5C,MAAM,0CAA0C;AAChD,MAAM,2EAA2E;AACjF,MAAM,4DAA4D;AAClE,MAAM,qBAAqB;AAC3B,QAAQ,kBAAkB;;AAE1B;AACA,MAAM,yGAAyG;;AAE/G;AACA,MAAM,sBAAsB;;AAE5B;AACA,MAAM,eAAe;AACrB,MAAM,cAAc;AACpB,MAAM,aAAa;AACnB,MAAM,aAAa;AACnB,MAAM,kBAAkB;AACxB,MAAM,mBAAmB;AACzB,MAAM,eAAe;;AAErB;AACA,MAAM,YAAY;AAClB,MAAM,iBAAiB;;AAEvB;AACA,MAAM,sBAAsB;;AAE5B;AACA;AACA;;AAEA;AACA,MAAM,gBAAgB;;AAEtB;AACA,MAAM,yBAAyB;AAC/B,MAAM,2BAA2B;AACjC,MAAM,yBAAyB;AAC/B,MAAM,yBAAyB;;AAE/B;AACA,MAAM,YAAY;;AAElB;AACA;AACA;AACA,MAAM,oDAAoD;AAC1D,MAAM,uCAAuC;AAC7C,MAAM,2CAA2C;AACjD,MAAM,yCAAyC;AAC/C,MAAM,sDAAsD;AAC5D,MAAM,0DAA0D;AAChE,MAAM,6CAA6C;AACnD,MAAM,iDAAiD;AACvD,MAAM,+CAA+C;AACrD,MAAM,4DAA4D;AAClE,MAAM,uCAAuC;AAC7C,MAAM,6CAA6C;AACnD,MAAM,6CAA6C;AACnD,MAAM,yCAAyC;AAC/C,MAAM,+CAA+C;AACrD,MAAM,+CAA+C;;AAErD;AACA;AACA;AACA,QAAQ,mCAAmC;AAC3C,MAAM,kCAAkC;AACxC,MAAM,kCAAkC;AACxC,MAAM,mCAAmC;;AAEzC;AACA;AACA;;AAEA;AACA,MAAM,qBAAqB;;AAE3B;AACA,MAAM,cAAc;;AAEpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,mBAAmB;AACnB,gBAAgB;AAChB,KAAK;AACL;AACA;AACA,gBAAgB;AAChB,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB;AAChB,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,oBAAoB,WAAW;AAC/B,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA,8BAA8B,2BAA2B;AACzD;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;;;AAID;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA,cAAc;AACd;AACA,cAAc;AACd;AACA;;AAEA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA,UAAU;AACV;AACA;AACA;;AAEA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,2CAA2C;AAC7E;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,mBAAmB;AACrD;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,KAAK;;;;AAIL;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET,4CAA4C;AAC5C;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA,2DAA2D,EAAE;AAC7D;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,6DAA6D,KAAK;AAClE;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA,yEAAyE;AACzE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;;AAET;AACA,mCAAmC,KAAK;AACxC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;AC7/MY;;AAEb,iBAAiB,mBAAO,CAAC,IAAc;AACvC,aAAa,mBAAO,CAAC,IAAU;AAC/B,oBAAoB,kDAAiC;;AAErD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA,GAAG;AACH;;;;;;;;;ACrEa;AACb;AACA,SAAS,mBAAO,CAAC,GAAS;AAC1B,WAAW,mBAAO,CAAC,IAAW;AAC9B,cAAc,mBAAO,CAAC,IAAc;AACpC,eAAe,mBAAO,CAAC,IAAe;AACtC;;;;;;;;;ACNa;AACb,WAAW,mBAAO,CAAC,IAAQ;AAC3B,cAAc,mBAAO,CAAC,IAAW;AACjC,0BAA0B,mBAAO,CAAC,GAAuB;AACzD,YAAY,mBAAO,CAAC,IAAS;AAC7B,eAAe,mBAAO,CAAC,IAAY;AACnC,oBAAoB,mBAAO,CAAC,IAAiB;;AAE7C,mBAAmB,gBAAgB;AACnC;;AAEA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,mDAAmD;AACnD;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL,uCAAuC;AACvC;AACA,MAAM;;AAEN;AACA,YAAY,qBAAqB;AACjC,aAAa,qBAAqB;AAClC,uBAAuB,qBAAqB;;AAE5C,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,cAAc,kBAAkB;AAChC,GAAG;AACH;AACA;AACA;AACA,UAAU,0CAA0C;AACpD;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;AAGD;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAA4C;AACxD,YAAY,4CAA4C;AACxD,aAAa,4CAA4C;AACzD,aAAa,4CAA4C;AACzD,eAAe,4CAA4C;AAC3D;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+DAA+D;AAC3E;AACA;AACA,kBAAkB,8DAA8D;AAChF,mBAAmB,6IAA6I;AAChK;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,kCAAkC;AACrD;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA,cAAc,iEAAiE;AAC/E;AACA,eAAe,8KAA8K;AAC7L,eAAe,+LAA+L;AAC9M;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,IAAU,GAAG;AACtC;AACA,GAAG;AACH;AACA,qBAAqB;AACrB;AACA,OAAO;AACP,uBAAuB;AACvB;AACA,OAAO;AACP,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAA4C;AAChE,mBAAmB,4CAA4C;AAC/D;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mCAAmC;AACjD,aAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA;AACA,cAAc,mCAAmC;AACjD,cAAc,mCAAmC;AACjD;AACA,cAAc,4CAA4C;AAC1D;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA,MAAM;AACN,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+BAA+B;AACpD,WAAW,sDAAsD;AACjE,YAAY,qDAAqD;AACjE,aAAa,qDAAqD;AAClE,gBAAgB,sDAAsD;AACtE,gBAAgB,sDAAsD;AACtE;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,kBAAkB,oDAAoD;AACtE,mBAAmB,6IAA6I;AAChK,iBAAiB,gKAAgK;AACjL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,cAAc;AACd;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,YAAY,6DAA6D;AACzE;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,gBAAgB,iCAAiC;AACjD;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mCAAmC;AACjD;AACA,cAAc,mCAAmC;AACjD;AACA;AACA,cAAc,4CAA4C;AAC1D;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,wBAAwB,6CAA6C;AACrE,yBAAyB,4BAA4B;AACrD,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,yBAAyB,uBAAuB;AAChD,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA,sBAAsB,gCAAgC;AACtD;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,aAAa,0BAA0B;AACvC;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,UAAU;AACV;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,eAAe;AACf;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA,GAAG;AACH;AACA,cAAc,kCAAkC;AAChD,cAAc,kCAAkC;AAChD;AACA,aAAa,wDAAwD;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,4BAA4B;AACtC,aAAa,+BAA+B;AAC5C;AACA;AACA,eAAe,4CAA4C;AAC3D;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,WAAW,gEAAgE;AAC3E;AACA;AACA,UAAU,4BAA4B;AACtC,aAAa,+BAA+B;AAC5C;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,YAAY;AACZ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4CAA4C;AAC3D,mBAAmB,4CAA4C;AAC/D,mBAAmB,4CAA4C;AAC/D;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,eAAe,kBAAkB,iCAAiC;AAClE,iBAAiB,oBAAoB;AACrC;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,aAAa;AACb;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,UAAU,4BAA4B;AACtC,aAAa,+BAA+B;AAC5C;AACA,eAAe,4CAA4C;AAC3D,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,YAAY;AACZ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,UAAU,4BAA4B;AACtC,aAAa,+BAA+B;AAC5C;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,YAAY,kBAAkB,sBAAsB;AACpD;AACA,wBAAwB,0BAA0B;AAClD,yBAAyB,uBAAuB;AAChD,KAAK;AACL;AACA,wBAAwB,0BAA0B,mBAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,kBAAkB,kBAAkB,6BAA6B;AACjE,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yDAAyD;AACpE,WAAW,0DAA0D;AACrE,gBAAgB,sDAAsD;AACtE,gBAAgB,sDAAsD;AACtE,iBAAiB,gKAAgK;AACjL;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,YAAY;AACZ;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,eAAe,mCAAmC,yBAAyB,oBAAoB;AAC/F;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,YAAY,2CAA2C;AACvD,aAAa;AACb;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,kBAAkB,kBAAkB;AACpC,+BAA+B,kBAAkB;AACjD,kBAAkB,kBAAkB;AACpC,8BAA8B,kBAAkB;AAChD,iBAAiB,kBAAkB;AACnC,cAAc;AACd,GAAG;AACH;AACA,aAAa,oCAAoC;AACjD,cAAc;AACd;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,YAAY,kBAAkB;AAC9B,iBAAiB,kBAAkB;AACnC,aAAa;AACb,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA,YAAY,0DAA0D;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,YAAY,oHAAoH;AAChI,GAAG;AACH;AACA,YAAY,kBAAkB,aAAa;AAC3C,eAAe,kBAAkB,aAAa;AAC9C,cAAc,kBAAkB,aAAa;AAC7C,aAAa,kBAAkB,aAAa;AAC5C,kBAAkB,gBAAgB;AAClC,aAAa;AACb;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,aAAa,4CAA4C;AACzD,YAAY,cAAc;AAC1B,YAAY,cAAc;AAC1B,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;ACj5CY;AACb,YAAY,mBAAO,CAAC,IAAS;;AAE7B;AACA,uBAAuB,mBAAO,CAAC,GAAuB;AACtD,iBAAiB,mBAAO,CAAC,IAAiB;AAC1C,WAAW,mBAAO,CAAC,IAAW;AAC9B,gBAAgB,mBAAO,CAAC,IAAgB;AACxC,qBAAqB,mBAAO,CAAC,IAAqB;AAClD,gBAAgB,mBAAO,CAAC,IAAgB;AACxC,YAAY,mBAAO,CAAC,IAAY;AAChC,oBAAoB,mBAAO,CAAC,IAAoB;AAChD,gBAAgB,mBAAO,CAAC,IAAgB;AACxC,WAAW,mBAAO,CAAC,IAAW;AAC9B,cAAc,mBAAO,CAAC,IAAc;AACpC,gBAAgB,mBAAO,CAAC,IAAgB;AACxC,QAAQ,mBAAO,CAAC,IAAQ;AACxB,YAAY,mBAAO,CAAC,IAAY;AAChC,cAAc,mBAAO,CAAC,IAAc;AACpC,yBAAyB,mBAAO,CAAC,IAAyB;AAC1D,QAAQ,mBAAO,CAAC,IAAQ;AACxB,UAAU,mBAAO,CAAC,IAAU;AAC5B;;AAEA,qBAAqB,mBAAO,CAAC,IAAU;AACvC,qBAAqB,oCAA8B;AACnD,qBAAqB,oCAAyB;;;;;;;;;AC1BjC;AACb,wBAAwB,mBAAO,CAAC,IAAqB;AACrD,iBAAiB,mBAAO,CAAC,IAAc;AACvC,aAAa,mBAAO,CAAC,IAAU;;AAE/B,+BAA+B;AAC/B;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,mDAAmD,cAAc;AACjE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,oBAAoB;AACpB;AACA,+BAA+B;AAC/B;AACA;;AAEA,wCAAgC;;;;;;;;;AC9EnB;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,KAAK;AACb;AACA;AACA;AACA,KAAK,MAAM,EAIN;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,wCAAwC;AACxC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C,IAAI;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB,iBAAiB;AACjB,mBAAmB;;AAEnB,eAAe;AACf,eAAe;AACf;AACA;AACA,oBAAoB;AACpB,IAAI;AACJ;AACA;;;;;;;;ACp6BA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kBAAkB;AAC9D;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;;;;;;;;ACvBa;AACb,cAAc,mBAAO,CAAC,IAAW;AACjC,oBAAoB,mBAAO,CAAC,IAAiB;AAC7C,YAAY,mBAAO,CAAC,IAAS;AAC7B,0BAA0B,mBAAO,CAAC,GAAuB;;AAEzD,kBAAkB,gBAAgB;AAClC;;AAEA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;ACxDY;AACb,mBAAmB,mBAAO,CAAC,IAAgB;AAC3C;AACA,oBAAoB,kDAAiC;;AAErD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC,6BAA6B,gBAAgB;AAC7C,0BAA0B,gBAAgB;AAC1C,6BAA6B,gBAAgB;AAC7C,kCAAkC,gBAAgB;AAClD,qBAAqB,gBAAgB;AACrC,yBAAyB,gBAAgB;AACzC,yBAAyB,gBAAgB;AACzC,mBAAmB,gBAAgB;AACnC,gCAAgC,gBAAgB;AAChD,sBAAsB,gBAAgB;AACtC,0BAA0B,gBAAgB;AAC1C,yBAAyB,gBAAgB;AACzC,qBAAqB,gBAAgB;AACrC,oBAAoB,gBAAgB;AACpC,kBAAkB,gBAAgB;AAClC,wBAAwB,gBAAgB;AACxC,0BAA0B,gBAAgB;AAC1C,oBAAoB,gBAAgB;AACpC,4BAA4B,gBAAgB;AAC5C,sBAAsB,gBAAgB;;AAEtC,WAAW;AACX;AACA;;AAEA,sBAAsB;AACtB,sCAAsC;AACtC;;AAEA,cAAc;AACd;AACA;AACA;AACA;;AAEA,cAAc;AACd;AACA,4CAA4C,wCAAwC;AACpF;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA,GAAG;AACH;;AAEA,wBAAwB;AACxB;AACA;AACA,GAAG;AACH;;;;;;;;;ACpFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC,iCAAiC;;AAEjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;;;;;;;;AC1FA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,WAAW,mBAAO,CAAC,IAAI;AACvB,aAAa,mBAAO,CAAC,IAAM;AAC3B,WAAW,mBAAO,CAAC,IAAI;;AAEvB;AACA,iCAAiC,QAAQ;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA,MAAM;AACN,2DAA2D,QAAQ,IAAI,KAAK;AAC5E;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,UAAU,KAAK,OAAO;;AAE7E;AACA;AACA;AACA,QAAQ;AACR,gBAAgB,IAAI;AACpB;AACA,KAAK;;AAEL,aAAa;AACb,IAAI;AACJ,aAAa;AACb;AACA;;AAEA,qBAAqB;AACrB,oBAAoB;;;;;;;;;ACrHP;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,wBAAwB,GAAG,iBAAiB;AACjE,sCAAsC,mBAAO,CAAC,IAAsB;AACpE,oCAAoC,mBAAO,CAAC,IAAoB;AAChE,iCAAiC,mBAAO,CAAC,IAAiB;AAC1D,yCAAyC,mBAAO,CAAC,EAAoB;AACrE,8DAA8D;AAC9D,iBAAiB;AACjB,wBAAwB;AACxB;AACA;AACA,4BAA4B;AAC5B;AACA,+BAA+B;AAC/B,kBAAkB;AAClB;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,sEAAsE,QAAQ;AAC9E;AACA;AACA,iCAAiC;AACjC,qBAAqB;AACrB;AACA;AACA;AACA,4BAA4B;AAC5B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACpDa;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,oCAAoC,mBAAO,CAAC,IAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;AC7BF;AACb;AACA,6CAA6C;AAC7C;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,cAAc,GAAG,0BAA0B,GAAG,kBAAkB,GAAG,iBAAiB;AACzG,iCAAiC,mBAAO,CAAC,IAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,iBAAiB;AACjB,sCAAsC,mBAAO,CAAC,IAAsB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,2CAA2C,uBAAuB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,0DAA0D,yCAAyC;AACnG;AACA;;;;;;;;;ACvIa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,GAAG,yBAAyB,GAAG,yBAAyB,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,wBAAwB,GAAG,kBAAkB,GAAG,iBAAiB,GAAG,mBAAmB,GAAG,mBAAmB,GAAG,kBAAkB,GAAG,cAAc,GAAG,0BAA0B,GAAG,kBAAkB,GAAG,iBAAiB,GAAG,cAAc,GAAG,oBAAoB,GAAG,cAAc;AAChZ,eAAe,mBAAO,CAAC,IAAU;AACjC,eAAe,mBAAO,CAAC,IAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,eAAe,mBAAO,CAAC,IAAU;AACjC,6CAA4C,EAAE,qCAAqC,8BAA8B,EAAC;AAClH,8CAA6C,EAAE,qCAAqC,+BAA+B,EAAC;AACpH,sDAAqD,EAAE,qCAAqC,uCAAuC,EAAC;AACpI,0CAAyC,EAAE,qCAAqC,2BAA2B,EAAC;AAC5G,8CAA6C,EAAE,qCAAqC,+BAA+B,EAAC;AACpH;AACA,+CAA8C,EAAE,qCAAqC,+BAA+B,EAAC;AACrH,+CAA8C,EAAE,qCAAqC,+BAA+B,EAAC;AACrH,eAAe,mBAAO,CAAC,IAAU;AACjC,6CAA4C,EAAE,qCAAqC,8BAA8B,EAAC;AAClH,8CAA6C,EAAE,qCAAqC,+BAA+B,EAAC;AACpH,oDAAmD,EAAE,qCAAqC,qCAAqC,EAAC;AAChI;AACA,+CAA8C,EAAE,qCAAqC,+BAA+B,EAAC;AACrH,+CAA8C,EAAE,qCAAqC,+BAA+B,EAAC;AACrH,qDAAoD,EAAE,qCAAqC,qCAAqC,EAAC;AACjI,qDAAoD,EAAE,qCAAqC,qCAAqC,EAAC;AACjI,mDAAkD,EAAE,qCAAqC,8BAA8B,EAAC;;;;;;;;;ACxD3G;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;;;;;;;;ACZa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,YAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,4BAA4B,iDAAiD;;AAE7E;AACA,OAAO;AACP,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;ACpHA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;ACVa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;ACTY;;AAEZ,aAAa,mBAAO,CAAC,IAAe;;AAEpC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxPY;;AAEZ;;AAEA,YAAY,mBAAO,CAAC,IAA0B;AAC9C,cAAc,mBAAO,CAAC,IAAuB;AAC7C,aAAa,mBAAO,CAAC,IAAsB;;AAE3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;;AAEA;AACA;AACA,wBAAwB,uDAAuD;AAC/E;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA,sBAAsB,6CAA6C;AACnE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;ACnLY;;AAEZ;;AAEA;;AAEA,eAAe,mBAAO,CAAC,IAAsB;AAC7C,aAAa,mBAAO,CAAC,IAAgC;AACrD,UAAU,mBAAO,CAAC,IAA0C;AAC5D,0BAA0B,mBAAO,CAAC,IAA0C;AAC5E,kBAAkB,mBAAO,CAAC,GAAmC;AAC7D,aAAa,mBAAO,CAAC,IAAsB;AAC3C,mBAAmB,mBAAO,CAAC,GAA2B;AACtD,kBAAkB,mBAAO,CAAC,IAA4B;AACtD,aAAa,mBAAO,CAAC,IAA8B;AACnD,wBAAwB,mBAAO,CAAC,IAA+B;;AAE/D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB,gDAAgD;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,+BAA+B;AACpD;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mCAAmC;AAChE;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,6BAA6B,mCAAmC;AAChE;AACA;AACA;AACA,6BAA6B,iCAAiC;AAC9D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kEAAkE;;AAElE;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;;;;;;;ACtzBY;;AAEZ,0CAAkC;;;;;;;;ACFlC,aAAa,mBAAO,CAAC,GAAQ;AAC7B,qBAAqB,mBAAO,CAAC,IAA6B;AAC1D,yBAAyB,mBAAO,CAAC,IAA8C;AAC/E,wBAAwB,mBAAO,CAAC,GAA6C;;AAE7E,kBAAkB;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,iDAAiD;AAC/D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,yCAAyC;AACzD;;AAEA;AACA,uBAAuB,8BAA8B;AACrD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,yCAAyC;AACzD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB,MAAM;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5JA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzBA,sBAAsB;AACtB,aAAa,IAAI;AACjB,YAAY,IAAI;;AAEhB;AACA,cAAc,6BAA6B;AAC3C;;AAEA;AACA;AACA;;;;;;;;ACVA,eAAe,mBAAO,CAAC,IAAoD;;AAE3E,cAAc,KAAK,wCAAwC;AAC3D,gBAAgB,IAAI;;AAEpB;;AAEA;AACA;AACA,uCAAuC,wBAAwB;AAC/D;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AChBA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,iDAAiD;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc,+BAA+B;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA,cAAc,gCAAgC;AAC9C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACpDA,eAAe,mBAAO,CAAC,IAAoD;AAC3E,wBAAwB,mBAAO,CAAC,IAA+C;AAC/E,oBAAoB,mBAAO,CAAC,IAAgB;;AAE5C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO,0CAA0C;AACjD,OAAO,0CAA0C;AACjD;AACA;AACA,OAAO,gDAAgD;AACvD;AACA,OAAO,yCAAyC;AAChD;AACA;AACA,OAAO,0CAA0C;AACjD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,8BAA8B;AACvE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC/GA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;;;;;;;;ACjDA,sBAAsB,mBAAO,CAAC,IAA6C;;AAE3E,cAAc,KAAK,8CAA8C;;AAEjE,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qDAAqD,IAAI;AACzD;;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;;ACrBA,sBAAsB,mBAAO,CAAC,IAA+C;AAC7E,oBAAoB,mBAAO,CAAC,IAA4C;AACxE,YAAY,mBAAO,CAAC,IAAoC;AACxD,mBAAmB,mBAAO,CAAC,IAA6C;;AAExE,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kEAAkE;AAClE;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;;;;;;;ACzCA,sBAAsB,mBAAO,CAAC,IAA6C;AAC3E,oBAAoB,mBAAO,CAAC,IAA0C;AACtE,YAAY,mBAAO,CAAC,IAAkC;AACtD,mBAAmB,mBAAO,CAAC,IAA2C;AACtE,gBAAgB,mBAAO,CAAC,IAAsC;;AAE9D;;AAEA;AACA;AACA,KAAK,YAAY,oCAAoC;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;ACrBA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN,+DAA+D;AAC/D,MAAM;AACN;AACA;AACA;;AAEA;AACA;;;;;;;;AC1BA;AACA;;AAEA,qBAAqB,mBAAO,CAAC,IAAyB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;ACpEA;;AAEA,aAAa,mBAAO,CAAC,IAAe;AACpC,kBAAkB,mBAAO,CAAC,IAAsB;AAChD,0BAA0B,mBAAO,CAAC,IAAgC;AAClE,WAAW,mBAAO,CAAC,IAAwB;AAC3C,kBAAkB,mBAAO,CAAC,IAAsB;;AAEhD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC9CA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACdA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;AClBA;;AAEA,aAAa,mBAAO,CAAC,IAAe;;AAEpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8CAA8C,0BAA0B;AACxE;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC9CA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;;;;;;;ACxDA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;;;;ACxBA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;ACxBY;;AAEZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;AC5BA,0CAAoC;;;;;;;;ACApC,iBAAiB,mBAAO,CAAC,IAAsC;AAC/D,wBAAwB,mBAAO,CAAC,IAA6C;AAC7E,mBAAmB,mBAAO,CAAC,IAAwC;AACnE,yBAAyB,mBAAO,CAAC,IAA+C;AAChF,yBAAyB,mBAAO,CAAC,IAA8C;AAC/E,wBAAwB,mBAAO,CAAC,GAA6C;;AAE7E,WAAW;AACX,cAAc;AACd,YAAY;AACZ,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB,oBAAoB;AACpB,qBAAqB;;AAErB;;AAEA;AACA,YAAY;;AAEZ;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpkBA;;AAEA,wBAAwB,mBAAO,CAAC,IAAwC;AACxE,oBAAoB,mBAAO,CAAC,IAAoC;AAChE,iBAAiB,mBAAO,CAAC,IAAiC;AAC1D,cAAc,mBAAO,CAAC,IAA6B;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,UAAU,OAAO,eAAe,eAAe;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/JA,0CAAoC;;;;;;;;ACApC,YAAY;AACZ,SAAS;AACT;;AAEA,kBAAkB,mBAAO,CAAC,IAAuC;;AAEjE,2BAA2B;AAC3B,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;AC/jBA,0CAAoC;;;;;;;;ACApC,gCAAgC,mBAAO,CAAC,IAAwD;AAChG,mBAAmB,mBAAO,CAAC,IAAuC;AAClE,iBAAiB,mBAAO,CAAC,IAAiC;;AAE1D,qBAAqB;;AAErB,YAAY,IAAI;;AAEhB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/EA,0CAAoC;;;;;;;;ACApC,cAAc,mBAAO,CAAC,IAAwC;AAC9D,eAAe,mBAAO,CAAC,IAA0C;AACjE,oBAAoB,mBAAO,CAAC,IAAuC;AACnE,YAAY,mBAAO,CAAC,IAA+B;AACnD,eAAe,mBAAO,CAAC,IAAwC;;AAE/D;;AAEA;AACA;AACA;;;;;;;;;ACVY;;AAEZ,iBAAiB,mBAAO,CAAC,IAAwB;;AAEjD;;AAEA;;;;;;;;;ACNY;;AAEZ,iBAAiB,mBAAO,CAAC,IAAwB;;AAEjD;;AAEA;;;;;;;;;ACNY;;AAEZ,iBAAiB,mBAAO,CAAC,IAAwB;;AAEjD;;AAEA;;;;;;;;;ACNY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACXY;;AAEZ,iBAAiB,mBAAO,CAAC,IAAwB;;AAEjD;;AAEA;;;;;;;;;ACNY;;AAEZ,iBAAiB,mBAAO,CAAC,IAAwB;;AAEjD;;AAEA;;;;;;;;;ACNY;;AAEZ,iBAAiB,mBAAO,CAAC,IAAwB;;AAEjD,8CAA8C;;AAE9C;;;;;;;;;ACNY;;AAEZ;AACA;AACA;;AAEA;;;;;;;;;ACNY;;AAEZ;AACA;AACA;;AAEA;;;;;;;;;ACNY;;AAEZ;AACA;AACA;;AAEA;;;;;;;;;ACNY;;AAEZ,8BAA8B,mBAAO,CAAC,IAA0C;AAChF,iBAAiB,mBAAO,CAAC,IAAwB;;AAEjD;;AAEA;;AAEA;;;;;;;;;ACTY;;AAEZ,iBAAiB,mBAAO,CAAC,IAAwB;;AAEjD;;AAEA;;;;;;;;;ACNY;;AAEZ;;AAEA;;;;;;;;;ACJY;;AAEZ;;AAEA;;;;;;;;;ACJY;;AAEZ,YAAY;;AAEZ;;;;;;;;;ACJY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACpEY;;AAEZ;AACA;;AAEA;;;;;;;;;ACLY;;AAEZ;;AAEA;;;;;;;;;ACJY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;;AAExC;;;;;;;;;ACVY;;AAEZ,8CAA6C,CAAC,YAAY,EAAC;;AAE3D,aAAa,mBAAO,CAAC,IAAsB;AAC3C,gBAAgB,mBAAO,CAAC,IAAyB;AACjD,eAAe,mBAAO,CAAC,IAAwB;AAC/C,iBAAiB,mBAAO,CAAC,IAA2B;AACpD,sBAAsB,mBAAO,CAAC,IAAgC;AAC9D,yBAAyB,mBAAO,CAAC,IAAmC;AACpE,iBAAiB,mBAAO,CAAC,IAA2B;AACpD,mBAAmB,mBAAO,CAAC,GAA6B;AACxD,eAAe,mBAAO,CAAC,IAAyB;AAChD,iBAAiB,mBAAO,CAAC,IAA0B;AACnD,sBAAsB,mBAAO,CAAC,IAAiC;AAC/D,iBAAiB,mBAAO,CAAC,IAA2B;AACpD,eAAe,mBAAO,CAAC,IAAyB;AAChD,eAAe,mBAAO,CAAC,IAAyB;AAChD,eAAe,mBAAO,CAAC,IAAyB;AAChD,sBAAsB,mBAAO,CAAC,IAAiC;AAC/D,qBAAqB,mBAAO,CAAC,GAAgC;AAC7D,iBAAiB,mBAAO,CAAC,IAA2B;AACpD,WAAW,mBAAO,CAAC,IAAoB;AACvC,sBAAsB,mBAAO,CAAC,IAAgC;AAC9D,oBAAoB,mBAAO,CAAC,IAA8B;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB,eAAe;AACf,gBAAgB;AAChB,YAAY;AACZ,mBAAmB;AACnB,kBAAkB;AAClB,cAAc;AACd,YAAY;;;;;;;;;AC9HA;;AAEZ,8CAA6C,CAAC,YAAY,EAAC;;AAE3D,yBAAyB,mBAAO,CAAC,IAAsC;AACvE,mBAAmB,mBAAO,CAAC,IAA8B;;AAEzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA,gBAAgB;;;;;;;;;ACpEJ;;AAEZ,8CAA6C,CAAC,YAAY,EAAC;;AAE3D,yBAAyB,mBAAO,CAAC,IAAsC;AACvE,mBAAmB,mBAAO,CAAC,IAA8B;AACzD,uBAAuB,mBAAO,CAAC,IAAmC;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;;;;;;;;;AC5OJ;;AAEZ,8CAA6C,CAAC,YAAY,EAAC;;AAE3D,cAAc,mBAAO,CAAC,IAAwB;AAC9C,mBAAmB,mBAAO,CAAC,IAA8B;AACzD,uBAAuB,mBAAO,CAAC,IAAmC;;AAElE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;;;;;;;;;AC3DJ;;AAEZ,8CAA6C,CAAC,YAAY,EAAC;;AAE3D,aAAa,mBAAO,CAAC,IAAuB;AAC5C,cAAc,mBAAO,CAAC,IAAoB;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,gBAAgB;AAChB,cAAc;AACd,YAAY;;;;;;;;;ACxMA;;AAEZ,cAAc,mBAAO,CAAC,IAAyB;AAC/C,eAAe,mBAAO,CAAC,IAA0B;AACjD,WAAW,mBAAO,CAAC,IAAsB;AACzC,WAAW,mBAAO,CAAC,IAAsB;AACzC,wBAAwB,mBAAO,CAAC,IAA8B;AAC9D,sBAAsB,mBAAO,CAAC,IAA4B;AAC1D,eAAe,mBAAO,CAAC,IAAoB;AAC3C,iBAAiB,mBAAO,CAAC,IAAiB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACnCY;;AAEZ,kBAAkB,mBAAO,CAAC,IAAuB;;AAEjD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;ACZY;;AAEZ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;ACtFY;;AAEZ,kBAAkB,mBAAO,CAAC,IAAyB;AACnD,oBAAoB,mBAAO,CAAC,IAA2B;AACvD,wBAAwB,mBAAO,CAAC,IAA+B;AAC/D,gBAAgB,mBAAO,CAAC,IAAuB;AAC/C,iBAAiB,mBAAO,CAAC,IAAwB;AACjD,cAAc,mBAAO,CAAC,IAAoB;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACzLY;;AAEZ,iBAAiB,mBAAO,CAAC,IAA6B;AACtD,wBAAwB,mBAAO,CAAC,IAAoC;AACpE,iBAAiB,mBAAO,CAAC,IAA6B;AACtD,mBAAmB,mBAAO,CAAC,IAA+B;;AAE1D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AC5HY;;AAEZ,oBAAoB,mBAAO,CAAC,IAAgC;AAC5D,mBAAmB,mBAAO,CAAC,IAAoB;;AAE/C;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;AClEY;;AAEZ,uBAAuB,mBAAO,CAAC,IAAmC;;AAElE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;ACjCY;;AAEZ,mBAAmB,mBAAO,CAAC,IAAiC;AAC5D,wBAAwB,mBAAO,CAAC,IAAoC;AACpE,iBAAiB,mBAAO,CAAC,IAA6B;AACtD,oBAAoB,mBAAO,CAAC,IAAiC;;AAE7D;AACA,6DAA6D;AAC7D;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;AC7FY;;AAEZ,yBAAyB,mBAAO,CAAC,IAAsC;AACvE,gCAAgC,mBAAO,CAAC,IAA+C;AACvF,iBAAiB,mBAAO,CAAC,IAAwB;AACjD,mBAAmB,mBAAO,CAAC,IAAoB;;AAE/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;AC/KY;;AAEZ,yBAAyB,mBAAO,CAAC,IAAsC;AACvE,oBAAoB,mBAAO,CAAC,IAA2B;AACvD,iBAAiB,mBAAO,CAAC,IAAwB;AACjD,mBAAmB,mBAAO,CAAC,IAAoB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;ACvEY;;AAEZ,yBAAyB,mBAAO,CAAC,IAAsC;;AAEvE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;;;;;;;;;ACjKY;;AAEZ,yBAAyB,mBAAO,CAAC,IAAsC;AACvE,iBAAiB,mBAAO,CAAC,IAAwB;AACjD,kBAAkB,mBAAO,CAAC,IAAwB;AAClD,mBAAmB,mBAAO,CAAC,IAAoB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;AClGY;;AAEZ,yBAAyB,mBAAO,CAAC,IAAsC;AACvE,gCAAgC,mBAAO,CAAC,IAA+C;AACvF,0BAA0B,mBAAO,CAAC,IAAiC;AACnE,yBAAyB,mBAAO,CAAC,IAA0B;AAC3D,mBAAmB,mBAAO,CAAC,IAAoB;AAC/C,mBAAmB,mBAAO,CAAC,IAAoB;AAC/C,wBAAwB,mBAAO,CAAC,IAAyB;AACzD,mBAAmB,mBAAO,CAAC,IAAoB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;AClHY;;AAEZ,mBAAmB,mBAAO,CAAC,IAA+B;AAC1D,gCAAgC,mBAAO,CAAC,IAA+C;AACvF,yBAAyB,mBAAO,CAAC,IAAsC;;AAEvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;AClIY;;AAEZ,yBAAyB,mBAAO,CAAC,IAAsC;AACvE,oBAAoB,mBAAO,CAAC,IAAgC;;AAE5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;ACvFY;;AAEZ,oBAAoB,mBAAO,CAAC,IAAgC;;AAE5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;AC7BY;;AAEZ,yBAAyB,mBAAO,CAAC,IAAsC;AACvE,mBAAmB,mBAAO,CAAC,IAAoB;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;AC1EY;;AAEZ,yBAAyB,mBAAO,CAAC,IAAsC;AACvE,oBAAoB,mBAAO,CAAC,IAAgC;AAC5D,mBAAmB,mBAAO,CAAC,IAAoB;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;AC/BY;;AAEZ,yBAAyB,mBAAO,CAAC,IAAsC;;AAEvE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;AC9BY;;AAEZ,yBAAyB,mBAAO,CAAC,IAAsC;AACvE,gCAAgC,mBAAO,CAAC,IAA+C;AACvF,oBAAoB,mBAAO,CAAC,IAAgC;AAC5D,oBAAoB,mBAAO,CAAC,IAA2B;AACvD,mBAAmB,mBAAO,CAAC,IAAoB;;AAE/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;AChIY;;AAEZ,iBAAiB,mBAAO,CAAC,IAA6B;AACtD,wBAAwB,mBAAO,CAAC,IAAoC;AACpE,yBAAyB,mBAAO,CAAC,IAAsC;AACvE,gCAAgC,mBAAO,CAAC,IAA+C;AACvF,oBAAoB,mBAAO,CAAC,IAAgC;AAC5D,mBAAmB,mBAAO,CAAC,IAA+B;AAC1D,qBAAqB,mBAAO,CAAC,IAAiC;AAC9D,mBAAmB,mBAAO,CAAC,IAA+B;AAC1D,uBAAuB,mBAAO,CAAC,IAAyB;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACreY;;AAEZ,iBAAiB,mBAAO,CAAC,IAA6B;AACtD,wBAAwB,mBAAO,CAAC,IAAoC;AACpE,yBAAyB,mBAAO,CAAC,IAAsC;AACvE,gCAAgC,mBAAO,CAAC,IAA+C;AACvF,oBAAoB,mBAAO,CAAC,IAAgC;AAC5D,mBAAmB,mBAAO,CAAC,IAAoB;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;AClbY;;AAEZ,gCAAgC,mBAAO,CAAC,IAA+C;AACvF,kBAAkB,mBAAO,CAAC,IAAyB;AACnD,oBAAoB,mBAAO,CAAC,IAA2B;AACvD,0BAA0B,mBAAO,CAAC,IAAiC;AACnE,iBAAiB,mBAAO,CAAC,IAAwB;AACjD,cAAc,mBAAO,CAAC,IAAoB;AAC1C,yBAAyB,mBAAO,CAAC,IAA0B;AAC3D,mBAAmB,mBAAO,CAAC,IAAoB;AAC/C,mBAAmB,mBAAO,CAAC,IAAoB;AAC/C,wBAAwB,mBAAO,CAAC,IAAyB;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;ACzUY;;AAEZ,eAAe,mBAAO,CAAC,IAAgB;;AAEvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AC7CY;;AAEZ,eAAe,mBAAO,CAAC,IAAgB;;AAEvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AClCY;;AAEZ,mBAAmB,mBAAO,CAAC,IAAoB;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACpBY;;AAEZ,iBAAiB,mBAAO,CAAC,IAA6B;AACtD,oBAAoB,mBAAO,CAAC,IAAgC;AAC5D,iBAAiB,mBAAO,CAAC,IAAwB;AACjD,iBAAiB,mBAAO,CAAC,IAAwB;AACjD,mBAAmB,mBAAO,CAAC,IAAoB;AAC/C,uBAAuB,mBAAO,CAAC,IAAyB;AACxD,oBAAoB,mBAAO,CAAC,IAAqB;;AAEjD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACrNY;;AAEZ,yBAAyB,mBAAO,CAAC,IAAsC;AACvE,mBAAmB,mBAAO,CAAC,IAAoB;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;AClBY;;AAEZ,yBAAyB,mBAAO,CAAC,IAAsC;AACvE,cAAc,mBAAO,CAAC,IAAoB;AAC1C,mBAAmB,mBAAO,CAAC,IAAoB;;AAE/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;ACpHY;;AAEZ,yBAAyB,mBAAO,CAAC,IAAsC;AACvE,oBAAoB,mBAAO,CAAC,IAAgC;AAC5D,mBAAmB,mBAAO,CAAC,IAAoB;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACpDY;;AAEZ,oBAAoB,mBAAO,CAAC,IAAqB;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;ACbY;;AAEZ,aAAa,mBAAO,CAAC,IAAuB;;AAE5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACrCY;;AAEZ,gCAAgC,mBAAO,CAAC,IAA+C;AACvF,yBAAyB,mBAAO,CAAC,IAAqC;AACtE,wBAAwB,mBAAO,CAAC,GAAoC;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACxBY;;AAEZ,qBAAqB,mBAAO,CAAC,IAAiC;AAC9D,oBAAoB,mBAAO,CAAC,IAAqB;AACjD,eAAe,mBAAO,CAAC,IAAe;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uEAAuE;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;;;;;;;;;AChDY;;AAEZ,aAAa,mBAAO,CAAC,IAAuB;AAC5C,yBAAyB,mBAAO,CAAC,IAAsC;AACvE,kBAAkB,mBAAO,CAAC,IAAmB;AAC7C,oBAAoB,mBAAO,CAAC,IAAqB;AACjD,eAAe,mBAAO,CAAC,IAAe;AACtC,iBAAiB,mBAAO,CAAC,IAAkB;AAC3C,sBAAsB,mBAAO,CAAC,IAAuB;AACrD,cAAc,mBAAO,CAAC,IAAc;AACpC,kBAAkB,mBAAO,CAAC,IAAmB;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,IAAI;;AAEJ;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AC3TY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACVY;;AAEZ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACXY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACjBY;;AAEZ,iBAAiB,mBAAO,CAAC,IAAkB;;AAE3C;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACVY;;AAEZ,mBAAmB,mBAAO,CAAC,IAA+B;;AAE1D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACZY;;AAEZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;ACnBY;;AAEZ,mBAAmB,mBAAO,CAAC,IAA+B;;AAE1D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;ACzBY;;AAEZ,mBAAmB,mBAAO,CAAC,IAA+B;;AAE1D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;ACvCY;;AAEZ,aAAa,mBAAO,CAAC,IAAuB;;AAE5C;AACA,kBAAkB;AAClB;;AAEA;;;;;;;;;ACRY;;AAEZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;ACfY;;AAEZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;AC1BY;;AAEZ,aAAa,mBAAO,CAAC,IAAuB;AAC5C,oBAAoB,mBAAO,CAAC,IAAqB;AACjD,cAAc,mBAAO,CAAC,IAAc;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;ACtMY;;AAEZ,wBAAwB,mBAAO,CAAC,IAAoB;;AAEpD;;AAEA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;;;;;;;;;ACZY;;AAEZ,aAAa,mBAAO,CAAC,IAAyB;AAC9C,mBAAmB,mBAAO,CAAC,GAA8B;AACzD,iBAAiB,mBAAO,CAAC,IAA4B;;AAErD;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtCY;;AAEZ;;AAEA,mBAAmB,mBAAO,CAAC,IAA0B;;AAErD;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;ACrEa;;AAEb,0CAAwC;;;;;;;;;ACFxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACtEa;AACb,aAAa,mBAAO,CAAC,IAAM;AAC3B,cAAc,mBAAO,CAAC,IAAO;AAC7B,eAAe,mBAAO,CAAC,IAAQ;AAC/B,YAAY,mBAAO,CAAC,IAAK;;AAEzB,eAAe,mBAAO,CAAC,IAAU;AACjC,cAAc,mBAAO,CAAC,IAAS;;AAE/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,yCAAyC,QAAQ;AACjD;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0BAA0B;AACjE;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;;AAEA;;;;;;;;ACvVA;AACA,iBAAiB,mBAAO,CAAC,IAAU;AACnC,eAAe,mBAAO,CAAC,IAAQ;;AAE/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,sCAAsC,kEAAkE,eAAe;AACvH;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpFA,CAAC,kBAAkB;AACnB,wCAAwC;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,WAAW;AAClC;AACA,0BAA0B,mBAAmB,aAAa;AAC1D,yBAAyB,yBAAyB;AAClD,yBAAyB;AACzB;;AAEA;AACA;AACA,aAAa,kCAAwB;AACrC,IAAI;AACJ;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,iBAAiB,yCAAuC;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;;AAEA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mBAAmB;AACpE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,YAAY,OAAO,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA,CAAC,EAAE,MAA8B,GAAG,CAAa,CAAC;;;;;;;;;AC5hDrC;;AAEb,eAAe,mBAAO,CAAC,IAAU;AACjC,mBAAmB,mBAAO,CAAC,IAAyB;;AAEpD;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,gDAAgD,4BAA4B;AAC5E;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC;;;;;;;;;AChMrB;;AAEZ,WAAW,mBAAO,CAAC,IAAW;;AAE9B;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;;;ACzEY;;AAEZ;;AAEA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/DY;;AAEZ,WAAW,mBAAO,CAAC,IAAM;AACzB,aAAa,mBAAO,CAAC,IAAW;AAChC,aAAa,mBAAO,CAAC,IAAQ;AAC7B,YAAY,mBAAO,CAAC,IAAc;AAClC,aAAa,mBAAO,CAAC,IAAQ;AAC7B,YAAY,mBAAO,CAAC,GAAO;;AAE3B;AACA;;AAEA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,0DAA0D;AAC1D;;AAEA;;AAEA;AACA;;AAEA;AACA,wCAAwC;AACxC;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,+BAA+B,WAAW;;AAE1C;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC3cY;;AAEZ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;AC5EY;;AAEZ,YAAY;;AAEZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;ACjDA;AACA;AACA;AACA;;;;;;;;;ACHY;;AAEZ;;AAEA,cAAc,mBAAO,CAAC,IAAuB;AAC7C,YAAY,mBAAO,CAAC,IAAS;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;AC5FY;;AAEZ,gBAAgB,mBAAO,CAAC,IAA+B;;AAEvD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,yBAAyB;AACrC,UAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;AC7FY;;AAEZ,0CAAiC;;;;;;;;;ACFrB;;AAEZ,QAAQ,mBAAO,CAAC,IAAW;AAC3B,WAAW,mBAAO,CAAC,IAAW;AAC9B,aAAa,mBAAO,CAAC,IAAW;;AAEhC;;AAEA,YAAY;;AAEZ;AACA,KAAK,0BAA0B;AAC/B;AACA;;AAEA;;AAEA;AACA,gDAAgD,2BAA2B;;AAE3E;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,gDAAgD,2BAA2B;;AAE3E;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,eAAe;AACf,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5KY;;AAEZ,eAAe,mBAAO,CAAC,GAAe;AACtC,YAAY,mBAAO,CAAC,IAAW;;AAE/B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;AC7CY;;AAEZ,0CAAgC;;;;;;;;;ACFpB;;AAEZ;;;;;;;;;ACFa;;AAEb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,oBAAoB;AAChE;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD,iBAAiB;AACnE,mDAAmD,gBAAgB;;AAEnE,oDAAoD,iBAAiB;AACrE,6DAA6D,gBAAgB;;AAE7E,mDAAmD,iBAAiB;AACpE,4DAA4D,gBAAgB;;AAE5E,wDAAwD,sCAAsC;AAC9F,iEAAiE,qCAAqC;;AAEtG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,sCAAsC;AAC1D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;AC5La;AACb,YAAY,mBAAO,CAAC,IAAqB;;AAEzC,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,qBAAqB;AACpE;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC,+CAA+C;AAChF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,uCAAuC;AAClE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B,2CAA2C;AACtE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,6BAA6B,uCAAuC;AACpE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,6CAA6C;AACxE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,6BAA6B;AAC5D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,2CAA2C;AAC1E;;AAEA;AACA;AACA;AACA;;;;;;;;;ACvMa;;AAEb,oBAAoB,mBAAO,CAAC,GAAoB;AAChD,cAAc,mBAAO,CAAC,IAAY;AAClC,aAAa,mBAAO,CAAC,IAAgB;;AAErC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,cAAc,UAAU;AACxB,cAAc;AACd;AACA;;;;;;;;;;AClMa;;AAEb,oDAAwC;AACxC,4DAAkE;AAClE,kEAA8E;AAC9E,6DAAoE;AACpE,8DAAsE;AACtE,8DAAsE;AACtE,6DAAoE;AACpE,gEAA0E;AAC1E,wDAA0D;;;;;;;;;ACV7C;AACb,iBAAiB,mBAAO,CAAC,IAAU;AACnC,aAAa,mBAAO,CAAC,IAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mCAAmC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,8CAA8C;AAC9C;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,+CAA+C,sEAAsE;AACrH;;;;;;;;;AChxCa;;AAEb,oBAAoB;AACpB;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA,4BAA4B;AAC5B,yBAAyB;;AAEzB,6BAA6B;AAC7B;AACA;;AAEA,6BAA6B;AAC7B;AACA;;;;;;;;;AClBA;AACA;AACA;AACA,EAAE,gBAAgB;AAClB;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,CAAC;;;;;;;;ACXD;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB,YAAY,mBAAO,CAAC,IAAY;;AAEhC,aAAa,oCAA8B;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAE,eAAe;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;AC9HD;AACA;AACA,EAAE,gBAAgB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;;ACvED;AACA;AACA;AACA;AACA,6BAA6B,mBAAmB,oCAAoC;AACpF,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,QAAQ,mBAAO,CAAC,IAAK;;AAErB,WAAW,mBAAO,CAAC,IAAQ;;AAE3B,QAAQ,mBAAO,CAAC,GAAO;;AAEvB,eAAe,mBAAO,CAAC,IAAc;;AAErC,iBAAiB,wCAA8B;;AAE/C,aAAa,oCAA8B;;AAE3C;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;;AAEA,EAAE,cAAc;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,sDAAsD,GAAG;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,GAAG;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA,GAAG;;AAEH,EAAE,mBAAmB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE,0BAA0B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;;AC5XD;AACA;AACA;AACA;;AAEA;;AAEA,EAAE,iBAAiB;AACnB;AACA;;AAEA,EAAE,0BAA0B;AAC5B;AACA;;AAEA,EAAE,mBAAmB;AACrB;AACA;;AAEA,EAAE,oBAAoB;AACtB;AACA;AACA;AACA;AACA;;AAEA,EAAE,qBAAqB;AACvB;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;;ACjCD;AACA;AACA;AACA;AACA,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,aAAa,mBAAO,CAAC,IAAY;;AAEjC,YAAY,mBAAO,CAAC,IAAW;;AAE/B,WAAW,mBAAO,CAAC,IAAU;;AAE7B,eAAe,mBAAO,CAAC,IAAc;;AAErC,EAAE,gBAAgB;;AAElB,EAAE,kBAAkB;;AAEpB,EAAE,uBAAuB;AACzB;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,EAAE,eAAe;;AAEjB,EAAE,cAAc;;AAEhB,EAAE,mBAAmB;;AAErB,EAAE,0BAA0B;;AAE5B,CAAC;;;;;;;;ACtCD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;;ACXD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;;ACtBD;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,EAAE,qBAAqB;;AAEvB,EAAE,yBAAyB;;AAE3B,EAAE,uBAAuB;;AAEzB,EAAE,sBAAsB;;AAExB,EAAE,sBAAsB;;AAExB,EAAE,4BAA4B;;AAE9B,EAAE,uBAAuB;;AAEzB,CAAC;;;;;;;;AClFD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;;ACTD;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,IAAY;;AAEjC,YAAY,mBAAO,CAAC,IAAW;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR,4BAA4B,aAAa;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;AC3GD;AACA;AACA;AACA,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,aAAa,mBAAO,CAAC,IAAY;;AAEjC,qBAAqB,mBAAO,CAAC,IAAoB;;AAEjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;ACnCD;AACA;AACA;AACA,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,YAAY,mBAAO,CAAC,IAAW;;AAE/B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;AC9ED;AACA;AACA;AACA,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,aAAa,mBAAO,CAAC,IAAY;;AAEjC,qBAAqB,mBAAO,CAAC,IAAoB;;AAEjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;ACnCD;AACA;AACA;;AAEA,uBAAuB,mBAAO,CAAC,IAAsB;;AAErD,qBAAqB,mBAAO,CAAC,IAAoB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;AC/DD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;ACfD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;AC/BD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;AC3BD;AACA;AACA;AACA,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,YAAY,mBAAO,CAAC,IAAW;;AAE/B,aAAa,mBAAO,CAAC,IAAY;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;ACtDD;AACA;AACA;AACA,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,YAAY,mBAAO,CAAC,IAAW;;AAE/B,aAAa,mBAAO,CAAC,IAAY;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;ACrCD;AACA;AACA;AACA,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,aAAa,oCAA6B;;AAE1C,YAAY,mBAAO,CAAC,IAAW;;AAE/B,aAAa,mBAAO,CAAC,IAAY;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;AChGD;AACA;AACA;AACA,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,YAAY,mBAAO,CAAC,IAAW;;AAE/B,aAAa,mBAAO,CAAC,IAAY;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;ACnDD;AACA;AACA;AACA,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,aAAa,oCAA6B;;AAE1C,YAAY,mBAAO,CAAC,IAAW;;AAE/B,aAAa,mBAAO,CAAC,IAAY;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;AC1CD;AACA;AACA;AACA,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,aAAa,oCAA6B;;AAE1C,YAAY,mBAAO,CAAC,IAAW;;AAE/B,aAAa,mBAAO,CAAC,IAAY;;AAEjC,kBAAkB,mBAAO,CAAC,IAAiB;;AAE3C,iBAAiB,mBAAO,CAAC,IAAgB;;AAEzC,kBAAkB,mBAAO,CAAC,IAAiB;;AAE3C,mBAAmB,mBAAO,CAAC,IAAkB;;AAE7C,oBAAoB,mBAAO,CAAC,GAAmB;;AAE/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;ACzLD;AACA;AACA;AACA,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,kBAAkB,yCAAkC;;AAEpD,yBAAyB,mBAAO,CAAC,IAAwB;;AAEzD,wBAAwB,mBAAO,CAAC,GAAuB;;AAEvD,YAAY,mBAAO,CAAC,IAAW;;AAE/B,aAAa,mBAAO,CAAC,IAAY;;AAEjC,mBAAmB,mBAAO,CAAC,IAAkB;;AAE7C,oBAAoB,mBAAO,CAAC,IAAmB;;AAE/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;ACjPD;AACA;AACA;AACA,gBAAgB;;AAEhB,QAAQ,mBAAO,CAAC,IAAW;;AAE3B,aAAa,mBAAO,CAAC,IAAY;;AAEjC,gBAAgB,mBAAO,CAAC,IAAe;;AAEvC,eAAe,mBAAO,CAAC,IAAc;;AAErC,aAAa,mBAAO,CAAC,IAAY;;AAEjC,eAAe,mBAAO,CAAC,IAAc;;AAErC,WAAW,mBAAO,CAAC,IAAU;;AAE7B,YAAY,mBAAO,CAAC,IAAW;;AAE/B,6BAA6B,mBAAO,CAAC,IAA4B;;AAEjE,mBAAmB,mBAAO,CAAC,IAAkB;;AAE7C,eAAe,mBAAO,CAAC,IAAc;;AAErC,kBAAkB,mBAAO,CAAC,IAAiB;;AAE3C,iBAAiB,mBAAO,CAAC,IAAgB;;AAEzC,kBAAkB,mBAAO,CAAC,IAAiB;;AAE3C,mBAAmB,mBAAO,CAAC,IAAkB;;AAE7C,iBAAiB,mBAAO,CAAC,IAAgB;;AAEzC,mBAAmB,mBAAO,CAAC,IAAkB;;AAE7C,oBAAoB,mBAAO,CAAC,IAAmB;;AAE/C,gBAAgB,mBAAO,CAAC,GAAe;;AAEvC;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;AC/gBD;AACA;AACA;AACA,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,YAAY,mBAAO,CAAC,IAAW;;AAE/B,aAAa,mBAAO,CAAC,IAAY;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;AC9BD;AACA;AACA;AACA,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,QAAQ,mBAAO,CAAC,IAAW;;AAE3B,YAAY,mBAAO,CAAC,IAAW;;AAE/B,aAAa,mBAAO,CAAC,IAAY;;AAEjC,iBAAiB,mBAAO,CAAC,IAAgB;;AAEzC,oBAAoB,mBAAO,CAAC,GAAmB;;AAE/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,mCAAmC;AACzF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;ACzSD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;ACzDD;AACA;AACA;AACA,gBAAgB;;AAEhB,SAAS,mBAAO,CAAC,IAAW;;AAE5B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,CAAC,IAAc;AAC3C,mBAAmB,mBAAO,CAAC,IAAY;AACvC,qBAAqB,mBAAO,CAAC,IAAc;AAC3C,yBAAyB,mBAAO,CAAC,IAAkB;AACnD,qBAAqB,mBAAO,CAAC,IAAc;AAC3C,iBAAiB,mBAAO,CAAC,IAAU;AACnC,kBAAkB,mBAAO,CAAC,IAAW;AACrC,mCAAmC,mBAAO,CAAC,IAA4B;AACvE,mBAAmB,mBAAO,CAAC,IAAY;AACvC,mBAAmB,mBAAO,CAAC,IAAY;AACvC,sBAAsB,mBAAO,CAAC,IAAe;AAC7C,0BAA0B,mBAAO,CAAC,GAAmB;AACrD,2BAA2B,mBAAO,CAAC,IAAoB;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,mCAAmC;AAC1F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;AChxBD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;AC3BD;AACA;AACA;AACA,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,aAAa,mBAAO,CAAC,IAAY;;AAEjC,qBAAqB,mBAAO,CAAC,IAAoB;;AAEjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;AChDD;AACA;AACA;AACA,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,aAAa,mBAAO,CAAC,IAAY;;AAEjC,YAAY,mBAAO,CAAC,IAAW;;AAE/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;AClCD;AACA;AACA;AACA,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,aAAa,mBAAO,CAAC,IAAY;;AAEjC,kBAAkB,mBAAO,CAAC,GAAiB;;AAE3C,gBAAgB,mBAAO,CAAC,GAAe;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;AC/KD;AACA;AACA;AACA,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,kBAAkB,mBAAO,CAAC,GAAiB;;AAE3C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;AClCD;AACA;AACA;AACA,6BAA6B,mBAAmB,oCAAoC;AACpF,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,yCAAyC,sBAAsB,sBAAsB,wBAAwB;AAC7G;;AAEA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,yCAAyC,sBAAsB,wBAAwB,wBAAwB,wBAAwB,wBAAwB;AAC/J;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;AC/OD;AACA;AACA;AACA,uCAAuC,0BAA0B,2DAA2D,kBAAkB,4BAA4B,mCAAmC,8BAA8B,oCAAoC,eAAe;AAC9R,gBAAgB;;AAEhB,aAAa,mBAAO,CAAC,IAAY;;AAEjC,qBAAqB,mBAAO,CAAC,IAAoB;;AAEjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;ACpED;AACA;AACA;AACA,gBAAgB;;AAEhB,WAAW,kCAA2B;;AAEtC,aAAa,mBAAO,CAAC,IAAY;;AAEjC,mBAAmB,mBAAO,CAAC,IAAkB;;AAE7C,eAAe,mBAAO,CAAC,IAAc;;AAErC,aAAa,mBAAO,CAAC,IAAY;;AAEjC,eAAe,mBAAO,CAAC,IAAc;;AAErC,eAAe,mBAAO,CAAC,IAAc;;AAErC,WAAW,mBAAO,CAAC,IAAU;;AAE7B,YAAY,mBAAO,CAAC,IAAW;;AAE/B,6BAA6B,mBAAO,CAAC,IAA4B;;AAEjE,aAAa,mBAAO,CAAC,IAAY;;AAEjC,kBAAkB,mBAAO,CAAC,IAAiB;;AAE3C,kBAAkB,mBAAO,CAAC,IAAiB;;AAE3C,iBAAiB,mBAAO,CAAC,IAAgB;;AAEzC,mBAAmB,mBAAO,CAAC,IAAkB;;AAE7C,gBAAgB,mBAAO,CAAC,GAAe;;AAEvC;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,GAAG;;AAEH,CAAC;;;;;;;;AC3aD;AACA;AACA;;AAEA,QAAQ,mBAAO,CAAC,IAAW;;AAE3B,yBAAyB,mBAAO,CAAC,IAAwB;;AAEzD,gBAAgB,mBAAO,CAAC,IAAe;;AAEvC,kBAAkB,mBAAO,CAAC,IAAiB;;AAE3C,oBAAoB,mBAAO,CAAC,IAAmB;;AAE/C,oBAAoB,mBAAO,CAAC,IAAmB;;AAE/C,aAAa,mBAAO,CAAC,IAAY;;AAEjC,gBAAgB,mBAAO,CAAC,GAAe;;AAEvC,EAAE,qBAAqB;AACvB;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE,oBAAoB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA,EAAE,2BAA2B;AAC7B;AACA;;AAEA,EAAE,2BAA2B;AAC7B;AACA;;AAEA,EAAE,6BAA6B;;AAE/B,EAAE,uBAAuB;;AAEzB,EAAE,0BAA0B;;AAE5B,CAAC;;;;;;;;;AChED;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA,MAAM,6BAA4B;;ACAN;AACJ;AACF;AACa;AACT;AACF;;AAExB;;AAEA;AACA,iBAAiB,yBAAe;;AAEhC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;;AAEA;AACA,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,UAAU;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA,oBAAoB,4BAAkB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kFAAkF;AAClF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG,yBAAyB,kCAAkC;AAC9D;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG,yBAAyB,gBAAM,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,gBAAM;AAC3B;AACA,iHAAiH,UAAU,IAAI,YAAY;AAC3I;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,+EAA+E,YAAY,UAAU,YAAY;AACjH;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,SAAS,kBAAkB;AAC3B,aAAa,kBAAkB;AAC/B,gBAAgB,kBAAkB;AAClC,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,SAAS;AACT,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qEAAqE,SAAS;AAC9E;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,gBAAM;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oEAAoE,YAAY,QAAQ,eAAe;AACvG,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yEAAyE,WAAW,IAAI,YAAY;AACpG;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,YAAY,cAAc,YAAY;AACnF;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA,4EAA4E,WAAW,IAAI,YAAY;AACvG;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,GAAG;AACf,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,gBAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,qBAAqB;AACrB,GAAG;AACH;AACA,4CAA4C;AAC5C,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,8BAA8B,WAAW,mBAAmB;AAC5D,GAAG,yBAAyB,gBAAM;AAClC;AACA;AACA;AACA,GAAG;AACH;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB;AACA,yBAAyB,MAAM;AAC/B;AACA;;AAEA;AACA,YAAY,MAAM;AAClB;AACA,yBAAyB,OAAO;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,QAAQ,kBAAkB;AAC1B,YAAY,kBAAkB;AAC9B,QAAQ,kBAAkB;AAC1B,WAAW,kBAAkB;AAC7B,QAAQ,kBAAkB;AAC1B,WAAW,kBAAkB;AAC7B,SAAS,kBAAkB;AAC3B,WAAW,kBAAkB;AAC7B,YAAY;AACZ,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,EAAE;AACF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;;AAE9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB,2BAAiB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA,QAAQ,kBAAkB;AAC1B,WAAW,kBAAkB;AAC7B,OAAO,kBAAkB;AACzB,eAAe,kBAAkB;AACjC,eAAe,kBAAkB;AACjC,YAAY,kBAAkB;AAC9B,UAAU;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,YAAY,iBAAO,IAAI,cAAa;;AAEpC;AACA,kBAAkB,mBAAS;AAC3B,mBAAmB,oBAAU;;AAE7B;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gDAAgD,mCAAyB;;AAEzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,KAAK;AACL;AACA,4BAA4B,MAAM;AAClC;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,iEAAiE;;AAEjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,WAAW,kBAAkB;AAC7B,QAAQ,kBAAkB;AAC1B,YAAY,kBAAkB;AAC9B,aAAa,kBAAkB;AAC/B,UAAU,kBAAkB;AAC5B,WAAW;AACX,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA+C,yBAAe;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,4BAAkB;AACxC,oBAAoB,qBAAW;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,eAAK,GAAG,cAAI;AAC5D;;AAEA;;AAEA;AACA;AACA;AACA,+CAA+C,yBAAe;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA,KAAK;AACL,IAAI;AACJ;;AAEA;AACA,uCAAuC,aAAa,kBAAkB,YAAY;AAClF;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sGAAsG,YAAY;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6DAA6D,YAAY;AACzE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAAiB;AAC5B,iBAAiB,0CAAiB;AAClC;;AAEA;AACA;AACA,qBAAqB,0CAAiB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2CAAkB;AACzC,OAAO;AACP,uBAAuB,8CAAqB;AAC5C;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,iCAAiC,oDAA2B;AAC5D,qBAAqB,oDAA2B;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0CAAe,KAAK,EAAC;AAC6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UC3nDlD;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;ACNe,SAASA,cAAT,CAAwBC,KAAxB,EAA+BC,KAA/B,EAAsC;AACnD,QAAMC,UAAU,GAAGC,IAAI,CAACC,KAAL,CAAWJ,KAAX,IAAoBG,IAAI,CAACC,KAAL,CAAWH,KAAX,CAAvC;AAEA,QAAMI,UAAU,GAAGF,IAAI,CAACC,KAAL,CAAWF,UAAU,GAAG,EAAb,GAAkB,EAAlB,GAAuB,EAAlC,CAAnB;AACA,QAAMI,WAAW,GAAGH,IAAI,CAACC,KAAL,CAAWF,UAAU,GAAG,EAAb,GAAkB,EAA7B,CAApB;AACA,QAAMK,aAAa,GAAGJ,IAAI,CAACC,KAAL,CAAWF,UAAU,GAAG,EAAxB,CAAtB;AACA,QAAMM,aAAa,GAAGL,IAAI,CAACC,KAAL,CAAWF,UAAX,CAAtB;AAEA,SAAO;AACLF,IAAAA,KADK;AAELC,IAAAA,KAFK;AAGLI,IAAAA,UAHK;AAILC,IAAAA,WAJK;AAKLC,IAAAA,aALK;AAMLC,IAAAA;AANK,GAAP;AAQD;;;;;;AChBD;AACA;AAEAC,WAAA;AAEA,MAAM;AACJI,EAAAA,gBADI;AAEJC,EAAAA,yBAFI;AAGJC,EAAAA,wBAHI;AAIJC,EAAAA;AAJI,IAKFC,OAAO,CAACC,GALZ;AAOA,MAAMC,QAAQ,GAAGH,EAAE,GAAGL,iCAAH,GAAmBA,mCAAtC;AAEO,eAAeW,qBAAf,GAAuC;AAC5C,QAAMC,MAAM,GAAG,IAAIb,kBAAJ,CAAW;AACxBc,IAAAA,IAAI,EAAEX,gBADkB;AAExBM,IAAAA;AAFwB,GAAX,CAAf;AAKA,MAAIM,QAAJ;;AACA,MAAI;AACFA,IAAAA,QAAQ,GAAG,MAAMF,MAAM,CAACG,SAAP,CAAiBC,KAAjB,CAAuB;AACtCC,MAAAA,WAAW,EAAEb,wBADyB;AAEtCc,MAAAA,MAAM,EAAE;AACNC,QAAAA,EAAE,EAAE,CACF;AACEC,UAAAA,QAAQ,EAAE,SADZ;AAEEC,UAAAA,QAAQ,EAAE;AACRC,YAAAA,MAAM,EAAE;AADA;AAFZ,SADE;AADE;AAF8B,KAAvB,CAAjB;AAaD,GAdD,CAcE,OAAOC,GAAP,EAAY;AACZC,IAAAA,OAAO,CAACC,KAAR,CAAcF,GAAd;AACA,WAAO,EAAP;AACD;;AAED,QAAMG,KAAK,GAAGZ,QAAQ,CAACa,OAAT,CAAiBC,GAAjB,CAAsBC,IAAD,KAAW;AAC5CC,IAAAA,KAAK,EAAED,IAAI,CAACE,UAAL,CAAgBC,KAAhB,CAAsBF,KAAtB,CAA4B,CAA5B,EAA+BG,UADM;AAE5CC,IAAAA,OAAO,EAAEL,IAAI,CAACE,UAAL,CAAgBI,IAAhB,CAAqBC,GAFc;AAG5CC,IAAAA,MAAM,EAAER,IAAI,CAACS;AAH+B,GAAX,CAArB,CAAd;AAMA,SAAOZ,KAAP;AACD;AAEM,eAAea,mBAAf,CAAmCC,UAAnC,EAA+C;AACpD,QAAM;AAAEV,IAAAA,KAAF;AAASW,IAAAA,IAAT;AAAeC,IAAAA,OAAf;AAAwBC,IAAAA,cAAxB;AAAwCN,IAAAA;AAAxC,MAAmDG,UAAzD;AAEA,QAAMI,aAAa,GAAG,CAAC,GAAI,GAAEd,KAAM,IAAGa,cAAe,EAA3B,CAA6BE,QAA7B,CAAsC,SAAtC,CAAJ,EACnBC,IADmB,CACd,GADc,EAEnBC,WAFmB,EAAtB;AAIA,QAAMnC,MAAM,GAAG,IAAIb,kBAAJ,CAAW;AACxBc,IAAAA,IAAI,EAAEX,gBADkB;AAExBM,IAAAA;AAFwB,GAAX,CAAf;;AAKA,MAAI;AACF,UAAMI,MAAM,CAACoC,KAAP,CAAaC,MAAb,CAAoB;AACxBC,MAAAA,MAAM,EAAE;AACNjC,QAAAA,WAAW,EAAEd;AADP,OADgB;AAIxB4B,MAAAA,UAAU,EAAE;AACVC,QAAAA,KAAK,EAAE;AACLF,UAAAA,KAAK,EAAE,CACL;AACEqB,YAAAA,IAAI,EAAE;AACJT,cAAAA,OAAO,EAAEZ;AADL;AADR,WADK;AADF,SADG;AAUVK,QAAAA,IAAI,EAAE;AACJC,UAAAA,GAAG,EAAEK;AADD,SAVI;AAaVW,QAAAA,MAAM,EAAE;AACNC,UAAAA,QAAQ,EAAE,CACR;AACEf,YAAAA,EAAE,EAAED;AADN,WADQ;AADJ,SAbE;AAoBViB,QAAAA,cAAc,EAAE;AACdC,UAAAA,SAAS,EAAE,CACT;AACEJ,YAAAA,IAAI,EAAE;AACJT,cAAAA,OAAO,EAAEE;AADL;AADR,WADS;AADG;AApBN,OAJY;AAkCxBY,MAAAA,QAAQ,EAAEd;AAlCc,KAApB,CAAN;AAoCD,GArCD,CAqCE,OAAOnB,GAAP,EAAY;AACZC,IAAAA,OAAO,CAACC,KAAR,CAAcF,GAAd;AACD;AACF;AAEM,eAAekC,kCAAf,GAAoD;AACzD,QAAM7C,MAAM,GAAG,IAAIb,kBAAJ,CAAW;AACxBc,IAAAA,IAAI,EAAEX,gBADkB;AAExBM,IAAAA;AAFwB,GAAX,CAAf,CADyD,CAMzD;;AACA,QAAMkD,eAAe,GAAG,IAAIC,IAAJ,EAAxB;AACAD,EAAAA,eAAe,CAACE,OAAhB,CAAwBF,eAAe,CAACG,OAAhB,KAA4B,EAApD,EARyD,CAUzD;AACA;;AACA,MAAI/C,QAAJ;;AACA,MAAI;AACFA,IAAAA,QAAQ,GAAG,MAAMF,MAAM,CAACG,SAAP,CAAiBC,KAAjB,CAAuB;AACtCC,MAAAA,WAAW,EAAEd,yBADyB;AAEtCe,MAAAA,MAAM,EAAE;AACN4C,QAAAA,GAAG,EAAE,CACH;AACE1C,UAAAA,QAAQ,EAAE,YADZ;AAEE2C,UAAAA,IAAI,EAAE;AACJC,YAAAA,YAAY,EAAEN,eAAe,CAACO,MAAhB;AADV;AAFR,SADG,EAOH;AACE7C,UAAAA,QAAQ,EAAE,MADZ;AAEEC,UAAAA,QAAQ,EAAE;AACRC,YAAAA,MAAM,EAAE;AADA;AAFZ,SAPG;AADC;AAF8B,KAAvB,CAAjB;AAmBD,GApBD,CAoBE,OAAOC,GAAP,EAAY;AACZC,IAAAA,OAAO,CAACC,KAAR,CAAcF,GAAd;AACA;AACD,GApCwD,CAsCzD;;;AACA,QAAM2C,YAAY,GAAGpD,QAAQ,CAACa,OAAT,CAAiBC,GAAjB,CAAsBC,IAAD,IAAUA,IAAI,CAACS,EAApC,CAArB;;AAEA,OAAK,IAAI6B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,YAAY,CAACE,MAAjC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5C,UAAM7B,EAAE,GAAG4B,YAAY,CAACC,CAAD,CAAvB;;AACA,QAAI;AACF,YAAMvD,MAAM,CAACoC,KAAP,CAAaqB,MAAb,CAAoB;AACxBC,QAAAA,OAAO,EAAEhC,EADe;AAExBiC,QAAAA,QAAQ,EAAE;AAFc,OAApB,CAAN;AAID,KALD,CAKE,OAAOhD,GAAP,EAAY;AACZC,MAAAA,OAAO,CAACC,KAAR,CAAcF,GAAd;AACD;AACF;AACF;;AC3JD;AACA;AACA;;AAEA,eAAekD,mBAAf,CAAmCvC,OAAnC,EAA4C;AAC1C,QAAMwC,MAAM,GAAG,IAAIF,sBAAJ,CAAW;AACxBG,IAAAA,YAAY,EAAE;AACZ9C,MAAAA,IAAI,EAAE,CAAC,CAAC,aAAD,EAAgB,YAAhB,EAA8B;AAAE+C,QAAAA,cAAc,EAAE;AAAlB,OAA9B,CAAD;AADM;AADU,GAAX,CAAf;AAKA,MAAIC,GAAJ;;AACA,MAAI;AACFA,IAAAA,GAAG,GAAG,MAAMH,MAAM,CAACI,QAAP,CAAgB5C,OAAhB,CAAZ;AACD,GAFD,CAEE,OAAOT,KAAP,EAAc;AACdD,IAAAA,OAAO,CAACC,KAAR,CAAcA,KAAd;AACA,WAAO,EAAP;AACD;;AACD,QAAMsD,UAAU,GAAG,IAAIpB,IAAJ,GAAWqB,OAAX,KAAuB,IAA1C;AACA,SAAOH,GAAG,CAACI,KAAJ,CAAU/D,MAAV,CAAkBW,IAAD,IAAU;AAChC,UAAMqD,iBAAiB,GAAG,IAAIvB,IAAJ,CAAS9B,IAAI,CAACsD,OAAd,EAAuBH,OAAvB,KAAmC,IAA7D;AACA,UAAM;AAAEtF,MAAAA;AAAF,QAAiBN,cAAc,CAAC2F,UAAD,EAAaG,iBAAb,CAArC;AACA,WAAOxF,UAAU,KAAK,CAAtB;AACD,GAJM,CAAP;AAKD;;AAEc,gBAAgB0F,eAAhB,GAAkC;AAC/C,QAAMC,eAAe,GAAG,EAAxB;AACA,QAAM3D,KAAK,GAAG,MAAMf,qBAAqB,EAAzC;;AAEA,OAAK,IAAIwD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGzC,KAAK,CAAC0C,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACrC,UAAM;AAAEjC,MAAAA,OAAF;AAAWG,MAAAA;AAAX,QAAsBX,KAAK,CAACyC,CAAD,CAAjC;AACA,UAAMmB,SAAS,GAAG,MAAMb,mBAAmB,CAACvC,OAAD,CAA3C;AACA,UAAMqD,YAAY,GAAG;AACnBlD,MAAAA,MADmB;AAEnBH,MAAAA,OAFmB;AAGnBoD,MAAAA;AAHmB,KAArB;AAMA,UAAMC,YAAN;AACD;AACF;;;;ACxCD;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA,0DAA0D,GAAG;;AAE7D;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA,oBAAoB,uBAAuB;AAC3C;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sDAAsD;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM,gCAAgC;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY,MAAM;AAClB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,UAAU;AACrB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uDAAuD;;AAEvD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,mBAAO,CAAC,GAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,mBAAO;AACxB;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mBAAmB;AACzC,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;;AAEA,SAAS,mBAAO;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,mBAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAe,eAAe,EAAC;;;AC/6B/B;AACA;;AAEA,SAASG,kBAAT,CAA4BC,WAA5B,EAAyC;AACvC,MAAI;AACF,UAAMC,eAAe,GAAG,IAAIH,WAAJ,EAAxB;AACA,WAAOG,eAAe,CAACC,QAAhB,CAAyBF,WAAzB,CAAP;AACD,GAHD,CAGE,OAAOlE,KAAP,EAAc;AACdD,IAAAA,OAAO,CAACC,KAAR,CAAcA,KAAd;AACA,WAAO,EAAP;AACD;AACF;;AAED,SAASqE,kBAAT,CAA4BC,eAA5B,EAA6C;AAC3C,SAAOP,8BAAgB,CAACO,eAAD,CAAvB;AACD;;AAEc,SAASC,kBAAT,CAA4BL,WAA5B,EAAyC;AACtD,QAAMM,YAAY,GAAGP,kBAAkB,CAACC,WAAD,CAAvC;AACA,SAAOG,kBAAkB,CAACG,YAAD,CAAzB;AACD;;ACpBD;AACA;AAIA;;AAEA,eAAeC,KAAf,GAAuB;AACrB,QAAMC,SAAS,GAAGf,eAAe,EAAjC;AACA,MAAIjB,CAAJ;;AACA,KAAG;AACDA,IAAAA,CAAC,GAAG,MAAMgC,SAAS,CAACC,IAAV,EAAV;AACA,UAAMC,IAAI,GAAGlC,CAAC,CAACmC,KAAf;AACAD,IAAAA,IAAI,CAACf,SAAL,CAAeiB,OAAf,CAAuB,MAAO1E,IAAP,IAAgB;AACrC,YAAMa,OAAO,GACXb,IAAI,CAACa,OAAL,IAAgBb,IAAI,CAAC2E,UAAL,CAAgB,mBAAhB,EAAqC1D,IAArC,EAAhB,IAA+D,EADjE;AAGA,YAAMN,UAAU,GAAG;AACjBH,QAAAA,MAAM,EAAEgE,IAAI,CAAChE,MADI;AAEjBP,QAAAA,KAAK,EAAED,IAAI,CAACC,KAFK;AAGjBW,QAAAA,IAAI,EAAEZ,IAAI,CAACY,IAHM;AAIjBC,QAAAA,OAAO,EAAEA,OAAO,CAAC0B,MAAR,GAAiB4B,kBAAkB,CAACtD,OAAD,CAAnC,GAA+C,IAJvC;AAKjBC,QAAAA,cAAc,EAAED,OAAO,CAAC0B,MAAR,GAAiB1B,OAAjB,GAA2B;AAL1B,OAAnB;AAOA,YAAMH,mBAAmB,CAACC,UAAD,CAAzB;AACD,KAZD;AAaD,GAhBD,QAgBS,CAAC2B,CAAC,CAACsC,IAhBZ;;AAkBA,QAAMhD,kCAAkC,EAAxC;AACD;;AAEDyC,KAAK,G","sources":["webpack://notion-feed-reader/./node_modules/@notionhq/client/build/src/Client.js","webpack://notion-feed-reader/./node_modules/@notionhq/client/build/src/api-endpoints.js","webpack://notion-feed-reader/./node_modules/@notionhq/client/build/src/errors.js","webpack://notion-feed-reader/./node_modules/@notionhq/client/build/src/helpers.js","webpack://notion-feed-reader/./node_modules/@notionhq/client/build/src/index.js","webpack://notion-feed-reader/./node_modules/@notionhq/client/build/src/logging.js","webpack://notion-feed-reader/./node_modules/@tryfabric/martian/build/src/index.js","webpack://notion-feed-reader/./node_modules/@tryfabric/martian/build/src/notion/blocks.js","webpack://notion-feed-reader/./node_modules/@tryfabric/martian/build/src/notion/common.js","webpack://notion-feed-reader/./node_modules/@tryfabric/martian/build/src/notion/index.js","webpack://notion-feed-reader/./node_modules/@tryfabric/martian/build/src/parser/internal.js","webpack://notion-feed-reader/./node_modules/bail/index.js","webpack://notion-feed-reader/./node_modules/ccount/index.js","webpack://notion-feed-reader/./node_modules/domino/lib/CSSStyleDeclaration.js","webpack://notion-feed-reader/./node_modules/domino/lib/CharacterData.js","webpack://notion-feed-reader/./node_modules/domino/lib/ChildNode.js","webpack://notion-feed-reader/./node_modules/domino/lib/Comment.js","webpack://notion-feed-reader/./node_modules/domino/lib/ContainerNode.js","webpack://notion-feed-reader/./node_modules/domino/lib/CustomEvent.js","webpack://notion-feed-reader/./node_modules/domino/lib/DOMException.js","webpack://notion-feed-reader/./node_modules/domino/lib/DOMImplementation.js","webpack://notion-feed-reader/./node_modules/domino/lib/DOMTokenList.js","webpack://notion-feed-reader/./node_modules/domino/lib/Document.js","webpack://notion-feed-reader/./node_modules/domino/lib/DocumentFragment.js","webpack://notion-feed-reader/./node_modules/domino/lib/DocumentType.js","webpack://notion-feed-reader/./node_modules/domino/lib/Element.js","webpack://notion-feed-reader/./node_modules/domino/lib/Event.js","webpack://notion-feed-reader/./node_modules/domino/lib/EventTarget.js","webpack://notion-feed-reader/./node_modules/domino/lib/FilteredElementList.js","webpack://notion-feed-reader/./node_modules/domino/lib/HTMLParser.js","webpack://notion-feed-reader/./node_modules/domino/lib/Leaf.js","webpack://notion-feed-reader/./node_modules/domino/lib/LinkedList.js","webpack://notion-feed-reader/./node_modules/domino/lib/Location.js","webpack://notion-feed-reader/./node_modules/domino/lib/MouseEvent.js","webpack://notion-feed-reader/./node_modules/domino/lib/MutationConstants.js","webpack://notion-feed-reader/./node_modules/domino/lib/NamedNodeMap.js","webpack://notion-feed-reader/./node_modules/domino/lib/NavigatorID.js","webpack://notion-feed-reader/./node_modules/domino/lib/Node.js","webpack://notion-feed-reader/./node_modules/domino/lib/NodeFilter.js","webpack://notion-feed-reader/./node_modules/domino/lib/NodeIterator.js","webpack://notion-feed-reader/./node_modules/domino/lib/NodeList.es5.js","webpack://notion-feed-reader/./node_modules/domino/lib/NodeList.es6.js","webpack://notion-feed-reader/./node_modules/domino/lib/NodeList.js","webpack://notion-feed-reader/./node_modules/domino/lib/NodeTraversal.js","webpack://notion-feed-reader/./node_modules/domino/lib/NodeUtils.js","webpack://notion-feed-reader/./node_modules/domino/lib/NonDocumentTypeChildNode.js","webpack://notion-feed-reader/./node_modules/domino/lib/ProcessingInstruction.js","webpack://notion-feed-reader/./node_modules/domino/lib/Text.js","webpack://notion-feed-reader/./node_modules/domino/lib/TreeWalker.js","webpack://notion-feed-reader/./node_modules/domino/lib/UIEvent.js","webpack://notion-feed-reader/./node_modules/domino/lib/URL.js","webpack://notion-feed-reader/./node_modules/domino/lib/URLUtils.js","webpack://notion-feed-reader/./node_modules/domino/lib/Window.js","webpack://notion-feed-reader/./node_modules/domino/lib/WindowTimers.js","webpack://notion-feed-reader/./node_modules/domino/lib/attributes.js","webpack://notion-feed-reader/./node_modules/domino/lib/config.js","webpack://notion-feed-reader/./node_modules/domino/lib/cssparser.js","webpack://notion-feed-reader/./node_modules/domino/lib/defineElement.js","webpack://notion-feed-reader/./node_modules/domino/lib/events.js","webpack://notion-feed-reader/./node_modules/domino/lib/htmlelts.js","webpack://notion-feed-reader/./node_modules/domino/lib/impl.js","webpack://notion-feed-reader/./node_modules/domino/lib/index.js","webpack://notion-feed-reader/./node_modules/domino/lib/select.js","webpack://notion-feed-reader/./node_modules/domino/lib/sloppy.js","webpack://notion-feed-reader/./node_modules/domino/lib/svg.js","webpack://notion-feed-reader/./node_modules/domino/lib/utils.js","webpack://notion-feed-reader/./node_modules/domino/lib/xmlnames.js","webpack://notion-feed-reader/./node_modules/dotenv/lib/main.js","webpack://notion-feed-reader/./node_modules/entities/lib/decode.js","webpack://notion-feed-reader/./node_modules/entities/lib/decode_codepoint.js","webpack://notion-feed-reader/./node_modules/entities/lib/encode.js","webpack://notion-feed-reader/./node_modules/entities/lib/index.js","webpack://notion-feed-reader/./node_modules/escape-string-regexp/index.js","webpack://notion-feed-reader/./node_modules/extend/index.js","webpack://notion-feed-reader/./node_modules/is-buffer/index.js","webpack://notion-feed-reader/./node_modules/is-plain-obj/index.js","webpack://notion-feed-reader/./node_modules/markdown-table/index.js","webpack://notion-feed-reader/./node_modules/mdast-util-find-and-replace/index.js","webpack://notion-feed-reader/./node_modules/mdast-util-from-markdown/dist/index.js","webpack://notion-feed-reader/./node_modules/mdast-util-from-markdown/index.js","webpack://notion-feed-reader/./node_modules/mdast-util-gfm-autolink-literal/from-markdown.js","webpack://notion-feed-reader/./node_modules/mdast-util-gfm-autolink-literal/to-markdown.js","webpack://notion-feed-reader/./node_modules/mdast-util-gfm-strikethrough/from-markdown.js","webpack://notion-feed-reader/./node_modules/mdast-util-gfm-strikethrough/to-markdown.js","webpack://notion-feed-reader/./node_modules/mdast-util-gfm-table/from-markdown.js","webpack://notion-feed-reader/./node_modules/mdast-util-gfm-table/to-markdown.js","webpack://notion-feed-reader/./node_modules/mdast-util-gfm-task-list-item/from-markdown.js","webpack://notion-feed-reader/./node_modules/mdast-util-gfm-task-list-item/to-markdown.js","webpack://notion-feed-reader/./node_modules/mdast-util-gfm/from-markdown.js","webpack://notion-feed-reader/./node_modules/mdast-util-gfm/to-markdown.js","webpack://notion-feed-reader/./node_modules/mdast-util-to-markdown/lib/configure.js","webpack://notion-feed-reader/./node_modules/mdast-util-to-markdown/lib/handle/inline-code.js","webpack://notion-feed-reader/./node_modules/mdast-util-to-markdown/lib/handle/list-item.js","webpack://notion-feed-reader/./node_modules/mdast-util-to-markdown/lib/util/check-bullet.js","webpack://notion-feed-reader/./node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js","webpack://notion-feed-reader/./node_modules/mdast-util-to-markdown/lib/util/container-flow.js","webpack://notion-feed-reader/./node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js","webpack://notion-feed-reader/./node_modules/mdast-util-to-markdown/lib/util/indent-lines.js","webpack://notion-feed-reader/./node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js","webpack://notion-feed-reader/./node_modules/mdast-util-to-string/index.js","webpack://notion-feed-reader/./node_modules/micromark-extension-gfm-autolink-literal/index.js","webpack://notion-feed-reader/./node_modules/micromark-extension-gfm-autolink-literal/syntax.js","webpack://notion-feed-reader/./node_modules/micromark-extension-gfm-strikethrough/index.js","webpack://notion-feed-reader/./node_modules/micromark-extension-gfm-table/index.js","webpack://notion-feed-reader/./node_modules/micromark-extension-gfm-table/syntax.js","webpack://notion-feed-reader/./node_modules/micromark-extension-gfm-task-list-item/index.js","webpack://notion-feed-reader/./node_modules/micromark-extension-gfm-task-list-item/syntax.js","webpack://notion-feed-reader/./node_modules/micromark-extension-gfm/index.js","webpack://notion-feed-reader/./node_modules/micromark-extension-gfm/syntax.js","webpack://notion-feed-reader/./node_modules/micromark/dist/character/ascii-alpha.js","webpack://notion-feed-reader/./node_modules/micromark/dist/character/ascii-alphanumeric.js","webpack://notion-feed-reader/./node_modules/micromark/dist/character/ascii-atext.js","webpack://notion-feed-reader/./node_modules/micromark/dist/character/ascii-control.js","webpack://notion-feed-reader/./node_modules/micromark/dist/character/ascii-digit.js","webpack://notion-feed-reader/./node_modules/micromark/dist/character/ascii-hex-digit.js","webpack://notion-feed-reader/./node_modules/micromark/dist/character/ascii-punctuation.js","webpack://notion-feed-reader/./node_modules/micromark/dist/character/markdown-line-ending-or-space.js","webpack://notion-feed-reader/./node_modules/micromark/dist/character/markdown-line-ending.js","webpack://notion-feed-reader/./node_modules/micromark/dist/character/markdown-space.js","webpack://notion-feed-reader/./node_modules/micromark/dist/character/unicode-punctuation.js","webpack://notion-feed-reader/./node_modules/micromark/dist/character/unicode-whitespace.js","webpack://notion-feed-reader/./node_modules/micromark/dist/constant/assign.js","webpack://notion-feed-reader/./node_modules/micromark/dist/constant/from-char-code.js","webpack://notion-feed-reader/./node_modules/micromark/dist/constant/has-own-property.js","webpack://notion-feed-reader/./node_modules/micromark/dist/constant/html-block-names.js","webpack://notion-feed-reader/./node_modules/micromark/dist/constant/html-raw-names.js","webpack://notion-feed-reader/./node_modules/micromark/dist/constant/splice.js","webpack://notion-feed-reader/./node_modules/micromark/dist/constant/unicode-punctuation-regex.js","webpack://notion-feed-reader/./node_modules/micromark/dist/constructs.js","webpack://notion-feed-reader/./node_modules/micromark/dist/initialize/content.js","webpack://notion-feed-reader/./node_modules/micromark/dist/initialize/document.js","webpack://notion-feed-reader/./node_modules/micromark/dist/initialize/flow.js","webpack://notion-feed-reader/./node_modules/micromark/dist/initialize/text.js","webpack://notion-feed-reader/./node_modules/micromark/dist/parse.js","webpack://notion-feed-reader/./node_modules/micromark/dist/postprocess.js","webpack://notion-feed-reader/./node_modules/micromark/dist/preprocess.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/attention.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/autolink.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/block-quote.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/character-escape.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/character-reference.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/code-fenced.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/code-indented.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/code-text.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/content.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/definition.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/factory-destination.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/factory-label.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/factory-space.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/factory-title.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/factory-whitespace.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/hard-break-escape.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/heading-atx.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/html-flow.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/html-text.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/label-end.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/label-start-image.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/label-start-link.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/line-ending.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/list.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/partial-blank-line.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/setext-underline.js","webpack://notion-feed-reader/./node_modules/micromark/dist/tokenize/thematic-break.js","webpack://notion-feed-reader/./node_modules/micromark/dist/util/chunked-push.js","webpack://notion-feed-reader/./node_modules/micromark/dist/util/chunked-splice.js","webpack://notion-feed-reader/./node_modules/micromark/dist/util/classify-character.js","webpack://notion-feed-reader/./node_modules/micromark/dist/util/combine-extensions.js","webpack://notion-feed-reader/./node_modules/micromark/dist/util/create-tokenizer.js","webpack://notion-feed-reader/./node_modules/micromark/dist/util/miniflat.js","webpack://notion-feed-reader/./node_modules/micromark/dist/util/move-point.js","webpack://notion-feed-reader/./node_modules/micromark/dist/util/normalize-identifier.js","webpack://notion-feed-reader/./node_modules/micromark/dist/util/prefix-size.js","webpack://notion-feed-reader/./node_modules/micromark/dist/util/regex-check.js","webpack://notion-feed-reader/./node_modules/micromark/dist/util/resolve-all.js","webpack://notion-feed-reader/./node_modules/micromark/dist/util/safe-from-int.js","webpack://notion-feed-reader/./node_modules/micromark/dist/util/serialize-chunks.js","webpack://notion-feed-reader/./node_modules/micromark/dist/util/shallow.js","webpack://notion-feed-reader/./node_modules/micromark/dist/util/size-chunks.js","webpack://notion-feed-reader/./node_modules/micromark/dist/util/slice-chunks.js","webpack://notion-feed-reader/./node_modules/micromark/dist/util/subtokenize.js","webpack://notion-feed-reader/./node_modules/parse-entities/decode-entity.js","webpack://notion-feed-reader/./node_modules/remark-gfm/index.js","webpack://notion-feed-reader/./node_modules/remark-parse/index.js","webpack://notion-feed-reader/./node_modules/repeat-string/index.js","webpack://notion-feed-reader/./node_modules/rss-parser/index.js","webpack://notion-feed-reader/./node_modules/rss-parser/lib/fields.js","webpack://notion-feed-reader/./node_modules/rss-parser/lib/parser.js","webpack://notion-feed-reader/./node_modules/rss-parser/lib/utils.js","webpack://notion-feed-reader/./node_modules/sax/lib/sax.js","webpack://notion-feed-reader/./node_modules/tr46/index.js","webpack://notion-feed-reader/./node_modules/trough/index.js","webpack://notion-feed-reader/./node_modules/trough/wrap.js","webpack://notion-feed-reader/./node_modules/unified/index.js","webpack://notion-feed-reader/./node_modules/unist-util-is/convert.js","webpack://notion-feed-reader/./node_modules/unist-util-stringify-position/index.js","webpack://notion-feed-reader/./node_modules/unist-util-visit-parents/color.js","webpack://notion-feed-reader/./node_modules/unist-util-visit-parents/index.js","webpack://notion-feed-reader/./node_modules/vfile-message/index.js","webpack://notion-feed-reader/./node_modules/vfile/index.js","webpack://notion-feed-reader/./node_modules/vfile/lib/core.js","webpack://notion-feed-reader/./node_modules/vfile/lib/index.js","webpack://notion-feed-reader/./node_modules/vfile/lib/minpath.js","webpack://notion-feed-reader/./node_modules/vfile/lib/minproc.js","webpack://notion-feed-reader/./node_modules/webidl-conversions/lib/index.js","webpack://notion-feed-reader/./node_modules/whatwg-url/lib/URL-impl.js","webpack://notion-feed-reader/./node_modules/whatwg-url/lib/URL.js","webpack://notion-feed-reader/./node_modules/whatwg-url/lib/public-api.js","webpack://notion-feed-reader/./node_modules/whatwg-url/lib/url-state-machine.js","webpack://notion-feed-reader/./node_modules/whatwg-url/lib/utils.js","webpack://notion-feed-reader/./node_modules/xml2js/lib/bom.js","webpack://notion-feed-reader/./node_modules/xml2js/lib/builder.js","webpack://notion-feed-reader/./node_modules/xml2js/lib/defaults.js","webpack://notion-feed-reader/./node_modules/xml2js/lib/parser.js","webpack://notion-feed-reader/./node_modules/xml2js/lib/processors.js","webpack://notion-feed-reader/./node_modules/xml2js/lib/xml2js.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/DocumentPosition.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/NodeType.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/Utility.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/WriterState.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLAttribute.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLCData.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLCharacterData.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLComment.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLDOMConfiguration.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLDOMErrorHandler.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLDOMImplementation.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLDOMStringList.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLDTDAttList.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLDTDElement.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLDTDEntity.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLDTDNotation.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLDeclaration.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLDocType.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLDocument.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLDocumentCB.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLDummy.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLElement.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLNamedNodeMap.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLNode.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLNodeList.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLProcessingInstruction.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLRaw.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLStreamWriter.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLStringWriter.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLStringifier.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLText.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/XMLWriterBase.js","webpack://notion-feed-reader/./node_modules/xmlbuilder/lib/index.js","webpack://notion-feed-reader/external node-commonjs \"events\"","webpack://notion-feed-reader/external node-commonjs \"fs\"","webpack://notion-feed-reader/external node-commonjs \"http\"","webpack://notion-feed-reader/external node-commonjs \"https\"","webpack://notion-feed-reader/external node-commonjs \"os\"","webpack://notion-feed-reader/external node-commonjs \"path\"","webpack://notion-feed-reader/external node-commonjs \"punycode\"","webpack://notion-feed-reader/external node-commonjs \"stream\"","webpack://notion-feed-reader/external node-commonjs \"string_decoder\"","webpack://notion-feed-reader/external node-commonjs \"timers\"","webpack://notion-feed-reader/external node-commonjs \"url\"","webpack://notion-feed-reader/external node-commonjs \"zlib\"","webpack://notion-feed-reader/./node_modules/node-fetch/lib/index.mjs","webpack://notion-feed-reader/webpack/bootstrap","webpack://notion-feed-reader/webpack/runtime/compat get default export","webpack://notion-feed-reader/webpack/runtime/define property getters","webpack://notion-feed-reader/webpack/runtime/hasOwnProperty shorthand","webpack://notion-feed-reader/webpack/runtime/make namespace object","webpack://notion-feed-reader/./src/helpers.js","webpack://notion-feed-reader/./src/notion.js","webpack://notion-feed-reader/./src/feed.js","webpack://notion-feed-reader/./node_modules/turndown/lib/turndown.es.js","webpack://notion-feed-reader/./src/parser.js","webpack://notion-feed-reader/./src/index.js"],"sourcesContent":["\"use strict\";\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Client_auth, _Client_logLevel, _Client_logger, _Client_prefixUrl, _Client_timeoutMs, _Client_notionVersion, _Client_fetch, _Client_agent, _Client_userAgent;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst logging_1 = require(\"./logging\");\nconst errors_1 = require(\"./errors\");\nconst helpers_1 = require(\"./helpers\");\nconst api_endpoints_1 = require(\"./api-endpoints\");\nconst node_fetch_1 = require(\"node-fetch\");\nconst package_json_1 = require(\"../package.json\");\nclass Client {\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f;\n        _Client_auth.set(this, void 0);\n        _Client_logLevel.set(this, void 0);\n        _Client_logger.set(this, void 0);\n        _Client_prefixUrl.set(this, void 0);\n        _Client_timeoutMs.set(this, void 0);\n        _Client_notionVersion.set(this, void 0);\n        _Client_fetch.set(this, void 0);\n        _Client_agent.set(this, void 0);\n        _Client_userAgent.set(this, void 0);\n        /*\n         * Notion API endpoints\n         */\n        this.blocks = {\n            /**\n             * Retrieve block\n             */\n            retrieve: (args) => {\n                return this.request({\n                    path: api_endpoints_1.getBlock.path(args),\n                    method: api_endpoints_1.getBlock.method,\n                    query: helpers_1.pick(args, api_endpoints_1.getBlock.queryParams),\n                    body: helpers_1.pick(args, api_endpoints_1.getBlock.bodyParams),\n                    auth: args === null || args === void 0 ? void 0 : args.auth,\n                });\n            },\n            /**\n             * Update block\n             */\n            update: (args) => {\n                return this.request({\n                    path: api_endpoints_1.updateBlock.path(args),\n                    method: api_endpoints_1.updateBlock.method,\n                    query: helpers_1.pick(args, api_endpoints_1.updateBlock.queryParams),\n                    body: helpers_1.pick(args, api_endpoints_1.updateBlock.bodyParams),\n                    auth: args === null || args === void 0 ? void 0 : args.auth,\n                });\n            },\n            /**\n             * Delete block\n             */\n            delete: (args) => {\n                return this.request({\n                    path: api_endpoints_1.deleteBlock.path(args),\n                    method: api_endpoints_1.deleteBlock.method,\n                    query: helpers_1.pick(args, api_endpoints_1.deleteBlock.queryParams),\n                    body: helpers_1.pick(args, api_endpoints_1.deleteBlock.bodyParams),\n                    auth: args === null || args === void 0 ? void 0 : args.auth,\n                });\n            },\n            children: {\n                /**\n                 * Append block children\n                 */\n                append: (args) => {\n                    return this.request({\n                        path: api_endpoints_1.appendBlockChildren.path(args),\n                        method: api_endpoints_1.appendBlockChildren.method,\n                        query: helpers_1.pick(args, api_endpoints_1.appendBlockChildren.queryParams),\n                        body: helpers_1.pick(args, api_endpoints_1.appendBlockChildren.bodyParams),\n                        auth: args === null || args === void 0 ? void 0 : args.auth,\n                    });\n                },\n                /**\n                 * Retrieve block children\n                 */\n                list: (args) => {\n                    return this.request({\n                        path: api_endpoints_1.listBlockChildren.path(args),\n                        method: api_endpoints_1.listBlockChildren.method,\n                        query: helpers_1.pick(args, api_endpoints_1.listBlockChildren.queryParams),\n                        body: helpers_1.pick(args, api_endpoints_1.listBlockChildren.bodyParams),\n                        auth: args === null || args === void 0 ? void 0 : args.auth,\n                    });\n                },\n            },\n        };\n        this.databases = {\n            /**\n             * List databases\n             *\n             * @deprecated Please use `search`\n             */\n            list: (args) => {\n                return this.request({\n                    path: api_endpoints_1.listDatabases.path(),\n                    method: api_endpoints_1.listDatabases.method,\n                    query: helpers_1.pick(args, api_endpoints_1.listDatabases.queryParams),\n                    body: helpers_1.pick(args, api_endpoints_1.listDatabases.bodyParams),\n                    auth: args === null || args === void 0 ? void 0 : args.auth,\n                });\n            },\n            /**\n             * Retrieve a database\n             */\n            retrieve: (args) => {\n                return this.request({\n                    path: api_endpoints_1.getDatabase.path(args),\n                    method: api_endpoints_1.getDatabase.method,\n                    query: helpers_1.pick(args, api_endpoints_1.getDatabase.queryParams),\n                    body: helpers_1.pick(args, api_endpoints_1.getDatabase.bodyParams),\n                    auth: args === null || args === void 0 ? void 0 : args.auth,\n                });\n            },\n            /**\n             * Query a database\n             */\n            query: (args) => {\n                return this.request({\n                    path: api_endpoints_1.queryDatabase.path(args),\n                    method: api_endpoints_1.queryDatabase.method,\n                    query: helpers_1.pick(args, api_endpoints_1.queryDatabase.queryParams),\n                    body: helpers_1.pick(args, api_endpoints_1.queryDatabase.bodyParams),\n                    auth: args === null || args === void 0 ? void 0 : args.auth,\n                });\n            },\n            /**\n             * Create a database\n             */\n            create: (args) => {\n                return this.request({\n                    path: api_endpoints_1.createDatabase.path(),\n                    method: api_endpoints_1.createDatabase.method,\n                    query: helpers_1.pick(args, api_endpoints_1.createDatabase.queryParams),\n                    body: helpers_1.pick(args, api_endpoints_1.createDatabase.bodyParams),\n                    auth: args === null || args === void 0 ? void 0 : args.auth,\n                });\n            },\n            /**\n             * Update a database\n             */\n            update: (args) => {\n                return this.request({\n                    path: api_endpoints_1.updateDatabase.path(args),\n                    method: api_endpoints_1.updateDatabase.method,\n                    query: helpers_1.pick(args, api_endpoints_1.updateDatabase.queryParams),\n                    body: helpers_1.pick(args, api_endpoints_1.updateDatabase.bodyParams),\n                    auth: args === null || args === void 0 ? void 0 : args.auth,\n                });\n            },\n        };\n        this.pages = {\n            /**\n             * Create a page\n             */\n            create: (args) => {\n                return this.request({\n                    path: api_endpoints_1.createPage.path(),\n                    method: api_endpoints_1.createPage.method,\n                    query: helpers_1.pick(args, api_endpoints_1.createPage.queryParams),\n                    body: helpers_1.pick(args, api_endpoints_1.createPage.bodyParams),\n                    auth: args === null || args === void 0 ? void 0 : args.auth,\n                });\n            },\n            /**\n             * Retrieve a page\n             */\n            retrieve: (args) => {\n                return this.request({\n                    path: api_endpoints_1.getPage.path(args),\n                    method: api_endpoints_1.getPage.method,\n                    query: helpers_1.pick(args, api_endpoints_1.getPage.queryParams),\n                    body: helpers_1.pick(args, api_endpoints_1.getPage.bodyParams),\n                    auth: args === null || args === void 0 ? void 0 : args.auth,\n                });\n            },\n            /**\n             * Update page properties\n             */\n            update: (args) => {\n                return this.request({\n                    path: api_endpoints_1.updatePage.path(args),\n                    method: api_endpoints_1.updatePage.method,\n                    query: helpers_1.pick(args, api_endpoints_1.updatePage.queryParams),\n                    body: helpers_1.pick(args, api_endpoints_1.updatePage.bodyParams),\n                    auth: args === null || args === void 0 ? void 0 : args.auth,\n                });\n            },\n            properties: {\n                /**\n                 * Retrieve page property\n                 */\n                retrieve: (args) => {\n                    return this.request({\n                        path: api_endpoints_1.getPageProperty.path(args),\n                        method: api_endpoints_1.getPageProperty.method,\n                        query: helpers_1.pick(args, api_endpoints_1.getPageProperty.queryParams),\n                        body: helpers_1.pick(args, api_endpoints_1.getPageProperty.bodyParams),\n                        auth: args === null || args === void 0 ? void 0 : args.auth,\n                    });\n                },\n            },\n        };\n        this.users = {\n            /**\n             * Retrieve a user\n             */\n            retrieve: (args) => {\n                return this.request({\n                    path: api_endpoints_1.getUser.path(args),\n                    method: api_endpoints_1.getUser.method,\n                    query: helpers_1.pick(args, api_endpoints_1.getUser.queryParams),\n                    body: helpers_1.pick(args, api_endpoints_1.getUser.bodyParams),\n                    auth: args === null || args === void 0 ? void 0 : args.auth,\n                });\n            },\n            /**\n             * List all users\n             */\n            list: (args) => {\n                return this.request({\n                    path: api_endpoints_1.listUsers.path(),\n                    method: api_endpoints_1.listUsers.method,\n                    query: helpers_1.pick(args, api_endpoints_1.listUsers.queryParams),\n                    body: helpers_1.pick(args, api_endpoints_1.listUsers.bodyParams),\n                    auth: args === null || args === void 0 ? void 0 : args.auth,\n                });\n            },\n            /**\n             * Get details about bot\n             */\n            me: (args) => {\n                return this.request({\n                    path: api_endpoints_1.getSelf.path(),\n                    method: api_endpoints_1.getSelf.method,\n                    query: helpers_1.pick(args, api_endpoints_1.getSelf.queryParams),\n                    body: helpers_1.pick(args, api_endpoints_1.getSelf.bodyParams),\n                    auth: args === null || args === void 0 ? void 0 : args.auth,\n                });\n            },\n        };\n        __classPrivateFieldSet(this, _Client_auth, options === null || options === void 0 ? void 0 : options.auth, \"f\");\n        __classPrivateFieldSet(this, _Client_logLevel, (_a = options === null || options === void 0 ? void 0 : options.logLevel) !== null && _a !== void 0 ? _a : logging_1.LogLevel.WARN, \"f\");\n        __classPrivateFieldSet(this, _Client_logger, (_b = options === null || options === void 0 ? void 0 : options.logger) !== null && _b !== void 0 ? _b : logging_1.makeConsoleLogger(package_json_1.name), \"f\");\n        __classPrivateFieldSet(this, _Client_prefixUrl, ((_c = options === null || options === void 0 ? void 0 : options.baseUrl) !== null && _c !== void 0 ? _c : \"https://api.notion.com\") + \"/v1/\", \"f\");\n        __classPrivateFieldSet(this, _Client_timeoutMs, (_d = options === null || options === void 0 ? void 0 : options.timeoutMs) !== null && _d !== void 0 ? _d : 60000, \"f\");\n        __classPrivateFieldSet(this, _Client_notionVersion, (_e = options === null || options === void 0 ? void 0 : options.notionVersion) !== null && _e !== void 0 ? _e : Client.defaultNotionVersion, \"f\");\n        __classPrivateFieldSet(this, _Client_fetch, (_f = options === null || options === void 0 ? void 0 : options.fetch) !== null && _f !== void 0 ? _f : node_fetch_1.default, \"f\");\n        __classPrivateFieldSet(this, _Client_agent, options === null || options === void 0 ? void 0 : options.agent, \"f\");\n        __classPrivateFieldSet(this, _Client_userAgent, `notionhq-client/${package_json_1.version}`, \"f\");\n    }\n    /**\n     * Sends a request.\n     *\n     * @param path\n     * @param method\n     * @param query\n     * @param body\n     * @returns\n     */\n    async request({ path, method, query, body, auth, }) {\n        this.log(logging_1.LogLevel.INFO, \"request start\", { method, path });\n        // If the body is empty, don't send the body in the HTTP request\n        const bodyAsJsonString = !body || Object.entries(body).length === 0\n            ? undefined\n            : JSON.stringify(body);\n        const url = new URL(`${__classPrivateFieldGet(this, _Client_prefixUrl, \"f\")}${path}`);\n        if (query) {\n            for (const [key, value] of Object.entries(query)) {\n                if (value !== undefined) {\n                    url.searchParams.append(key, String(value));\n                }\n            }\n        }\n        const headers = {\n            ...this.authAsHeaders(auth),\n            \"Notion-Version\": __classPrivateFieldGet(this, _Client_notionVersion, \"f\"),\n            \"user-agent\": __classPrivateFieldGet(this, _Client_userAgent, \"f\"),\n        };\n        if (bodyAsJsonString !== undefined) {\n            headers[\"content-type\"] = \"application/json\";\n        }\n        try {\n            const response = await errors_1.RequestTimeoutError.rejectAfterTimeout(__classPrivateFieldGet(this, _Client_fetch, \"f\").call(this, url.toString(), {\n                method,\n                headers,\n                body: bodyAsJsonString,\n                agent: __classPrivateFieldGet(this, _Client_agent, \"f\"),\n            }), __classPrivateFieldGet(this, _Client_timeoutMs, \"f\"));\n            const responseText = await response.text();\n            if (!response.ok) {\n                throw errors_1.buildRequestError(response, responseText);\n            }\n            const responseJson = JSON.parse(responseText);\n            this.log(logging_1.LogLevel.INFO, `request success`, { method, path });\n            return responseJson;\n        }\n        catch (error) {\n            if (!errors_1.isNotionClientError(error)) {\n                throw error;\n            }\n            // Log the error if it's one of our known error types\n            this.log(logging_1.LogLevel.WARN, `request fail`, {\n                code: error.code,\n                message: error.message,\n            });\n            if (errors_1.isHTTPResponseError(error)) {\n                // The response body may contain sensitive information so it is logged separately at the DEBUG level\n                this.log(logging_1.LogLevel.DEBUG, `failed response body`, {\n                    body: error.body,\n                });\n            }\n            throw error;\n        }\n    }\n    /**\n     * Search\n     */\n    search(args) {\n        return this.request({\n            path: api_endpoints_1.search.path(),\n            method: api_endpoints_1.search.method,\n            query: helpers_1.pick(args, api_endpoints_1.search.queryParams),\n            body: helpers_1.pick(args, api_endpoints_1.search.bodyParams),\n            auth: args === null || args === void 0 ? void 0 : args.auth,\n        });\n    }\n    /**\n     * Emits a log message to the console.\n     *\n     * @param level The level for this message\n     * @param args Arguments to send to the console\n     */\n    log(level, message, extraInfo) {\n        if (logging_1.logLevelSeverity(level) >= logging_1.logLevelSeverity(__classPrivateFieldGet(this, _Client_logLevel, \"f\"))) {\n            __classPrivateFieldGet(this, _Client_logger, \"f\").call(this, level, message, extraInfo);\n        }\n    }\n    /**\n     * Transforms an API key or access token into a headers object suitable for an HTTP request.\n     *\n     * This method uses the instance's value as the default when the input is undefined. If neither are defined, it returns\n     * an empty object\n     *\n     * @param auth API key or access token\n     * @returns headers key-value object\n     */\n    authAsHeaders(auth) {\n        const headers = {};\n        const authHeaderValue = auth !== null && auth !== void 0 ? auth : __classPrivateFieldGet(this, _Client_auth, \"f\");\n        if (authHeaderValue !== undefined) {\n            headers[\"authorization\"] = `Bearer ${authHeaderValue}`;\n        }\n        return headers;\n    }\n}\nexports.default = Client;\n_Client_auth = new WeakMap(), _Client_logLevel = new WeakMap(), _Client_logger = new WeakMap(), _Client_prefixUrl = new WeakMap(), _Client_timeoutMs = new WeakMap(), _Client_notionVersion = new WeakMap(), _Client_fetch = new WeakMap(), _Client_agent = new WeakMap(), _Client_userAgent = new WeakMap();\nClient.defaultNotionVersion = \"2021-08-16\";\n//# sourceMappingURL=Client.js.map","\"use strict\";\n// cspell:disable-file\n// Note: This is a generated file.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.search = exports.createDatabase = exports.listDatabases = exports.queryDatabase = exports.updateDatabase = exports.getDatabase = exports.appendBlockChildren = exports.listBlockChildren = exports.deleteBlock = exports.updateBlock = exports.getBlock = exports.getPageProperty = exports.updatePage = exports.getPage = exports.createPage = exports.listUsers = exports.getUser = exports.getSelf = void 0;\nexports.getSelf = {\n    method: \"get\",\n    pathParams: [],\n    queryParams: [],\n    bodyParams: [],\n    path: () => `users/me`,\n};\nexports.getUser = {\n    method: \"get\",\n    pathParams: [\"user_id\"],\n    queryParams: [],\n    bodyParams: [],\n    path: (p) => `users/${p.user_id}`,\n};\nexports.listUsers = {\n    method: \"get\",\n    pathParams: [],\n    queryParams: [\"start_cursor\", \"page_size\"],\n    bodyParams: [],\n    path: () => `users`,\n};\nexports.createPage = {\n    method: \"post\",\n    pathParams: [],\n    queryParams: [],\n    bodyParams: [\"parent\", \"properties\", \"icon\", \"cover\", \"content\", \"children\"],\n    path: () => `pages`,\n};\nexports.getPage = {\n    method: \"get\",\n    pathParams: [\"page_id\"],\n    queryParams: [],\n    bodyParams: [],\n    path: (p) => `pages/${p.page_id}`,\n};\nexports.updatePage = {\n    method: \"patch\",\n    pathParams: [\"page_id\"],\n    queryParams: [],\n    bodyParams: [\"properties\", \"icon\", \"cover\", \"archived\"],\n    path: (p) => `pages/${p.page_id}`,\n};\nexports.getPageProperty = {\n    method: \"get\",\n    pathParams: [\"page_id\", \"property_id\"],\n    queryParams: [\"start_cursor\", \"page_size\"],\n    bodyParams: [],\n    path: (p) => `pages/${p.page_id}/properties/${p.property_id}`,\n};\nexports.getBlock = {\n    method: \"get\",\n    pathParams: [\"block_id\"],\n    queryParams: [],\n    bodyParams: [],\n    path: (p) => `blocks/${p.block_id}`,\n};\nexports.updateBlock = {\n    method: \"patch\",\n    pathParams: [\"block_id\"],\n    queryParams: [],\n    bodyParams: [\n        \"heading_1\",\n        \"type\",\n        \"archived\",\n        \"heading_2\",\n        \"heading_3\",\n        \"embed\",\n        \"bookmark\",\n        \"image\",\n        \"video\",\n        \"pdf\",\n        \"file\",\n        \"audio\",\n        \"code\",\n        \"equation\",\n        \"divider\",\n        \"breadcrumb\",\n        \"table_of_contents\",\n        \"link_to_page\",\n        \"paragraph\",\n        \"bulleted_list_item\",\n        \"numbered_list_item\",\n        \"quote\",\n        \"to_do\",\n        \"toggle\",\n        \"template\",\n        \"callout\",\n        \"synced_block\",\n    ],\n    path: (p) => `blocks/${p.block_id}`,\n};\nexports.deleteBlock = {\n    method: \"delete\",\n    pathParams: [\"block_id\"],\n    queryParams: [],\n    bodyParams: [],\n    path: (p) => `blocks/${p.block_id}`,\n};\nexports.listBlockChildren = {\n    method: \"get\",\n    pathParams: [\"block_id\"],\n    queryParams: [\"start_cursor\", \"page_size\"],\n    bodyParams: [],\n    path: (p) => `blocks/${p.block_id}/children`,\n};\nexports.appendBlockChildren = {\n    method: \"patch\",\n    pathParams: [\"block_id\"],\n    queryParams: [],\n    bodyParams: [\"children\"],\n    path: (p) => `blocks/${p.block_id}/children`,\n};\nexports.getDatabase = {\n    method: \"get\",\n    pathParams: [\"database_id\"],\n    queryParams: [],\n    bodyParams: [],\n    path: (p) => `databases/${p.database_id}`,\n};\nexports.updateDatabase = {\n    method: \"patch\",\n    pathParams: [\"database_id\"],\n    queryParams: [],\n    bodyParams: [\"title\", \"icon\", \"cover\", \"properties\"],\n    path: (p) => `databases/${p.database_id}`,\n};\nexports.queryDatabase = {\n    method: \"post\",\n    pathParams: [\"database_id\"],\n    queryParams: [],\n    bodyParams: [\"sorts\", \"filter\", \"start_cursor\", \"page_size\", \"archived\"],\n    path: (p) => `databases/${p.database_id}/query`,\n};\nexports.listDatabases = {\n    method: \"get\",\n    pathParams: [],\n    queryParams: [\"start_cursor\", \"page_size\"],\n    bodyParams: [],\n    path: () => `databases`,\n};\nexports.createDatabase = {\n    method: \"post\",\n    pathParams: [],\n    queryParams: [],\n    bodyParams: [\"parent\", \"properties\", \"icon\", \"cover\", \"title\"],\n    path: () => `databases`,\n};\nexports.search = {\n    method: \"post\",\n    pathParams: [],\n    queryParams: [],\n    bodyParams: [\"sort\", \"query\", \"start_cursor\", \"page_size\", \"filter\"],\n    path: () => `search`,\n};\n//# sourceMappingURL=api-endpoints.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildRequestError = exports.APIResponseError = exports.UnknownHTTPResponseError = exports.isHTTPResponseError = exports.RequestTimeoutError = exports.isNotionClientError = exports.ClientErrorCode = exports.APIErrorCode = void 0;\nconst helpers_1 = require(\"./helpers\");\n/**\n * Error codes returned in responses from the API.\n */\nvar APIErrorCode;\n(function (APIErrorCode) {\n    APIErrorCode[\"Unauthorized\"] = \"unauthorized\";\n    APIErrorCode[\"RestrictedResource\"] = \"restricted_resource\";\n    APIErrorCode[\"ObjectNotFound\"] = \"object_not_found\";\n    APIErrorCode[\"RateLimited\"] = \"rate_limited\";\n    APIErrorCode[\"InvalidJSON\"] = \"invalid_json\";\n    APIErrorCode[\"InvalidRequestURL\"] = \"invalid_request_url\";\n    APIErrorCode[\"InvalidRequest\"] = \"invalid_request\";\n    APIErrorCode[\"ValidationError\"] = \"validation_error\";\n    APIErrorCode[\"ConflictError\"] = \"conflict_error\";\n    APIErrorCode[\"InternalServerError\"] = \"internal_server_error\";\n    APIErrorCode[\"ServiceUnavailable\"] = \"service_unavailable\";\n})(APIErrorCode = exports.APIErrorCode || (exports.APIErrorCode = {}));\n/**\n * Error codes generated for client errors.\n */\nvar ClientErrorCode;\n(function (ClientErrorCode) {\n    ClientErrorCode[\"RequestTimeout\"] = \"notionhq_client_request_timeout\";\n    ClientErrorCode[\"ResponseError\"] = \"notionhq_client_response_error\";\n})(ClientErrorCode = exports.ClientErrorCode || (exports.ClientErrorCode = {}));\n/**\n * Base error type.\n */\nclass NotionClientErrorBase extends Error {\n}\n/**\n * @param error any value, usually a caught error.\n * @returns `true` if error is a `NotionClientError`.\n */\nfunction isNotionClientError(error) {\n    return helpers_1.isObject(error) && error instanceof NotionClientErrorBase;\n}\nexports.isNotionClientError = isNotionClientError;\n/**\n * Narrows down the types of a NotionClientError.\n * @param error any value, usually a caught error.\n * @param codes an object mapping from possible error codes to `true`\n * @returns `true` if error is a `NotionClientError` with a code in `codes`.\n */\nfunction isNotionClientErrorWithCode(error, codes) {\n    return isNotionClientError(error) && error.code in codes;\n}\n/**\n * Error thrown by the client if a request times out.\n */\nclass RequestTimeoutError extends NotionClientErrorBase {\n    constructor(message = \"Request to Notion API has timed out\") {\n        super(message);\n        this.code = ClientErrorCode.RequestTimeout;\n        this.name = \"RequestTimeoutError\";\n    }\n    static isRequestTimeoutError(error) {\n        return isNotionClientErrorWithCode(error, {\n            [ClientErrorCode.RequestTimeout]: true,\n        });\n    }\n    static rejectAfterTimeout(promise, timeoutMS) {\n        return new Promise((resolve, reject) => {\n            const timeoutId = setTimeout(() => {\n                reject(new RequestTimeoutError());\n            }, timeoutMS);\n            promise\n                .then(resolve)\n                .catch(reject)\n                .then(() => clearTimeout(timeoutId));\n        });\n    }\n}\nexports.RequestTimeoutError = RequestTimeoutError;\nclass HTTPResponseError extends NotionClientErrorBase {\n    constructor(args) {\n        super(args.message);\n        this.name = \"HTTPResponseError\";\n        const { code, status, headers, rawBodyText } = args;\n        this.code = code;\n        this.status = status;\n        this.headers = headers;\n        this.body = rawBodyText;\n    }\n}\nconst httpResponseErrorCodes = {\n    [ClientErrorCode.ResponseError]: true,\n    [APIErrorCode.Unauthorized]: true,\n    [APIErrorCode.RestrictedResource]: true,\n    [APIErrorCode.ObjectNotFound]: true,\n    [APIErrorCode.RateLimited]: true,\n    [APIErrorCode.InvalidJSON]: true,\n    [APIErrorCode.InvalidRequestURL]: true,\n    [APIErrorCode.InvalidRequest]: true,\n    [APIErrorCode.ValidationError]: true,\n    [APIErrorCode.ConflictError]: true,\n    [APIErrorCode.InternalServerError]: true,\n    [APIErrorCode.ServiceUnavailable]: true,\n};\nfunction isHTTPResponseError(error) {\n    if (!isNotionClientErrorWithCode(error, httpResponseErrorCodes)) {\n        return false;\n    }\n    return true;\n}\nexports.isHTTPResponseError = isHTTPResponseError;\n/**\n * Error thrown if an API call responds with an unknown error code, or does not respond with\n * a property-formatted error.\n */\nclass UnknownHTTPResponseError extends HTTPResponseError {\n    constructor(args) {\n        var _a;\n        super({\n            ...args,\n            code: ClientErrorCode.ResponseError,\n            message: (_a = args.message) !== null && _a !== void 0 ? _a : `Request to Notion API failed with status: ${args.status}`,\n        });\n        this.name = \"UnknownHTTPResponseError\";\n    }\n    static isUnknownHTTPResponseError(error) {\n        return isNotionClientErrorWithCode(error, {\n            [ClientErrorCode.ResponseError]: true,\n        });\n    }\n}\nexports.UnknownHTTPResponseError = UnknownHTTPResponseError;\nconst apiErrorCodes = {\n    [APIErrorCode.Unauthorized]: true,\n    [APIErrorCode.RestrictedResource]: true,\n    [APIErrorCode.ObjectNotFound]: true,\n    [APIErrorCode.RateLimited]: true,\n    [APIErrorCode.InvalidJSON]: true,\n    [APIErrorCode.InvalidRequestURL]: true,\n    [APIErrorCode.InvalidRequest]: true,\n    [APIErrorCode.ValidationError]: true,\n    [APIErrorCode.ConflictError]: true,\n    [APIErrorCode.InternalServerError]: true,\n    [APIErrorCode.ServiceUnavailable]: true,\n};\n/**\n * A response from the API indicating a problem.\n * Use the `code` property to handle various kinds of errors. All its possible values are in `APIErrorCode`.\n */\nclass APIResponseError extends HTTPResponseError {\n    constructor() {\n        super(...arguments);\n        this.name = \"APIResponseError\";\n    }\n    static isAPIResponseError(error) {\n        return isNotionClientErrorWithCode(error, apiErrorCodes);\n    }\n}\nexports.APIResponseError = APIResponseError;\nfunction buildRequestError(response, bodyText) {\n    const apiErrorResponseBody = parseAPIErrorResponseBody(bodyText);\n    if (apiErrorResponseBody !== undefined) {\n        return new APIResponseError({\n            code: apiErrorResponseBody.code,\n            message: apiErrorResponseBody.message,\n            headers: response.headers,\n            status: response.status,\n            rawBodyText: bodyText,\n        });\n    }\n    return new UnknownHTTPResponseError({\n        message: undefined,\n        headers: response.headers,\n        status: response.status,\n        rawBodyText: bodyText,\n    });\n}\nexports.buildRequestError = buildRequestError;\nfunction parseAPIErrorResponseBody(body) {\n    if (typeof body !== \"string\") {\n        return;\n    }\n    let parsed;\n    try {\n        parsed = JSON.parse(body);\n    }\n    catch (parseError) {\n        return;\n    }\n    if (!helpers_1.isObject(parsed) ||\n        typeof parsed[\"message\"] !== \"string\" ||\n        !isAPIErrorCode(parsed[\"code\"])) {\n        return;\n    }\n    return {\n        ...parsed,\n        code: parsed[\"code\"],\n        message: parsed[\"message\"],\n    };\n}\nfunction isAPIErrorCode(code) {\n    return typeof code === \"string\" && code in apiErrorCodes;\n}\n//# sourceMappingURL=errors.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isObject = exports.pick = exports.assertNever = void 0;\n/**\n * Utility for enforcing exhaustiveness checks in the type system.\n *\n * @see https://basarat.gitbook.io/typescript/type-system/discriminated-unions#throw-in-exhaustive-checks\n *\n * @param value The variable with no remaining values\n */\nfunction assertNever(value) {\n    throw new Error(`Unexpected value should never occur: ${value}`);\n}\nexports.assertNever = assertNever;\nfunction pick(base, keys) {\n    const entries = keys.map(key => [key, base === null || base === void 0 ? void 0 : base[key]]);\n    return Object.fromEntries(entries);\n}\nexports.pick = pick;\nfunction isObject(o) {\n    return typeof o === \"object\" && o !== null;\n}\nexports.isObject = isObject;\n//# sourceMappingURL=helpers.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isNotionClientError = exports.RequestTimeoutError = exports.UnknownHTTPResponseError = exports.APIResponseError = exports.ClientErrorCode = exports.APIErrorCode = exports.LogLevel = exports.Client = void 0;\nvar Client_1 = require(\"./Client\");\nObject.defineProperty(exports, \"Client\", { enumerable: true, get: function () { return Client_1.default; } });\nvar logging_1 = require(\"./logging\");\nObject.defineProperty(exports, \"LogLevel\", { enumerable: true, get: function () { return logging_1.LogLevel; } });\nvar errors_1 = require(\"./errors\");\nObject.defineProperty(exports, \"APIErrorCode\", { enumerable: true, get: function () { return errors_1.APIErrorCode; } });\nObject.defineProperty(exports, \"ClientErrorCode\", { enumerable: true, get: function () { return errors_1.ClientErrorCode; } });\nObject.defineProperty(exports, \"APIResponseError\", { enumerable: true, get: function () { return errors_1.APIResponseError; } });\nObject.defineProperty(exports, \"UnknownHTTPResponseError\", { enumerable: true, get: function () { return errors_1.UnknownHTTPResponseError; } });\nObject.defineProperty(exports, \"RequestTimeoutError\", { enumerable: true, get: function () { return errors_1.RequestTimeoutError; } });\n// Error helpers\nObject.defineProperty(exports, \"isNotionClientError\", { enumerable: true, get: function () { return errors_1.isNotionClientError; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.logLevelSeverity = exports.makeConsoleLogger = exports.LogLevel = void 0;\nconst helpers_1 = require(\"./helpers\");\nvar LogLevel;\n(function (LogLevel) {\n    LogLevel[\"DEBUG\"] = \"debug\";\n    LogLevel[\"INFO\"] = \"info\";\n    LogLevel[\"WARN\"] = \"warn\";\n    LogLevel[\"ERROR\"] = \"error\";\n})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\nfunction makeConsoleLogger(name) {\n    return (level, message, extraInfo) => {\n        console[level](`${name} ${level}:`, message, extraInfo);\n    };\n}\nexports.makeConsoleLogger = makeConsoleLogger;\n/**\n * Transforms a log level into a comparable (numerical) value ordered by severity.\n */\nfunction logLevelSeverity(level) {\n    switch (level) {\n        case LogLevel.DEBUG:\n            return 20;\n        case LogLevel.INFO:\n            return 40;\n        case LogLevel.WARN:\n            return 60;\n        case LogLevel.ERROR:\n            return 80;\n        default:\n            return helpers_1.assertNever(level);\n    }\n}\nexports.logLevelSeverity = logLevelSeverity;\n//# sourceMappingURL=logging.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.markdownToRichText = exports.markdownToBlocks = void 0;\nconst unified_1 = __importDefault(require(\"unified\"));\nconst remark_parse_1 = __importDefault(require(\"remark-parse\"));\nconst internal_1 = require(\"./parser/internal\");\nconst remark_gfm_1 = __importDefault(require(\"remark-gfm\"));\n/**\n * Parses Markdown content into Notion Blocks.\n * - Supports all heading types (heading depths 4, 5, 6 are treated as 3 for Notion)\n * - Supports numbered lists, bulleted lists, to-do lists\n * - Supports italics, bold, strikethrough, inline code, hyperlinks\n *\n * Per Notion limitations, these markdown attributes are not supported:\n * - Tables (removed)\n * - HTML tags (removed)\n * - Thematic breaks (removed)\n * - Code blocks (treated as paragraph)\n * - Block quotes (treated as paragraph)\n *\n * Supports GitHub-flavoured Markdown.\n *\n * @param body any Markdown or GFM content\n */\nfunction markdownToBlocks(body, allowUnsupportedObjectType = false) {\n    const root = (0, unified_1.default)().use(remark_parse_1.default).use(remark_gfm_1.default).parse(body);\n    return (0, internal_1.parseBlocks)(root, allowUnsupportedObjectType);\n}\nexports.markdownToBlocks = markdownToBlocks;\n/**\n * Parses inline Markdown content into Notion RichText objects.\n * Only supports plain text, italics, bold, strikethrough, inline code, and hyperlinks.\n *\n * @param text any inline Markdown or GFM content\n */\nfunction markdownToRichText(text) {\n    const root = (0, unified_1.default)().use(remark_parse_1.default).use(remark_gfm_1.default).parse(text);\n    return (0, internal_1.parseRichText)(root);\n}\nexports.markdownToRichText = markdownToRichText;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.tableCell = exports.tableRow = exports.table = exports.toDo = exports.numberedListItem = exports.bulletedListItem = exports.headingThree = exports.headingTwo = exports.headingOne = exports.table_of_contents = exports.image = exports.blockquote = exports.code = exports.paragraph = void 0;\nfunction paragraph(text) {\n    return {\n        object: 'block',\n        type: 'paragraph',\n        paragraph: {\n            text: text,\n        },\n    };\n}\nexports.paragraph = paragraph;\nfunction code(text) {\n    return {\n        object: 'block',\n        type: 'code',\n        code: {\n            text: text,\n            language: 'javascript',\n        },\n    };\n}\nexports.code = code;\nfunction blockquote(text) {\n    return {\n        object: 'block',\n        type: 'quote',\n        quote: {\n            text: text,\n        },\n    };\n}\nexports.blockquote = blockquote;\nfunction image(url) {\n    return {\n        object: 'block',\n        type: 'image',\n        image: {\n            type: 'external',\n            external: {\n                url: url,\n            },\n        },\n    };\n}\nexports.image = image;\nfunction table_of_contents() {\n    return {\n        object: 'block',\n        type: 'table_of_contents',\n        table_of_contents: {},\n    };\n}\nexports.table_of_contents = table_of_contents;\nfunction headingOne(text) {\n    return {\n        object: 'block',\n        type: 'heading_1',\n        heading_1: {\n            text: text,\n        },\n    };\n}\nexports.headingOne = headingOne;\nfunction headingTwo(text) {\n    return {\n        object: 'block',\n        type: 'heading_2',\n        heading_2: {\n            text: text,\n        },\n    };\n}\nexports.headingTwo = headingTwo;\nfunction headingThree(text) {\n    return {\n        object: 'block',\n        type: 'heading_3',\n        heading_3: {\n            text: text,\n        },\n    };\n}\nexports.headingThree = headingThree;\nfunction bulletedListItem(text, children = []) {\n    return {\n        object: 'block',\n        type: 'bulleted_list_item',\n        bulleted_list_item: {\n            text: text,\n            children: children.length ? children : undefined,\n        },\n    };\n}\nexports.bulletedListItem = bulletedListItem;\nfunction numberedListItem(text, children = []) {\n    return {\n        object: 'block',\n        type: 'numbered_list_item',\n        numbered_list_item: {\n            text: text,\n            children: children.length ? children : undefined,\n        },\n    };\n}\nexports.numberedListItem = numberedListItem;\nfunction toDo(checked, text, children = []) {\n    return {\n        object: 'block',\n        type: 'to_do',\n        to_do: {\n            text: text,\n            checked: checked,\n            children: children.length ? children : undefined,\n        },\n    };\n}\nexports.toDo = toDo;\nfunction table(children = []) {\n    return {\n        object: 'unsupported',\n        type: 'table',\n        table: {\n            children: children.length ? children : undefined,\n        },\n    };\n}\nexports.table = table;\nfunction tableRow(children = []) {\n    return {\n        object: 'unsupported',\n        type: 'table_row',\n        table_row: {\n            children: children.length ? children : undefined,\n        },\n    };\n}\nexports.tableRow = tableRow;\nfunction tableCell(children = []) {\n    return {\n        object: 'unsupported',\n        type: 'table_cell',\n        table_cell: {\n            children: children.length ? children : undefined,\n        },\n    };\n}\nexports.tableCell = tableCell;\n//# sourceMappingURL=blocks.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.richText = void 0;\nfunction richText(content, options = {}) {\n    var _a;\n    const annotations = (_a = options.annotations) !== null && _a !== void 0 ? _a : {};\n    return {\n        type: 'text',\n        annotations: {\n            bold: false,\n            strikethrough: false,\n            underline: false,\n            italic: false,\n            code: false,\n            color: 'default',\n            ...annotations,\n        },\n        text: {\n            content: content,\n            link: options.url\n                ? {\n                    type: 'url',\n                    url: options.url,\n                }\n                : undefined,\n        },\n    };\n}\nexports.richText = richText;\n//# sourceMappingURL=common.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./blocks\"), exports);\n__exportStar(require(\"./common\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseRichText = exports.parseBlocks = void 0;\nconst notion = __importStar(require(\"../notion\"));\nconst url_1 = require(\"url\");\nfunction ensureLength(text, copy) {\n    const chunks = text.match(/[^]{1,2000}/g) || [];\n    return chunks.flatMap((item) => notion.richText(item, copy));\n}\nfunction parseInline(element, options) {\n    var _a;\n    const copy = {\n        annotations: {\n            ...((_a = options === null || options === void 0 ? void 0 : options.annotations) !== null && _a !== void 0 ? _a : {}),\n        },\n        url: options === null || options === void 0 ? void 0 : options.url,\n    };\n    switch (element.type) {\n        case 'text':\n            return ensureLength(element.value, copy);\n        case 'delete':\n            copy.annotations.strikethrough = true;\n            return element.children.flatMap(child => parseInline(child, copy));\n        case 'emphasis':\n            copy.annotations.italic = true;\n            return element.children.flatMap(child => parseInline(child, copy));\n        case 'strong':\n            copy.annotations.bold = true;\n            return element.children.flatMap(child => parseInline(child, copy));\n        case 'link':\n            copy.url = element.url;\n            return element.children.flatMap(child => parseInline(child, copy));\n        case 'inlineCode':\n            copy.annotations.code = true;\n            return [notion.richText(element.value, copy)];\n        default:\n            return [];\n    }\n}\nfunction parseParagraph(element) {\n    // If a paragraph containts an image element as its first element\n    // Lets assume it is an image, and parse it as only that (discard remaining content)\n    const isImage = element.children[0].type === 'image';\n    if (isImage) {\n        const image = element.children[0];\n        try {\n            new url_1.URL(image.url);\n            return notion.image(image.url);\n        }\n        catch (error) {\n            console.log(`${error.input} is not a valid url, I will process this as text for you to fix later`);\n        }\n    }\n    // Paragraphs can also be legacy 'TOC' from some markdown\n    const mightBeToc = element.children.length > 2 &&\n        element.children[0].type === 'text' &&\n        element.children[0].value === '[[' &&\n        element.children[1].type === 'emphasis';\n    if (mightBeToc) {\n        const emphasisItem = element.children[1];\n        const emphasisTextItem = emphasisItem.children[0];\n        if (emphasisTextItem.value === 'TOC') {\n            return notion.table_of_contents();\n        }\n    }\n    const text = element.children.flatMap(child => parseInline(child));\n    return notion.paragraph(text);\n}\nfunction parseBlockquote(element) {\n    // Quotes can only contain RichText[], but come through as Block[]\n    // This code collects and flattens the common ones\n    const blocks = element.children.flatMap(child => parseNode(child));\n    const paragraphs = blocks.flatMap(child => child);\n    const richtext = paragraphs.flatMap(child => {\n        if (child.paragraph) {\n            return child.paragraph.text;\n        }\n        if (child.heading_1) {\n            return child.heading_1.text;\n        }\n        if (child.heading_2) {\n            return child.heading_2.text;\n        }\n        if (child.heading_3) {\n            return child.heading_3.text;\n        }\n        return [];\n    });\n    return notion.blockquote(richtext);\n}\nfunction parseHeading(element) {\n    const text = element.children.flatMap(child => parseInline(child));\n    switch (element.depth) {\n        case 1:\n            return notion.headingOne(text);\n        case 2:\n            return notion.headingTwo(text);\n        default:\n            return notion.headingThree(text);\n    }\n}\nfunction parseCode(element) {\n    const text = ensureLength(element.value);\n    return notion.code(text);\n}\nfunction parseList(element) {\n    return element.children.flatMap(item => {\n        const paragraph = item.children.shift();\n        if (paragraph === undefined || paragraph.type !== 'paragraph') {\n            return [];\n        }\n        const text = paragraph.children.flatMap(child => parseInline(child));\n        // Now process any of the children\n        const parsedChildren = item.children.flatMap(child => parseNode(child));\n        if (element.start !== null && element.start !== undefined) {\n            return [notion.numberedListItem(text, parsedChildren)];\n        }\n        else if (item.checked !== null && item.checked !== undefined) {\n            return [notion.toDo(item.checked, text, parsedChildren)];\n        }\n        else {\n            return [notion.bulletedListItem(text, parsedChildren)];\n        }\n    });\n}\nfunction parseTableCell(node) {\n    const text = node.children.flatMap(child => parseInline(child));\n    return [notion.tableCell(text)];\n}\nfunction parseTableRow(node) {\n    const tableCells = node.children.flatMap(child => parseTableCell(child));\n    return [notion.tableRow(tableCells)];\n}\nfunction parseTable(node) {\n    const tableRows = node.children.flatMap(child => parseTableRow(child));\n    return [notion.table(tableRows)];\n}\nfunction parseNode(node, unsupported = false) {\n    switch (node.type) {\n        case 'heading':\n            return [parseHeading(node)];\n        case 'paragraph':\n            return [parseParagraph(node)];\n        case 'code':\n            return [parseCode(node)];\n        case 'blockquote':\n            return [parseBlockquote(node)];\n        case 'list':\n            return parseList(node);\n        case 'table':\n            if (unsupported) {\n                return parseTable(node);\n            }\n            else {\n                return [];\n            }\n        default:\n            return [];\n    }\n}\nfunction parseBlocks(root, unsupported = false) {\n    return root.children.flatMap(item => parseNode(item, unsupported));\n}\nexports.parseBlocks = parseBlocks;\nfunction parseRichText(root) {\n    if (root.children[0].type !== 'paragraph') {\n        throw new Error(`Unsupported markdown element: ${JSON.stringify(root)}`);\n    }\n    const richTexts = [];\n    root.children.forEach(paragraph => {\n        if (paragraph.type === 'paragraph') {\n            paragraph.children.forEach(child => richTexts.push(...parseInline(child)));\n        }\n    });\n    return richTexts;\n}\nexports.parseRichText = parseRichText;\n//# sourceMappingURL=internal.js.map","'use strict'\n\nmodule.exports = bail\n\nfunction bail(err) {\n  if (err) {\n    throw err\n  }\n}\n","'use strict'\n\nmodule.exports = ccount\n\nfunction ccount(source, character) {\n  var value = String(source)\n  var count = 0\n  var index\n\n  if (typeof character !== 'string') {\n    throw new Error('Expected character')\n  }\n\n  index = value.indexOf(character)\n\n  while (index !== -1) {\n    count++\n    index = value.indexOf(character, index + character.length)\n  }\n\n  return count\n}\n","\"use strict\";\nvar parserlib = require('./cssparser');\n\nmodule.exports = CSSStyleDeclaration;\n\nfunction CSSStyleDeclaration(elt) {\n  this._element = elt;\n}\n\n// Utility function for parsing style declarations\n// Pass in a string like \"margin-left: 5px; border-style: solid\"\n// and this function returns an object like\n// {\"margin-left\":\"5px\", \"border-style\":\"solid\"}\nfunction parseStyles(s) {\n  var parser = new parserlib.css.Parser();\n  var result = { property: Object.create(null), priority: Object.create(null) };\n  parser.addListener(\"property\", function(e) {\n    if (e.invalid) return; // Skip errors\n    result.property[e.property.text] = e.value.text;\n    if (e.important) result.priority[e.property.text] = 'important';\n  });\n  s = (''+s).replace(/^;/, '');\n  parser.parseStyleAttribute(s);\n  return result;\n}\n\nvar NO_CHANGE = {}; // Private marker object\n\nCSSStyleDeclaration.prototype = Object.create(Object.prototype, {\n\n  // Return the parsed form of the element's style attribute.\n  // If the element's style attribute has never been parsed\n  // or if it has changed since the last parse, then reparse it\n  // Note that the styles don't get parsed until they're actually needed\n  _parsed: { get: function() {\n    if (!this._parsedStyles || this.cssText !== this._lastParsedText) {\n      var text = this.cssText;\n      this._parsedStyles = parseStyles(text);\n      this._lastParsedText = text;\n      delete this._names;\n    }\n    return this._parsedStyles;\n  }},\n\n  // Call this method any time the parsed representation of the\n  // style changes.  It converts the style properties to a string and\n  // sets cssText and the element's style attribute\n  _serialize: { value: function() {\n    var styles = this._parsed;\n    var s = \"\";\n\n    for(var name in styles.property) {\n      if (s) s += \" \";\n      s += name + \": \" + styles.property[name];\n      if (styles.priority[name]) {\n        s += \" !\" + styles.priority[name];\n      }\n      s += \";\";\n    }\n\n    this.cssText = s;      // also sets the style attribute\n    this._lastParsedText = s;  // so we don't reparse\n    delete this._names;\n  }},\n\n  cssText: {\n    get: function() {\n      // XXX: this is a CSSStyleDeclaration for an element.\n      // A different impl might be necessary for a set of styles\n      // associated returned by getComputedStyle(), e.g.\n      return this._element.getAttribute(\"style\");\n    },\n    set: function(value) {\n      // XXX: I should parse and serialize the value to\n      // normalize it and remove errors. FF and chrome do that.\n      this._element.setAttribute(\"style\", value);\n    }\n  },\n\n  length: { get: function() {\n    if (!this._names)\n      this._names = Object.getOwnPropertyNames(this._parsed.property);\n    return this._names.length;\n  }},\n\n  item: { value: function(n) {\n    if (!this._names)\n      this._names = Object.getOwnPropertyNames(this._parsed.property);\n    return this._names[n];\n  }},\n\n  getPropertyValue: { value: function(property) {\n    property = property.toLowerCase();\n    return this._parsed.property[property] || \"\";\n  }},\n\n  getPropertyPriority: { value: function(property) {\n    property = property.toLowerCase();\n    return this._parsed.priority[property] || \"\";\n  }},\n\n  setProperty: { value: function(property, value, priority) {\n    property = property.toLowerCase();\n    if (value === null || value === undefined) {\n      value = \"\";\n    }\n    if (priority === null || priority === undefined) {\n      priority = \"\";\n    }\n\n    // String coercion\n    if (value !== NO_CHANGE) {\n      value = \"\" + value;\n    }\n\n    if (value === \"\") {\n      this.removeProperty(property);\n      return;\n    }\n\n    if (priority !== \"\" && priority !== NO_CHANGE &&\n        !/^important$/i.test(priority)) {\n      return;\n    }\n\n    var styles = this._parsed;\n    if (value === NO_CHANGE) {\n      if (!styles.property[property]) {\n        return; // Not a valid property name.\n      }\n      if (priority !== \"\") {\n        styles.priority[property] = \"important\";\n      } else {\n        delete styles.priority[property];\n      }\n    } else {\n      // We don't just accept the property value.  Instead\n      // we parse it to ensure that it is something valid.\n      // If it contains a semicolon it is invalid\n      if (value.indexOf(\";\") !== -1) return;\n\n      var newprops = parseStyles(property + \":\" + value);\n      if (Object.getOwnPropertyNames(newprops.property).length === 0) {\n        return; // no valid property found\n      }\n      if (Object.getOwnPropertyNames(newprops.priority).length !== 0) {\n        return; // if the value included '!important' it wasn't valid.\n      }\n\n      // XXX handle shorthand properties\n\n      for (var p in newprops.property) {\n        styles.property[p] = newprops.property[p];\n        if (priority === NO_CHANGE) {\n          continue;\n        } else if (priority !== \"\") {\n          styles.priority[p] = \"important\";\n        } else if (styles.priority[p]) {\n          delete styles.priority[p];\n        }\n      }\n    }\n\n    // Serialize and update cssText and element.style!\n    this._serialize();\n  }},\n\n  setPropertyValue: { value: function(property, value) {\n    return this.setProperty(property, value, NO_CHANGE);\n  }},\n\n  setPropertyPriority: { value: function(property, priority) {\n    return this.setProperty(property, NO_CHANGE, priority);\n  }},\n\n  removeProperty: { value: function(property) {\n    property = property.toLowerCase();\n    var styles = this._parsed;\n    if (property in styles.property) {\n      delete styles.property[property];\n      delete styles.priority[property];\n\n      // Serialize and update cssText and element.style!\n      this._serialize();\n    }\n  }},\n});\n\nvar cssProperties = {\n  alignContent: \"align-content\",\n  alignItems: \"align-items\",\n  alignmentBaseline: \"alignment-baseline\",\n  alignSelf: \"align-self\",\n  animation: \"animation\",\n  animationDelay: \"animation-delay\",\n  animationDirection: \"animation-direction\",\n  animationDuration: \"animation-duration\",\n  animationFillMode: \"animation-fill-mode\",\n  animationIterationCount: \"animation-iteration-count\",\n  animationName: \"animation-name\",\n  animationPlayState: \"animation-play-state\",\n  animationTimingFunction: \"animation-timing-function\",\n  backfaceVisibility: \"backface-visibility\",\n  background: \"background\",\n  backgroundAttachment: \"background-attachment\",\n  backgroundClip: \"background-clip\",\n  backgroundColor: \"background-color\",\n  backgroundImage: \"background-image\",\n  backgroundOrigin: \"background-origin\",\n  backgroundPosition: \"background-position\",\n  backgroundPositionX: \"background-position-x\",\n  backgroundPositionY: \"background-position-y\",\n  backgroundRepeat: \"background-repeat\",\n  backgroundSize: \"background-size\",\n  baselineShift: \"baseline-shift\",\n  border: \"border\",\n  borderBottom: \"border-bottom\",\n  borderBottomColor: \"border-bottom-color\",\n  borderBottomLeftRadius: \"border-bottom-left-radius\",\n  borderBottomRightRadius: \"border-bottom-right-radius\",\n  borderBottomStyle: \"border-bottom-style\",\n  borderBottomWidth: \"border-bottom-width\",\n  borderCollapse: \"border-collapse\",\n  borderColor: \"border-color\",\n  borderImage: \"border-image\",\n  borderImageOutset: \"border-image-outset\",\n  borderImageRepeat: \"border-image-repeat\",\n  borderImageSlice: \"border-image-slice\",\n  borderImageSource: \"border-image-source\",\n  borderImageWidth: \"border-image-width\",\n  borderLeft: \"border-left\",\n  borderLeftColor: \"border-left-color\",\n  borderLeftStyle: \"border-left-style\",\n  borderLeftWidth: \"border-left-width\",\n  borderRadius: \"border-radius\",\n  borderRight: \"border-right\",\n  borderRightColor: \"border-right-color\",\n  borderRightStyle: \"border-right-style\",\n  borderRightWidth: \"border-right-width\",\n  borderSpacing: \"border-spacing\",\n  borderStyle: \"border-style\",\n  borderTop: \"border-top\",\n  borderTopColor: \"border-top-color\",\n  borderTopLeftRadius: \"border-top-left-radius\",\n  borderTopRightRadius: \"border-top-right-radius\",\n  borderTopStyle: \"border-top-style\",\n  borderTopWidth: \"border-top-width\",\n  borderWidth: \"border-width\",\n  bottom: \"bottom\",\n  boxShadow: \"box-shadow\",\n  boxSizing: \"box-sizing\",\n  breakAfter: \"break-after\",\n  breakBefore: \"break-before\",\n  breakInside: \"break-inside\",\n  captionSide: \"caption-side\",\n  clear: \"clear\",\n  clip: \"clip\",\n  clipPath: \"clip-path\",\n  clipRule: \"clip-rule\",\n  color: \"color\",\n  colorInterpolationFilters: \"color-interpolation-filters\",\n  columnCount: \"column-count\",\n  columnFill: \"column-fill\",\n  columnGap: \"column-gap\",\n  columnRule: \"column-rule\",\n  columnRuleColor: \"column-rule-color\",\n  columnRuleStyle: \"column-rule-style\",\n  columnRuleWidth: \"column-rule-width\",\n  columns: \"columns\",\n  columnSpan: \"column-span\",\n  columnWidth: \"column-width\",\n  content: \"content\",\n  counterIncrement: \"counter-increment\",\n  counterReset: \"counter-reset\",\n  cssFloat: \"float\",\n  cursor: \"cursor\",\n  direction: \"direction\",\n  display: \"display\",\n  dominantBaseline: \"dominant-baseline\",\n  emptyCells: \"empty-cells\",\n  enableBackground: \"enable-background\",\n  fill: \"fill\",\n  fillOpacity: \"fill-opacity\",\n  fillRule: \"fill-rule\",\n  filter: \"filter\",\n  flex: \"flex\",\n  flexBasis: \"flex-basis\",\n  flexDirection: \"flex-direction\",\n  flexFlow: \"flex-flow\",\n  flexGrow: \"flex-grow\",\n  flexShrink: \"flex-shrink\",\n  flexWrap: \"flex-wrap\",\n  floodColor: \"flood-color\",\n  floodOpacity: \"flood-opacity\",\n  font: \"font\",\n  fontFamily: \"font-family\",\n  fontFeatureSettings: \"font-feature-settings\",\n  fontSize: \"font-size\",\n  fontSizeAdjust: \"font-size-adjust\",\n  fontStretch: \"font-stretch\",\n  fontStyle: \"font-style\",\n  fontVariant: \"font-variant\",\n  fontWeight: \"font-weight\",\n  glyphOrientationHorizontal: \"glyph-orientation-horizontal\",\n  glyphOrientationVertical: \"glyph-orientation-vertical\",\n  grid: \"grid\",\n  gridArea: \"grid-area\",\n  gridAutoColumns: \"grid-auto-columns\",\n  gridAutoFlow: \"grid-auto-flow\",\n  gridAutoRows: \"grid-auto-rows\",\n  gridColumn: \"grid-column\",\n  gridColumnEnd: \"grid-column-end\",\n  gridColumnGap: \"grid-column-gap\",\n  gridColumnStart: \"grid-column-start\",\n  gridGap: \"grid-gap\",\n  gridRow: \"grid-row\",\n  gridRowEnd: \"grid-row-end\",\n  gridRowGap: \"grid-row-gap\",\n  gridRowStart: \"grid-row-start\",\n  gridTemplate: \"grid-template\",\n  gridTemplateAreas: \"grid-template-areas\",\n  gridTemplateColumns: \"grid-template-columns\",\n  gridTemplateRows: \"grid-template-rows\",\n  height: \"height\",\n  imeMode: \"ime-mode\",\n  justifyContent: \"justify-content\",\n  kerning: \"kerning\",\n  layoutGrid: \"layout-grid\",\n  layoutGridChar: \"layout-grid-char\",\n  layoutGridLine: \"layout-grid-line\",\n  layoutGridMode: \"layout-grid-mode\",\n  layoutGridType: \"layout-grid-type\",\n  left: \"left\",\n  letterSpacing: \"letter-spacing\",\n  lightingColor: \"lighting-color\",\n  lineBreak: \"line-break\",\n  lineHeight: \"line-height\",\n  listStyle: \"list-style\",\n  listStyleImage: \"list-style-image\",\n  listStylePosition: \"list-style-position\",\n  listStyleType: \"list-style-type\",\n  margin: \"margin\",\n  marginBottom: \"margin-bottom\",\n  marginLeft: \"margin-left\",\n  marginRight: \"margin-right\",\n  marginTop: \"margin-top\",\n  marker: \"marker\",\n  markerEnd: \"marker-end\",\n  markerMid: \"marker-mid\",\n  markerStart: \"marker-start\",\n  mask: \"mask\",\n  maxHeight: \"max-height\",\n  maxWidth: \"max-width\",\n  minHeight: \"min-height\",\n  minWidth: \"min-width\",\n  msContentZoomChaining: \"-ms-content-zoom-chaining\",\n  msContentZooming: \"-ms-content-zooming\",\n  msContentZoomLimit: \"-ms-content-zoom-limit\",\n  msContentZoomLimitMax: \"-ms-content-zoom-limit-max\",\n  msContentZoomLimitMin: \"-ms-content-zoom-limit-min\",\n  msContentZoomSnap: \"-ms-content-zoom-snap\",\n  msContentZoomSnapPoints: \"-ms-content-zoom-snap-points\",\n  msContentZoomSnapType: \"-ms-content-zoom-snap-type\",\n  msFlowFrom: \"-ms-flow-from\",\n  msFlowInto: \"-ms-flow-into\",\n  msFontFeatureSettings: \"-ms-font-feature-settings\",\n  msGridColumn: \"-ms-grid-column\",\n  msGridColumnAlign: \"-ms-grid-column-align\",\n  msGridColumns: \"-ms-grid-columns\",\n  msGridColumnSpan: \"-ms-grid-column-span\",\n  msGridRow: \"-ms-grid-row\",\n  msGridRowAlign: \"-ms-grid-row-align\",\n  msGridRows: \"-ms-grid-rows\",\n  msGridRowSpan: \"-ms-grid-row-span\",\n  msHighContrastAdjust: \"-ms-high-contrast-adjust\",\n  msHyphenateLimitChars: \"-ms-hyphenate-limit-chars\",\n  msHyphenateLimitLines: \"-ms-hyphenate-limit-lines\",\n  msHyphenateLimitZone: \"-ms-hyphenate-limit-zone\",\n  msHyphens: \"-ms-hyphens\",\n  msImeAlign: \"-ms-ime-align\",\n  msOverflowStyle: \"-ms-overflow-style\",\n  msScrollChaining: \"-ms-scroll-chaining\",\n  msScrollLimit: \"-ms-scroll-limit\",\n  msScrollLimitXMax: \"-ms-scroll-limit-x-max\",\n  msScrollLimitXMin: \"-ms-scroll-limit-x-min\",\n  msScrollLimitYMax: \"-ms-scroll-limit-y-max\",\n  msScrollLimitYMin: \"-ms-scroll-limit-y-min\",\n  msScrollRails: \"-ms-scroll-rails\",\n  msScrollSnapPointsX: \"-ms-scroll-snap-points-x\",\n  msScrollSnapPointsY: \"-ms-scroll-snap-points-y\",\n  msScrollSnapType: \"-ms-scroll-snap-type\",\n  msScrollSnapX: \"-ms-scroll-snap-x\",\n  msScrollSnapY: \"-ms-scroll-snap-y\",\n  msScrollTranslation: \"-ms-scroll-translation\",\n  msTextCombineHorizontal: \"-ms-text-combine-horizontal\",\n  msTextSizeAdjust: \"-ms-text-size-adjust\",\n  msTouchAction: \"-ms-touch-action\",\n  msTouchSelect: \"-ms-touch-select\",\n  msUserSelect: \"-ms-user-select\",\n  msWrapFlow: \"-ms-wrap-flow\",\n  msWrapMargin: \"-ms-wrap-margin\",\n  msWrapThrough: \"-ms-wrap-through\",\n  opacity: \"opacity\",\n  order: \"order\",\n  orphans: \"orphans\",\n  outline: \"outline\",\n  outlineColor: \"outline-color\",\n  outlineOffset: \"outline-offset\",\n  outlineStyle: \"outline-style\",\n  outlineWidth: \"outline-width\",\n  overflow: \"overflow\",\n  overflowX: \"overflow-x\",\n  overflowY: \"overflow-y\",\n  padding: \"padding\",\n  paddingBottom: \"padding-bottom\",\n  paddingLeft: \"padding-left\",\n  paddingRight: \"padding-right\",\n  paddingTop: \"padding-top\",\n  page: \"page\",\n  pageBreakAfter: \"page-break-after\",\n  pageBreakBefore: \"page-break-before\",\n  pageBreakInside: \"page-break-inside\",\n  perspective: \"perspective\",\n  perspectiveOrigin: \"perspective-origin\",\n  pointerEvents: \"pointer-events\",\n  position: \"position\",\n  quotes: \"quotes\",\n  right: \"right\",\n  rotate: \"rotate\",\n  rubyAlign: \"ruby-align\",\n  rubyOverhang: \"ruby-overhang\",\n  rubyPosition: \"ruby-position\",\n  scale: \"scale\",\n  size: \"size\",\n  stopColor: \"stop-color\",\n  stopOpacity: \"stop-opacity\",\n  stroke: \"stroke\",\n  strokeDasharray: \"stroke-dasharray\",\n  strokeDashoffset: \"stroke-dashoffset\",\n  strokeLinecap: \"stroke-linecap\",\n  strokeLinejoin: \"stroke-linejoin\",\n  strokeMiterlimit: \"stroke-miterlimit\",\n  strokeOpacity: \"stroke-opacity\",\n  strokeWidth: \"stroke-width\",\n  tableLayout: \"table-layout\",\n  textAlign: \"text-align\",\n  textAlignLast: \"text-align-last\",\n  textAnchor: \"text-anchor\",\n  textDecoration: \"text-decoration\",\n  textIndent: \"text-indent\",\n  textJustify: \"text-justify\",\n  textKashida: \"text-kashida\",\n  textKashidaSpace: \"text-kashida-space\",\n  textOverflow: \"text-overflow\",\n  textShadow: \"text-shadow\",\n  textTransform: \"text-transform\",\n  textUnderlinePosition: \"text-underline-position\",\n  top: \"top\",\n  touchAction: \"touch-action\",\n  transform: \"transform\",\n  transformOrigin: \"transform-origin\",\n  transformStyle: \"transform-style\",\n  transition: \"transition\",\n  transitionDelay: \"transition-delay\",\n  transitionDuration: \"transition-duration\",\n  transitionProperty: \"transition-property\",\n  transitionTimingFunction: \"transition-timing-function\",\n  translate: \"translate\",\n  unicodeBidi: \"unicode-bidi\",\n  verticalAlign: \"vertical-align\",\n  visibility: \"visibility\",\n  webkitAlignContent: \"-webkit-align-content\",\n  webkitAlignItems: \"-webkit-align-items\",\n  webkitAlignSelf: \"-webkit-align-self\",\n  webkitAnimation: \"-webkit-animation\",\n  webkitAnimationDelay: \"-webkit-animation-delay\",\n  webkitAnimationDirection: \"-webkit-animation-direction\",\n  webkitAnimationDuration: \"-webkit-animation-duration\",\n  webkitAnimationFillMode: \"-webkit-animation-fill-mode\",\n  webkitAnimationIterationCount: \"-webkit-animation-iteration-count\",\n  webkitAnimationName: \"-webkit-animation-name\",\n  webkitAnimationPlayState: \"-webkit-animation-play-state\",\n  webkitAnimationTimingFunction: \"-webkit-animation-timing-funciton\",\n  webkitAppearance: \"-webkit-appearance\",\n  webkitBackfaceVisibility: \"-webkit-backface-visibility\",\n  webkitBackgroundClip: \"-webkit-background-clip\",\n  webkitBackgroundOrigin: \"-webkit-background-origin\",\n  webkitBackgroundSize: \"-webkit-background-size\",\n  webkitBorderBottomLeftRadius: \"-webkit-border-bottom-left-radius\",\n  webkitBorderBottomRightRadius: \"-webkit-border-bottom-right-radius\",\n  webkitBorderImage: \"-webkit-border-image\",\n  webkitBorderRadius: \"-webkit-border-radius\",\n  webkitBorderTopLeftRadius: \"-webkit-border-top-left-radius\",\n  webkitBorderTopRightRadius: \"-webkit-border-top-right-radius\",\n  webkitBoxAlign: \"-webkit-box-align\",\n  webkitBoxDirection: \"-webkit-box-direction\",\n  webkitBoxFlex: \"-webkit-box-flex\",\n  webkitBoxOrdinalGroup: \"-webkit-box-ordinal-group\",\n  webkitBoxOrient: \"-webkit-box-orient\",\n  webkitBoxPack: \"-webkit-box-pack\",\n  webkitBoxSizing: \"-webkit-box-sizing\",\n  webkitColumnBreakAfter: \"-webkit-column-break-after\",\n  webkitColumnBreakBefore: \"-webkit-column-break-before\",\n  webkitColumnBreakInside: \"-webkit-column-break-inside\",\n  webkitColumnCount: \"-webkit-column-count\",\n  webkitColumnGap: \"-webkit-column-gap\",\n  webkitColumnRule: \"-webkit-column-rule\",\n  webkitColumnRuleColor: \"-webkit-column-rule-color\",\n  webkitColumnRuleStyle: \"-webkit-column-rule-style\",\n  webkitColumnRuleWidth: \"-webkit-column-rule-width\",\n  webkitColumns: \"-webkit-columns\",\n  webkitColumnSpan: \"-webkit-column-span\",\n  webkitColumnWidth: \"-webkit-column-width\",\n  webkitFilter: \"-webkit-filter\",\n  webkitFlex: \"-webkit-flex\",\n  webkitFlexBasis: \"-webkit-flex-basis\",\n  webkitFlexDirection: \"-webkit-flex-direction\",\n  webkitFlexFlow: \"-webkit-flex-flow\",\n  webkitFlexGrow: \"-webkit-flex-grow\",\n  webkitFlexShrink: \"-webkit-flex-shrink\",\n  webkitFlexWrap: \"-webkit-flex-wrap\",\n  webkitJustifyContent: \"-webkit-justify-content\",\n  webkitOrder: \"-webkit-order\",\n  webkitPerspective: \"-webkit-perspective-origin\",\n  webkitPerspectiveOrigin: \"-webkit-perspective-origin\",\n  webkitTapHighlightColor: \"-webkit-tap-highlight-color\",\n  webkitTextFillColor: \"-webkit-text-fill-color\",\n  webkitTextSizeAdjust: \"-webkit-text-size-adjust\",\n  webkitTextStroke: \"-webkit-text-stroke\",\n  webkitTextStrokeColor: \"-webkit-text-stroke-color\",\n  webkitTextStrokeWidth: \"-webkit-text-stroke-width\",\n  webkitTransform: \"-webkit-transform\",\n  webkitTransformOrigin: \"-webkit-transform-origin\",\n  webkitTransformStyle: \"-webkit-transform-style\",\n  webkitTransition: \"-webkit-transition\",\n  webkitTransitionDelay: \"-webkit-transition-delay\",\n  webkitTransitionDuration: \"-webkit-transition-duration\",\n  webkitTransitionProperty: \"-webkit-transition-property\",\n  webkitTransitionTimingFunction: \"-webkit-transition-timing-function\",\n  webkitUserModify: \"-webkit-user-modify\",\n  webkitUserSelect: \"-webkit-user-select\",\n  webkitWritingMode: \"-webkit-writing-mode\",\n  whiteSpace: \"white-space\",\n  widows: \"widows\",\n  width: \"width\",\n  wordBreak: \"word-break\",\n  wordSpacing: \"word-spacing\",\n  wordWrap: \"word-wrap\",\n  writingMode: \"writing-mode\",\n  zIndex: \"z-index\",\n  zoom: \"zoom\",\n  resize: \"resize\",\n  userSelect: \"user-select\",\n};\n\nfor(var prop in cssProperties) defineStyleProperty(prop);\n\nfunction defineStyleProperty(jsname) {\n  var cssname = cssProperties[jsname];\n  Object.defineProperty(CSSStyleDeclaration.prototype, jsname, {\n    get: function() {\n      return this.getPropertyValue(cssname);\n    },\n    set: function(value) {\n      this.setProperty(cssname, value);\n    }\n  });\n\n  if (!CSSStyleDeclaration.prototype.hasOwnProperty(cssname)) {\n    Object.defineProperty(CSSStyleDeclaration.prototype, cssname, {\n      get: function() {\n        return this.getPropertyValue(cssname);\n      },\n      set: function(value) {\n        this.setProperty(cssname, value);\n      }\n    });\n  }\n}\n","/* jshint bitwise: false */\n\"use strict\";\nmodule.exports = CharacterData;\n\nvar Leaf = require('./Leaf');\nvar utils = require('./utils');\nvar ChildNode = require('./ChildNode');\nvar NonDocumentTypeChildNode = require('./NonDocumentTypeChildNode');\n\nfunction CharacterData() {\n  Leaf.call(this);\n}\n\nCharacterData.prototype = Object.create(Leaf.prototype, {\n  // DOMString substringData(unsigned long offset,\n  //               unsigned long count);\n  // The substringData(offset, count) method must run these steps:\n  //\n  //     If offset is greater than the context object's\n  //     length, throw an INDEX_SIZE_ERR exception and\n  //     terminate these steps.\n  //\n  //     If offset+count is greater than the context\n  //     object's length, return a DOMString whose value is\n  //     the UTF-16 code units from the offsetth UTF-16 code\n  //     unit to the end of data.\n  //\n  //     Return a DOMString whose value is the UTF-16 code\n  //     units from the offsetth UTF-16 code unit to the\n  //     offset+countth UTF-16 code unit in data.\n  substringData: { value: function substringData(offset, count) {\n    if (arguments.length < 2) { throw new TypeError(\"Not enough arguments\"); }\n    // Convert arguments to WebIDL \"unsigned long\"\n    offset = offset >>> 0;\n    count = count >>> 0;\n    if (offset > this.data.length || offset < 0 || count < 0) {\n      utils.IndexSizeError();\n    }\n    return this.data.substring(offset, offset+count);\n  }},\n\n  // void appendData(DOMString data);\n  // The appendData(data) method must append data to the context\n  // object's data.\n  appendData: { value: function appendData(data) {\n    if (arguments.length < 1) { throw new TypeError(\"Not enough arguments\"); }\n    this.data += String(data);\n  }},\n\n  // void insertData(unsigned long offset, DOMString data);\n  // The insertData(offset, data) method must run these steps:\n  //\n  //     If offset is greater than the context object's\n  //     length, throw an INDEX_SIZE_ERR exception and\n  //     terminate these steps.\n  //\n  //     Insert data into the context object's data after\n  //     offset UTF-16 code units.\n  //\n  insertData: { value: function insertData(offset, data) {\n    return this.replaceData(offset, 0, data);\n  }},\n\n\n  // void deleteData(unsigned long offset, unsigned long count);\n  // The deleteData(offset, count) method must run these steps:\n  //\n  //     If offset is greater than the context object's\n  //     length, throw an INDEX_SIZE_ERR exception and\n  //     terminate these steps.\n  //\n  //     If offset+count is greater than the context\n  //     object's length var count be length-offset.\n  //\n  //     Starting from offset UTF-16 code units remove count\n  //     UTF-16 code units from the context object's data.\n  deleteData: { value: function deleteData(offset, count) {\n    return this.replaceData(offset, count, '');\n  }},\n\n\n  // void replaceData(unsigned long offset, unsigned long count,\n  //          DOMString data);\n  //\n  // The replaceData(offset, count, data) method must act as\n  // if the deleteData() method is invoked with offset and\n  // count as arguments followed by the insertData() method\n  // with offset and data as arguments and re-throw any\n  // exceptions these methods might have thrown.\n  replaceData: { value: function replaceData(offset, count, data) {\n    var curtext = this.data, len = curtext.length;\n    // Convert arguments to correct WebIDL type\n    offset = offset >>> 0;\n    count = count >>> 0;\n    data = String(data);\n\n    if (offset > len || offset < 0) utils.IndexSizeError();\n\n    if (offset+count > len)\n      count = len - offset;\n\n    var prefix = curtext.substring(0, offset),\n    suffix = curtext.substring(offset+count);\n\n    this.data = prefix + data + suffix;\n  }},\n\n  // Utility method that Node.isEqualNode() calls to test Text and\n  // Comment nodes for equality.  It is okay to put it here, since\n  // Node will have already verified that nodeType is equal\n  isEqual: { value: function isEqual(n) {\n    return this._data === n._data;\n  }},\n\n  length: { get: function() { return this.data.length; }}\n\n});\n\nObject.defineProperties(CharacterData.prototype, ChildNode);\nObject.defineProperties(CharacterData.prototype, NonDocumentTypeChildNode);\n","\"use strict\";\n\nvar Node = require('./Node');\nvar LinkedList = require('./LinkedList');\n\nvar createDocumentFragmentFromArguments = function(document, args) {\n  var docFrag = document.createDocumentFragment();\n\n  for (var i=0; i<args.length; i++) {\n    var argItem = args[i];\n    var isNode = argItem instanceof Node;\n    docFrag.appendChild(isNode ? argItem :\n                        document.createTextNode(String(argItem)));\n  }\n\n  return docFrag;\n};\n\n// The ChildNode interface contains methods that are particular to `Node`\n// objects that can have a parent.  It is implemented by `Element`,\n// `DocumentType`, and `CharacterData` objects.\nvar ChildNode = {\n\n  // Inserts a set of Node or String objects in the children list of this\n  // ChildNode's parent, just after this ChildNode.  String objects are\n  // inserted as the equivalent Text nodes.\n  after: { value: function after() {\n    var argArr = Array.prototype.slice.call(arguments);\n    var parentNode = this.parentNode, nextSibling = this.nextSibling;\n    if (parentNode === null) { return; }\n    // Find \"viable next sibling\"; that is, next one not in argArr\n    while (nextSibling && argArr.some(function(v) { return v===nextSibling; }))\n      nextSibling = nextSibling.nextSibling;\n    // ok, parent and sibling are saved away since this node could itself\n    // appear in argArr and we're about to move argArr to a document fragment.\n    var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);\n\n    parentNode.insertBefore(docFrag, nextSibling);\n  }},\n\n  // Inserts a set of Node or String objects in the children list of this\n  // ChildNode's parent, just before this ChildNode.  String objects are\n  // inserted as the equivalent Text nodes.\n  before: { value: function before() {\n    var argArr = Array.prototype.slice.call(arguments);\n    var parentNode = this.parentNode, prevSibling = this.previousSibling;\n    if (parentNode === null) { return; }\n    // Find \"viable prev sibling\"; that is, prev one not in argArr\n    while (prevSibling && argArr.some(function(v) { return v===prevSibling; }))\n      prevSibling = prevSibling.previousSibling;\n    // ok, parent and sibling are saved away since this node could itself\n    // appear in argArr and we're about to move argArr to a document fragment.\n    var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);\n\n    var nextSibling =\n        prevSibling ? prevSibling.nextSibling : parentNode.firstChild;\n    parentNode.insertBefore(docFrag, nextSibling);\n  }},\n\n  // Remove this node from its parent\n  remove: { value: function remove() {\n    if (this.parentNode === null) return;\n\n    // Send mutation events if necessary\n    if (this.doc) {\n      this.doc._preremoveNodeIterators(this);\n      if (this.rooted) {\n        this.doc.mutateRemove(this);\n      }\n    }\n\n    // Remove this node from its parents array of children\n    // and update the structure id for all ancestors\n    this._remove();\n\n    // Forget this node's parent\n    this.parentNode = null;\n  }},\n\n  // Remove this node w/o uprooting or sending mutation events\n  // (But do update the structure id for all ancestors)\n  _remove: { value: function _remove() {\n    var parent = this.parentNode;\n    if (parent === null) return;\n    if (parent._childNodes) {\n      parent._childNodes.splice(this.index, 1);\n    } else if (parent._firstChild === this) {\n      if (this._nextSibling === this) {\n        parent._firstChild = null;\n      } else {\n        parent._firstChild = this._nextSibling;\n      }\n    }\n    LinkedList.remove(this);\n    parent.modify();\n  }},\n\n  // Replace this node with the nodes or strings provided as arguments.\n  replaceWith: { value: function replaceWith() {\n    var argArr = Array.prototype.slice.call(arguments);\n    var parentNode = this.parentNode, nextSibling = this.nextSibling;\n    if (parentNode === null) { return; }\n    // Find \"viable next sibling\"; that is, next one not in argArr\n    while (nextSibling && argArr.some(function(v) { return v===nextSibling; }))\n      nextSibling = nextSibling.nextSibling;\n    // ok, parent and sibling are saved away since this node could itself\n    // appear in argArr and we're about to move argArr to a document fragment.\n    var docFrag = createDocumentFragmentFromArguments(this.doc, argArr);\n    if (this.parentNode === parentNode) {\n      parentNode.replaceChild(docFrag, this);\n    } else {\n      // `this` was inserted into docFrag\n      parentNode.insertBefore(docFrag, nextSibling);\n    }\n  }},\n\n};\n\nmodule.exports = ChildNode;\n","\"use strict\";\nmodule.exports = Comment;\n\nvar Node = require('./Node');\nvar CharacterData = require('./CharacterData');\n\nfunction Comment(doc, data) {\n  CharacterData.call(this);\n  this.nodeType = Node.COMMENT_NODE;\n  this.ownerDocument = doc;\n  this._data = data;\n}\n\nvar nodeValue = {\n  get: function() { return this._data; },\n  set: function(v) {\n    if (v === null || v === undefined) { v = ''; } else { v = String(v); }\n    this._data = v;\n    if (this.rooted)\n      this.ownerDocument.mutateValue(this);\n  }\n};\n\nComment.prototype = Object.create(CharacterData.prototype, {\n  nodeName: { value: '#comment' },\n  nodeValue: nodeValue,\n  textContent: nodeValue,\n  data: {\n    get: nodeValue.get,\n    set: function(v) {\n      nodeValue.set.call(this, v===null ? '' : String(v));\n    },\n  },\n\n  // Utility methods\n  clone: { value: function clone() {\n    return new Comment(this.ownerDocument, this._data);\n  }},\n});\n","\"use strict\";\nmodule.exports = ContainerNode;\n\nvar Node = require('./Node');\nvar NodeList = require('./NodeList');\n\n// This class defines common functionality for node subtypes that\n// can have children\n\nfunction ContainerNode() {\n  Node.call(this);\n  this._firstChild = this._childNodes = null;\n}\n\n// Primary representation is a circular linked list of siblings\nContainerNode.prototype = Object.create(Node.prototype, {\n\n  hasChildNodes: { value: function() {\n    if (this._childNodes) {\n      return this._childNodes.length > 0;\n    }\n    return this._firstChild !== null;\n  }},\n\n  childNodes: { get: function() {\n    this._ensureChildNodes();\n    return this._childNodes;\n  }},\n\n  firstChild: { get: function() {\n    if (this._childNodes) {\n      return this._childNodes.length === 0 ? null : this._childNodes[0];\n    }\n    return this._firstChild;\n  }},\n\n  lastChild: { get: function() {\n    var kids = this._childNodes, first;\n    if (kids) {\n      return kids.length === 0 ? null: kids[kids.length-1];\n    }\n    first = this._firstChild;\n    if (first === null) { return null; }\n    return first._previousSibling; // circular linked list\n  }},\n\n  _ensureChildNodes: { value: function() {\n    if (this._childNodes) { return; }\n    var first = this._firstChild,\n        kid = first,\n        childNodes = this._childNodes = new NodeList();\n    if (first) do {\n      childNodes.push(kid);\n      kid = kid._nextSibling;\n    } while (kid !== first); // circular linked list\n    this._firstChild = null; // free memory\n  }},\n\n  // Remove all of this node's children.  This is a minor\n  // optimization that only calls modify() once.\n  removeChildren: { value: function removeChildren() {\n    var root = this.rooted ? this.ownerDocument : null,\n        next = this.firstChild,\n        kid;\n    while (next !== null) {\n      kid = next;\n      next = kid.nextSibling;\n\n      if (root) root.mutateRemove(kid);\n      kid.parentNode = null;\n    }\n    if (this._childNodes) {\n      this._childNodes.length = 0;\n    } else {\n      this._firstChild = null;\n    }\n    this.modify(); // Update last modified type once only\n  }},\n\n});\n","\"use strict\";\nmodule.exports = CustomEvent;\n\nvar Event = require('./Event');\n\nfunction CustomEvent(type, dictionary) {\n  // Just use the superclass constructor to initialize\n  Event.call(this, type, dictionary);\n}\nCustomEvent.prototype = Object.create(Event.prototype, {\n  constructor: { value: CustomEvent }\n});\n","\"use strict\";\nmodule.exports = DOMException;\n\nvar INDEX_SIZE_ERR = 1;\nvar HIERARCHY_REQUEST_ERR = 3;\nvar WRONG_DOCUMENT_ERR = 4;\nvar INVALID_CHARACTER_ERR = 5;\nvar NO_MODIFICATION_ALLOWED_ERR = 7;\nvar NOT_FOUND_ERR = 8;\nvar NOT_SUPPORTED_ERR = 9;\nvar INVALID_STATE_ERR = 11;\nvar SYNTAX_ERR = 12;\nvar INVALID_MODIFICATION_ERR = 13;\nvar NAMESPACE_ERR = 14;\nvar INVALID_ACCESS_ERR = 15;\nvar TYPE_MISMATCH_ERR = 17;\nvar SECURITY_ERR = 18;\nvar NETWORK_ERR = 19;\nvar ABORT_ERR = 20;\nvar URL_MISMATCH_ERR = 21;\nvar QUOTA_EXCEEDED_ERR = 22;\nvar TIMEOUT_ERR = 23;\nvar INVALID_NODE_TYPE_ERR = 24;\nvar DATA_CLONE_ERR = 25;\n\n// Code to name\nvar names = [\n  null,  // No error with code 0\n  'INDEX_SIZE_ERR',\n  null, // historical\n  'HIERARCHY_REQUEST_ERR',\n  'WRONG_DOCUMENT_ERR',\n  'INVALID_CHARACTER_ERR',\n  null, // historical\n  'NO_MODIFICATION_ALLOWED_ERR',\n  'NOT_FOUND_ERR',\n  'NOT_SUPPORTED_ERR',\n  'INUSE_ATTRIBUTE_ERR', // historical\n  'INVALID_STATE_ERR',\n  'SYNTAX_ERR',\n  'INVALID_MODIFICATION_ERR',\n  'NAMESPACE_ERR',\n  'INVALID_ACCESS_ERR',\n  null, // historical\n  'TYPE_MISMATCH_ERR',\n  'SECURITY_ERR',\n  'NETWORK_ERR',\n  'ABORT_ERR',\n  'URL_MISMATCH_ERR',\n  'QUOTA_EXCEEDED_ERR',\n  'TIMEOUT_ERR',\n  'INVALID_NODE_TYPE_ERR',\n  'DATA_CLONE_ERR',\n];\n\n// Code to message\n// These strings are from the 13 May 2011 Editor's Draft of DOM Core.\n// http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html\n// Copyright  2011 W3C (MIT, ERCIM, Keio), All Rights Reserved.\n// Used under the terms of the W3C Document License:\n// http://www.w3.org/Consortium/Legal/2002/copyright-documents-20021231\nvar messages = [\n  null,  // No error with code 0\n  'INDEX_SIZE_ERR (1): the index is not in the allowed range',\n  null,\n  'HIERARCHY_REQUEST_ERR (3): the operation would yield an incorrect nodes model',\n  'WRONG_DOCUMENT_ERR (4): the object is in the wrong Document, a call to importNode is required',\n  'INVALID_CHARACTER_ERR (5): the string contains invalid characters',\n  null,\n  'NO_MODIFICATION_ALLOWED_ERR (7): the object can not be modified',\n  'NOT_FOUND_ERR (8): the object can not be found here',\n  'NOT_SUPPORTED_ERR (9): this operation is not supported',\n  'INUSE_ATTRIBUTE_ERR (10): setAttributeNode called on owned Attribute',\n  'INVALID_STATE_ERR (11): the object is in an invalid state',\n  'SYNTAX_ERR (12): the string did not match the expected pattern',\n  'INVALID_MODIFICATION_ERR (13): the object can not be modified in this way',\n  'NAMESPACE_ERR (14): the operation is not allowed by Namespaces in XML',\n  'INVALID_ACCESS_ERR (15): the object does not support the operation or argument',\n  null,\n  'TYPE_MISMATCH_ERR (17): the type of the object does not match the expected type',\n  'SECURITY_ERR (18): the operation is insecure',\n  'NETWORK_ERR (19): a network error occurred',\n  'ABORT_ERR (20): the user aborted an operation',\n  'URL_MISMATCH_ERR (21): the given URL does not match another URL',\n  'QUOTA_EXCEEDED_ERR (22): the quota has been exceeded',\n  'TIMEOUT_ERR (23): a timeout occurred',\n  'INVALID_NODE_TYPE_ERR (24): the supplied node is invalid or has an invalid ancestor for this operation',\n  'DATA_CLONE_ERR (25): the object can not be cloned.'\n];\n\n// Name to code\nvar constants = {\n  INDEX_SIZE_ERR: INDEX_SIZE_ERR,\n  DOMSTRING_SIZE_ERR: 2, // historical\n  HIERARCHY_REQUEST_ERR: HIERARCHY_REQUEST_ERR,\n  WRONG_DOCUMENT_ERR: WRONG_DOCUMENT_ERR,\n  INVALID_CHARACTER_ERR: INVALID_CHARACTER_ERR,\n  NO_DATA_ALLOWED_ERR: 6, // historical\n  NO_MODIFICATION_ALLOWED_ERR: NO_MODIFICATION_ALLOWED_ERR,\n  NOT_FOUND_ERR: NOT_FOUND_ERR,\n  NOT_SUPPORTED_ERR: NOT_SUPPORTED_ERR,\n  INUSE_ATTRIBUTE_ERR: 10, // historical\n  INVALID_STATE_ERR: INVALID_STATE_ERR,\n  SYNTAX_ERR: SYNTAX_ERR,\n  INVALID_MODIFICATION_ERR: INVALID_MODIFICATION_ERR,\n  NAMESPACE_ERR: NAMESPACE_ERR,\n  INVALID_ACCESS_ERR: INVALID_ACCESS_ERR,\n  VALIDATION_ERR: 16, // historical\n  TYPE_MISMATCH_ERR: TYPE_MISMATCH_ERR,\n  SECURITY_ERR: SECURITY_ERR,\n  NETWORK_ERR: NETWORK_ERR,\n  ABORT_ERR: ABORT_ERR,\n  URL_MISMATCH_ERR: URL_MISMATCH_ERR,\n  QUOTA_EXCEEDED_ERR: QUOTA_EXCEEDED_ERR,\n  TIMEOUT_ERR: TIMEOUT_ERR,\n  INVALID_NODE_TYPE_ERR: INVALID_NODE_TYPE_ERR,\n  DATA_CLONE_ERR: DATA_CLONE_ERR\n};\n\nfunction DOMException(code) {\n  Error.call(this);\n  Error.captureStackTrace(this, this.constructor);\n  this.code = code;\n  this.message = messages[code];\n  this.name = names[code];\n}\nDOMException.prototype.__proto__ = Error.prototype;\n\n// Initialize the constants on DOMException and DOMException.prototype\nfor(var c in constants) {\n  var v = { value: constants[c] };\n  Object.defineProperty(DOMException, c, v);\n  Object.defineProperty(DOMException.prototype, c, v);\n}\n","\"use strict\";\nmodule.exports = DOMImplementation;\n\nvar Document = require('./Document');\nvar DocumentType = require('./DocumentType');\nvar HTMLParser = require('./HTMLParser');\nvar utils = require('./utils');\nvar xml = require('./xmlnames');\n\n// Each document must have its own instance of the domimplementation object\nfunction DOMImplementation(contextObject) {\n  this.contextObject = contextObject;\n}\n\n\n// Feature/version pairs that DOMImplementation.hasFeature() returns\n// true for.  It returns false for anything else.\nvar supportedFeatures = {\n  'xml': { '': true, '1.0': true, '2.0': true },   // DOM Core\n  'core': { '': true, '2.0': true },               // DOM Core\n  'html': { '': true, '1.0': true, '2.0': true} ,  // HTML\n  'xhtml': { '': true, '1.0': true, '2.0': true} , // HTML\n};\n\nDOMImplementation.prototype = {\n  hasFeature: function hasFeature(feature, version) {\n    var f = supportedFeatures[(feature || '').toLowerCase()];\n    return (f && f[version || '']) || false;\n  },\n\n  createDocumentType: function createDocumentType(qualifiedName, publicId, systemId) {\n    if (!xml.isValidQName(qualifiedName)) utils.InvalidCharacterError();\n\n    return new DocumentType(this.contextObject, qualifiedName, publicId, systemId);\n  },\n\n  createDocument: function createDocument(namespace, qualifiedName, doctype) {\n    //\n    // Note that the current DOMCore spec makes it impossible to\n    // create an HTML document with this function, even if the\n    // namespace and doctype are propertly set.  See this thread:\n    // http://lists.w3.org/Archives/Public/www-dom/2011AprJun/0132.html\n    //\n    var d = new Document(false, null);\n    var e;\n\n    if (qualifiedName)\n      e = d.createElementNS(namespace, qualifiedName);\n    else\n      e = null;\n\n    if (doctype) {\n      d.appendChild(doctype);\n    }\n\n    if (e) d.appendChild(e);\n    if (namespace === utils.NAMESPACE.HTML) {\n      d._contentType = 'application/xhtml+xml';\n    } else if (namespace === utils.NAMESPACE.SVG) {\n      d._contentType = 'image/svg+xml';\n    } else {\n      d._contentType = 'application/xml';\n    }\n\n    return d;\n  },\n\n  createHTMLDocument: function createHTMLDocument(titleText) {\n    var d = new Document(true, null);\n    d.appendChild(new DocumentType(d, 'html'));\n    var html = d.createElement('html');\n    d.appendChild(html);\n    var head = d.createElement('head');\n    html.appendChild(head);\n    if (titleText !== undefined) {\n      var title = d.createElement('title');\n      head.appendChild(title);\n      title.appendChild(d.createTextNode(titleText));\n    }\n    html.appendChild(d.createElement('body'));\n    d.modclock = 1; // Start tracking modifications\n    return d;\n  },\n\n  mozSetOutputMutationHandler: function(doc, handler) {\n    doc.mutationHandler = handler;\n  },\n\n  mozGetInputMutationHandler: function(doc) {\n    utils.nyi();\n  },\n\n  mozHTMLParser: HTMLParser,\n};\n","\"use strict\";\n// DOMTokenList implementation based on https://github.com/Raynos/DOM-shim\nvar utils = require('./utils');\n\nmodule.exports = DOMTokenList;\n\nfunction DOMTokenList(getter, setter) {\n  this._getString = getter;\n  this._setString = setter;\n  this._length = 0;\n  this._lastStringValue = '';\n  this._update();\n}\n\nObject.defineProperties(DOMTokenList.prototype, {\n  length: { get: function() { return this._length; } },\n  item: { value: function(index) {\n    var list = getList(this);\n    if (index < 0 || index >= list.length) {\n      return null;\n    }\n    return list[index];\n  }},\n\n  contains: { value: function(token) {\n    token = String(token); // no error checking for contains()\n    var list = getList(this);\n    return list.indexOf(token) > -1;\n  }},\n\n  add: { value: function() {\n    var list = getList(this);\n    for (var i = 0, len = arguments.length; i < len; i++) {\n      var token = handleErrors(arguments[i]);\n      if (list.indexOf(token) < 0) {\n        list.push(token);\n      }\n    }\n    // Note: as per spec, if handleErrors() throws any errors, we never\n    // make it here and none of the changes take effect.\n    // Also per spec: we run the \"update steps\" even if no change was\n    // made (ie, if the token already existed)\n    this._update(list);\n  }},\n\n  remove: { value: function() {\n    var list = getList(this);\n    for (var i = 0, len = arguments.length; i < len; i++) {\n      var token = handleErrors(arguments[i]);\n      var index = list.indexOf(token);\n      if (index > -1) {\n        list.splice(index, 1);\n      }\n    }\n    // Note: as per spec, if handleErrors() throws any errors, we never\n    // make it here and none of the changes take effect.\n    // Also per spec: we run the \"update steps\" even if no change was\n    // made (ie, if the token wasn't previously present)\n    this._update(list);\n  }},\n\n  toggle: { value: function toggle(token, force) {\n    token = handleErrors(token);\n    if (this.contains(token)) {\n      if (force === undefined || force === false) {\n        this.remove(token);\n        return false;\n      }\n      return true;\n    } else {\n      if (force === undefined || force === true) {\n        this.add(token);\n        return true;\n      }\n      return false;\n    }\n  }},\n\n  replace: { value: function replace(token, newToken) {\n    // weird corner case of spec: if `token` contains whitespace, but\n    // `newToken` is the empty string, we must throw SyntaxError not\n    // InvalidCharacterError (sigh)\n    if (String(newToken)==='') { utils.SyntaxError(); }\n    token = handleErrors(token);\n    newToken = handleErrors(newToken);\n    var list = getList(this);\n    var idx = list.indexOf(token);\n    if (idx < 0) {\n      // Note that, per spec, we do not run the update steps on this path.\n      return false;\n    }\n    var idx2 = list.indexOf(newToken);\n    if (idx2 < 0) {\n      list[idx] = newToken;\n    } else {\n      // \"replace the first instance of either `token` or `newToken` with\n      // `newToken` and remove all other instances\"\n      if (idx < idx2) {\n        list[idx] = newToken;\n        list.splice(idx2, 1);\n      } else {\n        // idx2 is already `newToken`\n        list.splice(idx, 1);\n      }\n    }\n    this._update(list);\n    return true;\n  }},\n\n  toString: { value: function() {\n    return this._getString();\n  }},\n\n  value: {\n    get: function() {\n      return this._getString();\n    },\n    set: function(v) {\n      this._setString(v);\n      this._update();\n    }\n  },\n\n  // Called when the setter is called from outside this interface.\n  _update: { value: function(list) {\n    if (list) {\n      fixIndex(this, list);\n      this._setString(list.join(\" \").trim());\n    } else {\n      fixIndex(this, getList(this));\n    }\n    this._lastStringValue = this._getString();\n  } },\n});\n\nfunction fixIndex(clist, list) {\n  var oldLength = clist._length;\n  var i;\n  clist._length = list.length;\n  for (i = 0; i < list.length; i++) {\n    clist[i] = list[i];\n  }\n  // Clear/free old entries.\n  for (; i < oldLength; i++) {\n    clist[i] = undefined;\n  }\n}\n\nfunction handleErrors(token) {\n  token = String(token);\n  if (token === \"\") {\n    utils.SyntaxError();\n  }\n  if (/[ \\t\\r\\n\\f]/.test(token)) {\n    utils.InvalidCharacterError();\n  }\n  return token;\n}\n\nfunction toArray(clist) {\n  var length = clist._length;\n  var arr = Array(length);\n  for (var i = 0; i < length; i++) {\n    arr[i] = clist[i];\n  }\n  return arr;\n}\n\nfunction getList(clist) {\n  var strProp = clist._getString();\n  if (strProp === clist._lastStringValue) {\n    return toArray(clist);\n  }\n  var str = strProp.replace(/(^[ \\t\\r\\n\\f]+)|([ \\t\\r\\n\\f]+$)/g, '');\n  if (str === \"\") {\n    return [];\n  } else {\n    var seen = Object.create(null);\n    return str.split(/[ \\t\\r\\n\\f]+/g).filter(function(n) {\n      var key = '$' + n;\n      if (seen[key]) { return false; }\n      seen[key] = true;\n      return true;\n    });\n  }\n}\n","\"use strict\";\nmodule.exports = Document;\n\nvar Node = require('./Node');\nvar NodeList = require('./NodeList');\nvar ContainerNode = require('./ContainerNode');\nvar Element = require('./Element');\nvar Text = require('./Text');\nvar Comment = require('./Comment');\nvar Event = require('./Event');\nvar DocumentFragment = require('./DocumentFragment');\nvar ProcessingInstruction = require('./ProcessingInstruction');\nvar DOMImplementation = require('./DOMImplementation');\nvar TreeWalker = require('./TreeWalker');\nvar NodeIterator = require('./NodeIterator');\nvar NodeFilter = require('./NodeFilter');\nvar URL = require('./URL');\nvar select = require('./select');\nvar events = require('./events');\nvar xml = require('./xmlnames');\nvar html = require('./htmlelts');\nvar svg = require('./svg');\nvar utils = require('./utils');\nvar MUTATE = require('./MutationConstants');\nvar NAMESPACE = utils.NAMESPACE;\nvar isApiWritable = require(\"./config\").isApiWritable;\n\nfunction Document(isHTML, address) {\n  ContainerNode.call(this);\n  this.nodeType = Node.DOCUMENT_NODE;\n  this.isHTML = isHTML;\n  this._address = address || 'about:blank';\n  this.readyState = 'loading';\n  this.implementation = new DOMImplementation(this);\n\n  // DOMCore says that documents are always associated with themselves\n  this.ownerDocument = null; // ... but W3C tests expect null\n  this._contentType = isHTML ? 'text/html' : 'application/xml';\n\n  // These will be initialized by our custom versions of\n  // appendChild and insertBefore that override the inherited\n  // Node methods.\n  // XXX: override those methods!\n  this.doctype = null;\n  this.documentElement = null;\n\n  // \"Associated inert template document\"\n  this._templateDocCache = null;\n  // List of active NodeIterators, see NodeIterator#_preremove()\n  this._nodeIterators = null;\n\n  // Documents are always rooted, by definition\n  this._nid = 1;\n  this._nextnid = 2; // For numbering children of the document\n  this._nodes = [null, this];  // nid to node map\n\n  // This maintains the mapping from element ids to element nodes.\n  // We may need to update this mapping every time a node is rooted\n  // or uprooted, and any time an attribute is added, removed or changed\n  // on a rooted element.\n  this.byId = Object.create(null);\n\n  // This property holds a monotonically increasing value akin to\n  // a timestamp used to record the last modification time of nodes\n  // and their subtrees. See the lastModTime attribute and modify()\n  // method of the Node class. And see FilteredElementList for an example\n  // of the use of lastModTime\n  this.modclock = 0;\n}\n\n// Map from lowercase event category names (used as arguments to\n// createEvent()) to the property name in the impl object of the\n// event constructor.\nvar supportedEvents = {\n  event: 'Event',\n  customevent: 'CustomEvent',\n  uievent: 'UIEvent',\n  mouseevent: 'MouseEvent'\n};\n\n// Certain arguments to document.createEvent() must be treated specially\nvar replacementEvent = {\n  events: 'event',\n  htmlevents: 'event',\n  mouseevents: 'mouseevent',\n  mutationevents: 'mutationevent',\n  uievents: 'uievent'\n};\n\nvar mirrorAttr = function(f, name, defaultValue) {\n  return {\n    get: function() {\n      var o = f.call(this);\n      if (o) { return o[name]; }\n      return defaultValue;\n    },\n    set: function(value) {\n      var o = f.call(this);\n      if (o) { o[name] = value; }\n    },\n  };\n};\n\n/** @spec https://dom.spec.whatwg.org/#validate-and-extract */\nfunction validateAndExtract(namespace, qualifiedName) {\n  var prefix, localName, pos;\n  if (namespace==='') { namespace = null; }\n  // See https://github.com/whatwg/dom/issues/671\n  // and https://github.com/whatwg/dom/issues/319\n  if (!xml.isValidQName(qualifiedName)) {\n    utils.InvalidCharacterError();\n  }\n  prefix = null;\n  localName = qualifiedName;\n\n  pos = qualifiedName.indexOf(':');\n  if (pos >= 0) {\n    prefix = qualifiedName.substring(0, pos);\n    localName = qualifiedName.substring(pos+1);\n  }\n  if (prefix !== null && namespace === null) {\n    utils.NamespaceError();\n  }\n  if (prefix === 'xml' && namespace !== NAMESPACE.XML) {\n    utils.NamespaceError();\n  }\n  if ((prefix === 'xmlns' || qualifiedName === 'xmlns') &&\n      namespace !== NAMESPACE.XMLNS) {\n    utils.NamespaceError();\n  }\n  if (namespace === NAMESPACE.XMLNS && !(prefix==='xmlns' || qualifiedName==='xmlns')) {\n    utils.NamespaceError();\n  }\n  return { namespace: namespace, prefix: prefix, localName: localName };\n}\n\nDocument.prototype = Object.create(ContainerNode.prototype, {\n  // This method allows dom.js to communicate with a renderer\n  // that displays the document in some way\n  // XXX: I should probably move this to the window object\n  _setMutationHandler: { value: function(handler) {\n    this.mutationHandler = handler;\n  }},\n\n  // This method allows dom.js to receive event notifications\n  // from the renderer.\n  // XXX: I should probably move this to the window object\n  _dispatchRendererEvent: { value: function(targetNid, type, details) {\n    var target = this._nodes[targetNid];\n    if (!target) return;\n    target._dispatchEvent(new Event(type, details), true);\n  }},\n\n  nodeName: { value: '#document'},\n  nodeValue: {\n    get: function() {\n      return null;\n    },\n    set: function() {}\n  },\n\n  // XXX: DOMCore may remove documentURI, so it is NYI for now\n  documentURI: { get: function() { return this._address; }, set: utils.nyi },\n  compatMode: { get: function() {\n    // The _quirks property is set by the HTML parser\n    return this._quirks ? 'BackCompat' : 'CSS1Compat';\n  }},\n\n  createTextNode: { value: function(data) {\n    return new Text(this, String(data));\n  }},\n  createComment: { value: function(data) {\n    return new Comment(this, data);\n  }},\n  createDocumentFragment: { value: function() {\n    return new DocumentFragment(this);\n  }},\n  createProcessingInstruction: { value: function(target, data) {\n    if (!xml.isValidName(target) || data.indexOf('?>') !== -1)\n      utils.InvalidCharacterError();\n    return new ProcessingInstruction(this, target, data);\n  }},\n\n  createAttribute: { value: function(localName) {\n    localName = String(localName);\n    if (!xml.isValidName(localName)) utils.InvalidCharacterError();\n    if (this.isHTML) {\n      localName = utils.toASCIILowerCase(localName);\n    }\n    return new Element._Attr(null, localName, null, null, '');\n  }},\n  createAttributeNS: { value: function(namespace, qualifiedName) {\n    // Convert parameter types according to WebIDL\n    namespace =\n      (namespace === null || namespace === undefined || namespace === '') ? null :\n      String(namespace);\n    qualifiedName = String(qualifiedName);\n    var ve = validateAndExtract(namespace, qualifiedName);\n    return new Element._Attr(null, ve.localName, ve.prefix, ve.namespace, '');\n  }},\n\n  createElement: { value: function(localName) {\n    localName = String(localName);\n    if (!xml.isValidName(localName)) utils.InvalidCharacterError();\n    // Per spec, namespace should be HTML namespace if \"context object is\n    // an HTML document or context object's content type is\n    // \"application/xhtml+xml\", and null otherwise.\n    if (this.isHTML) {\n      if (/[A-Z]/.test(localName))\n        localName = utils.toASCIILowerCase(localName);\n      return html.createElement(this, localName, null);\n    } else if (this.contentType === 'application/xhtml+xml') {\n      return html.createElement(this, localName, null);\n    } else {\n      return new Element(this, localName, null, null);\n    }\n  }, writable: isApiWritable },\n\n  createElementNS: { value: function(namespace, qualifiedName) {\n    // Convert parameter types according to WebIDL\n    namespace =\n      (namespace === null || namespace === undefined || namespace === '') ? null :\n      String(namespace);\n    qualifiedName = String(qualifiedName);\n    var ve = validateAndExtract(namespace, qualifiedName);\n    return this._createElementNS(ve.localName, ve.namespace, ve.prefix);\n  }, writable: isApiWritable },\n\n  // This is used directly by HTML parser, which allows it to create\n  // elements with localNames containing ':' and non-default namespaces\n  _createElementNS: { value: function(localName, namespace, prefix) {\n    if (namespace === NAMESPACE.HTML) {\n      return html.createElement(this, localName, prefix);\n    }\n    else if (namespace === NAMESPACE.SVG) {\n      return svg.createElement(this, localName, prefix);\n    }\n\n    return new Element(this, localName, namespace, prefix);\n  }},\n\n  createEvent: { value: function createEvent(interfaceName) {\n    interfaceName = interfaceName.toLowerCase();\n    var name = replacementEvent[interfaceName] || interfaceName;\n    var constructor = events[supportedEvents[name]];\n\n    if (constructor) {\n      var e = new constructor();\n      e._initialized = false;\n      return e;\n    }\n    else {\n      utils.NotSupportedError();\n    }\n  }},\n\n  // See: http://www.w3.org/TR/dom/#dom-document-createtreewalker\n  createTreeWalker: {value: function (root, whatToShow, filter) {\n    if (!root) { throw new TypeError(\"root argument is required\"); }\n    if (!(root instanceof Node)) { throw new TypeError(\"root not a node\"); }\n    whatToShow = whatToShow === undefined ? NodeFilter.SHOW_ALL : (+whatToShow);\n    filter = filter === undefined ? null : filter;\n\n    return new TreeWalker(root, whatToShow, filter);\n  }},\n\n  // See: http://www.w3.org/TR/dom/#dom-document-createnodeiterator\n  createNodeIterator: {value: function (root, whatToShow, filter) {\n    if (!root) { throw new TypeError(\"root argument is required\"); }\n    if (!(root instanceof Node)) { throw new TypeError(\"root not a node\"); }\n    whatToShow = whatToShow === undefined ? NodeFilter.SHOW_ALL : (+whatToShow);\n    filter = filter === undefined ? null : filter;\n\n    return new NodeIterator(root, whatToShow, filter);\n  }},\n\n  _attachNodeIterator: { value: function(ni) {\n    // XXX ideally this should be a weak reference from Document to NodeIterator\n    if (!this._nodeIterators) { this._nodeIterators = []; }\n    this._nodeIterators.push(ni);\n  }},\n\n  _detachNodeIterator: { value: function(ni) {\n    // ni should always be in list of node iterators\n    var idx = this._nodeIterators.indexOf(ni);\n    this._nodeIterators.splice(idx, 1);\n  }},\n\n  _preremoveNodeIterators: { value: function(toBeRemoved) {\n    if (this._nodeIterators) {\n      this._nodeIterators.forEach(function(ni) { ni._preremove(toBeRemoved); });\n    }\n  }},\n\n  // Maintain the documentElement and\n  // doctype properties of the document.  Each of the following\n  // methods chains to the Node implementation of the method\n  // to do the actual inserting, removal or replacement.\n\n  _updateDocTypeElement: { value: function _updateDocTypeElement() {\n    this.doctype = this.documentElement = null;\n    for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {\n      if (kid.nodeType === Node.DOCUMENT_TYPE_NODE)\n        this.doctype = kid;\n      else if (kid.nodeType === Node.ELEMENT_NODE)\n        this.documentElement = kid;\n    }\n  }},\n\n  insertBefore: { value: function insertBefore(child, refChild) {\n    Node.prototype.insertBefore.call(this, child, refChild);\n    this._updateDocTypeElement();\n    return child;\n  }},\n\n  replaceChild: { value: function replaceChild(node, child) {\n    Node.prototype.replaceChild.call(this, node, child);\n    this._updateDocTypeElement();\n    return child;\n  }},\n\n  removeChild: { value: function removeChild(child) {\n    Node.prototype.removeChild.call(this, child);\n    this._updateDocTypeElement();\n    return child;\n  }},\n\n  getElementById: { value: function(id) {\n    var n = this.byId[id];\n    if (!n) return null;\n    if (n instanceof MultiId) { // there was more than one element with this id\n      return n.getFirst();\n    }\n    return n;\n  }},\n\n  _hasMultipleElementsWithId: { value: function(id) {\n    // Used internally by querySelectorAll optimization\n    return (this.byId[id] instanceof MultiId);\n  }},\n\n  // Just copy this method from the Element prototype\n  getElementsByName: { value: Element.prototype.getElementsByName },\n  getElementsByTagName: { value: Element.prototype.getElementsByTagName },\n  getElementsByTagNameNS: { value: Element.prototype.getElementsByTagNameNS },\n  getElementsByClassName: { value: Element.prototype.getElementsByClassName },\n\n  adoptNode: { value: function adoptNode(node) {\n    if (node.nodeType === Node.DOCUMENT_NODE) utils.NotSupportedError();\n    if (node.nodeType === Node.ATTRIBUTE_NODE) { return node; }\n\n    if (node.parentNode) node.parentNode.removeChild(node);\n\n    if (node.ownerDocument !== this)\n      recursivelySetOwner(node, this);\n\n    return node;\n  }},\n\n  importNode: { value: function importNode(node, deep) {\n    return this.adoptNode(node.cloneNode(deep));\n  }, writable: isApiWritable },\n\n  // The following attributes and methods are from the HTML spec\n  origin: { get: function origin() { return null; } },\n  characterSet: { get: function characterSet() { return \"UTF-8\"; } },\n  contentType: { get: function contentType() { return this._contentType; } },\n  URL: { get: function URL() { return this._address; } },\n  domain: { get: utils.nyi, set: utils.nyi },\n  referrer: { get: utils.nyi },\n  cookie: { get: utils.nyi, set: utils.nyi },\n  lastModified: { get: utils.nyi },\n  location: {\n\tget: function() {\n\t  return this.defaultView ? this.defaultView.location : null; // gh #75\n\t},\n\tset: utils.nyi\n  },\n  _titleElement: {\n    get: function() {\n      // The title element of a document is the first title element in the\n      // document in tree order, if there is one, or null otherwise.\n      return this.getElementsByTagName('title').item(0) || null;\n    }\n  },\n  title: {\n    get: function() {\n      var elt = this._titleElement;\n      // The child text content of the title element, or '' if null.\n      var value = elt ? elt.textContent : '';\n      // Strip and collapse whitespace in value\n      return value.replace(/[ \\t\\n\\r\\f]+/g, ' ').replace(/(^ )|( $)/g, '');\n    },\n    set: function(value) {\n      var elt = this._titleElement;\n      var head = this.head;\n      if (!elt && !head) { return; /* according to spec */ }\n      if (!elt) {\n        elt = this.createElement('title');\n        head.appendChild(elt);\n      }\n      elt.textContent = value;\n    }\n  },\n  dir: mirrorAttr(function() {\n    var htmlElement = this.documentElement;\n    if (htmlElement && htmlElement.tagName === 'HTML') { return htmlElement; }\n  }, 'dir', ''),\n  fgColor: mirrorAttr(function() { return this.body; }, 'text', ''),\n  linkColor: mirrorAttr(function() { return this.body; }, 'link', ''),\n  vlinkColor: mirrorAttr(function() { return this.body; }, 'vLink', ''),\n  alinkColor: mirrorAttr(function() { return this.body; }, 'aLink', ''),\n  bgColor: mirrorAttr(function() { return this.body; }, 'bgColor', ''),\n\n  // Historical aliases of Document#characterSet\n  charset: { get: function() { return this.characterSet; } },\n  inputEncoding: { get: function() { return this.characterSet; } },\n\n  scrollingElement: {\n    get: function() {\n      return this._quirks ? this.body : this.documentElement;\n    }\n  },\n\n  // Return the first <body> child of the document element.\n  // XXX For now, setting this attribute is not implemented.\n  body: {\n    get: function() {\n      return namedHTMLChild(this.documentElement, 'body');\n    },\n    set: utils.nyi\n  },\n  // Return the first <head> child of the document element.\n  head: { get: function() {\n    return namedHTMLChild(this.documentElement, 'head');\n  }},\n  images: { get: utils.nyi },\n  embeds: { get: utils.nyi },\n  plugins: { get: utils.nyi },\n  links: { get: utils.nyi },\n  forms: { get: utils.nyi },\n  scripts: { get: utils.nyi },\n  applets: { get: function() { return []; } },\n  activeElement: { get: function() { return null; } },\n  innerHTML: {\n    get: function() { return this.serialize(); },\n    set: utils.nyi\n  },\n  outerHTML: {\n    get: function() { return this.serialize(); },\n    set: utils.nyi\n  },\n\n  write: { value: function(args) {\n    if (!this.isHTML) utils.InvalidStateError();\n\n    // XXX: still have to implement the ignore part\n    if (!this._parser /* && this._ignore_destructive_writes > 0 */ )\n      return;\n\n    if (!this._parser) {\n      // XXX call document.open, etc.\n    }\n\n    var s = arguments.join('');\n\n    // If the Document object's reload override flag is set, then\n    // append the string consisting of the concatenation of all the\n    // arguments to the method to the Document's reload override\n    // buffer.\n    // XXX: don't know what this is about.  Still have to do it\n\n    // If there is no pending parsing-blocking script, have the\n    // tokenizer process the characters that were inserted, one at a\n    // time, processing resulting tokens as they are emitted, and\n    // stopping when the tokenizer reaches the insertion point or when\n    // the processing of the tokenizer is aborted by the tree\n    // construction stage (this can happen if a script end tag token is\n    // emitted by the tokenizer).\n\n    // XXX: still have to do the above. Sounds as if we don't\n    // always call parse() here.  If we're blocked, then we just\n    // insert the text into the stream but don't parse it reentrantly...\n\n    // Invoke the parser reentrantly\n    this._parser.parse(s);\n  }},\n\n  writeln: { value: function writeln(args) {\n    this.write(Array.prototype.join.call(arguments, '') + '\\n');\n  }},\n\n  open: { value: function() {\n    this.documentElement = null;\n  }},\n\n  close: { value: function() {\n    this.readyState = 'interactive';\n    this._dispatchEvent(new Event('readystatechange'), true);\n    this._dispatchEvent(new Event('DOMContentLoaded'), true);\n    this.readyState = 'complete';\n    this._dispatchEvent(new Event('readystatechange'), true);\n    if (this.defaultView) {\n      this.defaultView._dispatchEvent(new Event('load'), true);\n    }\n  }},\n\n  // Utility methods\n  clone: { value: function clone() {\n    var d = new Document(this.isHTML, this._address);\n    d._quirks = this._quirks;\n    d._contentType = this._contentType;\n    return d;\n  }},\n\n  // We need to adopt the nodes if we do a deep clone\n  cloneNode: { value: function cloneNode(deep) {\n    var clone = Node.prototype.cloneNode.call(this, false);\n    if (deep) {\n      for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {\n        clone._appendChild(clone.importNode(kid, true));\n      }\n    }\n    clone._updateDocTypeElement();\n    return clone;\n  }},\n\n  isEqual: { value: function isEqual(n) {\n    // Any two documents are shallowly equal.\n    // Node.isEqualNode will also test the children\n    return true;\n  }},\n\n  // Implementation-specific function.  Called when a text, comment,\n  // or pi value changes.\n  mutateValue: { value: function(node) {\n    if (this.mutationHandler) {\n      this.mutationHandler({\n        type: MUTATE.VALUE,\n        target: node,\n        data: node.data\n      });\n    }\n  }},\n\n  // Invoked when an attribute's value changes. Attr holds the new\n  // value.  oldval is the old value.  Attribute mutations can also\n  // involve changes to the prefix (and therefore the qualified name)\n  mutateAttr: { value: function(attr, oldval) {\n    // Manage id->element mapping for getElementsById()\n    // XXX: this special case id handling should not go here,\n    // but in the attribute declaration for the id attribute\n    /*\n    if (attr.localName === 'id' && attr.namespaceURI === null) {\n      if (oldval) delId(oldval, attr.ownerElement);\n      addId(attr.value, attr.ownerElement);\n    }\n    */\n    if (this.mutationHandler) {\n      this.mutationHandler({\n        type: MUTATE.ATTR,\n        target: attr.ownerElement,\n        attr: attr\n      });\n    }\n  }},\n\n  // Used by removeAttribute and removeAttributeNS for attributes.\n  mutateRemoveAttr: { value: function(attr) {\n/*\n* This is now handled in Attributes.js\n    // Manage id to element mapping\n    if (attr.localName === 'id' && attr.namespaceURI === null) {\n      this.delId(attr.value, attr.ownerElement);\n    }\n*/\n    if (this.mutationHandler) {\n      this.mutationHandler({\n        type: MUTATE.REMOVE_ATTR,\n        target: attr.ownerElement,\n        attr: attr\n      });\n    }\n  }},\n\n  // Called by Node.removeChild, etc. to remove a rooted element from\n  // the tree. Only needs to generate a single mutation event when a\n  // node is removed, but must recursively mark all descendants as not\n  // rooted.\n  mutateRemove: { value: function(node) {\n    // Send a single mutation event\n    if (this.mutationHandler) {\n      this.mutationHandler({\n        type: MUTATE.REMOVE,\n        target: node.parentNode,\n        node: node\n      });\n    }\n\n    // Mark this and all descendants as not rooted\n    recursivelyUproot(node);\n  }},\n\n  // Called when a new element becomes rooted.  It must recursively\n  // generate mutation events for each of the children, and mark them all\n  // as rooted.\n  mutateInsert: { value: function(node) {\n    // Mark node and its descendants as rooted\n    recursivelyRoot(node);\n\n    // Send a single mutation event\n    if (this.mutationHandler) {\n      this.mutationHandler({\n        type: MUTATE.INSERT,\n        target: node.parentNode,\n        node: node\n      });\n    }\n  }},\n\n  // Called when a rooted element is moved within the document\n  mutateMove: { value: function(node) {\n    if (this.mutationHandler) {\n      this.mutationHandler({\n        type: MUTATE.MOVE,\n        target: node\n      });\n    }\n  }},\n\n\n  // Add a mapping from  id to n for n.ownerDocument\n  addId: { value: function addId(id, n) {\n    var val = this.byId[id];\n    if (!val) {\n      this.byId[id] = n;\n    }\n    else {\n      // TODO: Add a way to opt-out console warnings\n      //console.warn('Duplicate element id ' + id);\n      if (!(val instanceof MultiId)) {\n        val = new MultiId(val);\n        this.byId[id] = val;\n      }\n      val.add(n);\n    }\n  }},\n\n  // Delete the mapping from id to n for n.ownerDocument\n  delId: { value: function delId(id, n) {\n    var val = this.byId[id];\n    utils.assert(val);\n\n    if (val instanceof MultiId) {\n      val.del(n);\n      if (val.length === 1) { // convert back to a single node\n        this.byId[id] = val.downgrade();\n      }\n    }\n    else {\n      this.byId[id] = undefined;\n    }\n  }},\n\n  _resolve: { value: function(href) {\n    //XXX: Cache the URL\n    return new URL(this._documentBaseURL).resolve(href);\n  }},\n\n  _documentBaseURL: { get: function() {\n    // XXX: This is not implemented correctly yet\n    var url = this._address;\n    if (url === 'about:blank') url = '/';\n\n    var base = this.querySelector('base[href]');\n    if (base) {\n      return new URL(url).resolve(base.getAttribute('href'));\n    }\n    return url;\n\n    // The document base URL of a Document object is the\n    // absolute URL obtained by running these substeps:\n\n    //     Let fallback base url be the document's address.\n\n    //     If fallback base url is about:blank, and the\n    //     Document's browsing context has a creator browsing\n    //     context, then let fallback base url be the document\n    //     base URL of the creator Document instead.\n\n    //     If the Document is an iframe srcdoc document, then\n    //     let fallback base url be the document base URL of\n    //     the Document's browsing context's browsing context\n    //     container's Document instead.\n\n    //     If there is no base element that has an href\n    //     attribute, then the document base URL is fallback\n    //     base url; abort these steps. Otherwise, let url be\n    //     the value of the href attribute of the first such\n    //     element.\n\n    //     Resolve url relative to fallback base url (thus,\n    //     the base href attribute isn't affected by xml:base\n    //     attributes).\n\n    //     The document base URL is the result of the previous\n    //     step if it was successful; otherwise it is fallback\n    //     base url.\n  }},\n\n  _templateDoc: { get: function() {\n    if (!this._templateDocCache) {\n      // \"associated inert template document\"\n      var newDoc = new Document(this.isHTML, this._address);\n      this._templateDocCache = newDoc._templateDocCache = newDoc;\n    }\n    return this._templateDocCache;\n  }},\n\n  querySelector: { value: function(selector) {\n    return select(selector, this)[0];\n  }},\n\n  querySelectorAll: { value: function(selector) {\n    var nodes = select(selector, this);\n    return nodes.item ? nodes : new NodeList(nodes);\n  }}\n\n});\n\n\nvar eventHandlerTypes = [\n  'abort', 'canplay', 'canplaythrough', 'change', 'click', 'contextmenu',\n  'cuechange', 'dblclick', 'drag', 'dragend', 'dragenter', 'dragleave',\n  'dragover', 'dragstart', 'drop', 'durationchange', 'emptied', 'ended',\n  'input', 'invalid', 'keydown', 'keypress', 'keyup', 'loadeddata',\n  'loadedmetadata', 'loadstart', 'mousedown', 'mousemove', 'mouseout',\n  'mouseover', 'mouseup', 'mousewheel', 'pause', 'play', 'playing',\n  'progress', 'ratechange', 'readystatechange', 'reset', 'seeked',\n  'seeking', 'select', 'show', 'stalled', 'submit', 'suspend',\n  'timeupdate', 'volumechange', 'waiting',\n\n  'blur', 'error', 'focus', 'load', 'scroll'\n];\n\n// Add event handler idl attribute getters and setters to Document\neventHandlerTypes.forEach(function(type) {\n  // Define the event handler registration IDL attribute for this type\n  Object.defineProperty(Document.prototype, 'on' + type, {\n    get: function() {\n      return this._getEventHandler(type);\n    },\n    set: function(v) {\n      this._setEventHandler(type, v);\n    }\n  });\n});\n\nfunction namedHTMLChild(parent, name) {\n  if (parent && parent.isHTML) {\n    for (var kid = parent.firstChild; kid !== null; kid = kid.nextSibling) {\n      if (kid.nodeType === Node.ELEMENT_NODE &&\n        kid.localName === name &&\n        kid.namespaceURI === NAMESPACE.HTML) {\n        return kid;\n      }\n    }\n  }\n  return null;\n}\n\nfunction root(n) {\n  n._nid = n.ownerDocument._nextnid++;\n  n.ownerDocument._nodes[n._nid] = n;\n  // Manage id to element mapping\n  if (n.nodeType === Node.ELEMENT_NODE) {\n    var id = n.getAttribute('id');\n    if (id) n.ownerDocument.addId(id, n);\n\n    // Script elements need to know when they're inserted\n    // into the document\n    if (n._roothook) n._roothook();\n  }\n}\n\nfunction uproot(n) {\n  // Manage id to element mapping\n  if (n.nodeType === Node.ELEMENT_NODE) {\n    var id = n.getAttribute('id');\n    if (id) n.ownerDocument.delId(id, n);\n  }\n  n.ownerDocument._nodes[n._nid] = undefined;\n  n._nid = undefined;\n}\n\nfunction recursivelyRoot(node) {\n  root(node);\n  // XXX:\n  // accessing childNodes on a leaf node creates a new array the\n  // first time, so be careful to write this loop so that it\n  // doesn't do that. node is polymorphic, so maybe this is hard to\n  // optimize?  Try switching on nodeType?\n/*\n  if (node.hasChildNodes()) {\n    var kids = node.childNodes;\n    for(var i = 0, n = kids.length;  i < n; i++)\n      recursivelyRoot(kids[i]);\n  }\n*/\n  if (node.nodeType === Node.ELEMENT_NODE) {\n    for (var kid = node.firstChild; kid !== null; kid = kid.nextSibling)\n      recursivelyRoot(kid);\n  }\n}\n\nfunction recursivelyUproot(node) {\n  uproot(node);\n  for (var kid = node.firstChild; kid !== null; kid = kid.nextSibling)\n      recursivelyUproot(kid);\n}\n\nfunction recursivelySetOwner(node, owner) {\n  node.ownerDocument = owner;\n  node._lastModTime = undefined; // mod times are document-based\n  if (Object.prototype.hasOwnProperty.call(node, '_tagName')) {\n    node._tagName = undefined; // Element subclasses might need to change case\n  }\n  for (var kid = node.firstChild; kid !== null; kid = kid.nextSibling)\n    recursivelySetOwner(kid, owner);\n}\n\n// A class for storing multiple nodes with the same ID\nfunction MultiId(node) {\n  this.nodes = Object.create(null);\n  this.nodes[node._nid] = node;\n  this.length = 1;\n  this.firstNode = undefined;\n}\n\n// Add a node to the list, with O(1) time\nMultiId.prototype.add = function(node) {\n  if (!this.nodes[node._nid]) {\n    this.nodes[node._nid] = node;\n    this.length++;\n    this.firstNode = undefined;\n  }\n};\n\n// Remove a node from the list, with O(1) time\nMultiId.prototype.del = function(node) {\n  if (this.nodes[node._nid]) {\n    delete this.nodes[node._nid];\n    this.length--;\n    this.firstNode = undefined;\n  }\n};\n\n// Get the first node from the list, in the document order\n// Takes O(N) time in the size of the list, with a cache that is invalidated\n// when the list is modified.\nMultiId.prototype.getFirst = function() {\n  /* jshint bitwise: false */\n  if (!this.firstNode) {\n    var nid;\n    for (nid in this.nodes) {\n      if (this.firstNode === undefined ||\n        this.firstNode.compareDocumentPosition(this.nodes[nid]) & Node.DOCUMENT_POSITION_PRECEDING) {\n        this.firstNode = this.nodes[nid];\n      }\n    }\n  }\n  return this.firstNode;\n};\n\n// If there is only one node left, return it. Otherwise return \"this\".\nMultiId.prototype.downgrade = function() {\n  if (this.length === 1) {\n    var nid;\n    for (nid in this.nodes) {\n      return this.nodes[nid];\n    }\n  }\n  return this;\n};\n","\"use strict\";\nmodule.exports =  DocumentFragment;\n\nvar Node = require('./Node');\nvar NodeList = require('./NodeList');\nvar ContainerNode = require('./ContainerNode');\nvar Element = require('./Element');\nvar select = require('./select');\nvar utils = require('./utils');\n\nfunction DocumentFragment(doc) {\n  ContainerNode.call(this);\n  this.nodeType = Node.DOCUMENT_FRAGMENT_NODE;\n  this.ownerDocument = doc;\n}\n\nDocumentFragment.prototype = Object.create(ContainerNode.prototype, {\n  nodeName: { value: '#document-fragment' },\n  nodeValue: { \n    get: function() { \n      return null;\n    },\n    set: function() {}\n  },\n  // Copy the text content getter/setter from Element\n  textContent: Object.getOwnPropertyDescriptor(Element.prototype, 'textContent'),\n\n  querySelector: { value: function(selector) {\n    // implement in terms of querySelectorAll\n    var nodes = this.querySelectorAll(selector);\n    return nodes.length ? nodes[0] : null;\n  }},\n  querySelectorAll: { value: function(selector) {\n    // create a context\n    var context = Object.create(this);\n    // add some methods to the context for zest implementation, without\n    // adding them to the public DocumentFragment API\n    context.isHTML = true; // in HTML namespace (case-insensitive match)\n    context.getElementsByTagName = Element.prototype.getElementsByTagName;\n    context.nextElement =\n      Object.getOwnPropertyDescriptor(Element.prototype, 'firstElementChild').\n      get;\n    // invoke zest\n    var nodes = select(selector, context);\n    return nodes.item ? nodes : new NodeList(nodes);\n  }},\n\n  // Utility methods\n  clone: { value: function clone() {\n      return new DocumentFragment(this.ownerDocument);\n  }},\n  isEqual: { value: function isEqual(n) {\n      // Any two document fragments are shallowly equal.\n      // Node.isEqualNode() will test their children for equality\n      return true;\n  }},\n\n  // Non-standard, but useful (github issue #73)\n  innerHTML: {\n    get: function() { return this.serialize(); },\n    set: utils.nyi\n  },\n  outerHTML: {\n    get: function() { return this.serialize(); },\n    set: utils.nyi\n  },\n\n});\n","\"use strict\";\nmodule.exports = DocumentType;\n\nvar Node = require('./Node');\nvar Leaf = require('./Leaf');\nvar ChildNode = require('./ChildNode');\n\nfunction DocumentType(ownerDocument, name, publicId, systemId) {\n  Leaf.call(this);\n  this.nodeType = Node.DOCUMENT_TYPE_NODE;\n  this.ownerDocument = ownerDocument || null;\n  this.name = name;\n  this.publicId = publicId || \"\";\n  this.systemId = systemId || \"\";\n}\n\nDocumentType.prototype = Object.create(Leaf.prototype, {\n  nodeName: { get: function() { return this.name; }},\n  nodeValue: {\n    get: function() { return null; },\n    set: function() {}\n  },\n\n  // Utility methods\n  clone: { value: function clone() {\n    return new DocumentType(this.ownerDocument, this.name, this.publicId, this.systemId);\n  }},\n\n  isEqual: { value: function isEqual(n) {\n    return this.name === n.name &&\n      this.publicId === n.publicId &&\n      this.systemId === n.systemId;\n  }}\n});\n\nObject.defineProperties(DocumentType.prototype, ChildNode);\n","\"use strict\";\nmodule.exports = Element;\n\nvar xml = require('./xmlnames');\nvar utils = require('./utils');\nvar NAMESPACE = utils.NAMESPACE;\nvar attributes = require('./attributes');\nvar Node = require('./Node');\nvar NodeList = require('./NodeList');\nvar NodeUtils = require('./NodeUtils');\nvar FilteredElementList = require('./FilteredElementList');\nvar DOMException = require('./DOMException');\nvar DOMTokenList = require('./DOMTokenList');\nvar select = require('./select');\nvar ContainerNode = require('./ContainerNode');\nvar ChildNode = require('./ChildNode');\nvar NonDocumentTypeChildNode = require('./NonDocumentTypeChildNode');\nvar NamedNodeMap = require('./NamedNodeMap');\n\nvar uppercaseCache = Object.create(null);\n\nfunction Element(doc, localName, namespaceURI, prefix) {\n  ContainerNode.call(this);\n  this.nodeType = Node.ELEMENT_NODE;\n  this.ownerDocument = doc;\n  this.localName = localName;\n  this.namespaceURI = namespaceURI;\n  this.prefix = prefix;\n  this._tagName = undefined;\n\n  // These properties maintain the set of attributes\n  this._attrsByQName = Object.create(null); // The qname->Attr map\n  this._attrsByLName = Object.create(null); // The ns|lname->Attr map\n  this._attrKeys = [];     // attr index -> ns|lname\n}\n\nfunction recursiveGetText(node, a) {\n  if (node.nodeType === Node.TEXT_NODE) {\n    a.push(node._data);\n  }\n  else {\n    for(var i = 0, n = node.childNodes.length;  i < n; i++)\n      recursiveGetText(node.childNodes[i], a);\n  }\n}\n\nElement.prototype = Object.create(ContainerNode.prototype, {\n  isHTML: { get: function isHTML() {\n    return this.namespaceURI === NAMESPACE.HTML && this.ownerDocument.isHTML;\n  }},\n  tagName: { get: function tagName() {\n    if (this._tagName === undefined) {\n      var tn;\n      if (this.prefix === null) {\n        tn = this.localName;\n      } else {\n        tn = this.prefix + ':' + this.localName;\n      }\n      if (this.isHTML) {\n        var up = uppercaseCache[tn];\n        if (!up) {\n          // Converting to uppercase can be slow, so cache the conversion.\n          uppercaseCache[tn] = up = utils.toASCIIUpperCase(tn);\n        }\n        tn = up;\n      }\n      this._tagName = tn;\n    }\n    return this._tagName;\n  }},\n  nodeName: { get: function() { return this.tagName; }},\n  nodeValue: {\n    get: function() {\n      return null;\n    },\n    set: function() {}\n  },\n  textContent: {\n    get: function() {\n      var strings = [];\n      recursiveGetText(this, strings);\n      return strings.join('');\n    },\n    set: function(newtext) {\n      this.removeChildren();\n      if (newtext !== null && newtext !== undefined && newtext !== '') {\n        this._appendChild(this.ownerDocument.createTextNode(newtext));\n      }\n    }\n  },\n  innerHTML: {\n    get: function() {\n      return this.serialize();\n    },\n    set: utils.nyi\n  },\n  outerHTML: {\n    get: function() {\n      // \"the attribute must return the result of running the HTML fragment\n      // serialization algorithm on a fictional node whose only child is\n      // the context object\"\n      //\n      // The serialization logic is intentionally implemented in a separate\n      // `NodeUtils` helper instead of the more obvious choice of a private\n      // `_serializeOne()` method on the `Node.prototype` in order to avoid\n      // the megamorphic `this._serializeOne` property access, which reduces\n      // performance unnecessarily. If you need specialized behavior for a\n      // certain subclass, you'll need to implement that in `NodeUtils`.\n      // See https://github.com/fgnass/domino/pull/142 for more information.\n      return NodeUtils.serializeOne(this, { nodeType: 0 });\n    },\n    set: function(v) {\n      var document = this.ownerDocument;\n      var parent = this.parentNode;\n      if (parent === null) { return; }\n      if (parent.nodeType === Node.DOCUMENT_NODE) {\n        utils.NoModificationAllowedError();\n      }\n      if (parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n        parent = parent.ownerDocument.createElement(\"body\");\n      }\n      var parser = document.implementation.mozHTMLParser(\n        document._address,\n        parent\n      );\n      parser.parse(v===null?'':String(v), true);\n      this.replaceWith(parser._asDocumentFragment());\n    },\n  },\n\n  _insertAdjacent: { value: function _insertAdjacent(position, node) {\n    var first = false;\n    switch(position) {\n    case 'beforebegin':\n      first = true;\n      /* falls through */\n    case 'afterend':\n      var parent = this.parentNode;\n      if (parent === null) { return null; }\n      return parent.insertBefore(node, first ? this : this.nextSibling);\n    case 'afterbegin':\n      first = true;\n      /* falls through */\n    case 'beforeend':\n      return this.insertBefore(node, first ? this.firstChild : null);\n    default:\n      return utils.SyntaxError();\n    }\n  }},\n\n  insertAdjacentElement: { value: function insertAdjacentElement(position, element) {\n    if (element.nodeType !== Node.ELEMENT_NODE) {\n      throw new TypeError('not an element');\n    }\n    position = utils.toASCIILowerCase(String(position));\n    return this._insertAdjacent(position, element);\n  }},\n\n  insertAdjacentText: { value: function insertAdjacentText(position, data) {\n    var textNode = this.ownerDocument.createTextNode(data);\n    position = utils.toASCIILowerCase(String(position));\n    this._insertAdjacent(position, textNode);\n    // \"This method returns nothing because it existed before we had a chance\n    // to design it.\"\n  }},\n\n  insertAdjacentHTML: { value: function insertAdjacentHTML(position, text) {\n    position = utils.toASCIILowerCase(String(position));\n    text = String(text);\n    var context;\n    switch(position) {\n    case 'beforebegin':\n    case 'afterend':\n      context = this.parentNode;\n      if (context === null || context.nodeType === Node.DOCUMENT_NODE) {\n        utils.NoModificationAllowedError();\n      }\n      break;\n    case 'afterbegin':\n    case 'beforeend':\n      context = this;\n      break;\n    default:\n      utils.SyntaxError();\n    }\n    if ( (!(context instanceof Element)) || (\n      context.ownerDocument.isHTML &&\n      context.localName === 'html' &&\n      context.namespaceURI === NAMESPACE.HTML\n    ) ) {\n      context = context.ownerDocument.createElementNS(NAMESPACE.HTML, 'body');\n    }\n    var parser = this.ownerDocument.implementation.mozHTMLParser(\n      this.ownerDocument._address, context\n    );\n    parser.parse(text, true);\n    this._insertAdjacent(position, parser._asDocumentFragment());\n  }},\n\n  children: { get: function() {\n    if (!this._children) {\n      this._children = new ChildrenCollection(this);\n    }\n    return this._children;\n  }},\n\n  attributes: { get: function() {\n    if (!this._attributes) {\n      this._attributes = new AttributesArray(this);\n    }\n    return this._attributes;\n  }},\n\n\n  firstElementChild: { get: function() {\n    for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {\n      if (kid.nodeType === Node.ELEMENT_NODE) return kid;\n    }\n    return null;\n  }},\n\n  lastElementChild: { get: function() {\n    for (var kid = this.lastChild; kid !== null; kid = kid.previousSibling) {\n      if (kid.nodeType === Node.ELEMENT_NODE) return kid;\n    }\n    return null;\n  }},\n\n  childElementCount: { get: function() {\n    return this.children.length;\n  }},\n\n\n  // Return the next element, in source order, after this one or\n  // null if there are no more.  If root element is specified,\n  // then don't traverse beyond its subtree.\n  //\n  // This is not a DOM method, but is convenient for\n  // lazy traversals of the tree.\n  nextElement: { value: function(root) {\n    if (!root) root = this.ownerDocument.documentElement;\n    var next = this.firstElementChild;\n    if (!next) {\n      // don't use sibling if we're at root\n      if (this===root) return null;\n      next = this.nextElementSibling;\n    }\n    if (next) return next;\n\n    // If we can't go down or across, then we have to go up\n    // and across to the parent sibling or another ancestor's\n    // sibling.  Be careful, though: if we reach the root\n    // element, or if we reach the documentElement, then\n    // the traversal ends.\n    for(var parent = this.parentElement;\n      parent && parent !== root;\n      parent = parent.parentElement) {\n\n      next = parent.nextElementSibling;\n      if (next) return next;\n    }\n\n    return null;\n  }},\n\n  // XXX:\n  // Tests are currently failing for this function.\n  // Awaiting resolution of:\n  // http://lists.w3.org/Archives/Public/www-dom/2011JulSep/0016.html\n  getElementsByTagName: { value: function getElementsByTagName(lname) {\n    var filter;\n    if (!lname) return new NodeList();\n    if (lname === '*')\n      filter = function() { return true; };\n    else if (this.isHTML)\n      filter = htmlLocalNameElementFilter(lname);\n    else\n      filter = localNameElementFilter(lname);\n\n    return new FilteredElementList(this, filter);\n  }},\n\n  getElementsByTagNameNS: { value: function getElementsByTagNameNS(ns, lname){\n    var filter;\n    if (ns === '*' && lname === '*')\n      filter = function() { return true; };\n    else if (ns === '*')\n      filter = localNameElementFilter(lname);\n    else if (lname === '*')\n      filter = namespaceElementFilter(ns);\n    else\n      filter = namespaceLocalNameElementFilter(ns, lname);\n\n    return new FilteredElementList(this, filter);\n  }},\n\n  getElementsByClassName: { value: function getElementsByClassName(names){\n    names = String(names).trim();\n    if (names === '') {\n      var result = new NodeList(); // Empty node list\n      return result;\n    }\n    names = names.split(/[ \\t\\r\\n\\f]+/);  // Split on ASCII whitespace\n    return new FilteredElementList(this, classNamesElementFilter(names));\n  }},\n\n  getElementsByName: { value: function getElementsByName(name) {\n    return new FilteredElementList(this, elementNameFilter(String(name)));\n  }},\n\n  // Utility methods used by the public API methods above\n  clone: { value: function clone() {\n    var e;\n\n    // XXX:\n    // Modify this to use the constructor directly or\n    // avoid error checking in some other way. In case we try\n    // to clone an invalid node that the parser inserted.\n    //\n    if (this.namespaceURI !== NAMESPACE.HTML || this.prefix || !this.ownerDocument.isHTML) {\n      e = this.ownerDocument.createElementNS(\n        this.namespaceURI, (this.prefix !== null) ?\n          (this.prefix + ':' + this.localName) : this.localName\n      );\n    } else {\n      e = this.ownerDocument.createElement(this.localName);\n    }\n\n    for(var i = 0, n = this._attrKeys.length; i < n; i++) {\n      var lname = this._attrKeys[i];\n      var a = this._attrsByLName[lname];\n      var b = a.cloneNode();\n      b._setOwnerElement(e);\n      e._attrsByLName[lname] = b;\n      e._addQName(b);\n    }\n    e._attrKeys = this._attrKeys.concat();\n\n    return e;\n  }},\n\n  isEqual: { value: function isEqual(that) {\n    if (this.localName !== that.localName ||\n      this.namespaceURI !== that.namespaceURI ||\n      this.prefix !== that.prefix ||\n      this._numattrs !== that._numattrs)\n      return false;\n\n    // Compare the sets of attributes, ignoring order\n    // and ignoring attribute prefixes.\n    for(var i = 0, n = this._numattrs; i < n; i++) {\n      var a = this._attr(i);\n      if (!that.hasAttributeNS(a.namespaceURI, a.localName))\n        return false;\n      if (that.getAttributeNS(a.namespaceURI,a.localName) !== a.value)\n        return false;\n    }\n\n    return true;\n  }},\n\n  // This is the 'locate a namespace prefix' algorithm from the\n  // DOM specification.  It is used by Node.lookupPrefix()\n  // (Be sure to compare DOM3 and DOM4 versions of spec.)\n  _lookupNamespacePrefix: { value: function _lookupNamespacePrefix(ns, originalElement) {\n    if (\n      this.namespaceURI &&\n      this.namespaceURI === ns &&\n      this.prefix !== null &&\n      originalElement.lookupNamespaceURI(this.prefix) === ns\n    ) {\n      return this.prefix;\n    }\n\n    for(var i = 0, n = this._numattrs; i < n; i++) {\n      var a = this._attr(i);\n      if (\n        a.prefix === 'xmlns' &&\n        a.value === ns &&\n        originalElement.lookupNamespaceURI(a.localName) === ns\n      ) {\n        return a.localName;\n      }\n    }\n\n    var parent = this.parentElement;\n    return parent ? parent._lookupNamespacePrefix(ns, originalElement) : null;\n  }},\n\n  // This is the 'locate a namespace' algorithm for Element nodes\n  // from the DOM Core spec.  It is used by Node#lookupNamespaceURI()\n  lookupNamespaceURI: { value: function lookupNamespaceURI(prefix) {\n    if (prefix === '' || prefix === undefined) { prefix = null; }\n    if (this.namespaceURI !== null && this.prefix === prefix)\n      return this.namespaceURI;\n\n    for(var i = 0, n = this._numattrs; i < n; i++) {\n      var a = this._attr(i);\n      if (a.namespaceURI === NAMESPACE.XMLNS) {\n        if (\n          (a.prefix === 'xmlns' && a.localName === prefix) ||\n          (prefix === null && a.prefix === null && a.localName === 'xmlns')\n        ) {\n          return a.value || null;\n        }\n      }\n    }\n\n    var parent = this.parentElement;\n    return parent ? parent.lookupNamespaceURI(prefix) : null;\n  }},\n\n  //\n  // Attribute handling methods and utilities\n  //\n\n  /*\n   * Attributes in the DOM are tricky:\n   *\n   * - there are the 8 basic get/set/has/removeAttribute{NS} methods\n   *\n   * - but many HTML attributes are also 'reflected' through IDL\n   *   attributes which means that they can be queried and set through\n   *   regular properties of the element.  There is just one attribute\n   *   value, but two ways to get and set it.\n   *\n   * - Different HTML element types have different sets of reflected\n     attributes.\n   *\n   * - attributes can also be queried and set through the .attributes\n   *   property of an element.  This property behaves like an array of\n   *   Attr objects.  The value property of each Attr is writeable, so\n   *   this is a third way to read and write attributes.\n   *\n   * - for efficiency, we really want to store attributes in some kind\n   *   of name->attr map.  But the attributes[] array is an array, not a\n   *   map, which is kind of unnatural.\n   *\n   * - When using namespaces and prefixes, and mixing the NS methods\n   *   with the non-NS methods, it is apparently actually possible for\n   *   an attributes[] array to have more than one attribute with the\n   *   same qualified name.  And certain methods must operate on only\n   *   the first attribute with such a name.  So for these methods, an\n   *   inefficient array-like data structure would be easier to\n   *   implement.\n   *\n   * - The attributes[] array is live, not a snapshot, so changes to the\n   *   attributes must be immediately visible through existing arrays.\n   *\n   * - When attributes are queried and set through IDL properties\n   *   (instead of the get/setAttributes() method or the attributes[]\n   *   array) they may be subject to type conversions, URL\n   *   normalization, etc., so some extra processing is required in that\n   *   case.\n   *\n   * - But access through IDL properties is probably the most common\n   *   case, so we'd like that to be as fast as possible.\n   *\n   * - We can't just store attribute values in their parsed idl form,\n   *   because setAttribute() has to return whatever string is passed to\n   *   getAttribute even if it is not a legal, parseable value. So\n   *   attribute values must be stored in unparsed string form.\n   *\n   * - We need to be able to send change notifications or mutation\n   *   events of some sort to the renderer whenever an attribute value\n   *   changes, regardless of the way in which it changes.\n   *\n   * - Some attributes, such as id and class affect other parts of the\n   *   DOM API, like getElementById and getElementsByClassName and so\n   *   for efficiency, we need to specially track changes to these\n   *   special attributes.\n   *\n   * - Some attributes like class have different names (className) when\n   *   reflected.\n   *\n   * - Attributes whose names begin with the string 'data-' are treated\n     specially.\n   *\n   * - Reflected attributes that have a boolean type in IDL have special\n   *   behavior: setting them to false (in IDL) is the same as removing\n   *   them with removeAttribute()\n   *\n   * - numeric attributes (like HTMLElement.tabIndex) can have default\n   *   values that must be returned by the idl getter even if the\n   *   content attribute does not exist. (The default tabIndex value\n   *   actually varies based on the type of the element, so that is a\n   *   tricky one).\n   *\n   * See\n   * http://www.whatwg.org/specs/web-apps/current-work/multipage/urls.html#reflect\n   * for rules on how attributes are reflected.\n   *\n   */\n\n  getAttribute: { value: function getAttribute(qname) {\n    var attr = this.getAttributeNode(qname);\n    return attr ? attr.value : null;\n  }},\n\n  getAttributeNS: { value: function getAttributeNS(ns, lname) {\n    var attr = this.getAttributeNodeNS(ns, lname);\n    return attr ? attr.value : null;\n  }},\n\n  getAttributeNode: { value: function getAttributeNode(qname) {\n    qname = String(qname);\n    if (/[A-Z]/.test(qname) && this.isHTML)\n      qname = utils.toASCIILowerCase(qname);\n    var attr = this._attrsByQName[qname];\n    if (!attr) return null;\n\n    if (Array.isArray(attr))  // If there is more than one\n      attr = attr[0];         // use the first\n\n    return attr;\n  }},\n\n  getAttributeNodeNS: { value: function getAttributeNodeNS(ns, lname) {\n    ns = (ns === undefined || ns === null) ? '' : String(ns);\n    lname = String(lname);\n    var attr = this._attrsByLName[ns + '|' + lname];\n    return attr ? attr : null;\n  }},\n\n  hasAttribute: { value: function hasAttribute(qname) {\n    qname = String(qname);\n    if (/[A-Z]/.test(qname) && this.isHTML)\n      qname = utils.toASCIILowerCase(qname);\n    return this._attrsByQName[qname] !== undefined;\n  }},\n\n  hasAttributeNS: { value: function hasAttributeNS(ns, lname) {\n    ns = (ns === undefined || ns === null) ? '' : String(ns);\n    lname = String(lname);\n    var key = ns + '|' + lname;\n    return this._attrsByLName[key] !== undefined;\n  }},\n\n  hasAttributes: { value: function hasAttributes() {\n    return this._numattrs > 0;\n  }},\n\n  toggleAttribute: { value: function toggleAttribute(qname, force) {\n    qname = String(qname);\n    if (!xml.isValidName(qname)) utils.InvalidCharacterError();\n    if (/[A-Z]/.test(qname) && this.isHTML)\n      qname = utils.toASCIILowerCase(qname);\n    var a = this._attrsByQName[qname];\n    if (a === undefined) {\n      if (force === undefined || force === true) {\n        this._setAttribute(qname, '');\n        return true;\n      }\n      return false;\n    } else {\n      if (force === undefined || force === false) {\n        this.removeAttribute(qname);\n        return false;\n      }\n      return true;\n    }\n  }},\n\n  // Set the attribute without error checking. The parser uses this.\n  _setAttribute: { value: function _setAttribute(qname, value) {\n    // XXX: the spec says that this next search should be done\n    // on the local name, but I think that is an error.\n    // email pending on www-dom about it.\n    var attr = this._attrsByQName[qname];\n    var isnew;\n    if (!attr) {\n      attr = this._newattr(qname);\n      isnew = true;\n    }\n    else {\n      if (Array.isArray(attr)) attr = attr[0];\n    }\n\n    // Now set the attribute value on the new or existing Attr object.\n    // The Attr.value setter method handles mutation events, etc.\n    attr.value = value;\n    if (this._attributes) this._attributes[qname] = attr;\n    if (isnew && this._newattrhook) this._newattrhook(qname, value);\n  }},\n\n  // Check for errors, and then set the attribute\n  setAttribute: { value: function setAttribute(qname, value) {\n    qname = String(qname);\n    if (!xml.isValidName(qname)) utils.InvalidCharacterError();\n    if (/[A-Z]/.test(qname) && this.isHTML)\n      qname = utils.toASCIILowerCase(qname);\n    this._setAttribute(qname, String(value));\n  }},\n\n\n  // The version with no error checking used by the parser\n  _setAttributeNS: { value: function _setAttributeNS(ns, qname, value) {\n    var pos = qname.indexOf(':'), prefix, lname;\n    if (pos < 0) {\n      prefix = null;\n      lname = qname;\n    }\n    else {\n      prefix = qname.substring(0, pos);\n      lname = qname.substring(pos+1);\n    }\n\n    if (ns === '' || ns === undefined) ns = null;\n    var key = (ns === null ? '' : ns) + '|' + lname;\n\n    var attr = this._attrsByLName[key];\n    var isnew;\n    if (!attr) {\n      attr = new Attr(this, lname, prefix, ns);\n      isnew = true;\n      this._attrsByLName[key] = attr;\n      if (this._attributes) {\n        this._attributes[this._attrKeys.length] = attr;\n      }\n      this._attrKeys.push(key);\n\n      // We also have to make the attr searchable by qname.\n      // But we have to be careful because there may already\n      // be an attr with this qname.\n      this._addQName(attr);\n    }\n    else if (false /* changed in DOM 4 */) {\n      // Calling setAttributeNS() can change the prefix of an\n      // existing attribute in DOM 2/3.\n      if (attr.prefix !== prefix) {\n        // Unbind the old qname\n        this._removeQName(attr);\n        // Update the prefix\n        attr.prefix = prefix;\n        // Bind the new qname\n        this._addQName(attr);\n      }\n\n    }\n    attr.value = value; // Automatically sends mutation event\n    if (isnew && this._newattrhook) this._newattrhook(qname, value);\n  }},\n\n  // Do error checking then call _setAttributeNS\n  setAttributeNS: { value: function setAttributeNS(ns, qname, value) {\n    // Convert parameter types according to WebIDL\n    ns = (ns === null || ns === undefined || ns === '') ? null : String(ns);\n    qname = String(qname);\n    if (!xml.isValidQName(qname)) utils.InvalidCharacterError();\n\n    var pos = qname.indexOf(':');\n    var prefix = (pos < 0) ? null : qname.substring(0, pos);\n\n    if ((prefix !== null && ns === null) ||\n      (prefix === 'xml' && ns !== NAMESPACE.XML) ||\n      ((qname === 'xmlns' || prefix === 'xmlns') &&\n       (ns !== NAMESPACE.XMLNS)) ||\n      (ns === NAMESPACE.XMLNS &&\n       !(qname === 'xmlns' || prefix === 'xmlns')))\n      utils.NamespaceError();\n\n    this._setAttributeNS(ns, qname, String(value));\n  }},\n\n  setAttributeNode: { value: function setAttributeNode(attr) {\n    if (attr.ownerElement !== null && attr.ownerElement !== this) {\n      throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);\n    }\n    var result = null;\n    var oldAttrs = this._attrsByQName[attr.name];\n    if (oldAttrs) {\n      if (!Array.isArray(oldAttrs)) { oldAttrs = [ oldAttrs ]; }\n      if (oldAttrs.some(function(a) { return a===attr; })) {\n        return attr;\n      } else if (attr.ownerElement !== null) {\n        throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);\n      }\n      oldAttrs.forEach(function(a) { this.removeAttributeNode(a); }, this);\n      result = oldAttrs[0];\n    }\n    this.setAttributeNodeNS(attr);\n    return result;\n  }},\n\n  setAttributeNodeNS: { value: function setAttributeNodeNS(attr) {\n    if (attr.ownerElement !== null) {\n      throw new DOMException(DOMException.INUSE_ATTRIBUTE_ERR);\n    }\n    var ns = attr.namespaceURI;\n    var key = (ns === null ? '' : ns) + '|' + attr.localName;\n    var oldAttr = this._attrsByLName[key];\n    if (oldAttr) { this.removeAttributeNode(oldAttr); }\n    attr._setOwnerElement(this);\n    this._attrsByLName[key] = attr;\n    if (this._attributes) {\n      this._attributes[this._attrKeys.length] = attr;\n    }\n    this._attrKeys.push(key);\n    this._addQName(attr);\n    if (this._newattrhook) this._newattrhook(attr.name, attr.value);\n    return oldAttr || null;\n  }},\n\n  removeAttribute: { value: function removeAttribute(qname) {\n    qname = String(qname);\n    if (/[A-Z]/.test(qname) && this.isHTML)\n      qname = utils.toASCIILowerCase(qname);\n\n    var attr = this._attrsByQName[qname];\n    if (!attr) return;\n\n    // If there is more than one match for this qname\n    // so don't delete the qname mapping, just remove the first\n    // element from it.\n    if (Array.isArray(attr)) {\n      if (attr.length > 2) {\n        attr = attr.shift();  // remove it from the array\n      }\n      else {\n        this._attrsByQName[qname] = attr[1];\n        attr = attr[0];\n      }\n    }\n    else {\n      // only a single match, so remove the qname mapping\n      this._attrsByQName[qname] = undefined;\n    }\n\n    var ns = attr.namespaceURI;\n    // Now attr is the removed attribute.  Figure out its\n    // ns+lname key and remove it from the other mapping as well.\n    var key = (ns === null ? '' : ns) + '|' + attr.localName;\n    this._attrsByLName[key] = undefined;\n\n    var i = this._attrKeys.indexOf(key);\n    if (this._attributes) {\n      Array.prototype.splice.call(this._attributes, i, 1);\n      this._attributes[qname] = undefined;\n    }\n    this._attrKeys.splice(i, 1);\n\n    // Onchange handler for the attribute\n    var onchange = attr.onchange;\n    attr._setOwnerElement(null);\n    if (onchange) {\n      onchange.call(attr, this, attr.localName, attr.value, null);\n    }\n    // Mutation event\n    if (this.rooted) this.ownerDocument.mutateRemoveAttr(attr);\n  }},\n\n  removeAttributeNS: { value: function removeAttributeNS(ns, lname) {\n    ns = (ns === undefined || ns === null) ? '' : String(ns);\n    lname = String(lname);\n    var key = ns + '|' + lname;\n    var attr = this._attrsByLName[key];\n    if (!attr) return;\n\n    this._attrsByLName[key] = undefined;\n\n    var i = this._attrKeys.indexOf(key);\n    if (this._attributes) {\n      Array.prototype.splice.call(this._attributes, i, 1);\n    }\n    this._attrKeys.splice(i, 1);\n\n    // Now find the same Attr object in the qname mapping and remove it\n    // But be careful because there may be more than one match.\n    this._removeQName(attr);\n\n    // Onchange handler for the attribute\n    var onchange = attr.onchange;\n    attr._setOwnerElement(null);\n    if (onchange) {\n      onchange.call(attr, this, attr.localName, attr.value, null);\n    }\n    // Mutation event\n    if (this.rooted) this.ownerDocument.mutateRemoveAttr(attr);\n  }},\n\n  removeAttributeNode: { value: function removeAttributeNode(attr) {\n    var ns = attr.namespaceURI;\n    var key = (ns === null ? '' : ns) + '|' + attr.localName;\n    if (this._attrsByLName[key] !== attr) {\n      utils.NotFoundError();\n    }\n    this.removeAttributeNS(ns, attr.localName);\n    return attr;\n  }},\n\n  getAttributeNames: { value: function getAttributeNames() {\n    var elt = this;\n    return this._attrKeys.map(function(key) {\n      return elt._attrsByLName[key].name;\n    });\n  }},\n\n  // This 'raw' version of getAttribute is used by the getter functions\n  // of reflected attributes. It skips some error checking and\n  // namespace steps\n  _getattr: { value: function _getattr(qname) {\n    // Assume that qname is already lowercased, so don't do it here.\n    // Also don't check whether attr is an array: a qname with no\n    // prefix will never have two matching Attr objects (because\n    // setAttributeNS doesn't allow a non-null namespace with a\n    // null prefix.\n    var attr = this._attrsByQName[qname];\n    return attr ? attr.value : null;\n  }},\n\n  // The raw version of setAttribute for reflected idl attributes.\n  _setattr: { value: function _setattr(qname, value) {\n    var attr = this._attrsByQName[qname];\n    var isnew;\n    if (!attr) {\n      attr = this._newattr(qname);\n      isnew = true;\n    }\n    attr.value = String(value);\n    if (this._attributes) this._attributes[qname] = attr;\n    if (isnew && this._newattrhook) this._newattrhook(qname, value);\n  }},\n\n  // Create a new Attr object, insert it, and return it.\n  // Used by setAttribute() and by set()\n  _newattr: { value: function _newattr(qname) {\n    var attr = new Attr(this, qname, null, null);\n    var key = '|' + qname;\n    this._attrsByQName[qname] = attr;\n    this._attrsByLName[key] = attr;\n    if (this._attributes) {\n      this._attributes[this._attrKeys.length] = attr;\n    }\n    this._attrKeys.push(key);\n    return attr;\n  }},\n\n  // Add a qname->Attr mapping to the _attrsByQName object, taking into\n  // account that there may be more than one attr object with the\n  // same qname\n  _addQName: { value: function(attr) {\n    var qname = attr.name;\n    var existing = this._attrsByQName[qname];\n    if (!existing) {\n      this._attrsByQName[qname] = attr;\n    }\n    else if (Array.isArray(existing)) {\n      existing.push(attr);\n    }\n    else {\n      this._attrsByQName[qname] = [existing, attr];\n    }\n    if (this._attributes) this._attributes[qname] = attr;\n  }},\n\n  // Remove a qname->Attr mapping to the _attrsByQName object, taking into\n  // account that there may be more than one attr object with the\n  // same qname\n  _removeQName: { value: function(attr) {\n    var qname = attr.name;\n    var target = this._attrsByQName[qname];\n\n    if (Array.isArray(target)) {\n      var idx = target.indexOf(attr);\n      utils.assert(idx !== -1); // It must be here somewhere\n      if (target.length === 2) {\n        this._attrsByQName[qname] = target[1-idx];\n        if (this._attributes) {\n          this._attributes[qname] = this._attrsByQName[qname];\n        }\n      } else {\n        target.splice(idx, 1);\n        if (this._attributes && this._attributes[qname] === attr) {\n          this._attributes[qname] = target[0];\n        }\n      }\n    }\n    else {\n      utils.assert(target === attr);  // If only one, it must match\n      this._attrsByQName[qname] = undefined;\n      if (this._attributes) {\n        this._attributes[qname] = undefined;\n      }\n    }\n  }},\n\n  // Return the number of attributes\n  _numattrs: { get: function() { return this._attrKeys.length; }},\n  // Return the nth Attr object\n  _attr: { value: function(n) {\n    return this._attrsByLName[this._attrKeys[n]];\n  }},\n\n  // Define getters and setters for an 'id' property that reflects\n  // the content attribute 'id'.\n  id: attributes.property({name: 'id'}),\n\n  // Define getters and setters for a 'className' property that reflects\n  // the content attribute 'class'.\n  className: attributes.property({name: 'class'}),\n\n  classList: { get: function() {\n    var self = this;\n    if (this._classList) {\n      return this._classList;\n    }\n    var dtlist = new DOMTokenList(\n      function() {\n        return self.className || \"\";\n      },\n      function(v) {\n        self.className = v;\n      }\n    );\n    this._classList = dtlist;\n    return dtlist;\n  }, set: function(v) { this.className = v; }},\n\n  matches: { value: function(selector) {\n    return select.matches(this, selector);\n  }},\n\n  closest: { value: function(selector) {\n    var el = this;\n\tdo {\n\t  if (el.matches && el.matches(selector)) { return el; }\n\t  el = el.parentElement || el.parentNode;\n\t} while (el !== null && el.nodeType === Node.ELEMENT_NODE);\n\treturn null;\n  }},\n\n  querySelector: { value: function(selector) {\n    return select(selector, this)[0];\n  }},\n\n  querySelectorAll: { value: function(selector) {\n    var nodes = select(selector, this);\n    return nodes.item ? nodes : new NodeList(nodes);\n  }}\n\n});\n\nObject.defineProperties(Element.prototype, ChildNode);\nObject.defineProperties(Element.prototype, NonDocumentTypeChildNode);\n\n// Register special handling for the id attribute\nattributes.registerChangeHandler(Element, 'id',\n function(element, lname, oldval, newval) {\n   if (element.rooted) {\n     if (oldval) {\n       element.ownerDocument.delId(oldval, element);\n     }\n     if (newval) {\n       element.ownerDocument.addId(newval, element);\n     }\n   }\n }\n);\nattributes.registerChangeHandler(Element, 'class',\n function(element, lname, oldval, newval) {\n   if (element._classList) { element._classList._update(); }\n }\n);\n\n// The Attr class represents a single attribute.  The values in\n// _attrsByQName and _attrsByLName are instances of this class.\nfunction Attr(elt, lname, prefix, namespace, value) {\n  // localName and namespace are constant for any attr object.\n  // But value may change.  And so can prefix, and so, therefore can name.\n  this.localName = lname;\n  this.prefix = (prefix===null || prefix==='') ? null : ('' + prefix);\n  this.namespaceURI = (namespace===null || namespace==='') ? null : ('' + namespace);\n  this.data = value;\n  // Set ownerElement last to ensure it is hooked up to onchange handler\n  this._setOwnerElement(elt);\n}\n\n// In DOM 3 Attr was supposed to extend Node; in DOM 4 that was abandoned.\nAttr.prototype = Object.create(Object.prototype, {\n  ownerElement: {\n    get: function() { return this._ownerElement; },\n  },\n  _setOwnerElement: { value: function _setOwnerElement(elt) {\n    this._ownerElement = elt;\n    if (this.prefix === null && this.namespaceURI === null && elt) {\n      this.onchange = elt._attributeChangeHandlers[this.localName];\n    } else {\n      this.onchange = null;\n    }\n  }},\n\n  name: { get: function() {\n    return this.prefix ? this.prefix + ':' + this.localName : this.localName;\n  }},\n\n  specified: { get: function() {\n    // Deprecated\n    return true;\n  }},\n\n  value: {\n    get: function() {\n      return this.data;\n    },\n    set: function(value) {\n      var oldval = this.data;\n      value = (value === undefined) ? '' : value + '';\n      if (value === oldval) return;\n\n      this.data = value;\n\n      // Run the onchange hook for the attribute\n      // if there is one.\n      if (this.ownerElement) {\n        if (this.onchange)\n          this.onchange(this.ownerElement,this.localName, oldval, value);\n\n        // Generate a mutation event if the element is rooted\n        if (this.ownerElement.rooted)\n          this.ownerElement.ownerDocument.mutateAttr(this, oldval);\n      }\n    },\n  },\n\n  cloneNode: { value: function cloneNode(deep) {\n    // Both this method and Document#createAttribute*() create unowned Attrs\n    return new Attr(\n      null, this.localName, this.prefix, this.namespaceURI, this.data\n    );\n  }},\n\n  // Legacy aliases (see gh#70 and https://dom.spec.whatwg.org/#interface-attr)\n  nodeType: { get: function() { return Node.ATTRIBUTE_NODE; } },\n  nodeName: { get: function() { return this.name; } },\n  nodeValue: {\n    get: function() { return this.value; },\n    set: function(v) { this.value = v; },\n  },\n  textContent: {\n    get: function() { return this.value; },\n    set: function(v) {\n      if (v === null || v === undefined) { v = ''; }\n      this.value = v;\n    },\n  },\n});\n// Sneakily export this class for use by Document.createAttribute()\nElement._Attr = Attr;\n\n// The attributes property of an Element will be an instance of this class.\n// This class is really just a dummy, though. It only defines a length\n// property and an item() method. The AttrArrayProxy that\n// defines the public API just uses the Element object itself.\nfunction AttributesArray(elt) {\n  NamedNodeMap.call(this, elt);\n  for (var name in elt._attrsByQName) {\n    this[name] = elt._attrsByQName[name];\n  }\n  for (var i = 0; i < elt._attrKeys.length; i++) {\n    this[i] = elt._attrsByLName[elt._attrKeys[i]];\n  }\n}\nAttributesArray.prototype = Object.create(NamedNodeMap.prototype, {\n  length: { get: function() {\n    return this.element._attrKeys.length;\n  }, set: function() { /* ignore */ } },\n  item: { value: function(n) {\n    /* jshint bitwise: false */\n    n = n >>> 0;\n    if (n >= this.length) { return null; }\n    return this.element._attrsByLName[this.element._attrKeys[n]];\n    /* jshint bitwise: true */\n  } },\n});\n\n// We can't make direct array access work (without Proxies, node >=6)\n// but we can make `Array.from(node.attributes)` and for-of loops work.\nif (global.Symbol && global.Symbol.iterator) {\n    AttributesArray.prototype[global.Symbol.iterator] = function() {\n        var i=0, n=this.length, self=this;\n        return {\n            next: function() {\n                if (i<n) return { value: self.item(i++) };\n                return { done: true };\n            }\n        };\n    };\n}\n\n\n// The children property of an Element will be an instance of this class.\n// It defines length, item() and namedItem() and will be wrapped by an\n// HTMLCollection when exposed through the DOM.\nfunction ChildrenCollection(e) {\n  this.element = e;\n  this.updateCache();\n}\n\nChildrenCollection.prototype = Object.create(Object.prototype, {\n  length: { get: function() {\n    this.updateCache();\n    return this.childrenByNumber.length;\n  } },\n  item: { value: function item(n) {\n    this.updateCache();\n    return this.childrenByNumber[n] || null;\n  } },\n\n  namedItem: { value: function namedItem(name) {\n    this.updateCache();\n    return this.childrenByName[name] || null;\n  } },\n\n  // This attribute returns the entire name->element map.\n  // It is not part of the HTMLCollection API, but we need it in\n  // src/HTMLCollectionProxy\n  namedItems: { get: function() {\n    this.updateCache();\n    return this.childrenByName;\n  } },\n\n  updateCache: { value: function updateCache() {\n    var namedElts = /^(a|applet|area|embed|form|frame|frameset|iframe|img|object)$/;\n    if (this.lastModTime !== this.element.lastModTime) {\n      this.lastModTime = this.element.lastModTime;\n\n      var n = this.childrenByNumber && this.childrenByNumber.length || 0;\n      for(var i = 0; i < n; i++) {\n        this[i] = undefined;\n      }\n\n      this.childrenByNumber = [];\n      this.childrenByName = Object.create(null);\n\n      for (var c = this.element.firstChild; c !== null; c = c.nextSibling) {\n        if (c.nodeType === Node.ELEMENT_NODE) {\n\n          this[this.childrenByNumber.length] = c;\n          this.childrenByNumber.push(c);\n\n          // XXX Are there any requirements about the namespace\n          // of the id property?\n          var id = c.getAttribute('id');\n\n          // If there is an id that is not already in use...\n          if (id && !this.childrenByName[id])\n            this.childrenByName[id] = c;\n\n          // For certain HTML elements we check the name attribute\n          var name = c.getAttribute('name');\n          if (name &&\n            this.element.namespaceURI === NAMESPACE.HTML &&\n            namedElts.test(this.element.localName) &&\n            !this.childrenByName[name])\n            this.childrenByName[id] = c;\n        }\n      }\n    }\n  } },\n});\n\n// These functions return predicates for filtering elements.\n// They're used by the Document and Element classes for methods like\n// getElementsByTagName and getElementsByClassName\n\nfunction localNameElementFilter(lname) {\n  return function(e) { return e.localName === lname; };\n}\n\nfunction htmlLocalNameElementFilter(lname) {\n  var lclname = utils.toASCIILowerCase(lname);\n  if (lclname === lname)\n    return localNameElementFilter(lname);\n\n  return function(e) {\n    return e.isHTML ? e.localName === lclname : e.localName === lname;\n  };\n}\n\nfunction namespaceElementFilter(ns) {\n  return function(e) { return e.namespaceURI === ns; };\n}\n\nfunction namespaceLocalNameElementFilter(ns, lname) {\n  return function(e) {\n    return e.namespaceURI === ns && e.localName === lname;\n  };\n}\n\nfunction classNamesElementFilter(names) {\n  return function(e) {\n    return names.every(function(n) { return e.classList.contains(n); });\n  };\n}\n\nfunction elementNameFilter(name) {\n  return function(e) {\n    // All the *HTML elements* in the document with the given name attribute\n    if (e.namespaceURI !== NAMESPACE.HTML) { return false; }\n    return e.getAttribute('name') === name;\n  };\n}\n","\"use strict\";\nmodule.exports = Event;\n\nEvent.CAPTURING_PHASE = 1;\nEvent.AT_TARGET = 2;\nEvent.BUBBLING_PHASE = 3;\n\nfunction Event(type, dictionary) {\n  // Initialize basic event properties\n  this.type = '';\n  this.target = null;\n  this.currentTarget = null;\n  this.eventPhase = Event.AT_TARGET;\n  this.bubbles = false;\n  this.cancelable = false;\n  this.isTrusted = false;\n  this.defaultPrevented = false;\n  this.timeStamp = Date.now();\n\n  // Initialize internal flags\n  // XXX: Would it be better to inherit these defaults from the prototype?\n  this._propagationStopped = false;\n  this._immediatePropagationStopped = false;\n  this._initialized = true;\n  this._dispatching = false;\n\n  // Now initialize based on the constructor arguments (if any)\n  if (type) this.type = type;\n  if (dictionary) {\n    for(var p in dictionary) {\n      this[p] = dictionary[p];\n    }\n  }\n}\n\nEvent.prototype = Object.create(Object.prototype, {\n  constructor: { value: Event },\n  stopPropagation: { value: function stopPropagation() {\n    this._propagationStopped = true;\n  }},\n\n  stopImmediatePropagation: { value: function stopImmediatePropagation() {\n    this._propagationStopped = true;\n    this._immediatePropagationStopped = true;\n  }},\n\n  preventDefault: { value: function preventDefault() {\n    if (this.cancelable) this.defaultPrevented = true;\n  }},\n\n  initEvent: { value: function initEvent(type, bubbles, cancelable) {\n    this._initialized = true;\n    if (this._dispatching) return;\n\n    this._propagationStopped = false;\n    this._immediatePropagationStopped = false;\n    this.defaultPrevented = false;\n    this.isTrusted = false;\n\n    this.target = null;\n    this.type = type;\n    this.bubbles = bubbles;\n    this.cancelable = cancelable;\n  }},\n\n});\n","\"use strict\";\nvar Event = require('./Event');\nvar MouseEvent = require('./MouseEvent');\nvar utils = require('./utils');\n\nmodule.exports = EventTarget;\n\nfunction EventTarget() {}\n\nEventTarget.prototype = {\n  // XXX\n  // See WebIDL 4.8 for details on object event handlers\n  // and how they should behave.  We actually have to accept\n  // any object to addEventListener... Can't type check it.\n  // on registration.\n\n  // XXX:\n  // Capturing event listeners are sort of rare.  I think I can optimize\n  // them so that dispatchEvent can skip the capturing phase (or much of\n  // it).  Each time a capturing listener is added, increment a flag on\n  // the target node and each of its ancestors.  Decrement when removed.\n  // And update the counter when nodes are added and removed from the\n  // tree as well.  Then, in dispatch event, the capturing phase can\n  // abort if it sees any node with a zero count.\n  addEventListener: function addEventListener(type, listener, capture) {\n    if (!listener) return;\n    if (capture === undefined) capture = false;\n    if (!this._listeners) this._listeners = Object.create(null);\n    if (!this._listeners[type]) this._listeners[type] = [];\n    var list = this._listeners[type];\n\n    // If this listener has already been registered, just return\n    for(var i = 0, n = list.length; i < n; i++) {\n      var l = list[i];\n      if (l.listener === listener && l.capture === capture)\n        return;\n    }\n\n    // Add an object to the list of listeners\n    var obj = { listener: listener, capture: capture };\n    if (typeof listener === 'function') obj.f = listener;\n    list.push(obj);\n  },\n\n  removeEventListener: function removeEventListener(type,\n                            listener,\n                            capture) {\n    if (capture === undefined) capture = false;\n    if (this._listeners) {\n      var list = this._listeners[type];\n      if (list) {\n        // Find the listener in the list and remove it\n        for(var i = 0, n = list.length; i < n; i++) {\n          var l = list[i];\n          if (l.listener === listener && l.capture === capture) {\n            if (list.length === 1) {\n              this._listeners[type] = undefined;\n            }\n            else {\n              list.splice(i, 1);\n            }\n            return;\n          }\n        }\n      }\n    }\n  },\n\n  // This is the public API for dispatching untrusted public events.\n  // See _dispatchEvent for the implementation\n  dispatchEvent: function dispatchEvent(event) {\n    // Dispatch an untrusted event\n    return this._dispatchEvent(event, false);\n  },\n\n  //\n  // See DOMCore 4.4\n  // XXX: I'll probably need another version of this method for\n  // internal use, one that does not set isTrusted to false.\n  // XXX: see Document._dispatchEvent: perhaps that and this could\n  // call a common internal function with different settings of\n  // a trusted boolean argument\n  //\n  // XXX:\n  // The spec has changed in how to deal with handlers registered\n  // on idl or content attributes rather than with addEventListener.\n  // Used to say that they always ran first.  That's how webkit does it\n  // Spec now says that they run in a position determined by\n  // when they were first set.  FF does it that way.  See:\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/webappapis.html#event-handlers\n  //\n  _dispatchEvent: function _dispatchEvent(event, trusted) {\n    if (typeof trusted !== 'boolean') trusted = false;\n    function invoke(target, event) {\n      var type = event.type, phase = event.eventPhase;\n      event.currentTarget = target;\n\n      // If there was an individual handler defined, invoke it first\n      // XXX: see comment above: this shouldn't always be first.\n      if (phase !== Event.CAPTURING_PHASE &&\n        target._handlers && target._handlers[type])\n      {\n        var handler = target._handlers[type];\n        var rv;\n        if (typeof handler === 'function') {\n          rv=handler.call(event.currentTarget, event);\n        }\n        else {\n          var f = handler.handleEvent;\n          if (typeof f !== 'function')\n            throw new TypeError('handleEvent property of ' +\n                                'event handler object is' +\n                                'not a function.');\n          rv=f.call(handler, event);\n        }\n\n        switch(event.type) {\n        case 'mouseover':\n          if (rv === true)  // Historical baggage\n            event.preventDefault();\n          break;\n        case 'beforeunload':\n          // XXX: eventually we need a special case here\n          /* falls through */\n        default:\n          if (rv === false)\n            event.preventDefault();\n          break;\n        }\n      }\n\n      // Now invoke list list of listeners for this target and type\n      var list = target._listeners && target._listeners[type];\n      if (!list) return;\n      list = list.slice();\n      for(var i = 0, n = list.length; i < n; i++) {\n        if (event._immediatePropagationStopped) return;\n        var l = list[i];\n        if ((phase === Event.CAPTURING_PHASE && !l.capture) ||\n          (phase === Event.BUBBLING_PHASE && l.capture))\n          continue;\n        if (l.f) {\n          l.f.call(event.currentTarget, event);\n        }\n        else {\n          var fn = l.listener.handleEvent;\n          if (typeof fn !== 'function')\n            throw new TypeError('handleEvent property of event listener object is not a function.');\n          fn.call(l.listener, event);\n        }\n      }\n    }\n\n    if (!event._initialized || event._dispatching) utils.InvalidStateError();\n    event.isTrusted = trusted;\n\n    // Begin dispatching the event now\n    event._dispatching = true;\n    event.target = this;\n\n    // Build the list of targets for the capturing and bubbling phases\n    // XXX: we'll eventually have to add Window to this list.\n    var ancestors = [];\n    for(var n = this.parentNode; n; n = n.parentNode)\n      ancestors.push(n);\n\n    // Capturing phase\n    event.eventPhase = Event.CAPTURING_PHASE;\n    for(var i = ancestors.length-1; i >= 0; i--) {\n      invoke(ancestors[i], event);\n      if (event._propagationStopped) break;\n    }\n\n    // At target phase\n    if (!event._propagationStopped) {\n      event.eventPhase = Event.AT_TARGET;\n      invoke(this, event);\n    }\n\n    // Bubbling phase\n    if (event.bubbles && !event._propagationStopped) {\n      event.eventPhase = Event.BUBBLING_PHASE;\n      for(var ii = 0, nn = ancestors.length; ii < nn; ii++) {\n        invoke(ancestors[ii], event);\n        if (event._propagationStopped) break;\n      }\n    }\n\n    event._dispatching = false;\n    event.eventPhase = Event.AT_TARGET;\n    event.currentTarget = null;\n\n    // Deal with mouse events and figure out when\n    // a click has happened\n    if (trusted && !event.defaultPrevented && event instanceof MouseEvent) {\n      switch(event.type) {\n      case 'mousedown':\n        this._armed = {\n          x: event.clientX,\n          y: event.clientY,\n          t: event.timeStamp\n        };\n        break;\n      case 'mouseout':\n      case 'mouseover':\n        this._armed = null;\n        break;\n      case 'mouseup':\n        if (this._isClick(event)) this._doClick(event);\n        this._armed = null;\n        break;\n      }\n    }\n\n\n\n    return !event.defaultPrevented;\n  },\n\n  // Determine whether a click occurred\n  // XXX We don't support double clicks for now\n  _isClick: function(event) {\n    return (this._armed !== null &&\n        event.type === 'mouseup' &&\n        event.isTrusted &&\n        event.button === 0 &&\n        event.timeStamp - this._armed.t < 1000 &&\n        Math.abs(event.clientX - this._armed.x) < 10 &&\n        Math.abs(event.clientY - this._armed.Y) < 10);\n  },\n\n  // Clicks are handled like this:\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/elements.html#interactive-content-0\n  //\n  // Note that this method is similar to the HTMLElement.click() method\n  // The event argument must be the trusted mouseup event\n  _doClick: function(event) {\n    if (this._click_in_progress) return;\n    this._click_in_progress = true;\n\n    // Find the nearest enclosing element that is activatable\n    // An element is activatable if it has a\n    // _post_click_activation_steps hook\n    var activated = this;\n    while(activated && !activated._post_click_activation_steps)\n      activated = activated.parentNode;\n\n    if (activated && activated._pre_click_activation_steps) {\n      activated._pre_click_activation_steps();\n    }\n\n    var click = this.ownerDocument.createEvent('MouseEvent');\n    click.initMouseEvent('click', true, true,\n      this.ownerDocument.defaultView, 1,\n      event.screenX, event.screenY,\n      event.clientX, event.clientY,\n      event.ctrlKey, event.altKey,\n      event.shiftKey, event.metaKey,\n      event.button, null);\n\n    var result = this._dispatchEvent(click, true);\n\n    if (activated) {\n      if (result) {\n        // This is where hyperlinks get followed, for example.\n        if (activated._post_click_activation_steps)\n          activated._post_click_activation_steps(click);\n      }\n      else {\n        if (activated._cancelled_activation_steps)\n          activated._cancelled_activation_steps();\n      }\n    }\n  },\n\n  //\n  // An event handler is like an event listener, but it registered\n  // by setting an IDL or content attribute like onload or onclick.\n  // There can only be one of these at a time for any event type.\n  // This is an internal method for the attribute accessors and\n  // content attribute handlers that need to register events handlers.\n  // The type argument is the same as in addEventListener().\n  // The handler argument is the same as listeners in addEventListener:\n  // it can be a function or an object. Pass null to remove any existing\n  // handler.  Handlers are always invoked before any listeners of\n  // the same type.  They are not invoked during the capturing phase\n  // of event dispatch.\n  //\n  _setEventHandler: function _setEventHandler(type, handler) {\n    if (!this._handlers) this._handlers = Object.create(null);\n    this._handlers[type] = handler;\n  },\n\n  _getEventHandler: function _getEventHandler(type) {\n    return (this._handlers && this._handlers[type]) || null;\n  }\n\n};\n","\"use strict\";\nmodule.exports = FilteredElementList;\n\nvar Node = require('./Node');\n\n//\n// This file defines node list implementation that lazily traverses\n// the document tree (or a subtree rooted at any element) and includes\n// only those elements for which a specified filter function returns true.\n// It is used to implement the\n// {Document,Element}.getElementsBy{TagName,ClassName}{,NS} methods.\n//\n// XXX this should inherit from NodeList\n\nfunction FilteredElementList(root, filter) {\n  this.root = root;\n  this.filter = filter;\n  this.lastModTime = root.lastModTime;\n  this.done = false;\n  this.cache = [];\n  this.traverse();\n}\n\nFilteredElementList.prototype = Object.create(Object.prototype, {\n  length: { get: function() {\n    this.checkcache();\n    if (!this.done) this.traverse();\n    return this.cache.length;\n  } },\n\n  item: { value: function(n) {\n    this.checkcache();\n    if (!this.done && n >= this.cache.length) {\n      // This can lead to O(N^2) behavior if we stop when we get to n\n      // and the caller is iterating through the items in order; so\n      // be sure to do the full traverse here.\n      this.traverse(/*n*/);\n    }\n    return this.cache[n];\n  } },\n\n  checkcache: { value: function() {\n    if (this.lastModTime !== this.root.lastModTime) {\n      // subtree has changed, so invalidate cache\n      for (var i = this.cache.length-1; i>=0; i--) {\n        this[i] = undefined;\n      }\n      this.cache.length = 0;\n      this.done = false;\n      this.lastModTime = this.root.lastModTime;\n    }\n  } },\n\n  // If n is specified, then traverse the tree until we've found the nth\n  // item (or until we've found all items).  If n is not specified,\n  // traverse until we've found all items.\n  traverse: { value: function(n) {\n    // increment n so we can compare to length, and so it is never falsy\n    if (n !== undefined) n++;\n\n    var elt;\n    while ((elt = this.next()) !== null) {\n      this[this.cache.length] = elt; //XXX Use proxy instead\n      this.cache.push(elt);\n      if (n && this.cache.length === n) return;\n    }\n\n    // no next element, so we've found everything\n    this.done = true;\n  } },\n\n  // Return the next element under root that matches filter\n  next: { value: function() {\n    var start = (this.cache.length === 0) ? this.root // Start at the root or at\n      : this.cache[this.cache.length-1]; // the last element we found\n\n    var elt;\n    if (start.nodeType === Node.DOCUMENT_NODE)\n      elt = start.documentElement;\n    else\n      elt = start.nextElement(this.root);\n\n    while(elt) {\n      if (this.filter(elt)) {\n        return elt;\n      }\n\n      elt = elt.nextElement(this.root);\n    }\n    return null;\n  } },\n});\n","\"use strict\";\nmodule.exports = HTMLParser;\n\nvar Document = require('./Document');\nvar DocumentType = require('./DocumentType');\nvar Node = require('./Node');\nvar NAMESPACE = require('./utils').NAMESPACE;\nvar html = require('./htmlelts');\nvar impl = html.elements;\n\nvar pushAll = Function.prototype.apply.bind(Array.prototype.push);\n\n/*\n * This file contains an implementation of the HTML parsing algorithm.\n * The algorithm and the implementation are complex because HTML\n * explicitly defines how the parser should behave for all possible\n * valid and invalid inputs.\n *\n * Usage:\n *\n * The file defines a single HTMLParser() function, which dom.js exposes\n * publicly as document.implementation.mozHTMLParser(). This is a\n * factory function, not a constructor.\n *\n * When you call document.implementation.mozHTMLParser(), it returns\n * an object that has parse() and document() methods. To parse HTML text,\n * pass the text (in one or more chunks) to the parse() method.  When\n * you've passed all the text (on the last chunk, or afterward) pass\n * true as the second argument to parse() to tell the parser that there\n * is no more coming. Call document() to get the document object that\n * the parser is parsing into.  You can call this at any time, before\n * or after calling parse().\n *\n * The first argument to mozHTMLParser is the absolute URL of the document.\n *\n * The second argument is optional and is for internal use only.  Pass an\n * element as the fragmentContext to do innerHTML parsing for the\n * element.  To do innerHTML parsing on a document, pass null. Otherwise,\n * omit the 2nd argument. See HTMLElement.innerHTML for an example.  Note\n * that if you pass a context element, the end() method will return an\n * unwrapped document instead of a wrapped one.\n *\n * Implementation details:\n *\n * This is a long file of almost 7000 lines. It is structured as one\n * big function nested within another big function.  The outer\n * function defines a bunch of constant data, utility functions\n * that use that data, and a couple of classes used by the parser.\n * The outer function also defines and returns the\n * inner function. This inner function is the HTMLParser factory\n * function that implements the parser and holds all the parser state\n * as local variables.  The HTMLParser function is quite big because\n * it defines many nested functions that use those local variables.\n *\n * There are three tightly coupled parser stages: a scanner, a\n * tokenizer and a tree builder. In a (possibly misguided) attempt at\n * efficiency, the stages are not implemented as separate classes:\n * everything shares state and is (mostly) implemented in imperative\n * (rather than OO) style.\n *\n * The stages of the parser work like this: When the client code calls\n * the parser's parse() method, the specified string is passed to\n * scanChars(). The scanner loops through that string and passes characters\n * (sometimes one at a time, sometimes in chunks) to the tokenizer stage.\n * The tokenizer groups the characters into tokens: tags, endtags, runs\n * of text, comments, doctype declarations, and the end-of-file (EOF)\n * token.  These tokens are then passed to the tree building stage via\n * the insertToken() function.  The tree building stage builds up the\n * document tree.\n *\n * The tokenizer stage is a finite state machine.  Each state is\n * implemented as a function with a name that ends in \"_state\".  The\n * initial state is data_state(). The current tokenizer state is stored\n * in the variable 'tokenizer'.  Most state functions expect a single\n * integer argument which represents a single UTF-16 codepoint.  Some\n * states want more characters and set a lookahead property on\n * themselves.  The scanChars() function in the scanner checks for this\n * lookahead property.  If it doesn't exist, then scanChars() just passes\n * the next input character to the current tokenizer state function.\n * Otherwise, scanChars() looks ahead (a given # of characters, or for a\n * matching string, or for a matching regexp) and passes a string of\n * characters to the current tokenizer state function.\n *\n * As a shortcut, certain states of the tokenizer use regular expressions\n * to look ahead in the scanner's input buffer for runs of text, simple\n * tags and attributes.  For well-formed input, these shortcuts skip a\n * lot of state transitions and speed things up a bit.\n *\n * When a tokenizer state function has consumed a complete token, it\n * emits that token, by calling insertToken(), or by calling a utility\n * function that itself calls insertToken().  These tokens are passed to\n * the tree building stage, which is also a state machine.  Like the\n * tokenizer, the tree building states are implemented as functions, and\n * these functions have names that end with _mode (because the HTML spec\n * refers to them as insertion modes). The current insertion mode is held\n * by the 'parser' variable.  Each insertion mode function takes up to 4\n * arguments.  The first is a token type, represented by the constants\n * TAG, ENDTAG, TEXT, COMMENT, DOCTYPE and EOF.  The second argument is\n * the value of the token: the text or comment data, or tagname or\n * doctype.  For tags, the 3rd argument is an array of attributes.  For\n * DOCTYPES it is the optional public id.  For tags, the 4th argument is\n * true if the tag is self-closing. For doctypes, the 4th argument is the\n * optional system id.\n *\n * Search for \"***\" to find the major sub-divisions in the code.\n */\n\n\n/***\n * Data prolog.  Lots of constants declared here, including some\n * very large objects.  They're used throughout the code that follows\n */\n// Token types for the tree builder.\nvar EOF = -1;\nvar TEXT = 1;\nvar TAG = 2;\nvar ENDTAG = 3;\nvar COMMENT = 4;\nvar DOCTYPE = 5;\n\n// A re-usable empty array\nvar NOATTRS = [];\n\n// These DTD public ids put the browser in quirks mode\nvar quirkyPublicIds = /^HTML$|^-\\/\\/W3O\\/\\/DTD W3 HTML Strict 3\\.0\\/\\/EN\\/\\/$|^-\\/W3C\\/DTD HTML 4\\.0 Transitional\\/EN$|^\\+\\/\\/Silmaril\\/\\/dtd html Pro v0r11 19970101\\/\\/|^-\\/\\/AdvaSoft Ltd\\/\\/DTD HTML 3\\.0 asWedit \\+ extensions\\/\\/|^-\\/\\/AS\\/\\/DTD HTML 3\\.0 asWedit \\+ extensions\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 2\\.0 Level 1\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 2\\.0 Level 2\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 2\\.0 Strict Level 1\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 2\\.0 Strict Level 2\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 2\\.0 Strict\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 2\\.0\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 2\\.1E\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 3\\.0\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 3\\.2 Final\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 3\\.2\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML 3\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML Level 0\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML Level 1\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML Level 2\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML Level 3\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML Strict Level 0\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML Strict Level 1\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML Strict Level 2\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML Strict Level 3\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML Strict\\/\\/|^-\\/\\/IETF\\/\\/DTD HTML\\/\\/|^-\\/\\/Metrius\\/\\/DTD Metrius Presentational\\/\\/|^-\\/\\/Microsoft\\/\\/DTD Internet Explorer 2\\.0 HTML Strict\\/\\/|^-\\/\\/Microsoft\\/\\/DTD Internet Explorer 2\\.0 HTML\\/\\/|^-\\/\\/Microsoft\\/\\/DTD Internet Explorer 2\\.0 Tables\\/\\/|^-\\/\\/Microsoft\\/\\/DTD Internet Explorer 3\\.0 HTML Strict\\/\\/|^-\\/\\/Microsoft\\/\\/DTD Internet Explorer 3\\.0 HTML\\/\\/|^-\\/\\/Microsoft\\/\\/DTD Internet Explorer 3\\.0 Tables\\/\\/|^-\\/\\/Netscape Comm\\. Corp\\.\\/\\/DTD HTML\\/\\/|^-\\/\\/Netscape Comm\\. Corp\\.\\/\\/DTD Strict HTML\\/\\/|^-\\/\\/O'Reilly and Associates\\/\\/DTD HTML 2\\.0\\/\\/|^-\\/\\/O'Reilly and Associates\\/\\/DTD HTML Extended 1\\.0\\/\\/|^-\\/\\/O'Reilly and Associates\\/\\/DTD HTML Extended Relaxed 1\\.0\\/\\/|^-\\/\\/SoftQuad Software\\/\\/DTD HoTMetaL PRO 6\\.0::19990601::extensions to HTML 4\\.0\\/\\/|^-\\/\\/SoftQuad\\/\\/DTD HoTMetaL PRO 4\\.0::19971010::extensions to HTML 4\\.0\\/\\/|^-\\/\\/Spyglass\\/\\/DTD HTML 2\\.0 Extended\\/\\/|^-\\/\\/SQ\\/\\/DTD HTML 2\\.0 HoTMetaL \\+ extensions\\/\\/|^-\\/\\/Sun Microsystems Corp\\.\\/\\/DTD HotJava HTML\\/\\/|^-\\/\\/Sun Microsystems Corp\\.\\/\\/DTD HotJava Strict HTML\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML 3 1995-03-24\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML 3\\.2 Draft\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML 3\\.2 Final\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML 3\\.2\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML 3\\.2S Draft\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML 4\\.0 Frameset\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML 4\\.0 Transitional\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML Experimental 19960712\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML Experimental 970421\\/\\/|^-\\/\\/W3C\\/\\/DTD W3 HTML\\/\\/|^-\\/\\/W3O\\/\\/DTD W3 HTML 3\\.0\\/\\/|^-\\/\\/WebTechs\\/\\/DTD Mozilla HTML 2\\.0\\/\\/|^-\\/\\/WebTechs\\/\\/DTD Mozilla HTML\\/\\//i;\n\nvar quirkySystemId = \"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd\";\n\nvar conditionallyQuirkyPublicIds = /^-\\/\\/W3C\\/\\/DTD HTML 4\\.01 Frameset\\/\\/|^-\\/\\/W3C\\/\\/DTD HTML 4\\.01 Transitional\\/\\//i;\n\n// These DTD public ids put the browser in limited quirks mode\nvar limitedQuirkyPublicIds = /^-\\/\\/W3C\\/\\/DTD XHTML 1\\.0 Frameset\\/\\/|^-\\/\\/W3C\\/\\/DTD XHTML 1\\.0 Transitional\\/\\//i;\n\n\n// Element sets below. See the isA() function for a way to test\n// whether an element is a member of a set\nvar specialSet = Object.create(null);\nspecialSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"address\":true, \"applet\":true, \"area\":true, \"article\":true,\n  \"aside\":true, \"base\":true, \"basefont\":true, \"bgsound\":true,\n  \"blockquote\":true, \"body\":true, \"br\":true, \"button\":true,\n  \"caption\":true, \"center\":true, \"col\":true, \"colgroup\":true,\n  \"dd\":true, \"details\":true, \"dir\":true,\n  \"div\":true, \"dl\":true, \"dt\":true, \"embed\":true,\n  \"fieldset\":true, \"figcaption\":true, \"figure\":true, \"footer\":true,\n  \"form\":true, \"frame\":true, \"frameset\":true, \"h1\":true,\n  \"h2\":true, \"h3\":true, \"h4\":true, \"h5\":true,\n  \"h6\":true, \"head\":true, \"header\":true, \"hgroup\":true,\n  \"hr\":true, \"html\":true, \"iframe\":true, \"img\":true,\n  \"input\":true, \"li\":true, \"link\":true,\n  \"listing\":true, \"main\":true, \"marquee\":true, \"menu\":true, \"meta\":true,\n  \"nav\":true, \"noembed\":true, \"noframes\":true, \"noscript\":true,\n  \"object\":true, \"ol\":true, \"p\":true, \"param\":true,\n  \"plaintext\":true, \"pre\":true, \"script\":true, \"section\":true,\n  \"select\":true, \"source\":true, \"style\":true, \"summary\":true, \"table\":true,\n  \"tbody\":true, \"td\":true, \"template\":true, \"textarea\":true, \"tfoot\":true,\n  \"th\":true, \"thead\":true, \"title\":true, \"tr\":true, \"track\":true,\n  // Note that \"xmp\" was removed from the \"special\" set in the latest\n  // spec, apparently by accident; see\n  // https://github.com/whatwg/html/pull/1919\n  \"ul\":true, \"wbr\":true, \"xmp\":true\n};\nspecialSet[NAMESPACE.SVG] = {\n  __proto__: null,\n  \"foreignObject\": true, \"desc\": true, \"title\": true\n};\nspecialSet[NAMESPACE.MATHML] = {\n  __proto__: null,\n  \"mi\":true, \"mo\":true, \"mn\":true, \"ms\":true,\n  \"mtext\":true, \"annotation-xml\":true\n};\n\n// The set of address, div, and p HTML tags\nvar addressdivpSet = Object.create(null);\naddressdivpSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"address\":true, \"div\":true, \"p\":true\n};\n\nvar dddtSet = Object.create(null);\ndddtSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"dd\":true, \"dt\":true\n};\n\nvar tablesectionrowSet = Object.create(null);\ntablesectionrowSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"table\":true, \"thead\":true, \"tbody\":true, \"tfoot\":true, \"tr\":true\n};\n\nvar impliedEndTagsSet = Object.create(null);\nimpliedEndTagsSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"dd\": true, \"dt\": true, \"li\": true, \"menuitem\": true, \"optgroup\": true,\n  \"option\": true, \"p\": true, \"rb\": true, \"rp\": true, \"rt\": true, \"rtc\": true\n};\n\nvar thoroughImpliedEndTagsSet = Object.create(null);\nthoroughImpliedEndTagsSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"caption\": true, \"colgroup\": true, \"dd\": true, \"dt\": true, \"li\": true,\n  \"optgroup\": true, \"option\": true, \"p\": true, \"rb\": true, \"rp\": true,\n  \"rt\": true, \"rtc\": true, \"tbody\": true, \"td\": true, \"tfoot\": true,\n  \"th\": true, \"thead\": true, \"tr\": true\n};\n\nvar tableContextSet = Object.create(null);\ntableContextSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"table\": true, \"template\": true, \"html\": true\n};\n\nvar tableBodyContextSet = Object.create(null);\ntableBodyContextSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"tbody\": true, \"tfoot\": true, \"thead\": true, \"template\": true, \"html\": true\n};\n\nvar tableRowContextSet = Object.create(null);\ntableRowContextSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"tr\": true, \"template\": true, \"html\": true\n};\n\n// See http://www.w3.org/TR/html5/forms.html#form-associated-element\nvar formassociatedSet = Object.create(null);\nformassociatedSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"button\": true, \"fieldset\": true, \"input\": true, \"keygen\": true,\n  \"object\": true, \"output\": true, \"select\": true, \"textarea\": true,\n  \"img\": true\n};\n\nvar inScopeSet = Object.create(null);\ninScopeSet[NAMESPACE.HTML]= {\n  __proto__: null,\n  \"applet\":true, \"caption\":true, \"html\":true, \"table\":true,\n  \"td\":true, \"th\":true, \"marquee\":true, \"object\":true,\n  \"template\":true\n};\ninScopeSet[NAMESPACE.MATHML] = {\n  __proto__: null,\n  \"mi\":true, \"mo\":true, \"mn\":true, \"ms\":true,\n  \"mtext\":true, \"annotation-xml\":true\n};\ninScopeSet[NAMESPACE.SVG] = {\n  __proto__: null,\n  \"foreignObject\":true, \"desc\":true, \"title\":true\n};\n\nvar inListItemScopeSet = Object.create(inScopeSet);\ninListItemScopeSet[NAMESPACE.HTML] =\n  Object.create(inScopeSet[NAMESPACE.HTML]);\ninListItemScopeSet[NAMESPACE.HTML].ol = true;\ninListItemScopeSet[NAMESPACE.HTML].ul = true;\n\nvar inButtonScopeSet = Object.create(inScopeSet);\ninButtonScopeSet[NAMESPACE.HTML] =\n  Object.create(inScopeSet[NAMESPACE.HTML]);\ninButtonScopeSet[NAMESPACE.HTML].button = true;\n\nvar inTableScopeSet = Object.create(null);\ninTableScopeSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"html\":true, \"table\":true, \"template\":true\n};\n\n// The set of elements for select scope is the everything *except* these\nvar invertedSelectScopeSet = Object.create(null);\ninvertedSelectScopeSet[NAMESPACE.HTML] = {\n  __proto__: null,\n  \"optgroup\":true, \"option\":true\n};\n\nvar mathmlTextIntegrationPointSet = Object.create(null);\nmathmlTextIntegrationPointSet[NAMESPACE.MATHML] = {\n  __proto__: null,\n  mi: true,\n  mo: true,\n  mn: true,\n  ms: true,\n  mtext: true\n};\n\nvar htmlIntegrationPointSet = Object.create(null);\nhtmlIntegrationPointSet[NAMESPACE.SVG] = {\n  __proto__: null,\n  foreignObject: true,\n  desc: true,\n  title: true\n};\n\nvar foreignAttributes = {\n  __proto__: null,\n  \"xlink:actuate\": NAMESPACE.XLINK, \"xlink:arcrole\": NAMESPACE.XLINK,\n  \"xlink:href\":   NAMESPACE.XLINK,  \"xlink:role\":    NAMESPACE.XLINK,\n  \"xlink:show\":   NAMESPACE.XLINK,  \"xlink:title\":   NAMESPACE.XLINK,\n  \"xlink:type\":   NAMESPACE.XLINK,  \"xml:base\":      NAMESPACE.XML,\n  \"xml:lang\":     NAMESPACE.XML,    \"xml:space\":     NAMESPACE.XML,\n  \"xmlns\":        NAMESPACE.XMLNS,  \"xmlns:xlink\":   NAMESPACE.XMLNS\n};\n\n\n// Lowercase to mixed case mapping for SVG attributes and tagnames\nvar svgAttrAdjustments = {\n  __proto__: null,\n  attributename: \"attributeName\", attributetype: \"attributeType\",\n  basefrequency: \"baseFrequency\", baseprofile: \"baseProfile\",\n  calcmode: \"calcMode\", clippathunits: \"clipPathUnits\",\n  diffuseconstant: \"diffuseConstant\",\n  edgemode: \"edgeMode\",\n  filterunits: \"filterUnits\",\n  glyphref: \"glyphRef\", gradienttransform: \"gradientTransform\",\n  gradientunits: \"gradientUnits\", kernelmatrix: \"kernelMatrix\",\n  kernelunitlength: \"kernelUnitLength\", keypoints: \"keyPoints\",\n  keysplines: \"keySplines\", keytimes: \"keyTimes\",\n  lengthadjust: \"lengthAdjust\", limitingconeangle: \"limitingConeAngle\",\n  markerheight: \"markerHeight\", markerunits: \"markerUnits\",\n  markerwidth: \"markerWidth\", maskcontentunits: \"maskContentUnits\",\n  maskunits: \"maskUnits\", numoctaves: \"numOctaves\",\n  pathlength: \"pathLength\", patterncontentunits: \"patternContentUnits\",\n  patterntransform: \"patternTransform\", patternunits: \"patternUnits\",\n  pointsatx: \"pointsAtX\", pointsaty: \"pointsAtY\",\n  pointsatz: \"pointsAtZ\", preservealpha: \"preserveAlpha\",\n  preserveaspectratio: \"preserveAspectRatio\",\n  primitiveunits: \"primitiveUnits\", refx: \"refX\",\n  refy: \"refY\", repeatcount: \"repeatCount\",\n  repeatdur: \"repeatDur\", requiredextensions: \"requiredExtensions\",\n  requiredfeatures: \"requiredFeatures\",\n  specularconstant: \"specularConstant\",\n  specularexponent: \"specularExponent\", spreadmethod: \"spreadMethod\",\n  startoffset: \"startOffset\", stddeviation: \"stdDeviation\",\n  stitchtiles: \"stitchTiles\", surfacescale: \"surfaceScale\",\n  systemlanguage: \"systemLanguage\", tablevalues: \"tableValues\",\n  targetx: \"targetX\", targety: \"targetY\",\n  textlength: \"textLength\", viewbox: \"viewBox\",\n  viewtarget: \"viewTarget\", xchannelselector: \"xChannelSelector\",\n  ychannelselector: \"yChannelSelector\", zoomandpan: \"zoomAndPan\"\n};\n\nvar svgTagNameAdjustments = {\n  __proto__: null,\n  altglyph: \"altGlyph\", altglyphdef: \"altGlyphDef\",\n  altglyphitem: \"altGlyphItem\", animatecolor: \"animateColor\",\n  animatemotion: \"animateMotion\", animatetransform: \"animateTransform\",\n  clippath: \"clipPath\", feblend: \"feBlend\",\n  fecolormatrix: \"feColorMatrix\",\n  fecomponenttransfer: \"feComponentTransfer\", fecomposite: \"feComposite\",\n  feconvolvematrix: \"feConvolveMatrix\",\n  fediffuselighting: \"feDiffuseLighting\",\n  fedisplacementmap: \"feDisplacementMap\",\n  fedistantlight: \"feDistantLight\", feflood: \"feFlood\",\n  fefunca: \"feFuncA\", fefuncb: \"feFuncB\",\n  fefuncg: \"feFuncG\", fefuncr: \"feFuncR\",\n  fegaussianblur: \"feGaussianBlur\", feimage: \"feImage\",\n  femerge: \"feMerge\", femergenode: \"feMergeNode\",\n  femorphology: \"feMorphology\", feoffset: \"feOffset\",\n  fepointlight: \"fePointLight\", fespecularlighting: \"feSpecularLighting\",\n  fespotlight: \"feSpotLight\", fetile: \"feTile\",\n  feturbulence: \"feTurbulence\", foreignobject: \"foreignObject\",\n  glyphref: \"glyphRef\", lineargradient: \"linearGradient\",\n  radialgradient: \"radialGradient\", textpath: \"textPath\"\n};\n\n\n// Data for parsing numeric and named character references\n// These next 3 objects are direct translations of tables\n// in the HTML spec into JavaScript object format\nvar numericCharRefReplacements = {\n  __proto__: null,\n  0x00:0xFFFD, 0x80:0x20AC, 0x82:0x201A, 0x83:0x0192, 0x84:0x201E,\n  0x85:0x2026, 0x86:0x2020, 0x87:0x2021, 0x88:0x02C6, 0x89:0x2030,\n  0x8A:0x0160, 0x8B:0x2039, 0x8C:0x0152, 0x8E:0x017D, 0x91:0x2018,\n  0x92:0x2019, 0x93:0x201C, 0x94:0x201D, 0x95:0x2022, 0x96:0x2013,\n  0x97:0x2014, 0x98:0x02DC, 0x99:0x2122, 0x9A:0x0161, 0x9B:0x203A,\n  0x9C:0x0153, 0x9E:0x017E, 0x9F:0x0178\n};\n\n/*\n * This table is generated with test/tools/update-entities.js\n */\nvar namedCharRefs = {\n  __proto__: null,\n  \"AElig\":0xc6, \"AElig;\":0xc6,\n  \"AMP\":0x26, \"AMP;\":0x26,\n  \"Aacute\":0xc1, \"Aacute;\":0xc1,\n  \"Abreve;\":0x102, \"Acirc\":0xc2,\n  \"Acirc;\":0xc2, \"Acy;\":0x410,\n  \"Afr;\":[0xd835,0xdd04], \"Agrave\":0xc0,\n  \"Agrave;\":0xc0, \"Alpha;\":0x391,\n  \"Amacr;\":0x100, \"And;\":0x2a53,\n  \"Aogon;\":0x104, \"Aopf;\":[0xd835,0xdd38],\n  \"ApplyFunction;\":0x2061, \"Aring\":0xc5,\n  \"Aring;\":0xc5, \"Ascr;\":[0xd835,0xdc9c],\n  \"Assign;\":0x2254, \"Atilde\":0xc3,\n  \"Atilde;\":0xc3, \"Auml\":0xc4,\n  \"Auml;\":0xc4, \"Backslash;\":0x2216,\n  \"Barv;\":0x2ae7, \"Barwed;\":0x2306,\n  \"Bcy;\":0x411, \"Because;\":0x2235,\n  \"Bernoullis;\":0x212c, \"Beta;\":0x392,\n  \"Bfr;\":[0xd835,0xdd05], \"Bopf;\":[0xd835,0xdd39],\n  \"Breve;\":0x2d8, \"Bscr;\":0x212c,\n  \"Bumpeq;\":0x224e, \"CHcy;\":0x427,\n  \"COPY\":0xa9, \"COPY;\":0xa9,\n  \"Cacute;\":0x106, \"Cap;\":0x22d2,\n  \"CapitalDifferentialD;\":0x2145, \"Cayleys;\":0x212d,\n  \"Ccaron;\":0x10c, \"Ccedil\":0xc7,\n  \"Ccedil;\":0xc7, \"Ccirc;\":0x108,\n  \"Cconint;\":0x2230, \"Cdot;\":0x10a,\n  \"Cedilla;\":0xb8, \"CenterDot;\":0xb7,\n  \"Cfr;\":0x212d, \"Chi;\":0x3a7,\n  \"CircleDot;\":0x2299, \"CircleMinus;\":0x2296,\n  \"CirclePlus;\":0x2295, \"CircleTimes;\":0x2297,\n  \"ClockwiseContourIntegral;\":0x2232, \"CloseCurlyDoubleQuote;\":0x201d,\n  \"CloseCurlyQuote;\":0x2019, \"Colon;\":0x2237,\n  \"Colone;\":0x2a74, \"Congruent;\":0x2261,\n  \"Conint;\":0x222f, \"ContourIntegral;\":0x222e,\n  \"Copf;\":0x2102, \"Coproduct;\":0x2210,\n  \"CounterClockwiseContourIntegral;\":0x2233, \"Cross;\":0x2a2f,\n  \"Cscr;\":[0xd835,0xdc9e], \"Cup;\":0x22d3,\n  \"CupCap;\":0x224d, \"DD;\":0x2145,\n  \"DDotrahd;\":0x2911, \"DJcy;\":0x402,\n  \"DScy;\":0x405, \"DZcy;\":0x40f,\n  \"Dagger;\":0x2021, \"Darr;\":0x21a1,\n  \"Dashv;\":0x2ae4, \"Dcaron;\":0x10e,\n  \"Dcy;\":0x414, \"Del;\":0x2207,\n  \"Delta;\":0x394, \"Dfr;\":[0xd835,0xdd07],\n  \"DiacriticalAcute;\":0xb4, \"DiacriticalDot;\":0x2d9,\n  \"DiacriticalDoubleAcute;\":0x2dd, \"DiacriticalGrave;\":0x60,\n  \"DiacriticalTilde;\":0x2dc, \"Diamond;\":0x22c4,\n  \"DifferentialD;\":0x2146, \"Dopf;\":[0xd835,0xdd3b],\n  \"Dot;\":0xa8, \"DotDot;\":0x20dc,\n  \"DotEqual;\":0x2250, \"DoubleContourIntegral;\":0x222f,\n  \"DoubleDot;\":0xa8, \"DoubleDownArrow;\":0x21d3,\n  \"DoubleLeftArrow;\":0x21d0, \"DoubleLeftRightArrow;\":0x21d4,\n  \"DoubleLeftTee;\":0x2ae4, \"DoubleLongLeftArrow;\":0x27f8,\n  \"DoubleLongLeftRightArrow;\":0x27fa, \"DoubleLongRightArrow;\":0x27f9,\n  \"DoubleRightArrow;\":0x21d2, \"DoubleRightTee;\":0x22a8,\n  \"DoubleUpArrow;\":0x21d1, \"DoubleUpDownArrow;\":0x21d5,\n  \"DoubleVerticalBar;\":0x2225, \"DownArrow;\":0x2193,\n  \"DownArrowBar;\":0x2913, \"DownArrowUpArrow;\":0x21f5,\n  \"DownBreve;\":0x311, \"DownLeftRightVector;\":0x2950,\n  \"DownLeftTeeVector;\":0x295e, \"DownLeftVector;\":0x21bd,\n  \"DownLeftVectorBar;\":0x2956, \"DownRightTeeVector;\":0x295f,\n  \"DownRightVector;\":0x21c1, \"DownRightVectorBar;\":0x2957,\n  \"DownTee;\":0x22a4, \"DownTeeArrow;\":0x21a7,\n  \"Downarrow;\":0x21d3, \"Dscr;\":[0xd835,0xdc9f],\n  \"Dstrok;\":0x110, \"ENG;\":0x14a,\n  \"ETH\":0xd0, \"ETH;\":0xd0,\n  \"Eacute\":0xc9, \"Eacute;\":0xc9,\n  \"Ecaron;\":0x11a, \"Ecirc\":0xca,\n  \"Ecirc;\":0xca, \"Ecy;\":0x42d,\n  \"Edot;\":0x116, \"Efr;\":[0xd835,0xdd08],\n  \"Egrave\":0xc8, \"Egrave;\":0xc8,\n  \"Element;\":0x2208, \"Emacr;\":0x112,\n  \"EmptySmallSquare;\":0x25fb, \"EmptyVerySmallSquare;\":0x25ab,\n  \"Eogon;\":0x118, \"Eopf;\":[0xd835,0xdd3c],\n  \"Epsilon;\":0x395, \"Equal;\":0x2a75,\n  \"EqualTilde;\":0x2242, \"Equilibrium;\":0x21cc,\n  \"Escr;\":0x2130, \"Esim;\":0x2a73,\n  \"Eta;\":0x397, \"Euml\":0xcb,\n  \"Euml;\":0xcb, \"Exists;\":0x2203,\n  \"ExponentialE;\":0x2147, \"Fcy;\":0x424,\n  \"Ffr;\":[0xd835,0xdd09], \"FilledSmallSquare;\":0x25fc,\n  \"FilledVerySmallSquare;\":0x25aa, \"Fopf;\":[0xd835,0xdd3d],\n  \"ForAll;\":0x2200, \"Fouriertrf;\":0x2131,\n  \"Fscr;\":0x2131, \"GJcy;\":0x403,\n  \"GT\":0x3e, \"GT;\":0x3e,\n  \"Gamma;\":0x393, \"Gammad;\":0x3dc,\n  \"Gbreve;\":0x11e, \"Gcedil;\":0x122,\n  \"Gcirc;\":0x11c, \"Gcy;\":0x413,\n  \"Gdot;\":0x120, \"Gfr;\":[0xd835,0xdd0a],\n  \"Gg;\":0x22d9, \"Gopf;\":[0xd835,0xdd3e],\n  \"GreaterEqual;\":0x2265, \"GreaterEqualLess;\":0x22db,\n  \"GreaterFullEqual;\":0x2267, \"GreaterGreater;\":0x2aa2,\n  \"GreaterLess;\":0x2277, \"GreaterSlantEqual;\":0x2a7e,\n  \"GreaterTilde;\":0x2273, \"Gscr;\":[0xd835,0xdca2],\n  \"Gt;\":0x226b, \"HARDcy;\":0x42a,\n  \"Hacek;\":0x2c7, \"Hat;\":0x5e,\n  \"Hcirc;\":0x124, \"Hfr;\":0x210c,\n  \"HilbertSpace;\":0x210b, \"Hopf;\":0x210d,\n  \"HorizontalLine;\":0x2500, \"Hscr;\":0x210b,\n  \"Hstrok;\":0x126, \"HumpDownHump;\":0x224e,\n  \"HumpEqual;\":0x224f, \"IEcy;\":0x415,\n  \"IJlig;\":0x132, \"IOcy;\":0x401,\n  \"Iacute\":0xcd, \"Iacute;\":0xcd,\n  \"Icirc\":0xce, \"Icirc;\":0xce,\n  \"Icy;\":0x418, \"Idot;\":0x130,\n  \"Ifr;\":0x2111, \"Igrave\":0xcc,\n  \"Igrave;\":0xcc, \"Im;\":0x2111,\n  \"Imacr;\":0x12a, \"ImaginaryI;\":0x2148,\n  \"Implies;\":0x21d2, \"Int;\":0x222c,\n  \"Integral;\":0x222b, \"Intersection;\":0x22c2,\n  \"InvisibleComma;\":0x2063, \"InvisibleTimes;\":0x2062,\n  \"Iogon;\":0x12e, \"Iopf;\":[0xd835,0xdd40],\n  \"Iota;\":0x399, \"Iscr;\":0x2110,\n  \"Itilde;\":0x128, \"Iukcy;\":0x406,\n  \"Iuml\":0xcf, \"Iuml;\":0xcf,\n  \"Jcirc;\":0x134, \"Jcy;\":0x419,\n  \"Jfr;\":[0xd835,0xdd0d], \"Jopf;\":[0xd835,0xdd41],\n  \"Jscr;\":[0xd835,0xdca5], \"Jsercy;\":0x408,\n  \"Jukcy;\":0x404, \"KHcy;\":0x425,\n  \"KJcy;\":0x40c, \"Kappa;\":0x39a,\n  \"Kcedil;\":0x136, \"Kcy;\":0x41a,\n  \"Kfr;\":[0xd835,0xdd0e], \"Kopf;\":[0xd835,0xdd42],\n  \"Kscr;\":[0xd835,0xdca6], \"LJcy;\":0x409,\n  \"LT\":0x3c, \"LT;\":0x3c,\n  \"Lacute;\":0x139, \"Lambda;\":0x39b,\n  \"Lang;\":0x27ea, \"Laplacetrf;\":0x2112,\n  \"Larr;\":0x219e, \"Lcaron;\":0x13d,\n  \"Lcedil;\":0x13b, \"Lcy;\":0x41b,\n  \"LeftAngleBracket;\":0x27e8, \"LeftArrow;\":0x2190,\n  \"LeftArrowBar;\":0x21e4, \"LeftArrowRightArrow;\":0x21c6,\n  \"LeftCeiling;\":0x2308, \"LeftDoubleBracket;\":0x27e6,\n  \"LeftDownTeeVector;\":0x2961, \"LeftDownVector;\":0x21c3,\n  \"LeftDownVectorBar;\":0x2959, \"LeftFloor;\":0x230a,\n  \"LeftRightArrow;\":0x2194, \"LeftRightVector;\":0x294e,\n  \"LeftTee;\":0x22a3, \"LeftTeeArrow;\":0x21a4,\n  \"LeftTeeVector;\":0x295a, \"LeftTriangle;\":0x22b2,\n  \"LeftTriangleBar;\":0x29cf, \"LeftTriangleEqual;\":0x22b4,\n  \"LeftUpDownVector;\":0x2951, \"LeftUpTeeVector;\":0x2960,\n  \"LeftUpVector;\":0x21bf, \"LeftUpVectorBar;\":0x2958,\n  \"LeftVector;\":0x21bc, \"LeftVectorBar;\":0x2952,\n  \"Leftarrow;\":0x21d0, \"Leftrightarrow;\":0x21d4,\n  \"LessEqualGreater;\":0x22da, \"LessFullEqual;\":0x2266,\n  \"LessGreater;\":0x2276, \"LessLess;\":0x2aa1,\n  \"LessSlantEqual;\":0x2a7d, \"LessTilde;\":0x2272,\n  \"Lfr;\":[0xd835,0xdd0f], \"Ll;\":0x22d8,\n  \"Lleftarrow;\":0x21da, \"Lmidot;\":0x13f,\n  \"LongLeftArrow;\":0x27f5, \"LongLeftRightArrow;\":0x27f7,\n  \"LongRightArrow;\":0x27f6, \"Longleftarrow;\":0x27f8,\n  \"Longleftrightarrow;\":0x27fa, \"Longrightarrow;\":0x27f9,\n  \"Lopf;\":[0xd835,0xdd43], \"LowerLeftArrow;\":0x2199,\n  \"LowerRightArrow;\":0x2198, \"Lscr;\":0x2112,\n  \"Lsh;\":0x21b0, \"Lstrok;\":0x141,\n  \"Lt;\":0x226a, \"Map;\":0x2905,\n  \"Mcy;\":0x41c, \"MediumSpace;\":0x205f,\n  \"Mellintrf;\":0x2133, \"Mfr;\":[0xd835,0xdd10],\n  \"MinusPlus;\":0x2213, \"Mopf;\":[0xd835,0xdd44],\n  \"Mscr;\":0x2133, \"Mu;\":0x39c,\n  \"NJcy;\":0x40a, \"Nacute;\":0x143,\n  \"Ncaron;\":0x147, \"Ncedil;\":0x145,\n  \"Ncy;\":0x41d, \"NegativeMediumSpace;\":0x200b,\n  \"NegativeThickSpace;\":0x200b, \"NegativeThinSpace;\":0x200b,\n  \"NegativeVeryThinSpace;\":0x200b, \"NestedGreaterGreater;\":0x226b,\n  \"NestedLessLess;\":0x226a, \"NewLine;\":0xa,\n  \"Nfr;\":[0xd835,0xdd11], \"NoBreak;\":0x2060,\n  \"NonBreakingSpace;\":0xa0, \"Nopf;\":0x2115,\n  \"Not;\":0x2aec, \"NotCongruent;\":0x2262,\n  \"NotCupCap;\":0x226d, \"NotDoubleVerticalBar;\":0x2226,\n  \"NotElement;\":0x2209, \"NotEqual;\":0x2260,\n  \"NotEqualTilde;\":[0x2242,0x338], \"NotExists;\":0x2204,\n  \"NotGreater;\":0x226f, \"NotGreaterEqual;\":0x2271,\n  \"NotGreaterFullEqual;\":[0x2267,0x338], \"NotGreaterGreater;\":[0x226b,0x338],\n  \"NotGreaterLess;\":0x2279, \"NotGreaterSlantEqual;\":[0x2a7e,0x338],\n  \"NotGreaterTilde;\":0x2275, \"NotHumpDownHump;\":[0x224e,0x338],\n  \"NotHumpEqual;\":[0x224f,0x338], \"NotLeftTriangle;\":0x22ea,\n  \"NotLeftTriangleBar;\":[0x29cf,0x338], \"NotLeftTriangleEqual;\":0x22ec,\n  \"NotLess;\":0x226e, \"NotLessEqual;\":0x2270,\n  \"NotLessGreater;\":0x2278, \"NotLessLess;\":[0x226a,0x338],\n  \"NotLessSlantEqual;\":[0x2a7d,0x338], \"NotLessTilde;\":0x2274,\n  \"NotNestedGreaterGreater;\":[0x2aa2,0x338], \"NotNestedLessLess;\":[0x2aa1,0x338],\n  \"NotPrecedes;\":0x2280, \"NotPrecedesEqual;\":[0x2aaf,0x338],\n  \"NotPrecedesSlantEqual;\":0x22e0, \"NotReverseElement;\":0x220c,\n  \"NotRightTriangle;\":0x22eb, \"NotRightTriangleBar;\":[0x29d0,0x338],\n  \"NotRightTriangleEqual;\":0x22ed, \"NotSquareSubset;\":[0x228f,0x338],\n  \"NotSquareSubsetEqual;\":0x22e2, \"NotSquareSuperset;\":[0x2290,0x338],\n  \"NotSquareSupersetEqual;\":0x22e3, \"NotSubset;\":[0x2282,0x20d2],\n  \"NotSubsetEqual;\":0x2288, \"NotSucceeds;\":0x2281,\n  \"NotSucceedsEqual;\":[0x2ab0,0x338], \"NotSucceedsSlantEqual;\":0x22e1,\n  \"NotSucceedsTilde;\":[0x227f,0x338], \"NotSuperset;\":[0x2283,0x20d2],\n  \"NotSupersetEqual;\":0x2289, \"NotTilde;\":0x2241,\n  \"NotTildeEqual;\":0x2244, \"NotTildeFullEqual;\":0x2247,\n  \"NotTildeTilde;\":0x2249, \"NotVerticalBar;\":0x2224,\n  \"Nscr;\":[0xd835,0xdca9], \"Ntilde\":0xd1,\n  \"Ntilde;\":0xd1, \"Nu;\":0x39d,\n  \"OElig;\":0x152, \"Oacute\":0xd3,\n  \"Oacute;\":0xd3, \"Ocirc\":0xd4,\n  \"Ocirc;\":0xd4, \"Ocy;\":0x41e,\n  \"Odblac;\":0x150, \"Ofr;\":[0xd835,0xdd12],\n  \"Ograve\":0xd2, \"Ograve;\":0xd2,\n  \"Omacr;\":0x14c, \"Omega;\":0x3a9,\n  \"Omicron;\":0x39f, \"Oopf;\":[0xd835,0xdd46],\n  \"OpenCurlyDoubleQuote;\":0x201c, \"OpenCurlyQuote;\":0x2018,\n  \"Or;\":0x2a54, \"Oscr;\":[0xd835,0xdcaa],\n  \"Oslash\":0xd8, \"Oslash;\":0xd8,\n  \"Otilde\":0xd5, \"Otilde;\":0xd5,\n  \"Otimes;\":0x2a37, \"Ouml\":0xd6,\n  \"Ouml;\":0xd6, \"OverBar;\":0x203e,\n  \"OverBrace;\":0x23de, \"OverBracket;\":0x23b4,\n  \"OverParenthesis;\":0x23dc, \"PartialD;\":0x2202,\n  \"Pcy;\":0x41f, \"Pfr;\":[0xd835,0xdd13],\n  \"Phi;\":0x3a6, \"Pi;\":0x3a0,\n  \"PlusMinus;\":0xb1, \"Poincareplane;\":0x210c,\n  \"Popf;\":0x2119, \"Pr;\":0x2abb,\n  \"Precedes;\":0x227a, \"PrecedesEqual;\":0x2aaf,\n  \"PrecedesSlantEqual;\":0x227c, \"PrecedesTilde;\":0x227e,\n  \"Prime;\":0x2033, \"Product;\":0x220f,\n  \"Proportion;\":0x2237, \"Proportional;\":0x221d,\n  \"Pscr;\":[0xd835,0xdcab], \"Psi;\":0x3a8,\n  \"QUOT\":0x22, \"QUOT;\":0x22,\n  \"Qfr;\":[0xd835,0xdd14], \"Qopf;\":0x211a,\n  \"Qscr;\":[0xd835,0xdcac], \"RBarr;\":0x2910,\n  \"REG\":0xae, \"REG;\":0xae,\n  \"Racute;\":0x154, \"Rang;\":0x27eb,\n  \"Rarr;\":0x21a0, \"Rarrtl;\":0x2916,\n  \"Rcaron;\":0x158, \"Rcedil;\":0x156,\n  \"Rcy;\":0x420, \"Re;\":0x211c,\n  \"ReverseElement;\":0x220b, \"ReverseEquilibrium;\":0x21cb,\n  \"ReverseUpEquilibrium;\":0x296f, \"Rfr;\":0x211c,\n  \"Rho;\":0x3a1, \"RightAngleBracket;\":0x27e9,\n  \"RightArrow;\":0x2192, \"RightArrowBar;\":0x21e5,\n  \"RightArrowLeftArrow;\":0x21c4, \"RightCeiling;\":0x2309,\n  \"RightDoubleBracket;\":0x27e7, \"RightDownTeeVector;\":0x295d,\n  \"RightDownVector;\":0x21c2, \"RightDownVectorBar;\":0x2955,\n  \"RightFloor;\":0x230b, \"RightTee;\":0x22a2,\n  \"RightTeeArrow;\":0x21a6, \"RightTeeVector;\":0x295b,\n  \"RightTriangle;\":0x22b3, \"RightTriangleBar;\":0x29d0,\n  \"RightTriangleEqual;\":0x22b5, \"RightUpDownVector;\":0x294f,\n  \"RightUpTeeVector;\":0x295c, \"RightUpVector;\":0x21be,\n  \"RightUpVectorBar;\":0x2954, \"RightVector;\":0x21c0,\n  \"RightVectorBar;\":0x2953, \"Rightarrow;\":0x21d2,\n  \"Ropf;\":0x211d, \"RoundImplies;\":0x2970,\n  \"Rrightarrow;\":0x21db, \"Rscr;\":0x211b,\n  \"Rsh;\":0x21b1, \"RuleDelayed;\":0x29f4,\n  \"SHCHcy;\":0x429, \"SHcy;\":0x428,\n  \"SOFTcy;\":0x42c, \"Sacute;\":0x15a,\n  \"Sc;\":0x2abc, \"Scaron;\":0x160,\n  \"Scedil;\":0x15e, \"Scirc;\":0x15c,\n  \"Scy;\":0x421, \"Sfr;\":[0xd835,0xdd16],\n  \"ShortDownArrow;\":0x2193, \"ShortLeftArrow;\":0x2190,\n  \"ShortRightArrow;\":0x2192, \"ShortUpArrow;\":0x2191,\n  \"Sigma;\":0x3a3, \"SmallCircle;\":0x2218,\n  \"Sopf;\":[0xd835,0xdd4a], \"Sqrt;\":0x221a,\n  \"Square;\":0x25a1, \"SquareIntersection;\":0x2293,\n  \"SquareSubset;\":0x228f, \"SquareSubsetEqual;\":0x2291,\n  \"SquareSuperset;\":0x2290, \"SquareSupersetEqual;\":0x2292,\n  \"SquareUnion;\":0x2294, \"Sscr;\":[0xd835,0xdcae],\n  \"Star;\":0x22c6, \"Sub;\":0x22d0,\n  \"Subset;\":0x22d0, \"SubsetEqual;\":0x2286,\n  \"Succeeds;\":0x227b, \"SucceedsEqual;\":0x2ab0,\n  \"SucceedsSlantEqual;\":0x227d, \"SucceedsTilde;\":0x227f,\n  \"SuchThat;\":0x220b, \"Sum;\":0x2211,\n  \"Sup;\":0x22d1, \"Superset;\":0x2283,\n  \"SupersetEqual;\":0x2287, \"Supset;\":0x22d1,\n  \"THORN\":0xde, \"THORN;\":0xde,\n  \"TRADE;\":0x2122, \"TSHcy;\":0x40b,\n  \"TScy;\":0x426, \"Tab;\":0x9,\n  \"Tau;\":0x3a4, \"Tcaron;\":0x164,\n  \"Tcedil;\":0x162, \"Tcy;\":0x422,\n  \"Tfr;\":[0xd835,0xdd17], \"Therefore;\":0x2234,\n  \"Theta;\":0x398, \"ThickSpace;\":[0x205f,0x200a],\n  \"ThinSpace;\":0x2009, \"Tilde;\":0x223c,\n  \"TildeEqual;\":0x2243, \"TildeFullEqual;\":0x2245,\n  \"TildeTilde;\":0x2248, \"Topf;\":[0xd835,0xdd4b],\n  \"TripleDot;\":0x20db, \"Tscr;\":[0xd835,0xdcaf],\n  \"Tstrok;\":0x166, \"Uacute\":0xda,\n  \"Uacute;\":0xda, \"Uarr;\":0x219f,\n  \"Uarrocir;\":0x2949, \"Ubrcy;\":0x40e,\n  \"Ubreve;\":0x16c, \"Ucirc\":0xdb,\n  \"Ucirc;\":0xdb, \"Ucy;\":0x423,\n  \"Udblac;\":0x170, \"Ufr;\":[0xd835,0xdd18],\n  \"Ugrave\":0xd9, \"Ugrave;\":0xd9,\n  \"Umacr;\":0x16a, \"UnderBar;\":0x5f,\n  \"UnderBrace;\":0x23df, \"UnderBracket;\":0x23b5,\n  \"UnderParenthesis;\":0x23dd, \"Union;\":0x22c3,\n  \"UnionPlus;\":0x228e, \"Uogon;\":0x172,\n  \"Uopf;\":[0xd835,0xdd4c], \"UpArrow;\":0x2191,\n  \"UpArrowBar;\":0x2912, \"UpArrowDownArrow;\":0x21c5,\n  \"UpDownArrow;\":0x2195, \"UpEquilibrium;\":0x296e,\n  \"UpTee;\":0x22a5, \"UpTeeArrow;\":0x21a5,\n  \"Uparrow;\":0x21d1, \"Updownarrow;\":0x21d5,\n  \"UpperLeftArrow;\":0x2196, \"UpperRightArrow;\":0x2197,\n  \"Upsi;\":0x3d2, \"Upsilon;\":0x3a5,\n  \"Uring;\":0x16e, \"Uscr;\":[0xd835,0xdcb0],\n  \"Utilde;\":0x168, \"Uuml\":0xdc,\n  \"Uuml;\":0xdc, \"VDash;\":0x22ab,\n  \"Vbar;\":0x2aeb, \"Vcy;\":0x412,\n  \"Vdash;\":0x22a9, \"Vdashl;\":0x2ae6,\n  \"Vee;\":0x22c1, \"Verbar;\":0x2016,\n  \"Vert;\":0x2016, \"VerticalBar;\":0x2223,\n  \"VerticalLine;\":0x7c, \"VerticalSeparator;\":0x2758,\n  \"VerticalTilde;\":0x2240, \"VeryThinSpace;\":0x200a,\n  \"Vfr;\":[0xd835,0xdd19], \"Vopf;\":[0xd835,0xdd4d],\n  \"Vscr;\":[0xd835,0xdcb1], \"Vvdash;\":0x22aa,\n  \"Wcirc;\":0x174, \"Wedge;\":0x22c0,\n  \"Wfr;\":[0xd835,0xdd1a], \"Wopf;\":[0xd835,0xdd4e],\n  \"Wscr;\":[0xd835,0xdcb2], \"Xfr;\":[0xd835,0xdd1b],\n  \"Xi;\":0x39e, \"Xopf;\":[0xd835,0xdd4f],\n  \"Xscr;\":[0xd835,0xdcb3], \"YAcy;\":0x42f,\n  \"YIcy;\":0x407, \"YUcy;\":0x42e,\n  \"Yacute\":0xdd, \"Yacute;\":0xdd,\n  \"Ycirc;\":0x176, \"Ycy;\":0x42b,\n  \"Yfr;\":[0xd835,0xdd1c], \"Yopf;\":[0xd835,0xdd50],\n  \"Yscr;\":[0xd835,0xdcb4], \"Yuml;\":0x178,\n  \"ZHcy;\":0x416, \"Zacute;\":0x179,\n  \"Zcaron;\":0x17d, \"Zcy;\":0x417,\n  \"Zdot;\":0x17b, \"ZeroWidthSpace;\":0x200b,\n  \"Zeta;\":0x396, \"Zfr;\":0x2128,\n  \"Zopf;\":0x2124, \"Zscr;\":[0xd835,0xdcb5],\n  \"aacute\":0xe1, \"aacute;\":0xe1,\n  \"abreve;\":0x103, \"ac;\":0x223e,\n  \"acE;\":[0x223e,0x333], \"acd;\":0x223f,\n  \"acirc\":0xe2, \"acirc;\":0xe2,\n  \"acute\":0xb4, \"acute;\":0xb4,\n  \"acy;\":0x430, \"aelig\":0xe6,\n  \"aelig;\":0xe6, \"af;\":0x2061,\n  \"afr;\":[0xd835,0xdd1e], \"agrave\":0xe0,\n  \"agrave;\":0xe0, \"alefsym;\":0x2135,\n  \"aleph;\":0x2135, \"alpha;\":0x3b1,\n  \"amacr;\":0x101, \"amalg;\":0x2a3f,\n  \"amp\":0x26, \"amp;\":0x26,\n  \"and;\":0x2227, \"andand;\":0x2a55,\n  \"andd;\":0x2a5c, \"andslope;\":0x2a58,\n  \"andv;\":0x2a5a, \"ang;\":0x2220,\n  \"ange;\":0x29a4, \"angle;\":0x2220,\n  \"angmsd;\":0x2221, \"angmsdaa;\":0x29a8,\n  \"angmsdab;\":0x29a9, \"angmsdac;\":0x29aa,\n  \"angmsdad;\":0x29ab, \"angmsdae;\":0x29ac,\n  \"angmsdaf;\":0x29ad, \"angmsdag;\":0x29ae,\n  \"angmsdah;\":0x29af, \"angrt;\":0x221f,\n  \"angrtvb;\":0x22be, \"angrtvbd;\":0x299d,\n  \"angsph;\":0x2222, \"angst;\":0xc5,\n  \"angzarr;\":0x237c, \"aogon;\":0x105,\n  \"aopf;\":[0xd835,0xdd52], \"ap;\":0x2248,\n  \"apE;\":0x2a70, \"apacir;\":0x2a6f,\n  \"ape;\":0x224a, \"apid;\":0x224b,\n  \"apos;\":0x27, \"approx;\":0x2248,\n  \"approxeq;\":0x224a, \"aring\":0xe5,\n  \"aring;\":0xe5, \"ascr;\":[0xd835,0xdcb6],\n  \"ast;\":0x2a, \"asymp;\":0x2248,\n  \"asympeq;\":0x224d, \"atilde\":0xe3,\n  \"atilde;\":0xe3, \"auml\":0xe4,\n  \"auml;\":0xe4, \"awconint;\":0x2233,\n  \"awint;\":0x2a11, \"bNot;\":0x2aed,\n  \"backcong;\":0x224c, \"backepsilon;\":0x3f6,\n  \"backprime;\":0x2035, \"backsim;\":0x223d,\n  \"backsimeq;\":0x22cd, \"barvee;\":0x22bd,\n  \"barwed;\":0x2305, \"barwedge;\":0x2305,\n  \"bbrk;\":0x23b5, \"bbrktbrk;\":0x23b6,\n  \"bcong;\":0x224c, \"bcy;\":0x431,\n  \"bdquo;\":0x201e, \"becaus;\":0x2235,\n  \"because;\":0x2235, \"bemptyv;\":0x29b0,\n  \"bepsi;\":0x3f6, \"bernou;\":0x212c,\n  \"beta;\":0x3b2, \"beth;\":0x2136,\n  \"between;\":0x226c, \"bfr;\":[0xd835,0xdd1f],\n  \"bigcap;\":0x22c2, \"bigcirc;\":0x25ef,\n  \"bigcup;\":0x22c3, \"bigodot;\":0x2a00,\n  \"bigoplus;\":0x2a01, \"bigotimes;\":0x2a02,\n  \"bigsqcup;\":0x2a06, \"bigstar;\":0x2605,\n  \"bigtriangledown;\":0x25bd, \"bigtriangleup;\":0x25b3,\n  \"biguplus;\":0x2a04, \"bigvee;\":0x22c1,\n  \"bigwedge;\":0x22c0, \"bkarow;\":0x290d,\n  \"blacklozenge;\":0x29eb, \"blacksquare;\":0x25aa,\n  \"blacktriangle;\":0x25b4, \"blacktriangledown;\":0x25be,\n  \"blacktriangleleft;\":0x25c2, \"blacktriangleright;\":0x25b8,\n  \"blank;\":0x2423, \"blk12;\":0x2592,\n  \"blk14;\":0x2591, \"blk34;\":0x2593,\n  \"block;\":0x2588, \"bne;\":[0x3d,0x20e5],\n  \"bnequiv;\":[0x2261,0x20e5], \"bnot;\":0x2310,\n  \"bopf;\":[0xd835,0xdd53], \"bot;\":0x22a5,\n  \"bottom;\":0x22a5, \"bowtie;\":0x22c8,\n  \"boxDL;\":0x2557, \"boxDR;\":0x2554,\n  \"boxDl;\":0x2556, \"boxDr;\":0x2553,\n  \"boxH;\":0x2550, \"boxHD;\":0x2566,\n  \"boxHU;\":0x2569, \"boxHd;\":0x2564,\n  \"boxHu;\":0x2567, \"boxUL;\":0x255d,\n  \"boxUR;\":0x255a, \"boxUl;\":0x255c,\n  \"boxUr;\":0x2559, \"boxV;\":0x2551,\n  \"boxVH;\":0x256c, \"boxVL;\":0x2563,\n  \"boxVR;\":0x2560, \"boxVh;\":0x256b,\n  \"boxVl;\":0x2562, \"boxVr;\":0x255f,\n  \"boxbox;\":0x29c9, \"boxdL;\":0x2555,\n  \"boxdR;\":0x2552, \"boxdl;\":0x2510,\n  \"boxdr;\":0x250c, \"boxh;\":0x2500,\n  \"boxhD;\":0x2565, \"boxhU;\":0x2568,\n  \"boxhd;\":0x252c, \"boxhu;\":0x2534,\n  \"boxminus;\":0x229f, \"boxplus;\":0x229e,\n  \"boxtimes;\":0x22a0, \"boxuL;\":0x255b,\n  \"boxuR;\":0x2558, \"boxul;\":0x2518,\n  \"boxur;\":0x2514, \"boxv;\":0x2502,\n  \"boxvH;\":0x256a, \"boxvL;\":0x2561,\n  \"boxvR;\":0x255e, \"boxvh;\":0x253c,\n  \"boxvl;\":0x2524, \"boxvr;\":0x251c,\n  \"bprime;\":0x2035, \"breve;\":0x2d8,\n  \"brvbar\":0xa6, \"brvbar;\":0xa6,\n  \"bscr;\":[0xd835,0xdcb7], \"bsemi;\":0x204f,\n  \"bsim;\":0x223d, \"bsime;\":0x22cd,\n  \"bsol;\":0x5c, \"bsolb;\":0x29c5,\n  \"bsolhsub;\":0x27c8, \"bull;\":0x2022,\n  \"bullet;\":0x2022, \"bump;\":0x224e,\n  \"bumpE;\":0x2aae, \"bumpe;\":0x224f,\n  \"bumpeq;\":0x224f, \"cacute;\":0x107,\n  \"cap;\":0x2229, \"capand;\":0x2a44,\n  \"capbrcup;\":0x2a49, \"capcap;\":0x2a4b,\n  \"capcup;\":0x2a47, \"capdot;\":0x2a40,\n  \"caps;\":[0x2229,0xfe00], \"caret;\":0x2041,\n  \"caron;\":0x2c7, \"ccaps;\":0x2a4d,\n  \"ccaron;\":0x10d, \"ccedil\":0xe7,\n  \"ccedil;\":0xe7, \"ccirc;\":0x109,\n  \"ccups;\":0x2a4c, \"ccupssm;\":0x2a50,\n  \"cdot;\":0x10b, \"cedil\":0xb8,\n  \"cedil;\":0xb8, \"cemptyv;\":0x29b2,\n  \"cent\":0xa2, \"cent;\":0xa2,\n  \"centerdot;\":0xb7, \"cfr;\":[0xd835,0xdd20],\n  \"chcy;\":0x447, \"check;\":0x2713,\n  \"checkmark;\":0x2713, \"chi;\":0x3c7,\n  \"cir;\":0x25cb, \"cirE;\":0x29c3,\n  \"circ;\":0x2c6, \"circeq;\":0x2257,\n  \"circlearrowleft;\":0x21ba, \"circlearrowright;\":0x21bb,\n  \"circledR;\":0xae, \"circledS;\":0x24c8,\n  \"circledast;\":0x229b, \"circledcirc;\":0x229a,\n  \"circleddash;\":0x229d, \"cire;\":0x2257,\n  \"cirfnint;\":0x2a10, \"cirmid;\":0x2aef,\n  \"cirscir;\":0x29c2, \"clubs;\":0x2663,\n  \"clubsuit;\":0x2663, \"colon;\":0x3a,\n  \"colone;\":0x2254, \"coloneq;\":0x2254,\n  \"comma;\":0x2c, \"commat;\":0x40,\n  \"comp;\":0x2201, \"compfn;\":0x2218,\n  \"complement;\":0x2201, \"complexes;\":0x2102,\n  \"cong;\":0x2245, \"congdot;\":0x2a6d,\n  \"conint;\":0x222e, \"copf;\":[0xd835,0xdd54],\n  \"coprod;\":0x2210, \"copy\":0xa9,\n  \"copy;\":0xa9, \"copysr;\":0x2117,\n  \"crarr;\":0x21b5, \"cross;\":0x2717,\n  \"cscr;\":[0xd835,0xdcb8], \"csub;\":0x2acf,\n  \"csube;\":0x2ad1, \"csup;\":0x2ad0,\n  \"csupe;\":0x2ad2, \"ctdot;\":0x22ef,\n  \"cudarrl;\":0x2938, \"cudarrr;\":0x2935,\n  \"cuepr;\":0x22de, \"cuesc;\":0x22df,\n  \"cularr;\":0x21b6, \"cularrp;\":0x293d,\n  \"cup;\":0x222a, \"cupbrcap;\":0x2a48,\n  \"cupcap;\":0x2a46, \"cupcup;\":0x2a4a,\n  \"cupdot;\":0x228d, \"cupor;\":0x2a45,\n  \"cups;\":[0x222a,0xfe00], \"curarr;\":0x21b7,\n  \"curarrm;\":0x293c, \"curlyeqprec;\":0x22de,\n  \"curlyeqsucc;\":0x22df, \"curlyvee;\":0x22ce,\n  \"curlywedge;\":0x22cf, \"curren\":0xa4,\n  \"curren;\":0xa4, \"curvearrowleft;\":0x21b6,\n  \"curvearrowright;\":0x21b7, \"cuvee;\":0x22ce,\n  \"cuwed;\":0x22cf, \"cwconint;\":0x2232,\n  \"cwint;\":0x2231, \"cylcty;\":0x232d,\n  \"dArr;\":0x21d3, \"dHar;\":0x2965,\n  \"dagger;\":0x2020, \"daleth;\":0x2138,\n  \"darr;\":0x2193, \"dash;\":0x2010,\n  \"dashv;\":0x22a3, \"dbkarow;\":0x290f,\n  \"dblac;\":0x2dd, \"dcaron;\":0x10f,\n  \"dcy;\":0x434, \"dd;\":0x2146,\n  \"ddagger;\":0x2021, \"ddarr;\":0x21ca,\n  \"ddotseq;\":0x2a77, \"deg\":0xb0,\n  \"deg;\":0xb0, \"delta;\":0x3b4,\n  \"demptyv;\":0x29b1, \"dfisht;\":0x297f,\n  \"dfr;\":[0xd835,0xdd21], \"dharl;\":0x21c3,\n  \"dharr;\":0x21c2, \"diam;\":0x22c4,\n  \"diamond;\":0x22c4, \"diamondsuit;\":0x2666,\n  \"diams;\":0x2666, \"die;\":0xa8,\n  \"digamma;\":0x3dd, \"disin;\":0x22f2,\n  \"div;\":0xf7, \"divide\":0xf7,\n  \"divide;\":0xf7, \"divideontimes;\":0x22c7,\n  \"divonx;\":0x22c7, \"djcy;\":0x452,\n  \"dlcorn;\":0x231e, \"dlcrop;\":0x230d,\n  \"dollar;\":0x24, \"dopf;\":[0xd835,0xdd55],\n  \"dot;\":0x2d9, \"doteq;\":0x2250,\n  \"doteqdot;\":0x2251, \"dotminus;\":0x2238,\n  \"dotplus;\":0x2214, \"dotsquare;\":0x22a1,\n  \"doublebarwedge;\":0x2306, \"downarrow;\":0x2193,\n  \"downdownarrows;\":0x21ca, \"downharpoonleft;\":0x21c3,\n  \"downharpoonright;\":0x21c2, \"drbkarow;\":0x2910,\n  \"drcorn;\":0x231f, \"drcrop;\":0x230c,\n  \"dscr;\":[0xd835,0xdcb9], \"dscy;\":0x455,\n  \"dsol;\":0x29f6, \"dstrok;\":0x111,\n  \"dtdot;\":0x22f1, \"dtri;\":0x25bf,\n  \"dtrif;\":0x25be, \"duarr;\":0x21f5,\n  \"duhar;\":0x296f, \"dwangle;\":0x29a6,\n  \"dzcy;\":0x45f, \"dzigrarr;\":0x27ff,\n  \"eDDot;\":0x2a77, \"eDot;\":0x2251,\n  \"eacute\":0xe9, \"eacute;\":0xe9,\n  \"easter;\":0x2a6e, \"ecaron;\":0x11b,\n  \"ecir;\":0x2256, \"ecirc\":0xea,\n  \"ecirc;\":0xea, \"ecolon;\":0x2255,\n  \"ecy;\":0x44d, \"edot;\":0x117,\n  \"ee;\":0x2147, \"efDot;\":0x2252,\n  \"efr;\":[0xd835,0xdd22], \"eg;\":0x2a9a,\n  \"egrave\":0xe8, \"egrave;\":0xe8,\n  \"egs;\":0x2a96, \"egsdot;\":0x2a98,\n  \"el;\":0x2a99, \"elinters;\":0x23e7,\n  \"ell;\":0x2113, \"els;\":0x2a95,\n  \"elsdot;\":0x2a97, \"emacr;\":0x113,\n  \"empty;\":0x2205, \"emptyset;\":0x2205,\n  \"emptyv;\":0x2205, \"emsp13;\":0x2004,\n  \"emsp14;\":0x2005, \"emsp;\":0x2003,\n  \"eng;\":0x14b, \"ensp;\":0x2002,\n  \"eogon;\":0x119, \"eopf;\":[0xd835,0xdd56],\n  \"epar;\":0x22d5, \"eparsl;\":0x29e3,\n  \"eplus;\":0x2a71, \"epsi;\":0x3b5,\n  \"epsilon;\":0x3b5, \"epsiv;\":0x3f5,\n  \"eqcirc;\":0x2256, \"eqcolon;\":0x2255,\n  \"eqsim;\":0x2242, \"eqslantgtr;\":0x2a96,\n  \"eqslantless;\":0x2a95, \"equals;\":0x3d,\n  \"equest;\":0x225f, \"equiv;\":0x2261,\n  \"equivDD;\":0x2a78, \"eqvparsl;\":0x29e5,\n  \"erDot;\":0x2253, \"erarr;\":0x2971,\n  \"escr;\":0x212f, \"esdot;\":0x2250,\n  \"esim;\":0x2242, \"eta;\":0x3b7,\n  \"eth\":0xf0, \"eth;\":0xf0,\n  \"euml\":0xeb, \"euml;\":0xeb,\n  \"euro;\":0x20ac, \"excl;\":0x21,\n  \"exist;\":0x2203, \"expectation;\":0x2130,\n  \"exponentiale;\":0x2147, \"fallingdotseq;\":0x2252,\n  \"fcy;\":0x444, \"female;\":0x2640,\n  \"ffilig;\":0xfb03, \"fflig;\":0xfb00,\n  \"ffllig;\":0xfb04, \"ffr;\":[0xd835,0xdd23],\n  \"filig;\":0xfb01, \"fjlig;\":[0x66,0x6a],\n  \"flat;\":0x266d, \"fllig;\":0xfb02,\n  \"fltns;\":0x25b1, \"fnof;\":0x192,\n  \"fopf;\":[0xd835,0xdd57], \"forall;\":0x2200,\n  \"fork;\":0x22d4, \"forkv;\":0x2ad9,\n  \"fpartint;\":0x2a0d, \"frac12\":0xbd,\n  \"frac12;\":0xbd, \"frac13;\":0x2153,\n  \"frac14\":0xbc, \"frac14;\":0xbc,\n  \"frac15;\":0x2155, \"frac16;\":0x2159,\n  \"frac18;\":0x215b, \"frac23;\":0x2154,\n  \"frac25;\":0x2156, \"frac34\":0xbe,\n  \"frac34;\":0xbe, \"frac35;\":0x2157,\n  \"frac38;\":0x215c, \"frac45;\":0x2158,\n  \"frac56;\":0x215a, \"frac58;\":0x215d,\n  \"frac78;\":0x215e, \"frasl;\":0x2044,\n  \"frown;\":0x2322, \"fscr;\":[0xd835,0xdcbb],\n  \"gE;\":0x2267, \"gEl;\":0x2a8c,\n  \"gacute;\":0x1f5, \"gamma;\":0x3b3,\n  \"gammad;\":0x3dd, \"gap;\":0x2a86,\n  \"gbreve;\":0x11f, \"gcirc;\":0x11d,\n  \"gcy;\":0x433, \"gdot;\":0x121,\n  \"ge;\":0x2265, \"gel;\":0x22db,\n  \"geq;\":0x2265, \"geqq;\":0x2267,\n  \"geqslant;\":0x2a7e, \"ges;\":0x2a7e,\n  \"gescc;\":0x2aa9, \"gesdot;\":0x2a80,\n  \"gesdoto;\":0x2a82, \"gesdotol;\":0x2a84,\n  \"gesl;\":[0x22db,0xfe00], \"gesles;\":0x2a94,\n  \"gfr;\":[0xd835,0xdd24], \"gg;\":0x226b,\n  \"ggg;\":0x22d9, \"gimel;\":0x2137,\n  \"gjcy;\":0x453, \"gl;\":0x2277,\n  \"glE;\":0x2a92, \"gla;\":0x2aa5,\n  \"glj;\":0x2aa4, \"gnE;\":0x2269,\n  \"gnap;\":0x2a8a, \"gnapprox;\":0x2a8a,\n  \"gne;\":0x2a88, \"gneq;\":0x2a88,\n  \"gneqq;\":0x2269, \"gnsim;\":0x22e7,\n  \"gopf;\":[0xd835,0xdd58], \"grave;\":0x60,\n  \"gscr;\":0x210a, \"gsim;\":0x2273,\n  \"gsime;\":0x2a8e, \"gsiml;\":0x2a90,\n  \"gt\":0x3e, \"gt;\":0x3e,\n  \"gtcc;\":0x2aa7, \"gtcir;\":0x2a7a,\n  \"gtdot;\":0x22d7, \"gtlPar;\":0x2995,\n  \"gtquest;\":0x2a7c, \"gtrapprox;\":0x2a86,\n  \"gtrarr;\":0x2978, \"gtrdot;\":0x22d7,\n  \"gtreqless;\":0x22db, \"gtreqqless;\":0x2a8c,\n  \"gtrless;\":0x2277, \"gtrsim;\":0x2273,\n  \"gvertneqq;\":[0x2269,0xfe00], \"gvnE;\":[0x2269,0xfe00],\n  \"hArr;\":0x21d4, \"hairsp;\":0x200a,\n  \"half;\":0xbd, \"hamilt;\":0x210b,\n  \"hardcy;\":0x44a, \"harr;\":0x2194,\n  \"harrcir;\":0x2948, \"harrw;\":0x21ad,\n  \"hbar;\":0x210f, \"hcirc;\":0x125,\n  \"hearts;\":0x2665, \"heartsuit;\":0x2665,\n  \"hellip;\":0x2026, \"hercon;\":0x22b9,\n  \"hfr;\":[0xd835,0xdd25], \"hksearow;\":0x2925,\n  \"hkswarow;\":0x2926, \"hoarr;\":0x21ff,\n  \"homtht;\":0x223b, \"hookleftarrow;\":0x21a9,\n  \"hookrightarrow;\":0x21aa, \"hopf;\":[0xd835,0xdd59],\n  \"horbar;\":0x2015, \"hscr;\":[0xd835,0xdcbd],\n  \"hslash;\":0x210f, \"hstrok;\":0x127,\n  \"hybull;\":0x2043, \"hyphen;\":0x2010,\n  \"iacute\":0xed, \"iacute;\":0xed,\n  \"ic;\":0x2063, \"icirc\":0xee,\n  \"icirc;\":0xee, \"icy;\":0x438,\n  \"iecy;\":0x435, \"iexcl\":0xa1,\n  \"iexcl;\":0xa1, \"iff;\":0x21d4,\n  \"ifr;\":[0xd835,0xdd26], \"igrave\":0xec,\n  \"igrave;\":0xec, \"ii;\":0x2148,\n  \"iiiint;\":0x2a0c, \"iiint;\":0x222d,\n  \"iinfin;\":0x29dc, \"iiota;\":0x2129,\n  \"ijlig;\":0x133, \"imacr;\":0x12b,\n  \"image;\":0x2111, \"imagline;\":0x2110,\n  \"imagpart;\":0x2111, \"imath;\":0x131,\n  \"imof;\":0x22b7, \"imped;\":0x1b5,\n  \"in;\":0x2208, \"incare;\":0x2105,\n  \"infin;\":0x221e, \"infintie;\":0x29dd,\n  \"inodot;\":0x131, \"int;\":0x222b,\n  \"intcal;\":0x22ba, \"integers;\":0x2124,\n  \"intercal;\":0x22ba, \"intlarhk;\":0x2a17,\n  \"intprod;\":0x2a3c, \"iocy;\":0x451,\n  \"iogon;\":0x12f, \"iopf;\":[0xd835,0xdd5a],\n  \"iota;\":0x3b9, \"iprod;\":0x2a3c,\n  \"iquest\":0xbf, \"iquest;\":0xbf,\n  \"iscr;\":[0xd835,0xdcbe], \"isin;\":0x2208,\n  \"isinE;\":0x22f9, \"isindot;\":0x22f5,\n  \"isins;\":0x22f4, \"isinsv;\":0x22f3,\n  \"isinv;\":0x2208, \"it;\":0x2062,\n  \"itilde;\":0x129, \"iukcy;\":0x456,\n  \"iuml\":0xef, \"iuml;\":0xef,\n  \"jcirc;\":0x135, \"jcy;\":0x439,\n  \"jfr;\":[0xd835,0xdd27], \"jmath;\":0x237,\n  \"jopf;\":[0xd835,0xdd5b], \"jscr;\":[0xd835,0xdcbf],\n  \"jsercy;\":0x458, \"jukcy;\":0x454,\n  \"kappa;\":0x3ba, \"kappav;\":0x3f0,\n  \"kcedil;\":0x137, \"kcy;\":0x43a,\n  \"kfr;\":[0xd835,0xdd28], \"kgreen;\":0x138,\n  \"khcy;\":0x445, \"kjcy;\":0x45c,\n  \"kopf;\":[0xd835,0xdd5c], \"kscr;\":[0xd835,0xdcc0],\n  \"lAarr;\":0x21da, \"lArr;\":0x21d0,\n  \"lAtail;\":0x291b, \"lBarr;\":0x290e,\n  \"lE;\":0x2266, \"lEg;\":0x2a8b,\n  \"lHar;\":0x2962, \"lacute;\":0x13a,\n  \"laemptyv;\":0x29b4, \"lagran;\":0x2112,\n  \"lambda;\":0x3bb, \"lang;\":0x27e8,\n  \"langd;\":0x2991, \"langle;\":0x27e8,\n  \"lap;\":0x2a85, \"laquo\":0xab,\n  \"laquo;\":0xab, \"larr;\":0x2190,\n  \"larrb;\":0x21e4, \"larrbfs;\":0x291f,\n  \"larrfs;\":0x291d, \"larrhk;\":0x21a9,\n  \"larrlp;\":0x21ab, \"larrpl;\":0x2939,\n  \"larrsim;\":0x2973, \"larrtl;\":0x21a2,\n  \"lat;\":0x2aab, \"latail;\":0x2919,\n  \"late;\":0x2aad, \"lates;\":[0x2aad,0xfe00],\n  \"lbarr;\":0x290c, \"lbbrk;\":0x2772,\n  \"lbrace;\":0x7b, \"lbrack;\":0x5b,\n  \"lbrke;\":0x298b, \"lbrksld;\":0x298f,\n  \"lbrkslu;\":0x298d, \"lcaron;\":0x13e,\n  \"lcedil;\":0x13c, \"lceil;\":0x2308,\n  \"lcub;\":0x7b, \"lcy;\":0x43b,\n  \"ldca;\":0x2936, \"ldquo;\":0x201c,\n  \"ldquor;\":0x201e, \"ldrdhar;\":0x2967,\n  \"ldrushar;\":0x294b, \"ldsh;\":0x21b2,\n  \"le;\":0x2264, \"leftarrow;\":0x2190,\n  \"leftarrowtail;\":0x21a2, \"leftharpoondown;\":0x21bd,\n  \"leftharpoonup;\":0x21bc, \"leftleftarrows;\":0x21c7,\n  \"leftrightarrow;\":0x2194, \"leftrightarrows;\":0x21c6,\n  \"leftrightharpoons;\":0x21cb, \"leftrightsquigarrow;\":0x21ad,\n  \"leftthreetimes;\":0x22cb, \"leg;\":0x22da,\n  \"leq;\":0x2264, \"leqq;\":0x2266,\n  \"leqslant;\":0x2a7d, \"les;\":0x2a7d,\n  \"lescc;\":0x2aa8, \"lesdot;\":0x2a7f,\n  \"lesdoto;\":0x2a81, \"lesdotor;\":0x2a83,\n  \"lesg;\":[0x22da,0xfe00], \"lesges;\":0x2a93,\n  \"lessapprox;\":0x2a85, \"lessdot;\":0x22d6,\n  \"lesseqgtr;\":0x22da, \"lesseqqgtr;\":0x2a8b,\n  \"lessgtr;\":0x2276, \"lesssim;\":0x2272,\n  \"lfisht;\":0x297c, \"lfloor;\":0x230a,\n  \"lfr;\":[0xd835,0xdd29], \"lg;\":0x2276,\n  \"lgE;\":0x2a91, \"lhard;\":0x21bd,\n  \"lharu;\":0x21bc, \"lharul;\":0x296a,\n  \"lhblk;\":0x2584, \"ljcy;\":0x459,\n  \"ll;\":0x226a, \"llarr;\":0x21c7,\n  \"llcorner;\":0x231e, \"llhard;\":0x296b,\n  \"lltri;\":0x25fa, \"lmidot;\":0x140,\n  \"lmoust;\":0x23b0, \"lmoustache;\":0x23b0,\n  \"lnE;\":0x2268, \"lnap;\":0x2a89,\n  \"lnapprox;\":0x2a89, \"lne;\":0x2a87,\n  \"lneq;\":0x2a87, \"lneqq;\":0x2268,\n  \"lnsim;\":0x22e6, \"loang;\":0x27ec,\n  \"loarr;\":0x21fd, \"lobrk;\":0x27e6,\n  \"longleftarrow;\":0x27f5, \"longleftrightarrow;\":0x27f7,\n  \"longmapsto;\":0x27fc, \"longrightarrow;\":0x27f6,\n  \"looparrowleft;\":0x21ab, \"looparrowright;\":0x21ac,\n  \"lopar;\":0x2985, \"lopf;\":[0xd835,0xdd5d],\n  \"loplus;\":0x2a2d, \"lotimes;\":0x2a34,\n  \"lowast;\":0x2217, \"lowbar;\":0x5f,\n  \"loz;\":0x25ca, \"lozenge;\":0x25ca,\n  \"lozf;\":0x29eb, \"lpar;\":0x28,\n  \"lparlt;\":0x2993, \"lrarr;\":0x21c6,\n  \"lrcorner;\":0x231f, \"lrhar;\":0x21cb,\n  \"lrhard;\":0x296d, \"lrm;\":0x200e,\n  \"lrtri;\":0x22bf, \"lsaquo;\":0x2039,\n  \"lscr;\":[0xd835,0xdcc1], \"lsh;\":0x21b0,\n  \"lsim;\":0x2272, \"lsime;\":0x2a8d,\n  \"lsimg;\":0x2a8f, \"lsqb;\":0x5b,\n  \"lsquo;\":0x2018, \"lsquor;\":0x201a,\n  \"lstrok;\":0x142, \"lt\":0x3c,\n  \"lt;\":0x3c, \"ltcc;\":0x2aa6,\n  \"ltcir;\":0x2a79, \"ltdot;\":0x22d6,\n  \"lthree;\":0x22cb, \"ltimes;\":0x22c9,\n  \"ltlarr;\":0x2976, \"ltquest;\":0x2a7b,\n  \"ltrPar;\":0x2996, \"ltri;\":0x25c3,\n  \"ltrie;\":0x22b4, \"ltrif;\":0x25c2,\n  \"lurdshar;\":0x294a, \"luruhar;\":0x2966,\n  \"lvertneqq;\":[0x2268,0xfe00], \"lvnE;\":[0x2268,0xfe00],\n  \"mDDot;\":0x223a, \"macr\":0xaf,\n  \"macr;\":0xaf, \"male;\":0x2642,\n  \"malt;\":0x2720, \"maltese;\":0x2720,\n  \"map;\":0x21a6, \"mapsto;\":0x21a6,\n  \"mapstodown;\":0x21a7, \"mapstoleft;\":0x21a4,\n  \"mapstoup;\":0x21a5, \"marker;\":0x25ae,\n  \"mcomma;\":0x2a29, \"mcy;\":0x43c,\n  \"mdash;\":0x2014, \"measuredangle;\":0x2221,\n  \"mfr;\":[0xd835,0xdd2a], \"mho;\":0x2127,\n  \"micro\":0xb5, \"micro;\":0xb5,\n  \"mid;\":0x2223, \"midast;\":0x2a,\n  \"midcir;\":0x2af0, \"middot\":0xb7,\n  \"middot;\":0xb7, \"minus;\":0x2212,\n  \"minusb;\":0x229f, \"minusd;\":0x2238,\n  \"minusdu;\":0x2a2a, \"mlcp;\":0x2adb,\n  \"mldr;\":0x2026, \"mnplus;\":0x2213,\n  \"models;\":0x22a7, \"mopf;\":[0xd835,0xdd5e],\n  \"mp;\":0x2213, \"mscr;\":[0xd835,0xdcc2],\n  \"mstpos;\":0x223e, \"mu;\":0x3bc,\n  \"multimap;\":0x22b8, \"mumap;\":0x22b8,\n  \"nGg;\":[0x22d9,0x338], \"nGt;\":[0x226b,0x20d2],\n  \"nGtv;\":[0x226b,0x338], \"nLeftarrow;\":0x21cd,\n  \"nLeftrightarrow;\":0x21ce, \"nLl;\":[0x22d8,0x338],\n  \"nLt;\":[0x226a,0x20d2], \"nLtv;\":[0x226a,0x338],\n  \"nRightarrow;\":0x21cf, \"nVDash;\":0x22af,\n  \"nVdash;\":0x22ae, \"nabla;\":0x2207,\n  \"nacute;\":0x144, \"nang;\":[0x2220,0x20d2],\n  \"nap;\":0x2249, \"napE;\":[0x2a70,0x338],\n  \"napid;\":[0x224b,0x338], \"napos;\":0x149,\n  \"napprox;\":0x2249, \"natur;\":0x266e,\n  \"natural;\":0x266e, \"naturals;\":0x2115,\n  \"nbsp\":0xa0, \"nbsp;\":0xa0,\n  \"nbump;\":[0x224e,0x338], \"nbumpe;\":[0x224f,0x338],\n  \"ncap;\":0x2a43, \"ncaron;\":0x148,\n  \"ncedil;\":0x146, \"ncong;\":0x2247,\n  \"ncongdot;\":[0x2a6d,0x338], \"ncup;\":0x2a42,\n  \"ncy;\":0x43d, \"ndash;\":0x2013,\n  \"ne;\":0x2260, \"neArr;\":0x21d7,\n  \"nearhk;\":0x2924, \"nearr;\":0x2197,\n  \"nearrow;\":0x2197, \"nedot;\":[0x2250,0x338],\n  \"nequiv;\":0x2262, \"nesear;\":0x2928,\n  \"nesim;\":[0x2242,0x338], \"nexist;\":0x2204,\n  \"nexists;\":0x2204, \"nfr;\":[0xd835,0xdd2b],\n  \"ngE;\":[0x2267,0x338], \"nge;\":0x2271,\n  \"ngeq;\":0x2271, \"ngeqq;\":[0x2267,0x338],\n  \"ngeqslant;\":[0x2a7e,0x338], \"nges;\":[0x2a7e,0x338],\n  \"ngsim;\":0x2275, \"ngt;\":0x226f,\n  \"ngtr;\":0x226f, \"nhArr;\":0x21ce,\n  \"nharr;\":0x21ae, \"nhpar;\":0x2af2,\n  \"ni;\":0x220b, \"nis;\":0x22fc,\n  \"nisd;\":0x22fa, \"niv;\":0x220b,\n  \"njcy;\":0x45a, \"nlArr;\":0x21cd,\n  \"nlE;\":[0x2266,0x338], \"nlarr;\":0x219a,\n  \"nldr;\":0x2025, \"nle;\":0x2270,\n  \"nleftarrow;\":0x219a, \"nleftrightarrow;\":0x21ae,\n  \"nleq;\":0x2270, \"nleqq;\":[0x2266,0x338],\n  \"nleqslant;\":[0x2a7d,0x338], \"nles;\":[0x2a7d,0x338],\n  \"nless;\":0x226e, \"nlsim;\":0x2274,\n  \"nlt;\":0x226e, \"nltri;\":0x22ea,\n  \"nltrie;\":0x22ec, \"nmid;\":0x2224,\n  \"nopf;\":[0xd835,0xdd5f], \"not\":0xac,\n  \"not;\":0xac, \"notin;\":0x2209,\n  \"notinE;\":[0x22f9,0x338], \"notindot;\":[0x22f5,0x338],\n  \"notinva;\":0x2209, \"notinvb;\":0x22f7,\n  \"notinvc;\":0x22f6, \"notni;\":0x220c,\n  \"notniva;\":0x220c, \"notnivb;\":0x22fe,\n  \"notnivc;\":0x22fd, \"npar;\":0x2226,\n  \"nparallel;\":0x2226, \"nparsl;\":[0x2afd,0x20e5],\n  \"npart;\":[0x2202,0x338], \"npolint;\":0x2a14,\n  \"npr;\":0x2280, \"nprcue;\":0x22e0,\n  \"npre;\":[0x2aaf,0x338], \"nprec;\":0x2280,\n  \"npreceq;\":[0x2aaf,0x338], \"nrArr;\":0x21cf,\n  \"nrarr;\":0x219b, \"nrarrc;\":[0x2933,0x338],\n  \"nrarrw;\":[0x219d,0x338], \"nrightarrow;\":0x219b,\n  \"nrtri;\":0x22eb, \"nrtrie;\":0x22ed,\n  \"nsc;\":0x2281, \"nsccue;\":0x22e1,\n  \"nsce;\":[0x2ab0,0x338], \"nscr;\":[0xd835,0xdcc3],\n  \"nshortmid;\":0x2224, \"nshortparallel;\":0x2226,\n  \"nsim;\":0x2241, \"nsime;\":0x2244,\n  \"nsimeq;\":0x2244, \"nsmid;\":0x2224,\n  \"nspar;\":0x2226, \"nsqsube;\":0x22e2,\n  \"nsqsupe;\":0x22e3, \"nsub;\":0x2284,\n  \"nsubE;\":[0x2ac5,0x338], \"nsube;\":0x2288,\n  \"nsubset;\":[0x2282,0x20d2], \"nsubseteq;\":0x2288,\n  \"nsubseteqq;\":[0x2ac5,0x338], \"nsucc;\":0x2281,\n  \"nsucceq;\":[0x2ab0,0x338], \"nsup;\":0x2285,\n  \"nsupE;\":[0x2ac6,0x338], \"nsupe;\":0x2289,\n  \"nsupset;\":[0x2283,0x20d2], \"nsupseteq;\":0x2289,\n  \"nsupseteqq;\":[0x2ac6,0x338], \"ntgl;\":0x2279,\n  \"ntilde\":0xf1, \"ntilde;\":0xf1,\n  \"ntlg;\":0x2278, \"ntriangleleft;\":0x22ea,\n  \"ntrianglelefteq;\":0x22ec, \"ntriangleright;\":0x22eb,\n  \"ntrianglerighteq;\":0x22ed, \"nu;\":0x3bd,\n  \"num;\":0x23, \"numero;\":0x2116,\n  \"numsp;\":0x2007, \"nvDash;\":0x22ad,\n  \"nvHarr;\":0x2904, \"nvap;\":[0x224d,0x20d2],\n  \"nvdash;\":0x22ac, \"nvge;\":[0x2265,0x20d2],\n  \"nvgt;\":[0x3e,0x20d2], \"nvinfin;\":0x29de,\n  \"nvlArr;\":0x2902, \"nvle;\":[0x2264,0x20d2],\n  \"nvlt;\":[0x3c,0x20d2], \"nvltrie;\":[0x22b4,0x20d2],\n  \"nvrArr;\":0x2903, \"nvrtrie;\":[0x22b5,0x20d2],\n  \"nvsim;\":[0x223c,0x20d2], \"nwArr;\":0x21d6,\n  \"nwarhk;\":0x2923, \"nwarr;\":0x2196,\n  \"nwarrow;\":0x2196, \"nwnear;\":0x2927,\n  \"oS;\":0x24c8, \"oacute\":0xf3,\n  \"oacute;\":0xf3, \"oast;\":0x229b,\n  \"ocir;\":0x229a, \"ocirc\":0xf4,\n  \"ocirc;\":0xf4, \"ocy;\":0x43e,\n  \"odash;\":0x229d, \"odblac;\":0x151,\n  \"odiv;\":0x2a38, \"odot;\":0x2299,\n  \"odsold;\":0x29bc, \"oelig;\":0x153,\n  \"ofcir;\":0x29bf, \"ofr;\":[0xd835,0xdd2c],\n  \"ogon;\":0x2db, \"ograve\":0xf2,\n  \"ograve;\":0xf2, \"ogt;\":0x29c1,\n  \"ohbar;\":0x29b5, \"ohm;\":0x3a9,\n  \"oint;\":0x222e, \"olarr;\":0x21ba,\n  \"olcir;\":0x29be, \"olcross;\":0x29bb,\n  \"oline;\":0x203e, \"olt;\":0x29c0,\n  \"omacr;\":0x14d, \"omega;\":0x3c9,\n  \"omicron;\":0x3bf, \"omid;\":0x29b6,\n  \"ominus;\":0x2296, \"oopf;\":[0xd835,0xdd60],\n  \"opar;\":0x29b7, \"operp;\":0x29b9,\n  \"oplus;\":0x2295, \"or;\":0x2228,\n  \"orarr;\":0x21bb, \"ord;\":0x2a5d,\n  \"order;\":0x2134, \"orderof;\":0x2134,\n  \"ordf\":0xaa, \"ordf;\":0xaa,\n  \"ordm\":0xba, \"ordm;\":0xba,\n  \"origof;\":0x22b6, \"oror;\":0x2a56,\n  \"orslope;\":0x2a57, \"orv;\":0x2a5b,\n  \"oscr;\":0x2134, \"oslash\":0xf8,\n  \"oslash;\":0xf8, \"osol;\":0x2298,\n  \"otilde\":0xf5, \"otilde;\":0xf5,\n  \"otimes;\":0x2297, \"otimesas;\":0x2a36,\n  \"ouml\":0xf6, \"ouml;\":0xf6,\n  \"ovbar;\":0x233d, \"par;\":0x2225,\n  \"para\":0xb6, \"para;\":0xb6,\n  \"parallel;\":0x2225, \"parsim;\":0x2af3,\n  \"parsl;\":0x2afd, \"part;\":0x2202,\n  \"pcy;\":0x43f, \"percnt;\":0x25,\n  \"period;\":0x2e, \"permil;\":0x2030,\n  \"perp;\":0x22a5, \"pertenk;\":0x2031,\n  \"pfr;\":[0xd835,0xdd2d], \"phi;\":0x3c6,\n  \"phiv;\":0x3d5, \"phmmat;\":0x2133,\n  \"phone;\":0x260e, \"pi;\":0x3c0,\n  \"pitchfork;\":0x22d4, \"piv;\":0x3d6,\n  \"planck;\":0x210f, \"planckh;\":0x210e,\n  \"plankv;\":0x210f, \"plus;\":0x2b,\n  \"plusacir;\":0x2a23, \"plusb;\":0x229e,\n  \"pluscir;\":0x2a22, \"plusdo;\":0x2214,\n  \"plusdu;\":0x2a25, \"pluse;\":0x2a72,\n  \"plusmn\":0xb1, \"plusmn;\":0xb1,\n  \"plussim;\":0x2a26, \"plustwo;\":0x2a27,\n  \"pm;\":0xb1, \"pointint;\":0x2a15,\n  \"popf;\":[0xd835,0xdd61], \"pound\":0xa3,\n  \"pound;\":0xa3, \"pr;\":0x227a,\n  \"prE;\":0x2ab3, \"prap;\":0x2ab7,\n  \"prcue;\":0x227c, \"pre;\":0x2aaf,\n  \"prec;\":0x227a, \"precapprox;\":0x2ab7,\n  \"preccurlyeq;\":0x227c, \"preceq;\":0x2aaf,\n  \"precnapprox;\":0x2ab9, \"precneqq;\":0x2ab5,\n  \"precnsim;\":0x22e8, \"precsim;\":0x227e,\n  \"prime;\":0x2032, \"primes;\":0x2119,\n  \"prnE;\":0x2ab5, \"prnap;\":0x2ab9,\n  \"prnsim;\":0x22e8, \"prod;\":0x220f,\n  \"profalar;\":0x232e, \"profline;\":0x2312,\n  \"profsurf;\":0x2313, \"prop;\":0x221d,\n  \"propto;\":0x221d, \"prsim;\":0x227e,\n  \"prurel;\":0x22b0, \"pscr;\":[0xd835,0xdcc5],\n  \"psi;\":0x3c8, \"puncsp;\":0x2008,\n  \"qfr;\":[0xd835,0xdd2e], \"qint;\":0x2a0c,\n  \"qopf;\":[0xd835,0xdd62], \"qprime;\":0x2057,\n  \"qscr;\":[0xd835,0xdcc6], \"quaternions;\":0x210d,\n  \"quatint;\":0x2a16, \"quest;\":0x3f,\n  \"questeq;\":0x225f, \"quot\":0x22,\n  \"quot;\":0x22, \"rAarr;\":0x21db,\n  \"rArr;\":0x21d2, \"rAtail;\":0x291c,\n  \"rBarr;\":0x290f, \"rHar;\":0x2964,\n  \"race;\":[0x223d,0x331], \"racute;\":0x155,\n  \"radic;\":0x221a, \"raemptyv;\":0x29b3,\n  \"rang;\":0x27e9, \"rangd;\":0x2992,\n  \"range;\":0x29a5, \"rangle;\":0x27e9,\n  \"raquo\":0xbb, \"raquo;\":0xbb,\n  \"rarr;\":0x2192, \"rarrap;\":0x2975,\n  \"rarrb;\":0x21e5, \"rarrbfs;\":0x2920,\n  \"rarrc;\":0x2933, \"rarrfs;\":0x291e,\n  \"rarrhk;\":0x21aa, \"rarrlp;\":0x21ac,\n  \"rarrpl;\":0x2945, \"rarrsim;\":0x2974,\n  \"rarrtl;\":0x21a3, \"rarrw;\":0x219d,\n  \"ratail;\":0x291a, \"ratio;\":0x2236,\n  \"rationals;\":0x211a, \"rbarr;\":0x290d,\n  \"rbbrk;\":0x2773, \"rbrace;\":0x7d,\n  \"rbrack;\":0x5d, \"rbrke;\":0x298c,\n  \"rbrksld;\":0x298e, \"rbrkslu;\":0x2990,\n  \"rcaron;\":0x159, \"rcedil;\":0x157,\n  \"rceil;\":0x2309, \"rcub;\":0x7d,\n  \"rcy;\":0x440, \"rdca;\":0x2937,\n  \"rdldhar;\":0x2969, \"rdquo;\":0x201d,\n  \"rdquor;\":0x201d, \"rdsh;\":0x21b3,\n  \"real;\":0x211c, \"realine;\":0x211b,\n  \"realpart;\":0x211c, \"reals;\":0x211d,\n  \"rect;\":0x25ad, \"reg\":0xae,\n  \"reg;\":0xae, \"rfisht;\":0x297d,\n  \"rfloor;\":0x230b, \"rfr;\":[0xd835,0xdd2f],\n  \"rhard;\":0x21c1, \"rharu;\":0x21c0,\n  \"rharul;\":0x296c, \"rho;\":0x3c1,\n  \"rhov;\":0x3f1, \"rightarrow;\":0x2192,\n  \"rightarrowtail;\":0x21a3, \"rightharpoondown;\":0x21c1,\n  \"rightharpoonup;\":0x21c0, \"rightleftarrows;\":0x21c4,\n  \"rightleftharpoons;\":0x21cc, \"rightrightarrows;\":0x21c9,\n  \"rightsquigarrow;\":0x219d, \"rightthreetimes;\":0x22cc,\n  \"ring;\":0x2da, \"risingdotseq;\":0x2253,\n  \"rlarr;\":0x21c4, \"rlhar;\":0x21cc,\n  \"rlm;\":0x200f, \"rmoust;\":0x23b1,\n  \"rmoustache;\":0x23b1, \"rnmid;\":0x2aee,\n  \"roang;\":0x27ed, \"roarr;\":0x21fe,\n  \"robrk;\":0x27e7, \"ropar;\":0x2986,\n  \"ropf;\":[0xd835,0xdd63], \"roplus;\":0x2a2e,\n  \"rotimes;\":0x2a35, \"rpar;\":0x29,\n  \"rpargt;\":0x2994, \"rppolint;\":0x2a12,\n  \"rrarr;\":0x21c9, \"rsaquo;\":0x203a,\n  \"rscr;\":[0xd835,0xdcc7], \"rsh;\":0x21b1,\n  \"rsqb;\":0x5d, \"rsquo;\":0x2019,\n  \"rsquor;\":0x2019, \"rthree;\":0x22cc,\n  \"rtimes;\":0x22ca, \"rtri;\":0x25b9,\n  \"rtrie;\":0x22b5, \"rtrif;\":0x25b8,\n  \"rtriltri;\":0x29ce, \"ruluhar;\":0x2968,\n  \"rx;\":0x211e, \"sacute;\":0x15b,\n  \"sbquo;\":0x201a, \"sc;\":0x227b,\n  \"scE;\":0x2ab4, \"scap;\":0x2ab8,\n  \"scaron;\":0x161, \"sccue;\":0x227d,\n  \"sce;\":0x2ab0, \"scedil;\":0x15f,\n  \"scirc;\":0x15d, \"scnE;\":0x2ab6,\n  \"scnap;\":0x2aba, \"scnsim;\":0x22e9,\n  \"scpolint;\":0x2a13, \"scsim;\":0x227f,\n  \"scy;\":0x441, \"sdot;\":0x22c5,\n  \"sdotb;\":0x22a1, \"sdote;\":0x2a66,\n  \"seArr;\":0x21d8, \"searhk;\":0x2925,\n  \"searr;\":0x2198, \"searrow;\":0x2198,\n  \"sect\":0xa7, \"sect;\":0xa7,\n  \"semi;\":0x3b, \"seswar;\":0x2929,\n  \"setminus;\":0x2216, \"setmn;\":0x2216,\n  \"sext;\":0x2736, \"sfr;\":[0xd835,0xdd30],\n  \"sfrown;\":0x2322, \"sharp;\":0x266f,\n  \"shchcy;\":0x449, \"shcy;\":0x448,\n  \"shortmid;\":0x2223, \"shortparallel;\":0x2225,\n  \"shy\":0xad, \"shy;\":0xad,\n  \"sigma;\":0x3c3, \"sigmaf;\":0x3c2,\n  \"sigmav;\":0x3c2, \"sim;\":0x223c,\n  \"simdot;\":0x2a6a, \"sime;\":0x2243,\n  \"simeq;\":0x2243, \"simg;\":0x2a9e,\n  \"simgE;\":0x2aa0, \"siml;\":0x2a9d,\n  \"simlE;\":0x2a9f, \"simne;\":0x2246,\n  \"simplus;\":0x2a24, \"simrarr;\":0x2972,\n  \"slarr;\":0x2190, \"smallsetminus;\":0x2216,\n  \"smashp;\":0x2a33, \"smeparsl;\":0x29e4,\n  \"smid;\":0x2223, \"smile;\":0x2323,\n  \"smt;\":0x2aaa, \"smte;\":0x2aac,\n  \"smtes;\":[0x2aac,0xfe00], \"softcy;\":0x44c,\n  \"sol;\":0x2f, \"solb;\":0x29c4,\n  \"solbar;\":0x233f, \"sopf;\":[0xd835,0xdd64],\n  \"spades;\":0x2660, \"spadesuit;\":0x2660,\n  \"spar;\":0x2225, \"sqcap;\":0x2293,\n  \"sqcaps;\":[0x2293,0xfe00], \"sqcup;\":0x2294,\n  \"sqcups;\":[0x2294,0xfe00], \"sqsub;\":0x228f,\n  \"sqsube;\":0x2291, \"sqsubset;\":0x228f,\n  \"sqsubseteq;\":0x2291, \"sqsup;\":0x2290,\n  \"sqsupe;\":0x2292, \"sqsupset;\":0x2290,\n  \"sqsupseteq;\":0x2292, \"squ;\":0x25a1,\n  \"square;\":0x25a1, \"squarf;\":0x25aa,\n  \"squf;\":0x25aa, \"srarr;\":0x2192,\n  \"sscr;\":[0xd835,0xdcc8], \"ssetmn;\":0x2216,\n  \"ssmile;\":0x2323, \"sstarf;\":0x22c6,\n  \"star;\":0x2606, \"starf;\":0x2605,\n  \"straightepsilon;\":0x3f5, \"straightphi;\":0x3d5,\n  \"strns;\":0xaf, \"sub;\":0x2282,\n  \"subE;\":0x2ac5, \"subdot;\":0x2abd,\n  \"sube;\":0x2286, \"subedot;\":0x2ac3,\n  \"submult;\":0x2ac1, \"subnE;\":0x2acb,\n  \"subne;\":0x228a, \"subplus;\":0x2abf,\n  \"subrarr;\":0x2979, \"subset;\":0x2282,\n  \"subseteq;\":0x2286, \"subseteqq;\":0x2ac5,\n  \"subsetneq;\":0x228a, \"subsetneqq;\":0x2acb,\n  \"subsim;\":0x2ac7, \"subsub;\":0x2ad5,\n  \"subsup;\":0x2ad3, \"succ;\":0x227b,\n  \"succapprox;\":0x2ab8, \"succcurlyeq;\":0x227d,\n  \"succeq;\":0x2ab0, \"succnapprox;\":0x2aba,\n  \"succneqq;\":0x2ab6, \"succnsim;\":0x22e9,\n  \"succsim;\":0x227f, \"sum;\":0x2211,\n  \"sung;\":0x266a, \"sup1\":0xb9,\n  \"sup1;\":0xb9, \"sup2\":0xb2,\n  \"sup2;\":0xb2, \"sup3\":0xb3,\n  \"sup3;\":0xb3, \"sup;\":0x2283,\n  \"supE;\":0x2ac6, \"supdot;\":0x2abe,\n  \"supdsub;\":0x2ad8, \"supe;\":0x2287,\n  \"supedot;\":0x2ac4, \"suphsol;\":0x27c9,\n  \"suphsub;\":0x2ad7, \"suplarr;\":0x297b,\n  \"supmult;\":0x2ac2, \"supnE;\":0x2acc,\n  \"supne;\":0x228b, \"supplus;\":0x2ac0,\n  \"supset;\":0x2283, \"supseteq;\":0x2287,\n  \"supseteqq;\":0x2ac6, \"supsetneq;\":0x228b,\n  \"supsetneqq;\":0x2acc, \"supsim;\":0x2ac8,\n  \"supsub;\":0x2ad4, \"supsup;\":0x2ad6,\n  \"swArr;\":0x21d9, \"swarhk;\":0x2926,\n  \"swarr;\":0x2199, \"swarrow;\":0x2199,\n  \"swnwar;\":0x292a, \"szlig\":0xdf,\n  \"szlig;\":0xdf, \"target;\":0x2316,\n  \"tau;\":0x3c4, \"tbrk;\":0x23b4,\n  \"tcaron;\":0x165, \"tcedil;\":0x163,\n  \"tcy;\":0x442, \"tdot;\":0x20db,\n  \"telrec;\":0x2315, \"tfr;\":[0xd835,0xdd31],\n  \"there4;\":0x2234, \"therefore;\":0x2234,\n  \"theta;\":0x3b8, \"thetasym;\":0x3d1,\n  \"thetav;\":0x3d1, \"thickapprox;\":0x2248,\n  \"thicksim;\":0x223c, \"thinsp;\":0x2009,\n  \"thkap;\":0x2248, \"thksim;\":0x223c,\n  \"thorn\":0xfe, \"thorn;\":0xfe,\n  \"tilde;\":0x2dc, \"times\":0xd7,\n  \"times;\":0xd7, \"timesb;\":0x22a0,\n  \"timesbar;\":0x2a31, \"timesd;\":0x2a30,\n  \"tint;\":0x222d, \"toea;\":0x2928,\n  \"top;\":0x22a4, \"topbot;\":0x2336,\n  \"topcir;\":0x2af1, \"topf;\":[0xd835,0xdd65],\n  \"topfork;\":0x2ada, \"tosa;\":0x2929,\n  \"tprime;\":0x2034, \"trade;\":0x2122,\n  \"triangle;\":0x25b5, \"triangledown;\":0x25bf,\n  \"triangleleft;\":0x25c3, \"trianglelefteq;\":0x22b4,\n  \"triangleq;\":0x225c, \"triangleright;\":0x25b9,\n  \"trianglerighteq;\":0x22b5, \"tridot;\":0x25ec,\n  \"trie;\":0x225c, \"triminus;\":0x2a3a,\n  \"triplus;\":0x2a39, \"trisb;\":0x29cd,\n  \"tritime;\":0x2a3b, \"trpezium;\":0x23e2,\n  \"tscr;\":[0xd835,0xdcc9], \"tscy;\":0x446,\n  \"tshcy;\":0x45b, \"tstrok;\":0x167,\n  \"twixt;\":0x226c, \"twoheadleftarrow;\":0x219e,\n  \"twoheadrightarrow;\":0x21a0, \"uArr;\":0x21d1,\n  \"uHar;\":0x2963, \"uacute\":0xfa,\n  \"uacute;\":0xfa, \"uarr;\":0x2191,\n  \"ubrcy;\":0x45e, \"ubreve;\":0x16d,\n  \"ucirc\":0xfb, \"ucirc;\":0xfb,\n  \"ucy;\":0x443, \"udarr;\":0x21c5,\n  \"udblac;\":0x171, \"udhar;\":0x296e,\n  \"ufisht;\":0x297e, \"ufr;\":[0xd835,0xdd32],\n  \"ugrave\":0xf9, \"ugrave;\":0xf9,\n  \"uharl;\":0x21bf, \"uharr;\":0x21be,\n  \"uhblk;\":0x2580, \"ulcorn;\":0x231c,\n  \"ulcorner;\":0x231c, \"ulcrop;\":0x230f,\n  \"ultri;\":0x25f8, \"umacr;\":0x16b,\n  \"uml\":0xa8, \"uml;\":0xa8,\n  \"uogon;\":0x173, \"uopf;\":[0xd835,0xdd66],\n  \"uparrow;\":0x2191, \"updownarrow;\":0x2195,\n  \"upharpoonleft;\":0x21bf, \"upharpoonright;\":0x21be,\n  \"uplus;\":0x228e, \"upsi;\":0x3c5,\n  \"upsih;\":0x3d2, \"upsilon;\":0x3c5,\n  \"upuparrows;\":0x21c8, \"urcorn;\":0x231d,\n  \"urcorner;\":0x231d, \"urcrop;\":0x230e,\n  \"uring;\":0x16f, \"urtri;\":0x25f9,\n  \"uscr;\":[0xd835,0xdcca], \"utdot;\":0x22f0,\n  \"utilde;\":0x169, \"utri;\":0x25b5,\n  \"utrif;\":0x25b4, \"uuarr;\":0x21c8,\n  \"uuml\":0xfc, \"uuml;\":0xfc,\n  \"uwangle;\":0x29a7, \"vArr;\":0x21d5,\n  \"vBar;\":0x2ae8, \"vBarv;\":0x2ae9,\n  \"vDash;\":0x22a8, \"vangrt;\":0x299c,\n  \"varepsilon;\":0x3f5, \"varkappa;\":0x3f0,\n  \"varnothing;\":0x2205, \"varphi;\":0x3d5,\n  \"varpi;\":0x3d6, \"varpropto;\":0x221d,\n  \"varr;\":0x2195, \"varrho;\":0x3f1,\n  \"varsigma;\":0x3c2, \"varsubsetneq;\":[0x228a,0xfe00],\n  \"varsubsetneqq;\":[0x2acb,0xfe00], \"varsupsetneq;\":[0x228b,0xfe00],\n  \"varsupsetneqq;\":[0x2acc,0xfe00], \"vartheta;\":0x3d1,\n  \"vartriangleleft;\":0x22b2, \"vartriangleright;\":0x22b3,\n  \"vcy;\":0x432, \"vdash;\":0x22a2,\n  \"vee;\":0x2228, \"veebar;\":0x22bb,\n  \"veeeq;\":0x225a, \"vellip;\":0x22ee,\n  \"verbar;\":0x7c, \"vert;\":0x7c,\n  \"vfr;\":[0xd835,0xdd33], \"vltri;\":0x22b2,\n  \"vnsub;\":[0x2282,0x20d2], \"vnsup;\":[0x2283,0x20d2],\n  \"vopf;\":[0xd835,0xdd67], \"vprop;\":0x221d,\n  \"vrtri;\":0x22b3, \"vscr;\":[0xd835,0xdccb],\n  \"vsubnE;\":[0x2acb,0xfe00], \"vsubne;\":[0x228a,0xfe00],\n  \"vsupnE;\":[0x2acc,0xfe00], \"vsupne;\":[0x228b,0xfe00],\n  \"vzigzag;\":0x299a, \"wcirc;\":0x175,\n  \"wedbar;\":0x2a5f, \"wedge;\":0x2227,\n  \"wedgeq;\":0x2259, \"weierp;\":0x2118,\n  \"wfr;\":[0xd835,0xdd34], \"wopf;\":[0xd835,0xdd68],\n  \"wp;\":0x2118, \"wr;\":0x2240,\n  \"wreath;\":0x2240, \"wscr;\":[0xd835,0xdccc],\n  \"xcap;\":0x22c2, \"xcirc;\":0x25ef,\n  \"xcup;\":0x22c3, \"xdtri;\":0x25bd,\n  \"xfr;\":[0xd835,0xdd35], \"xhArr;\":0x27fa,\n  \"xharr;\":0x27f7, \"xi;\":0x3be,\n  \"xlArr;\":0x27f8, \"xlarr;\":0x27f5,\n  \"xmap;\":0x27fc, \"xnis;\":0x22fb,\n  \"xodot;\":0x2a00, \"xopf;\":[0xd835,0xdd69],\n  \"xoplus;\":0x2a01, \"xotime;\":0x2a02,\n  \"xrArr;\":0x27f9, \"xrarr;\":0x27f6,\n  \"xscr;\":[0xd835,0xdccd], \"xsqcup;\":0x2a06,\n  \"xuplus;\":0x2a04, \"xutri;\":0x25b3,\n  \"xvee;\":0x22c1, \"xwedge;\":0x22c0,\n  \"yacute\":0xfd, \"yacute;\":0xfd,\n  \"yacy;\":0x44f, \"ycirc;\":0x177,\n  \"ycy;\":0x44b, \"yen\":0xa5,\n  \"yen;\":0xa5, \"yfr;\":[0xd835,0xdd36],\n  \"yicy;\":0x457, \"yopf;\":[0xd835,0xdd6a],\n  \"yscr;\":[0xd835,0xdcce], \"yucy;\":0x44e,\n  \"yuml\":0xff, \"yuml;\":0xff,\n  \"zacute;\":0x17a, \"zcaron;\":0x17e,\n  \"zcy;\":0x437, \"zdot;\":0x17c,\n  \"zeetrf;\":0x2128, \"zeta;\":0x3b6,\n  \"zfr;\":[0xd835,0xdd37], \"zhcy;\":0x436,\n  \"zigrarr;\":0x21dd, \"zopf;\":[0xd835,0xdd6b],\n  \"zscr;\":[0xd835,0xdccf], \"zwj;\":0x200d,\n  \"zwnj;\":0x200c,\n};\n/*\n * This regexp is generated with test/tools/update-entities.js\n * It will always match at least one character -- but note that there\n * are no entities whose names are a single character long.\n */\nvar NAMEDCHARREF = /(A(?:Elig;?|MP;?|acute;?|breve;|c(?:irc;?|y;)|fr;|grave;?|lpha;|macr;|nd;|o(?:gon;|pf;)|pplyFunction;|ring;?|s(?:cr;|sign;)|tilde;?|uml;?)|B(?:a(?:ckslash;|r(?:v;|wed;))|cy;|e(?:cause;|rnoullis;|ta;)|fr;|opf;|reve;|scr;|umpeq;)|C(?:Hcy;|OPY;?|a(?:cute;|p(?:;|italDifferentialD;)|yleys;)|c(?:aron;|edil;?|irc;|onint;)|dot;|e(?:dilla;|nterDot;)|fr;|hi;|ircle(?:Dot;|Minus;|Plus;|Times;)|lo(?:ckwiseContourIntegral;|seCurly(?:DoubleQuote;|Quote;))|o(?:lon(?:;|e;)|n(?:gruent;|int;|tourIntegral;)|p(?:f;|roduct;)|unterClockwiseContourIntegral;)|ross;|scr;|up(?:;|Cap;))|D(?:D(?:;|otrahd;)|Jcy;|Scy;|Zcy;|a(?:gger;|rr;|shv;)|c(?:aron;|y;)|el(?:;|ta;)|fr;|i(?:a(?:critical(?:Acute;|Do(?:t;|ubleAcute;)|Grave;|Tilde;)|mond;)|fferentialD;)|o(?:pf;|t(?:;|Dot;|Equal;)|uble(?:ContourIntegral;|Do(?:t;|wnArrow;)|L(?:eft(?:Arrow;|RightArrow;|Tee;)|ong(?:Left(?:Arrow;|RightArrow;)|RightArrow;))|Right(?:Arrow;|Tee;)|Up(?:Arrow;|DownArrow;)|VerticalBar;)|wn(?:Arrow(?:;|Bar;|UpArrow;)|Breve;|Left(?:RightVector;|TeeVector;|Vector(?:;|Bar;))|Right(?:TeeVector;|Vector(?:;|Bar;))|Tee(?:;|Arrow;)|arrow;))|s(?:cr;|trok;))|E(?:NG;|TH;?|acute;?|c(?:aron;|irc;?|y;)|dot;|fr;|grave;?|lement;|m(?:acr;|pty(?:SmallSquare;|VerySmallSquare;))|o(?:gon;|pf;)|psilon;|qu(?:al(?:;|Tilde;)|ilibrium;)|s(?:cr;|im;)|ta;|uml;?|x(?:ists;|ponentialE;))|F(?:cy;|fr;|illed(?:SmallSquare;|VerySmallSquare;)|o(?:pf;|rAll;|uriertrf;)|scr;)|G(?:Jcy;|T;?|amma(?:;|d;)|breve;|c(?:edil;|irc;|y;)|dot;|fr;|g;|opf;|reater(?:Equal(?:;|Less;)|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|scr;|t;)|H(?:ARDcy;|a(?:cek;|t;)|circ;|fr;|ilbertSpace;|o(?:pf;|rizontalLine;)|s(?:cr;|trok;)|ump(?:DownHump;|Equal;))|I(?:Ecy;|Jlig;|Ocy;|acute;?|c(?:irc;?|y;)|dot;|fr;|grave;?|m(?:;|a(?:cr;|ginaryI;)|plies;)|n(?:t(?:;|e(?:gral;|rsection;))|visible(?:Comma;|Times;))|o(?:gon;|pf;|ta;)|scr;|tilde;|u(?:kcy;|ml;?))|J(?:c(?:irc;|y;)|fr;|opf;|s(?:cr;|ercy;)|ukcy;)|K(?:Hcy;|Jcy;|appa;|c(?:edil;|y;)|fr;|opf;|scr;)|L(?:Jcy;|T;?|a(?:cute;|mbda;|ng;|placetrf;|rr;)|c(?:aron;|edil;|y;)|e(?:ft(?:A(?:ngleBracket;|rrow(?:;|Bar;|RightArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|Right(?:Arrow;|Vector;)|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;|rightarrow;)|ss(?:EqualGreater;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;))|fr;|l(?:;|eftarrow;)|midot;|o(?:ng(?:Left(?:Arrow;|RightArrow;)|RightArrow;|left(?:arrow;|rightarrow;)|rightarrow;)|pf;|wer(?:LeftArrow;|RightArrow;))|s(?:cr;|h;|trok;)|t;)|M(?:ap;|cy;|e(?:diumSpace;|llintrf;)|fr;|inusPlus;|opf;|scr;|u;)|N(?:Jcy;|acute;|c(?:aron;|edil;|y;)|e(?:gative(?:MediumSpace;|Thi(?:ckSpace;|nSpace;)|VeryThinSpace;)|sted(?:GreaterGreater;|LessLess;)|wLine;)|fr;|o(?:Break;|nBreakingSpace;|pf;|t(?:;|C(?:ongruent;|upCap;)|DoubleVerticalBar;|E(?:lement;|qual(?:;|Tilde;)|xists;)|Greater(?:;|Equal;|FullEqual;|Greater;|Less;|SlantEqual;|Tilde;)|Hump(?:DownHump;|Equal;)|Le(?:ftTriangle(?:;|Bar;|Equal;)|ss(?:;|Equal;|Greater;|Less;|SlantEqual;|Tilde;))|Nested(?:GreaterGreater;|LessLess;)|Precedes(?:;|Equal;|SlantEqual;)|R(?:everseElement;|ightTriangle(?:;|Bar;|Equal;))|S(?:quareSu(?:bset(?:;|Equal;)|perset(?:;|Equal;))|u(?:bset(?:;|Equal;)|cceeds(?:;|Equal;|SlantEqual;|Tilde;)|perset(?:;|Equal;)))|Tilde(?:;|Equal;|FullEqual;|Tilde;)|VerticalBar;))|scr;|tilde;?|u;)|O(?:Elig;|acute;?|c(?:irc;?|y;)|dblac;|fr;|grave;?|m(?:acr;|ega;|icron;)|opf;|penCurly(?:DoubleQuote;|Quote;)|r;|s(?:cr;|lash;?)|ti(?:lde;?|mes;)|uml;?|ver(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;))|P(?:artialD;|cy;|fr;|hi;|i;|lusMinus;|o(?:incareplane;|pf;)|r(?:;|ecedes(?:;|Equal;|SlantEqual;|Tilde;)|ime;|o(?:duct;|portion(?:;|al;)))|s(?:cr;|i;))|Q(?:UOT;?|fr;|opf;|scr;)|R(?:Barr;|EG;?|a(?:cute;|ng;|rr(?:;|tl;))|c(?:aron;|edil;|y;)|e(?:;|verse(?:E(?:lement;|quilibrium;)|UpEquilibrium;))|fr;|ho;|ight(?:A(?:ngleBracket;|rrow(?:;|Bar;|LeftArrow;))|Ceiling;|Do(?:ubleBracket;|wn(?:TeeVector;|Vector(?:;|Bar;)))|Floor;|T(?:ee(?:;|Arrow;|Vector;)|riangle(?:;|Bar;|Equal;))|Up(?:DownVector;|TeeVector;|Vector(?:;|Bar;))|Vector(?:;|Bar;)|arrow;)|o(?:pf;|undImplies;)|rightarrow;|s(?:cr;|h;)|uleDelayed;)|S(?:H(?:CHcy;|cy;)|OFTcy;|acute;|c(?:;|aron;|edil;|irc;|y;)|fr;|hort(?:DownArrow;|LeftArrow;|RightArrow;|UpArrow;)|igma;|mallCircle;|opf;|q(?:rt;|uare(?:;|Intersection;|Su(?:bset(?:;|Equal;)|perset(?:;|Equal;))|Union;))|scr;|tar;|u(?:b(?:;|set(?:;|Equal;))|c(?:ceeds(?:;|Equal;|SlantEqual;|Tilde;)|hThat;)|m;|p(?:;|erset(?:;|Equal;)|set;)))|T(?:HORN;?|RADE;|S(?:Hcy;|cy;)|a(?:b;|u;)|c(?:aron;|edil;|y;)|fr;|h(?:e(?:refore;|ta;)|i(?:ckSpace;|nSpace;))|ilde(?:;|Equal;|FullEqual;|Tilde;)|opf;|ripleDot;|s(?:cr;|trok;))|U(?:a(?:cute;?|rr(?:;|ocir;))|br(?:cy;|eve;)|c(?:irc;?|y;)|dblac;|fr;|grave;?|macr;|n(?:der(?:B(?:ar;|rac(?:e;|ket;))|Parenthesis;)|ion(?:;|Plus;))|o(?:gon;|pf;)|p(?:Arrow(?:;|Bar;|DownArrow;)|DownArrow;|Equilibrium;|Tee(?:;|Arrow;)|arrow;|downarrow;|per(?:LeftArrow;|RightArrow;)|si(?:;|lon;))|ring;|scr;|tilde;|uml;?)|V(?:Dash;|bar;|cy;|dash(?:;|l;)|e(?:e;|r(?:bar;|t(?:;|ical(?:Bar;|Line;|Separator;|Tilde;))|yThinSpace;))|fr;|opf;|scr;|vdash;)|W(?:circ;|edge;|fr;|opf;|scr;)|X(?:fr;|i;|opf;|scr;)|Y(?:Acy;|Icy;|Ucy;|acute;?|c(?:irc;|y;)|fr;|opf;|scr;|uml;)|Z(?:Hcy;|acute;|c(?:aron;|y;)|dot;|e(?:roWidthSpace;|ta;)|fr;|opf;|scr;)|a(?:acute;?|breve;|c(?:;|E;|d;|irc;?|ute;?|y;)|elig;?|f(?:;|r;)|grave;?|l(?:e(?:fsym;|ph;)|pha;)|m(?:a(?:cr;|lg;)|p;?)|n(?:d(?:;|and;|d;|slope;|v;)|g(?:;|e;|le;|msd(?:;|a(?:a;|b;|c;|d;|e;|f;|g;|h;))|rt(?:;|vb(?:;|d;))|s(?:ph;|t;)|zarr;))|o(?:gon;|pf;)|p(?:;|E;|acir;|e;|id;|os;|prox(?:;|eq;))|ring;?|s(?:cr;|t;|ymp(?:;|eq;))|tilde;?|uml;?|w(?:conint;|int;))|b(?:Not;|a(?:ck(?:cong;|epsilon;|prime;|sim(?:;|eq;))|r(?:vee;|wed(?:;|ge;)))|brk(?:;|tbrk;)|c(?:ong;|y;)|dquo;|e(?:caus(?:;|e;)|mptyv;|psi;|rnou;|t(?:a;|h;|ween;))|fr;|ig(?:c(?:ap;|irc;|up;)|o(?:dot;|plus;|times;)|s(?:qcup;|tar;)|triangle(?:down;|up;)|uplus;|vee;|wedge;)|karow;|l(?:a(?:ck(?:lozenge;|square;|triangle(?:;|down;|left;|right;))|nk;)|k(?:1(?:2;|4;)|34;)|ock;)|n(?:e(?:;|quiv;)|ot;)|o(?:pf;|t(?:;|tom;)|wtie;|x(?:D(?:L;|R;|l;|r;)|H(?:;|D;|U;|d;|u;)|U(?:L;|R;|l;|r;)|V(?:;|H;|L;|R;|h;|l;|r;)|box;|d(?:L;|R;|l;|r;)|h(?:;|D;|U;|d;|u;)|minus;|plus;|times;|u(?:L;|R;|l;|r;)|v(?:;|H;|L;|R;|h;|l;|r;)))|prime;|r(?:eve;|vbar;?)|s(?:cr;|emi;|im(?:;|e;)|ol(?:;|b;|hsub;))|u(?:ll(?:;|et;)|mp(?:;|E;|e(?:;|q;))))|c(?:a(?:cute;|p(?:;|and;|brcup;|c(?:ap;|up;)|dot;|s;)|r(?:et;|on;))|c(?:a(?:ps;|ron;)|edil;?|irc;|ups(?:;|sm;))|dot;|e(?:dil;?|mptyv;|nt(?:;|erdot;|))|fr;|h(?:cy;|eck(?:;|mark;)|i;)|ir(?:;|E;|c(?:;|eq;|le(?:arrow(?:left;|right;)|d(?:R;|S;|ast;|circ;|dash;)))|e;|fnint;|mid;|scir;)|lubs(?:;|uit;)|o(?:lon(?:;|e(?:;|q;))|m(?:ma(?:;|t;)|p(?:;|fn;|le(?:ment;|xes;)))|n(?:g(?:;|dot;)|int;)|p(?:f;|rod;|y(?:;|sr;|)))|r(?:arr;|oss;)|s(?:cr;|u(?:b(?:;|e;)|p(?:;|e;)))|tdot;|u(?:darr(?:l;|r;)|e(?:pr;|sc;)|larr(?:;|p;)|p(?:;|brcap;|c(?:ap;|up;)|dot;|or;|s;)|r(?:arr(?:;|m;)|ly(?:eq(?:prec;|succ;)|vee;|wedge;)|ren;?|vearrow(?:left;|right;))|vee;|wed;)|w(?:conint;|int;)|ylcty;)|d(?:Arr;|Har;|a(?:gger;|leth;|rr;|sh(?:;|v;))|b(?:karow;|lac;)|c(?:aron;|y;)|d(?:;|a(?:gger;|rr;)|otseq;)|e(?:g;?|lta;|mptyv;)|f(?:isht;|r;)|har(?:l;|r;)|i(?:am(?:;|ond(?:;|suit;)|s;)|e;|gamma;|sin;|v(?:;|ide(?:;|ontimes;|)|onx;))|jcy;|lc(?:orn;|rop;)|o(?:llar;|pf;|t(?:;|eq(?:;|dot;)|minus;|plus;|square;)|ublebarwedge;|wn(?:arrow;|downarrows;|harpoon(?:left;|right;)))|r(?:bkarow;|c(?:orn;|rop;))|s(?:c(?:r;|y;)|ol;|trok;)|t(?:dot;|ri(?:;|f;))|u(?:arr;|har;)|wangle;|z(?:cy;|igrarr;))|e(?:D(?:Dot;|ot;)|a(?:cute;?|ster;)|c(?:aron;|ir(?:;|c;?)|olon;|y;)|dot;|e;|f(?:Dot;|r;)|g(?:;|rave;?|s(?:;|dot;))|l(?:;|inters;|l;|s(?:;|dot;))|m(?:acr;|pty(?:;|set;|v;)|sp(?:1(?:3;|4;)|;))|n(?:g;|sp;)|o(?:gon;|pf;)|p(?:ar(?:;|sl;)|lus;|si(?:;|lon;|v;))|q(?:c(?:irc;|olon;)|s(?:im;|lant(?:gtr;|less;))|u(?:als;|est;|iv(?:;|DD;))|vparsl;)|r(?:Dot;|arr;)|s(?:cr;|dot;|im;)|t(?:a;|h;?)|u(?:ml;?|ro;)|x(?:cl;|ist;|p(?:ectation;|onentiale;)))|f(?:allingdotseq;|cy;|emale;|f(?:ilig;|l(?:ig;|lig;)|r;)|ilig;|jlig;|l(?:at;|lig;|tns;)|nof;|o(?:pf;|r(?:all;|k(?:;|v;)))|partint;|r(?:a(?:c(?:1(?:2;?|3;|4;?|5;|6;|8;)|2(?:3;|5;)|3(?:4;?|5;|8;)|45;|5(?:6;|8;)|78;)|sl;)|own;)|scr;)|g(?:E(?:;|l;)|a(?:cute;|mma(?:;|d;)|p;)|breve;|c(?:irc;|y;)|dot;|e(?:;|l;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|l;))|l(?:;|es;)))|fr;|g(?:;|g;)|imel;|jcy;|l(?:;|E;|a;|j;)|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|opf;|rave;|s(?:cr;|im(?:;|e;|l;))|t(?:;|c(?:c;|ir;)|dot;|lPar;|quest;|r(?:a(?:pprox;|rr;)|dot;|eq(?:less;|qless;)|less;|sim;)|)|v(?:ertneqq;|nE;))|h(?:Arr;|a(?:irsp;|lf;|milt;|r(?:dcy;|r(?:;|cir;|w;)))|bar;|circ;|e(?:arts(?:;|uit;)|llip;|rcon;)|fr;|ks(?:earow;|warow;)|o(?:arr;|mtht;|ok(?:leftarrow;|rightarrow;)|pf;|rbar;)|s(?:cr;|lash;|trok;)|y(?:bull;|phen;))|i(?:acute;?|c(?:;|irc;?|y;)|e(?:cy;|xcl;?)|f(?:f;|r;)|grave;?|i(?:;|i(?:int;|nt;)|nfin;|ota;)|jlig;|m(?:a(?:cr;|g(?:e;|line;|part;)|th;)|of;|ped;)|n(?:;|care;|fin(?:;|tie;)|odot;|t(?:;|cal;|e(?:gers;|rcal;)|larhk;|prod;))|o(?:cy;|gon;|pf;|ta;)|prod;|quest;?|s(?:cr;|in(?:;|E;|dot;|s(?:;|v;)|v;))|t(?:;|ilde;)|u(?:kcy;|ml;?))|j(?:c(?:irc;|y;)|fr;|math;|opf;|s(?:cr;|ercy;)|ukcy;)|k(?:appa(?:;|v;)|c(?:edil;|y;)|fr;|green;|hcy;|jcy;|opf;|scr;)|l(?:A(?:arr;|rr;|tail;)|Barr;|E(?:;|g;)|Har;|a(?:cute;|emptyv;|gran;|mbda;|ng(?:;|d;|le;)|p;|quo;?|rr(?:;|b(?:;|fs;)|fs;|hk;|lp;|pl;|sim;|tl;)|t(?:;|ail;|e(?:;|s;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|quo(?:;|r;)|r(?:dhar;|ushar;)|sh;)|e(?:;|ft(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|leftarrows;|right(?:arrow(?:;|s;)|harpoons;|squigarrow;)|threetimes;)|g;|q(?:;|q;|slant;)|s(?:;|cc;|dot(?:;|o(?:;|r;))|g(?:;|es;)|s(?:approx;|dot;|eq(?:gtr;|qgtr;)|gtr;|sim;)))|f(?:isht;|loor;|r;)|g(?:;|E;)|h(?:ar(?:d;|u(?:;|l;))|blk;)|jcy;|l(?:;|arr;|corner;|hard;|tri;)|m(?:idot;|oust(?:;|ache;))|n(?:E;|ap(?:;|prox;)|e(?:;|q(?:;|q;))|sim;)|o(?:a(?:ng;|rr;)|brk;|ng(?:left(?:arrow;|rightarrow;)|mapsto;|rightarrow;)|oparrow(?:left;|right;)|p(?:ar;|f;|lus;)|times;|w(?:ast;|bar;)|z(?:;|enge;|f;))|par(?:;|lt;)|r(?:arr;|corner;|har(?:;|d;)|m;|tri;)|s(?:aquo;|cr;|h;|im(?:;|e;|g;)|q(?:b;|uo(?:;|r;))|trok;)|t(?:;|c(?:c;|ir;)|dot;|hree;|imes;|larr;|quest;|r(?:Par;|i(?:;|e;|f;))|)|ur(?:dshar;|uhar;)|v(?:ertneqq;|nE;))|m(?:DDot;|a(?:cr;?|l(?:e;|t(?:;|ese;))|p(?:;|sto(?:;|down;|left;|up;))|rker;)|c(?:omma;|y;)|dash;|easuredangle;|fr;|ho;|i(?:cro;?|d(?:;|ast;|cir;|dot;?)|nus(?:;|b;|d(?:;|u;)))|l(?:cp;|dr;)|nplus;|o(?:dels;|pf;)|p;|s(?:cr;|tpos;)|u(?:;|ltimap;|map;))|n(?:G(?:g;|t(?:;|v;))|L(?:eft(?:arrow;|rightarrow;)|l;|t(?:;|v;))|Rightarrow;|V(?:Dash;|dash;)|a(?:bla;|cute;|ng;|p(?:;|E;|id;|os;|prox;)|tur(?:;|al(?:;|s;)))|b(?:sp;?|ump(?:;|e;))|c(?:a(?:p;|ron;)|edil;|ong(?:;|dot;)|up;|y;)|dash;|e(?:;|Arr;|ar(?:hk;|r(?:;|ow;))|dot;|quiv;|s(?:ear;|im;)|xist(?:;|s;))|fr;|g(?:E;|e(?:;|q(?:;|q;|slant;)|s;)|sim;|t(?:;|r;))|h(?:Arr;|arr;|par;)|i(?:;|s(?:;|d;)|v;)|jcy;|l(?:Arr;|E;|arr;|dr;|e(?:;|ft(?:arrow;|rightarrow;)|q(?:;|q;|slant;)|s(?:;|s;))|sim;|t(?:;|ri(?:;|e;)))|mid;|o(?:pf;|t(?:;|in(?:;|E;|dot;|v(?:a;|b;|c;))|ni(?:;|v(?:a;|b;|c;))|))|p(?:ar(?:;|allel;|sl;|t;)|olint;|r(?:;|cue;|e(?:;|c(?:;|eq;))))|r(?:Arr;|arr(?:;|c;|w;)|ightarrow;|tri(?:;|e;))|s(?:c(?:;|cue;|e;|r;)|hort(?:mid;|parallel;)|im(?:;|e(?:;|q;))|mid;|par;|qsu(?:be;|pe;)|u(?:b(?:;|E;|e;|set(?:;|eq(?:;|q;)))|cc(?:;|eq;)|p(?:;|E;|e;|set(?:;|eq(?:;|q;)))))|t(?:gl;|ilde;?|lg;|riangle(?:left(?:;|eq;)|right(?:;|eq;)))|u(?:;|m(?:;|ero;|sp;))|v(?:Dash;|Harr;|ap;|dash;|g(?:e;|t;)|infin;|l(?:Arr;|e;|t(?:;|rie;))|r(?:Arr;|trie;)|sim;)|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|near;))|o(?:S;|a(?:cute;?|st;)|c(?:ir(?:;|c;?)|y;)|d(?:ash;|blac;|iv;|ot;|sold;)|elig;|f(?:cir;|r;)|g(?:on;|rave;?|t;)|h(?:bar;|m;)|int;|l(?:arr;|c(?:ir;|ross;)|ine;|t;)|m(?:acr;|ega;|i(?:cron;|d;|nus;))|opf;|p(?:ar;|erp;|lus;)|r(?:;|arr;|d(?:;|er(?:;|of;)|f;?|m;?)|igof;|or;|slope;|v;)|s(?:cr;|lash;?|ol;)|ti(?:lde;?|mes(?:;|as;))|uml;?|vbar;)|p(?:ar(?:;|a(?:;|llel;|)|s(?:im;|l;)|t;)|cy;|er(?:cnt;|iod;|mil;|p;|tenk;)|fr;|h(?:i(?:;|v;)|mmat;|one;)|i(?:;|tchfork;|v;)|l(?:an(?:ck(?:;|h;)|kv;)|us(?:;|acir;|b;|cir;|d(?:o;|u;)|e;|mn;?|sim;|two;))|m;|o(?:intint;|pf;|und;?)|r(?:;|E;|ap;|cue;|e(?:;|c(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;))|ime(?:;|s;)|n(?:E;|ap;|sim;)|o(?:d;|f(?:alar;|line;|surf;)|p(?:;|to;))|sim;|urel;)|s(?:cr;|i;)|uncsp;)|q(?:fr;|int;|opf;|prime;|scr;|u(?:at(?:ernions;|int;)|est(?:;|eq;)|ot;?))|r(?:A(?:arr;|rr;|tail;)|Barr;|Har;|a(?:c(?:e;|ute;)|dic;|emptyv;|ng(?:;|d;|e;|le;)|quo;?|rr(?:;|ap;|b(?:;|fs;)|c;|fs;|hk;|lp;|pl;|sim;|tl;|w;)|t(?:ail;|io(?:;|nals;)))|b(?:arr;|brk;|r(?:ac(?:e;|k;)|k(?:e;|sl(?:d;|u;))))|c(?:aron;|e(?:dil;|il;)|ub;|y;)|d(?:ca;|ldhar;|quo(?:;|r;)|sh;)|e(?:al(?:;|ine;|part;|s;)|ct;|g;?)|f(?:isht;|loor;|r;)|h(?:ar(?:d;|u(?:;|l;))|o(?:;|v;))|i(?:ght(?:arrow(?:;|tail;)|harpoon(?:down;|up;)|left(?:arrows;|harpoons;)|rightarrows;|squigarrow;|threetimes;)|ng;|singdotseq;)|l(?:arr;|har;|m;)|moust(?:;|ache;)|nmid;|o(?:a(?:ng;|rr;)|brk;|p(?:ar;|f;|lus;)|times;)|p(?:ar(?:;|gt;)|polint;)|rarr;|s(?:aquo;|cr;|h;|q(?:b;|uo(?:;|r;)))|t(?:hree;|imes;|ri(?:;|e;|f;|ltri;))|uluhar;|x;)|s(?:acute;|bquo;|c(?:;|E;|a(?:p;|ron;)|cue;|e(?:;|dil;)|irc;|n(?:E;|ap;|sim;)|polint;|sim;|y;)|dot(?:;|b;|e;)|e(?:Arr;|ar(?:hk;|r(?:;|ow;))|ct;?|mi;|swar;|tm(?:inus;|n;)|xt;)|fr(?:;|own;)|h(?:arp;|c(?:hcy;|y;)|ort(?:mid;|parallel;)|y;?)|i(?:gma(?:;|f;|v;)|m(?:;|dot;|e(?:;|q;)|g(?:;|E;)|l(?:;|E;)|ne;|plus;|rarr;))|larr;|m(?:a(?:llsetminus;|shp;)|eparsl;|i(?:d;|le;)|t(?:;|e(?:;|s;)))|o(?:ftcy;|l(?:;|b(?:;|ar;))|pf;)|pa(?:des(?:;|uit;)|r;)|q(?:c(?:ap(?:;|s;)|up(?:;|s;))|su(?:b(?:;|e;|set(?:;|eq;))|p(?:;|e;|set(?:;|eq;)))|u(?:;|ar(?:e;|f;)|f;))|rarr;|s(?:cr;|etmn;|mile;|tarf;)|t(?:ar(?:;|f;)|r(?:aight(?:epsilon;|phi;)|ns;))|u(?:b(?:;|E;|dot;|e(?:;|dot;)|mult;|n(?:E;|e;)|plus;|rarr;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;)))|cc(?:;|approx;|curlyeq;|eq;|n(?:approx;|eqq;|sim;)|sim;)|m;|ng;|p(?:1;?|2;?|3;?|;|E;|d(?:ot;|sub;)|e(?:;|dot;)|hs(?:ol;|ub;)|larr;|mult;|n(?:E;|e;)|plus;|s(?:et(?:;|eq(?:;|q;)|neq(?:;|q;))|im;|u(?:b;|p;))))|w(?:Arr;|ar(?:hk;|r(?:;|ow;))|nwar;)|zlig;?)|t(?:a(?:rget;|u;)|brk;|c(?:aron;|edil;|y;)|dot;|elrec;|fr;|h(?:e(?:re(?:4;|fore;)|ta(?:;|sym;|v;))|i(?:ck(?:approx;|sim;)|nsp;)|k(?:ap;|sim;)|orn;?)|i(?:lde;|mes(?:;|b(?:;|ar;)|d;|)|nt;)|o(?:ea;|p(?:;|bot;|cir;|f(?:;|ork;))|sa;)|prime;|r(?:ade;|i(?:angle(?:;|down;|left(?:;|eq;)|q;|right(?:;|eq;))|dot;|e;|minus;|plus;|sb;|time;)|pezium;)|s(?:c(?:r;|y;)|hcy;|trok;)|w(?:ixt;|ohead(?:leftarrow;|rightarrow;)))|u(?:Arr;|Har;|a(?:cute;?|rr;)|br(?:cy;|eve;)|c(?:irc;?|y;)|d(?:arr;|blac;|har;)|f(?:isht;|r;)|grave;?|h(?:ar(?:l;|r;)|blk;)|l(?:c(?:orn(?:;|er;)|rop;)|tri;)|m(?:acr;|l;?)|o(?:gon;|pf;)|p(?:arrow;|downarrow;|harpoon(?:left;|right;)|lus;|si(?:;|h;|lon;)|uparrows;)|r(?:c(?:orn(?:;|er;)|rop;)|ing;|tri;)|scr;|t(?:dot;|ilde;|ri(?:;|f;))|u(?:arr;|ml;?)|wangle;)|v(?:Arr;|Bar(?:;|v;)|Dash;|a(?:ngrt;|r(?:epsilon;|kappa;|nothing;|p(?:hi;|i;|ropto;)|r(?:;|ho;)|s(?:igma;|u(?:bsetneq(?:;|q;)|psetneq(?:;|q;)))|t(?:heta;|riangle(?:left;|right;))))|cy;|dash;|e(?:e(?:;|bar;|eq;)|llip;|r(?:bar;|t;))|fr;|ltri;|nsu(?:b;|p;)|opf;|prop;|rtri;|s(?:cr;|u(?:bn(?:E;|e;)|pn(?:E;|e;)))|zigzag;)|w(?:circ;|e(?:d(?:bar;|ge(?:;|q;))|ierp;)|fr;|opf;|p;|r(?:;|eath;)|scr;)|x(?:c(?:ap;|irc;|up;)|dtri;|fr;|h(?:Arr;|arr;)|i;|l(?:Arr;|arr;)|map;|nis;|o(?:dot;|p(?:f;|lus;)|time;)|r(?:Arr;|arr;)|s(?:cr;|qcup;)|u(?:plus;|tri;)|vee;|wedge;)|y(?:ac(?:ute;?|y;)|c(?:irc;|y;)|en;?|fr;|icy;|opf;|scr;|u(?:cy;|ml;?))|z(?:acute;|c(?:aron;|y;)|dot;|e(?:etrf;|ta;)|fr;|hcy;|igrarr;|opf;|scr;|w(?:j;|nj;)))|[\\s\\S]/g;\n\nvar NAMEDCHARREF_MAXLEN = 32;\n\n// Regular expression constants used by the tokenizer and parser\n\n// Note that \\r is included in all of these regexps because it will need\n// to be converted to LF by the scanChars() function.\nvar DBLQUOTEATTRVAL = /[^\\r\"&\\u0000]+/g;\nvar SINGLEQUOTEATTRVAL = /[^\\r'&\\u0000]+/g;\nvar UNQUOTEDATTRVAL = /[^\\r\\t\\n\\f &>\\u0000]+/g;\nvar TAGNAME = /[^\\r\\t\\n\\f \\/>A-Z\\u0000]+/g;\nvar ATTRNAME = /[^\\r\\t\\n\\f \\/=>A-Z\\u0000]+/g;\n\nvar CDATATEXT = /[^\\]\\r\\u0000\\uffff]*/g;\nvar DATATEXT = /[^&<\\r\\u0000\\uffff]*/g;\nvar RAWTEXT = /[^<\\r\\u0000\\uffff]*/g;\nvar PLAINTEXT = /[^\\r\\u0000\\uffff]*/g;\n// Since we don't have the 'sticky tag', add '|.' to the end of SIMPLETAG\n// and SIMPLEATTR so that we are guaranteed to always match.  This prevents\n// us from scanning past the lastIndex set. (Note that the desired matches\n// are always greater than 1 char long, so longest-match will ensure that .\n// is not matched unless the desired match fails.)\nvar SIMPLETAG = /(?:(\\/)?([a-z]+)>)|[\\s\\S]/g;\nvar SIMPLEATTR = /(?:([-a-z]+)[ \\t\\n\\f]*=[ \\t\\n\\f]*('[^'&\\r\\u0000]*'|\"[^\"&\\r\\u0000]*\"|[^\\t\\n\\r\\f \"&'\\u0000>][^&> \\t\\n\\r\\f\\u0000]*[ \\t\\n\\f]))|[\\s\\S]/g;\n\nvar NONWS = /[^\\x09\\x0A\\x0C\\x0D\\x20]/;\nvar ALLNONWS = /[^\\x09\\x0A\\x0C\\x0D\\x20]/g; // like above, with g flag\nvar NONWSNONNUL = /[^\\x00\\x09\\x0A\\x0C\\x0D\\x20]/; // don't allow NUL either\nvar LEADINGWS = /^[\\x09\\x0A\\x0C\\x0D\\x20]+/;\nvar NULCHARS = /\\x00/g;\n\n/***\n * These are utility functions that don't use any of the parser's\n * internal state.\n */\nfunction buf2str(buf) {\n  var CHUNKSIZE=16384;\n  if (buf.length < CHUNKSIZE) {\n    return String.fromCharCode.apply(String, buf);\n  }\n  // special case for large strings, to avoid busting the stack.\n  var result = '';\n  for (var i = 0; i < buf.length; i += CHUNKSIZE) {\n    result += String.fromCharCode.apply(String, buf.slice(i, i+CHUNKSIZE));\n  }\n  return result;\n}\n\nfunction str2buf(s) {\n  var result = [];\n  for (var i=0; i<s.length; i++) {\n    result[i] = s.charCodeAt(i);\n  }\n  return result;\n}\n\n// Determine whether the element is a member of the set.\n// The set is an object that maps namespaces to objects. The objects\n// then map local tagnames to the value true if that tag is part of the set\nfunction isA(elt, set) {\n  if (typeof set === 'string') {\n    // convenience case for testing a particular HTML element\n    return elt.namespaceURI === NAMESPACE.HTML &&\n      elt.localName === set;\n  }\n  var tagnames = set[elt.namespaceURI];\n  return tagnames && tagnames[elt.localName];\n}\n\nfunction isMathmlTextIntegrationPoint(n) {\n  return isA(n, mathmlTextIntegrationPointSet);\n}\n\nfunction isHTMLIntegrationPoint(n) {\n  if (isA(n, htmlIntegrationPointSet)) return true;\n  if (n.namespaceURI === NAMESPACE.MATHML &&\n    n.localName === \"annotation-xml\") {\n    var encoding = n.getAttribute(\"encoding\");\n    if (encoding) encoding = encoding.toLowerCase();\n    if (encoding === \"text/html\" ||\n      encoding === \"application/xhtml+xml\")\n      return true;\n  }\n  return false;\n}\n\nfunction adjustSVGTagName(name) {\n  if (name in svgTagNameAdjustments)\n    return svgTagNameAdjustments[name];\n  else\n    return name;\n}\n\nfunction adjustSVGAttributes(attrs) {\n  for(var i = 0, n = attrs.length; i < n; i++) {\n    if (attrs[i][0] in svgAttrAdjustments) {\n      attrs[i][0] = svgAttrAdjustments[attrs[i][0]];\n    }\n  }\n}\n\nfunction adjustMathMLAttributes(attrs) {\n  for(var i = 0, n = attrs.length; i < n; i++) {\n    if (attrs[i][0] === \"definitionurl\") {\n      attrs[i][0] = \"definitionURL\";\n      break;\n    }\n  }\n}\n\nfunction adjustForeignAttributes(attrs) {\n  for(var i = 0, n = attrs.length; i < n; i++) {\n    if (attrs[i][0] in foreignAttributes) {\n      // Attributes with namespaces get a 3rd element:\n      // [Qname, value, namespace]\n      attrs[i].push(foreignAttributes[attrs[i][0]]);\n    }\n  }\n}\n\n// For each attribute in attrs, if elt doesn't have an attribute\n// by that name, add the attribute to elt\n// XXX: I'm ignoring namespaces for now\nfunction transferAttributes(attrs, elt) {\n  for(var i = 0, n = attrs.length; i < n; i++) {\n    var name = attrs[i][0], value = attrs[i][1];\n    if (elt.hasAttribute(name)) continue;\n    elt._setAttribute(name, value);\n  }\n}\n\n/***\n * The ElementStack class\n */\nHTMLParser.ElementStack = function ElementStack() {\n  this.elements = [];\n  this.top = null; // stack.top is the \"current node\" in the spec\n};\n\n/*\n// This is for debugging only\nHTMLParser.ElementStack.prototype.toString = function(e) {\n  return \"STACK: \" +\n  this.elements.map(function(e) {return e.localName;}).join(\"-\");\n}\n*/\n\nHTMLParser.ElementStack.prototype.push = function(e) {\n  this.elements.push(e);\n  this.top = e;\n};\n\nHTMLParser.ElementStack.prototype.pop = function(e) {\n  this.elements.pop();\n  this.top = this.elements[this.elements.length-1];\n};\n\n// Pop elements off the stack up to and including the first\n// element with the specified (HTML) tagname\nHTMLParser.ElementStack.prototype.popTag = function(tag) {\n  for(var i = this.elements.length-1; i > 0; i--) {\n    var e = this.elements[i];\n    if (isA(e, tag)) break;\n  }\n  this.elements.length = i;\n  this.top = this.elements[i-1];\n};\n\n// Pop elements off the stack up to and including the first\n// element that is an instance of the specified type\nHTMLParser.ElementStack.prototype.popElementType = function(type) {\n  for(var i = this.elements.length-1; i > 0; i--) {\n    if (this.elements[i] instanceof type) break;\n  }\n  this.elements.length = i;\n  this.top = this.elements[i-1];\n};\n\n// Pop elements off the stack up to and including the element e.\n// Note that this is very different from removeElement()\n// This requires that e is on the stack.\nHTMLParser.ElementStack.prototype.popElement = function(e) {\n  for(var i = this.elements.length-1; i > 0; i--) {\n    if (this.elements[i] === e) break;\n  }\n  this.elements.length = i;\n  this.top = this.elements[i-1];\n};\n\n// Remove a specific element from the stack.\n// Do nothing if the element is not on the stack\nHTMLParser.ElementStack.prototype.removeElement = function(e) {\n  if (this.top === e) this.pop();\n  else {\n    var idx = this.elements.lastIndexOf(e);\n    if (idx !== -1)\n      this.elements.splice(idx, 1);\n  }\n};\n\nHTMLParser.ElementStack.prototype.clearToContext = function(set) {\n  // Note that we don't loop to 0. Never pop the <html> elt off.\n  for(var i = this.elements.length-1; i > 0; i--) {\n    if (isA(this.elements[i], set)) break;\n  }\n  this.elements.length = i+1;\n  this.top = this.elements[i];\n};\n\nHTMLParser.ElementStack.prototype.contains = function(tag) {\n  return this.inSpecificScope(tag, Object.create(null));\n};\n\nHTMLParser.ElementStack.prototype.inSpecificScope = function(tag, set) {\n  for(var i = this.elements.length-1; i >= 0; i--) {\n    var elt = this.elements[i];\n    if (isA(elt, tag)) return true;\n    if (isA(elt, set)) return false;\n  }\n  return false;\n};\n\n// Like the above, but for a specific element, not a tagname\nHTMLParser.ElementStack.prototype.elementInSpecificScope = function(target, set) {\n  for(var i = this.elements.length-1; i >= 0; i--) {\n    var elt = this.elements[i];\n    if (elt === target) return true;\n    if (isA(elt, set)) return false;\n  }\n  return false;\n};\n\n// Like the above, but for an element interface, not a tagname\nHTMLParser.ElementStack.prototype.elementTypeInSpecificScope = function(target, set) {\n  for(var i = this.elements.length-1; i >= 0; i--) {\n    var elt = this.elements[i];\n    if (elt instanceof target) return true;\n    if (isA(elt, set)) return false;\n  }\n  return false;\n};\n\nHTMLParser.ElementStack.prototype.inScope = function(tag) {\n  return this.inSpecificScope(tag, inScopeSet);\n};\n\nHTMLParser.ElementStack.prototype.elementInScope = function(e) {\n  return this.elementInSpecificScope(e, inScopeSet);\n};\n\nHTMLParser.ElementStack.prototype.elementTypeInScope = function(type) {\n  return this.elementTypeInSpecificScope(type, inScopeSet);\n};\n\nHTMLParser.ElementStack.prototype.inButtonScope = function(tag) {\n  return this.inSpecificScope(tag, inButtonScopeSet);\n};\n\nHTMLParser.ElementStack.prototype.inListItemScope = function(tag) {\n  return this.inSpecificScope(tag, inListItemScopeSet);\n};\n\nHTMLParser.ElementStack.prototype.inTableScope = function(tag) {\n  return this.inSpecificScope(tag, inTableScopeSet);\n};\n\nHTMLParser.ElementStack.prototype.inSelectScope = function(tag) {\n  // Can't implement this one with inSpecificScope, since it involves\n  // a set defined by inverting another set. So implement manually.\n  for(var i = this.elements.length-1; i >= 0; i--) {\n    var elt = this.elements[i];\n    if (elt.namespaceURI !== NAMESPACE.HTML) return false;\n    var localname = elt.localName;\n    if (localname === tag) return true;\n    if (localname !== \"optgroup\" && localname !== \"option\")\n      return false;\n  }\n  return false;\n};\n\nHTMLParser.ElementStack.prototype.generateImpliedEndTags = function(butnot, thorough) {\n  var endTagSet = thorough ? thoroughImpliedEndTagsSet : impliedEndTagsSet;\n  for(var i = this.elements.length-1; i >= 0; i--) {\n    var e = this.elements[i];\n    if (butnot && isA(e, butnot)) break;\n    if (!isA(this.elements[i], endTagSet)) break;\n  }\n\n  this.elements.length = i+1;\n  this.top = this.elements[i];\n};\n\n/***\n * The ActiveFormattingElements class\n */\nHTMLParser.ActiveFormattingElements = function AFE() {\n  this.list = []; // elements\n  this.attrs = []; // attribute tokens for cloning\n};\n\nHTMLParser.ActiveFormattingElements.prototype.MARKER = { localName: \"|\" };\n\n/*\n// For debugging\nHTMLParser.ActiveFormattingElements.prototype.toString = function() {\n  return \"AFE: \" +\n  this.list.map(function(e) { return e.localName; }).join(\"-\");\n}\n*/\n\nHTMLParser.ActiveFormattingElements.prototype.insertMarker = function() {\n  this.list.push(this.MARKER);\n  this.attrs.push(this.MARKER);\n};\n\nHTMLParser.ActiveFormattingElements.prototype.push = function(elt, attrs) {\n  // Scan backwards: if there are already 3 copies of this element\n  // before we encounter a marker, then drop the last one\n  var count = 0;\n  for(var i = this.list.length-1; i >= 0; i--) {\n    if (this.list[i] === this.MARKER) break;\n    // equal() is defined below\n    if (equal(elt, this.list[i], this.attrs[i])) {\n      count++;\n      if (count === 3) {\n        this.list.splice(i, 1);\n        this.attrs.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n\n  // Now push the element onto the list\n  this.list.push(elt);\n\n  // Copy the attributes and push those on, too\n  var attrcopy = [];\n  for(var ii = 0; ii < attrs.length; ii++) {\n    attrcopy[ii] = attrs[ii];\n  }\n\n  this.attrs.push(attrcopy);\n\n  // This function defines equality of two elements for the purposes\n  // of the AFE list.  Note that it compares the new elements\n  // attributes to the saved array of attributes associated with\n  // the old element because a script could have changed the\n  // old element's set of attributes\n  function equal(newelt, oldelt, oldattrs) {\n    if (newelt.localName !== oldelt.localName) return false;\n    if (newelt._numattrs !== oldattrs.length) return false;\n    for(var i = 0, n = oldattrs.length; i < n; i++) {\n      var oldname = oldattrs[i][0];\n      var oldval = oldattrs[i][1];\n      if (!newelt.hasAttribute(oldname)) return false;\n      if (newelt.getAttribute(oldname) !== oldval) return false;\n    }\n    return true;\n  }\n};\n\nHTMLParser.ActiveFormattingElements.prototype.clearToMarker = function() {\n  for(var i = this.list.length-1; i >= 0; i--) {\n    if (this.list[i] === this.MARKER) break;\n  }\n  if (i < 0) i = 0;\n  this.list.length = i;\n  this.attrs.length = i;\n};\n\n// Find and return the last element with the specified tag between the\n// end of the list and the last marker on the list.\n// Used when parsing <a> in_body_mode()\nHTMLParser.ActiveFormattingElements.prototype.findElementByTag = function(tag) {\n  for(var i = this.list.length-1; i >= 0; i--) {\n    var elt = this.list[i];\n    if (elt === this.MARKER) break;\n    if (elt.localName === tag) return elt;\n  }\n  return null;\n};\n\nHTMLParser.ActiveFormattingElements.prototype.indexOf = function(e) {\n  return this.list.lastIndexOf(e);\n};\n\n// Find the element e in the list and remove it\n// Used when parsing <a> in_body()\nHTMLParser.ActiveFormattingElements.prototype.remove = function(e) {\n  var idx = this.list.lastIndexOf(e);\n  if (idx !== -1) {\n    this.list.splice(idx, 1);\n    this.attrs.splice(idx, 1);\n  }\n};\n\n// Find element a in the list and replace it with element b\n// XXX: Do I need to handle attributes here?\nHTMLParser.ActiveFormattingElements.prototype.replace = function(a, b, attrs) {\n  var idx = this.list.lastIndexOf(a);\n  if (idx !== -1) {\n    this.list[idx] = b;\n    this.attrs[idx] = attrs;\n  }\n};\n\n// Find a in the list and insert b after it\n// This is only used for insert a bookmark object, so the\n// attrs array doesn't really matter\nHTMLParser.ActiveFormattingElements.prototype.insertAfter = function(a,b) {\n  var idx = this.list.lastIndexOf(a);\n  if (idx !== -1) {\n    this.list.splice(idx, 0, b);\n    this.attrs.splice(idx, 0, b);\n  }\n};\n\n\n\n\n/***\n * This is the parser factory function. It is the return value of\n * the outer closure that it is defined within.  Most of the parser\n * implementation details are inside this function.\n */\nfunction HTMLParser(address, fragmentContext, options) {\n  /***\n   * These are the parser's state variables\n   */\n  // Scanner state\n  var chars = null;\n  var numchars = 0; // Length of chars\n  var nextchar = 0; // Index of next char\n  var input_complete = false; // Becomes true when end() called.\n  var scanner_skip_newline = false; // If previous char was CR\n  var reentrant_invocations = 0;\n  var saved_scanner_state = [];\n  var leftovers = \"\";\n  var first_batch = true;\n  var paused = 0; // Becomes non-zero while loading scripts\n\n\n  // Tokenizer state\n  var tokenizer = data_state; // Current tokenizer state\n  var return_state;\n  var character_reference_code;\n  var tagnamebuf = \"\";\n  var lasttagname = \"\"; // holds the target end tag for text states\n  var tempbuf = [];\n  var attrnamebuf = \"\";\n  var attrvaluebuf = \"\";\n  var commentbuf = [];\n  var doctypenamebuf = [];\n  var doctypepublicbuf = [];\n  var doctypesystembuf = [];\n  var attributes = [];\n  var is_end_tag = false;\n\n  // Tree builder state\n  var parser = initial_mode; // Current insertion mode\n  var originalInsertionMode = null; // A saved insertion mode\n  var templateInsertionModes = []; // Stack of template insertion modes.\n  var stack = new HTMLParser.ElementStack(); // Stack of open elements\n  var afe = new HTMLParser.ActiveFormattingElements(); // mis-nested tags\n  var fragment = (fragmentContext!==undefined); // For innerHTML, etc.\n  var head_element_pointer = null;\n  var form_element_pointer = null;\n  var scripting_enabled = true;\n  if (fragmentContext) {\n\tscripting_enabled = fragmentContext.ownerDocument._scripting_enabled;\n  }\n  if (options && options.scripting_enabled === false)\n    scripting_enabled = false;\n  var frameset_ok = true;\n  var force_quirks = false;\n  var pending_table_text;\n  var text_integration_mode; // XXX a spec bug workaround?\n\n  // A single run of characters, buffered up to be sent to\n  // the parser as a single string.\n  var textrun = [];\n  var textIncludesNUL = false;\n  var ignore_linefeed = false;\n\n  /***\n   * This is the parser object that will be the return value of this\n   * factory function, which is some 5000 lines below.\n   * Note that the variable \"parser\" is the current state of the\n   * parser's state machine.  This variable \"htmlparser\" is the\n   * return value and defines the public API of the parser\n   */\n  var htmlparser = {\n    document: function() {\n      return doc;\n    },\n\n    // Convenience function for internal use. Can only be called once,\n    // as it removes the nodes from `doc` to add them to fragment.\n    _asDocumentFragment: function() {\n      var frag = doc.createDocumentFragment();\n      var root = doc.firstChild;\n      while(root.hasChildNodes()) {\n        frag.appendChild(root.firstChild);\n      }\n      return frag;\n    },\n\n    // Internal function used from HTMLScriptElement to pause the\n    // parser while a script is being loaded from the network\n    pause: function() {\n      // print(\"pausing parser\");\n      paused++;\n    },\n\n    // Called when a script finishes loading\n    resume: function() {\n      // print(\"resuming parser\");\n      paused--;\n      // XXX: added this to force a resumption.\n      // Is this the right thing to do?\n      this.parse(\"\");\n    },\n\n    // Parse the HTML text s.\n    // The second argument should be true if there is no more\n    // text to be parsed, and should be false or omitted otherwise.\n    // The second argument must not be set for recursive invocations\n    // from document.write()\n    parse: function(s, end, shouldPauseFunc) {\n      var moreToDo;\n\n      // If we're paused, remember the text to parse, but\n      // don't parse it now.\n      // (Don't invoke shouldPauseFunc because we haven't handled 'end' yet.)\n      if (paused > 0) {\n        leftovers += s;\n        return true; // more to do\n      }\n\n\n      if (reentrant_invocations === 0) {\n        // A normal, top-level invocation\n        if (leftovers) {\n          s = leftovers + s;\n          leftovers = \"\";\n        }\n\n        // Add a special marker character to the end of\n        // the buffer.  If the scanner is at the end of\n        // the buffer and input_complete is set, then this\n        // character will transform into an EOF token.\n        // Having an actual character that represents EOF\n        // in the character buffer makes lookahead regexp\n        // matching work more easily, and this is\n        // important for character references.\n        if (end) {\n          s += \"\\uFFFF\";\n          input_complete = true; // Makes scanChars() send EOF\n        }\n\n        chars = s;\n        numchars = s.length;\n        nextchar = 0;\n\n        if (first_batch) {\n          // We skip a leading Byte Order Mark (\\uFEFF)\n          // on first batch of text we're given\n          first_batch = false;\n          if (chars.charCodeAt(0) === 0xFEFF) nextchar = 1;\n        }\n\n        reentrant_invocations++;\n        moreToDo = scanChars(shouldPauseFunc);\n        leftovers = chars.substring(nextchar, numchars);\n        reentrant_invocations--;\n      }\n      else {\n        // This is the re-entrant case, which we have to\n        // handle a little differently.\n        reentrant_invocations++;\n\n        // Save current scanner state\n        saved_scanner_state.push(chars, numchars, nextchar);\n\n        // Set new scanner state\n        chars = s;\n        numchars = s.length;\n        nextchar = 0;\n\n        // Now scan as many of these new chars as we can\n        scanChars();\n        moreToDo = false;\n\n        leftovers = chars.substring(nextchar, numchars);\n\n        // restore old scanner state\n        nextchar = saved_scanner_state.pop();\n        numchars = saved_scanner_state.pop();\n        chars = saved_scanner_state.pop();\n\n        // If there were leftover chars from this invocation\n        // insert them into the pending invocation's buffer\n        // and trim already processed chars at the same time\n        if (leftovers) {\n          chars = leftovers + chars.substring(nextchar);\n          numchars = chars.length;\n          nextchar = 0;\n          leftovers = \"\";\n        }\n\n        // Decrement the counter\n        reentrant_invocations--;\n      }\n      return moreToDo;\n    }\n  };\n\n\n  // This is the document we'll be building up\n  var doc = new Document(true, address);\n\n  // The document needs to know about the parser, for document.write().\n  // This _parser property will be deleted when we're done parsing.\n  doc._parser = htmlparser;\n\n  // XXX I think that any document we use this parser on should support\n  // scripts. But I may need to configure that through a parser parameter\n  // Only documents with windows (\"browsing contexts\" to be precise)\n  // allow scripting.\n  doc._scripting_enabled = scripting_enabled;\n\n\n  /***\n   * The actual code of the HTMLParser() factory function begins here.\n   */\n\n  if (fragmentContext) { // for innerHTML parsing\n    if (fragmentContext.ownerDocument._quirks)\n      doc._quirks = true;\n    if (fragmentContext.ownerDocument._limitedQuirks)\n      doc._limitedQuirks = true;\n\n    // Set the initial tokenizer state\n    if (fragmentContext.namespaceURI === NAMESPACE.HTML) {\n      switch(fragmentContext.localName) {\n      case \"title\":\n      case \"textarea\":\n        tokenizer = rcdata_state;\n        break;\n      case \"style\":\n      case \"xmp\":\n      case \"iframe\":\n      case \"noembed\":\n      case \"noframes\":\n      case \"script\":\n      case \"plaintext\":\n        tokenizer = plaintext_state;\n        break;\n      case \"noscript\":\n        if (scripting_enabled)\n          tokenizer = plaintext_state;\n      }\n    }\n\n    var root = doc.createElement(\"html\");\n    doc._appendChild(root);\n    stack.push(root);\n    if (fragmentContext instanceof impl.HTMLTemplateElement) {\n      templateInsertionModes.push(in_template_mode);\n    }\n    resetInsertionMode();\n\n    for(var e = fragmentContext; e !== null; e = e.parentElement) {\n      if (e instanceof impl.HTMLFormElement) {\n        form_element_pointer = e;\n        break;\n      }\n    }\n  }\n\n  /***\n   * Scanner functions\n   */\n  // Loop through the characters in chars, and pass them one at a time\n  // to the tokenizer FSM. Return when no more characters can be processed\n  // (This may leave 1 or more characters in the buffer: like a CR\n  // waiting to see if the next char is LF, or for states that require\n  // lookahead...)\n  function scanChars(shouldPauseFunc) {\n    var codepoint, s, pattern, eof;\n\n    while(nextchar < numchars) {\n\n      // If we just tokenized a </script> tag, then the paused flag\n      // may have been set to tell us to stop tokenizing while\n      // the script is loading\n      if (paused > 0 || (shouldPauseFunc && shouldPauseFunc())) {\n        return true;\n      }\n\n\n      switch(typeof tokenizer.lookahead) {\n      case 'undefined':\n        codepoint = chars.charCodeAt(nextchar++);\n        if (scanner_skip_newline) {\n          scanner_skip_newline = false;\n          if (codepoint === 0x000A) {\n            nextchar++;\n            continue;\n          }\n        }\n        switch(codepoint) {\n        case 0x000D:\n          // CR always turns into LF, but if the next character\n          // is LF, then that second LF is skipped.\n          if (nextchar < numchars) {\n            if (chars.charCodeAt(nextchar) === 0x000A)\n              nextchar++;\n          }\n          else {\n            // We don't know the next char right now, so we\n            // can't check if it is a LF.  So set a flag\n            scanner_skip_newline = true;\n          }\n\n          // In either case, emit a LF\n          tokenizer(0x000A);\n\n          break;\n        case 0xFFFF:\n          if (input_complete && nextchar === numchars) {\n            tokenizer(EOF); // codepoint will be 0xFFFF here\n            break;\n          }\n          /* falls through */\n        default:\n          tokenizer(codepoint);\n          break;\n        }\n        break;\n\n      case 'number':\n        codepoint = chars.charCodeAt(nextchar);\n\n        // The only tokenizer states that require fixed lookahead\n        // only consume alphanum characters, so we don't have\n        // to worry about CR and LF in this case\n\n        // tokenizer wants n chars of lookahead\n        var n = tokenizer.lookahead;\n        var needsString = true;\n        if (n < 0) {\n          needsString = false;\n          n = -n;\n        }\n\n        if (n < numchars - nextchar) {\n          // If we can look ahead that far\n          s = needsString ? chars.substring(nextchar, nextchar+n) : null;\n          eof = false;\n        }\n        else { // if we don't have that many characters\n          if (input_complete) { // If no more are coming\n            // Just return what we have\n            s = needsString ? chars.substring(nextchar, numchars) : null;\n            eof = true;\n            if (codepoint === 0xFFFF && nextchar === numchars-1)\n              codepoint = EOF;\n          }\n          else {\n            // Return now and wait for more chars later\n            return true;\n          }\n        }\n        tokenizer(codepoint, s, eof);\n        break;\n      case 'string':\n        codepoint = chars.charCodeAt(nextchar);\n\n        // tokenizer wants characters up to a matching string\n        pattern = tokenizer.lookahead;\n        var pos = chars.indexOf(pattern, nextchar);\n        if (pos !== -1) {\n          s = chars.substring(nextchar, pos + pattern.length);\n          eof = false;\n        }\n        else {  // No match\n          // If more characters coming, wait for them\n          if (!input_complete) return true;\n\n          // Otherwise, we've got to return what we've got\n          s = chars.substring(nextchar, numchars);\n          if (codepoint === 0xFFFF && nextchar === numchars-1)\n            codepoint = EOF;\n          eof = true;\n        }\n\n        // The tokenizer states that require this kind of\n        // lookahead have to be careful to handle CR characters\n        // correctly\n        tokenizer(codepoint, s, eof);\n        break;\n      }\n    }\n    return false; // no more characters to scan!\n  }\n\n\n  /***\n   * Tokenizer utility functions\n   */\n  function addAttribute(name,value) {\n    // Make sure there isn't already an attribute with this name\n    // If there is, ignore this one.\n    for(var i = 0; i < attributes.length; i++) {\n      if (attributes[i][0] === name) return;\n    }\n\n    if (value !== undefined) {\n      attributes.push([name, value]);\n    }\n    else {\n      attributes.push([name]);\n    }\n  }\n\n  // Shortcut for simple attributes\n  function handleSimpleAttribute() {\n    SIMPLEATTR.lastIndex = nextchar-1;\n    var matched = SIMPLEATTR.exec(chars);\n    if (!matched) throw new Error(\"should never happen\");\n    var name = matched[1];\n    if (!name) return false;\n    var value = matched[2];\n    var len = value.length;\n    switch(value[0]) {\n    case '\"':\n    case \"'\":\n      value = value.substring(1, len-1);\n      nextchar += (matched[0].length-1);\n      tokenizer = after_attribute_value_quoted_state;\n      break;\n    default:\n      tokenizer = before_attribute_name_state;\n      nextchar += (matched[0].length-1);\n      value = value.substring(0, len-1);\n      break;\n    }\n\n    // Make sure there isn't already an attribute with this name\n    // If there is, ignore this one.\n    for(var i = 0; i < attributes.length; i++) {\n      if (attributes[i][0] === name) return true;\n    }\n\n    attributes.push([name, value]);\n    return true;\n  }\n\n  function beginTagName() {\n    is_end_tag = false;\n    tagnamebuf = \"\";\n    attributes.length = 0;\n  }\n  function beginEndTagName() {\n    is_end_tag = true;\n    tagnamebuf = \"\";\n    attributes.length = 0;\n  }\n\n  function beginTempBuf() { tempbuf.length = 0; }\n  function beginAttrName() { attrnamebuf = \"\"; }\n  function beginAttrValue() { attrvaluebuf = \"\"; }\n  function beginComment() { commentbuf.length = 0; }\n  function beginDoctype() {\n    doctypenamebuf.length = 0;\n    doctypepublicbuf = null;\n    doctypesystembuf = null;\n  }\n  function beginDoctypePublicId() { doctypepublicbuf = []; }\n  function beginDoctypeSystemId() { doctypesystembuf = []; }\n  function forcequirks() { force_quirks = true; }\n  function cdataAllowed() {\n    return stack.top &&\n      stack.top.namespaceURI !== \"http://www.w3.org/1999/xhtml\";\n  }\n\n  // Return true if the codepoints in the specified buffer match the\n  // characters of lasttagname\n  function appropriateEndTag(buf) {\n    return lasttagname === buf;\n  }\n\n  function flushText() {\n    if (textrun.length > 0) {\n      var s = buf2str(textrun);\n      textrun.length = 0;\n\n      if (ignore_linefeed) {\n        ignore_linefeed = false;\n        if (s[0] === \"\\n\") s = s.substring(1);\n        if (s.length === 0) return;\n      }\n\n      insertToken(TEXT, s);\n      textIncludesNUL = false;\n    }\n    ignore_linefeed = false;\n  }\n\n  // Consume chars matched by the pattern and return them as a string. Starts\n  // matching at the current position, so users should drop the current char\n  // otherwise.\n  function getMatchingChars(pattern) {\n    pattern.lastIndex = nextchar - 1;\n    var match = pattern.exec(chars);\n    if (match && match.index === nextchar - 1) {\n      match = match[0];\n      nextchar += match.length - 1;\n      /* Careful!  Make sure we haven't matched the EOF character! */\n      if (input_complete && nextchar === numchars) {\n        // Oops, backup one.\n        match = match.slice(0, -1);\n        nextchar--;\n      }\n      return match;\n    } else {\n      throw new Error(\"should never happen\");\n    }\n  }\n\n  // emit a string of chars that match a regexp\n  // Returns false if no chars matched.\n  function emitCharsWhile(pattern) {\n    pattern.lastIndex = nextchar-1;\n    var match = pattern.exec(chars)[0];\n    if (!match) return false;\n    emitCharString(match);\n    nextchar += match.length - 1;\n    return true;\n  }\n\n  // This is used by CDATA sections\n  function emitCharString(s) {\n    if (textrun.length > 0) flushText();\n\n    if (ignore_linefeed) {\n      ignore_linefeed = false;\n      if (s[0] === \"\\n\") s = s.substring(1);\n      if (s.length === 0) return;\n    }\n\n    insertToken(TEXT, s);\n  }\n\n  function emitTag() {\n    if (is_end_tag) insertToken(ENDTAG, tagnamebuf);\n    else {\n      // Remember the last open tag we emitted\n      var tagname = tagnamebuf;\n      tagnamebuf = \"\";\n      lasttagname = tagname;\n      insertToken(TAG, tagname, attributes);\n    }\n  }\n\n\n  // A shortcut: look ahead and if this is a open or close tag\n  // in lowercase with no spaces and no attributes, just emit it now.\n  function emitSimpleTag() {\n    if (nextchar === numchars) { return false; /* not even 1 char left */ }\n    SIMPLETAG.lastIndex = nextchar;\n    var matched = SIMPLETAG.exec(chars);\n    if (!matched) throw new Error(\"should never happen\");\n    var tagname = matched[2];\n    if (!tagname) return false;\n    var endtag = matched[1];\n    if (endtag) {\n      nextchar += (tagname.length+2);\n      insertToken(ENDTAG, tagname);\n    }\n    else {\n      nextchar += (tagname.length+1);\n      lasttagname = tagname;\n      insertToken(TAG, tagname, NOATTRS);\n    }\n    return true;\n  }\n\n  function emitSelfClosingTag() {\n    if (is_end_tag) insertToken(ENDTAG, tagnamebuf, null, true);\n    else {\n      insertToken(TAG, tagnamebuf, attributes, true);\n    }\n  }\n\n  function emitDoctype() {\n    insertToken(DOCTYPE,\n          buf2str(doctypenamebuf),\n          doctypepublicbuf ? buf2str(doctypepublicbuf) : undefined,\n          doctypesystembuf ? buf2str(doctypesystembuf) : undefined);\n  }\n\n  function emitEOF() {\n    flushText();\n    parser(EOF); // EOF never goes to insertForeignContent()\n    doc.modclock = 1; // Start tracking modifications\n  }\n\n  // Insert a token, either using the current parser insertion mode\n  // (for HTML stuff) or using the insertForeignToken() method.\n  var insertToken = htmlparser.insertToken = function insertToken(t, value, arg3, arg4) {\n    flushText();\n    var current = stack.top;\n\n    if (!current || current.namespaceURI === NAMESPACE.HTML) {\n      // This is the common case\n      parser(t, value, arg3, arg4);\n    }\n    else {\n      // Otherwise we may need to insert this token as foreign content\n      if (t !== TAG && t !== TEXT) {\n        insertForeignToken(t, value, arg3, arg4);\n      }\n      else {\n        // But in some cases we treat it as regular content\n        if ((isMathmlTextIntegrationPoint(current) &&\n           (t === TEXT ||\n            (t === TAG &&\n             value !== \"mglyph\" && value !== \"malignmark\"))) ||\n          (t === TAG &&\n           value === \"svg\" &&\n           current.namespaceURI === NAMESPACE.MATHML &&\n           current.localName === \"annotation-xml\") ||\n          isHTMLIntegrationPoint(current)) {\n\n          // XXX: the text_integration_mode stuff is an\n          // attempted bug workaround of mine\n          text_integration_mode = true;\n          parser(t, value, arg3, arg4);\n          text_integration_mode = false;\n        }\n        // Otherwise it is foreign content\n        else {\n          insertForeignToken(t, value, arg3, arg4);\n        }\n      }\n    }\n  };\n\n\n  /***\n   * Tree building utility functions\n   */\n  function insertComment(data) {\n    var parent = stack.top;\n    if (foster_parent_mode && isA(parent, tablesectionrowSet)) {\n      fosterParent(function(doc) { return doc.createComment(data); });\n    } else {\n      // \"If the adjusted insertion location is inside a template element,\n      // let it instead be inside the template element's template contents\"\n      if (parent instanceof impl.HTMLTemplateElement) {\n        parent = parent.content;\n      }\n      parent._appendChild(parent.ownerDocument.createComment(data));\n    }\n  }\n\n  function insertText(s) {\n    var parent = stack.top;\n    if (foster_parent_mode && isA(parent, tablesectionrowSet)) {\n      fosterParent(function(doc) { return doc.createTextNode(s); });\n    } else {\n      // \"If the adjusted insertion location is inside a template element,\n      // let it instead be inside the template element's template contents\"\n      if (parent instanceof impl.HTMLTemplateElement) {\n        parent = parent.content;\n      }\n      // \"If there is a Text node immediately before the adjusted insertion\n      // location, then append data to that Text node's data.\"\n      var lastChild = parent.lastChild;\n      if (lastChild && lastChild.nodeType === Node.TEXT_NODE) {\n        lastChild.appendData(s);\n      } else {\n        parent._appendChild(parent.ownerDocument.createTextNode(s));\n      }\n    }\n  }\n\n  function createHTMLElt(doc, name, attrs) {\n    // Create the element this way, rather than with\n    // doc.createElement because createElement() does error\n    // checking on the element name that we need to avoid here.\n    var elt = html.createElement(doc, name, null);\n\n    if (attrs) {\n      for(var i = 0, n = attrs.length; i < n; i++) {\n        // Use the _ version to avoid testing the validity\n        // of the attribute name\n        elt._setAttribute(attrs[i][0], attrs[i][1]);\n      }\n    }\n    // XXX\n    // If the element is a resettable form element,\n    // run its reset algorithm now\n    // XXX\n    // handle case where form-element-pointer is not null\n    return elt;\n  }\n\n  // The in_table insertion mode turns on this flag, and that makes\n  // insertHTMLElement use the foster parenting algorithm for elements\n  // tags inside a table\n  var foster_parent_mode = false;\n\n  function insertHTMLElement(name, attrs) {\n    var elt = insertElement(function(doc) {\n      return createHTMLElt(doc, name, attrs);\n    });\n\n    // XXX\n    // If this is a form element, set its form attribute property here\n    if (isA(elt, formassociatedSet)) {\n      elt._form = form_element_pointer;\n    }\n\n    return elt;\n  }\n\n  // Insert the element into the open element or foster parent it\n  function insertElement(eltFunc) {\n    var elt;\n    if (foster_parent_mode && isA(stack.top, tablesectionrowSet)) {\n      elt = fosterParent(eltFunc);\n    }\n    else if (stack.top instanceof impl.HTMLTemplateElement) {\n      // \"If the adjusted insertion location is inside a template element,\n      // let it instead be inside the template element's template contents\"\n      elt = eltFunc(stack.top.content.ownerDocument);\n      stack.top.content._appendChild(elt);\n    } else {\n      elt = eltFunc(stack.top.ownerDocument);\n      stack.top._appendChild(elt);\n    }\n\n    stack.push(elt);\n    return elt;\n  }\n\n  function insertForeignElement(name, attrs, ns) {\n    return insertElement(function(doc) {\n      // We need to prevent createElementNS from trying to parse `name` as a\n      // `qname`, so use an internal Document#_createElementNS() interface.\n      var elt = doc._createElementNS(name, ns, null);\n      if (attrs) {\n        for(var i = 0, n = attrs.length; i < n; i++) {\n          var attr = attrs[i];\n          if (attr.length === 2)\n            elt._setAttribute(attr[0], attr[1]);\n          else {\n            elt._setAttributeNS(attr[2], attr[0], attr[1]);\n          }\n        }\n      }\n      return elt;\n    });\n  }\n\n  function lastElementOfType(type) {\n    for(var i = stack.elements.length-1; i >= 0; i--) {\n      if (stack.elements[i] instanceof type) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  function fosterParent(eltFunc) {\n    var parent, before, lastTable = -1, lastTemplate = -1, elt;\n\n    lastTable = lastElementOfType(impl.HTMLTableElement);\n    lastTemplate = lastElementOfType(impl.HTMLTemplateElement);\n\n    if (lastTemplate >= 0 && (lastTable < 0 || lastTemplate > lastTable)) {\n      parent = stack.elements[lastTemplate];\n    } else if (lastTable >= 0) {\n      parent = stack.elements[lastTable].parentNode;\n      if (parent) {\n        before = stack.elements[lastTable];\n      } else {\n        parent = stack.elements[lastTable - 1];\n      }\n    }\n    if (!parent) parent = stack.elements[0]; // the `html` element.\n\n    // \"If the adjusted insertion location is inside a template element,\n    // let it instead be inside the template element's template contents\"\n    if (parent instanceof impl.HTMLTemplateElement) {\n      parent = parent.content;\n    }\n    // Create element in the appropriate document.\n    elt = eltFunc(parent.ownerDocument);\n\n    if (elt.nodeType === Node.TEXT_NODE) {\n      var prev;\n      if (before) prev = before.previousSibling;\n      else prev = parent.lastChild;\n      if (prev && prev.nodeType === Node.TEXT_NODE) {\n        prev.appendData(elt.data);\n        return elt;\n      }\n    }\n    if (before)\n      parent.insertBefore(elt, before);\n    else\n      parent._appendChild(elt);\n    return elt;\n  }\n\n\n  function resetInsertionMode() {\n    var last = false;\n    for(var i = stack.elements.length-1; i >= 0; i--) {\n      var node = stack.elements[i];\n      if (i === 0) {\n        last = true;\n        if (fragment) {\n          node = fragmentContext;\n        }\n      }\n      if (node.namespaceURI === NAMESPACE.HTML) {\n        var tag = node.localName;\n        switch(tag) {\n        case \"select\":\n          for(var j = i; j > 0; ) {\n            var ancestor = stack.elements[--j];\n            if (ancestor instanceof impl.HTMLTemplateElement) {\n              break;\n            } else if (ancestor instanceof impl.HTMLTableElement) {\n              parser = in_select_in_table_mode;\n              return;\n            }\n          }\n          parser = in_select_mode;\n          return;\n        case \"tr\":\n          parser = in_row_mode;\n          return;\n        case \"tbody\":\n        case \"tfoot\":\n        case \"thead\":\n          parser = in_table_body_mode;\n          return;\n        case \"caption\":\n          parser = in_caption_mode;\n          return;\n        case \"colgroup\":\n          parser = in_column_group_mode;\n          return;\n        case \"table\":\n          parser = in_table_mode;\n          return;\n        case \"template\":\n          parser = templateInsertionModes[templateInsertionModes.length-1];\n          return;\n        case \"body\":\n          parser = in_body_mode;\n          return;\n        case \"frameset\":\n          parser = in_frameset_mode;\n          return;\n        case \"html\":\n          if (head_element_pointer === null) {\n            parser = before_head_mode;\n          } else {\n            parser = after_head_mode;\n          }\n          return;\n        default:\n          if (!last) {\n            if (tag === \"head\") {\n              parser = in_head_mode;\n              return;\n            }\n            if (tag === \"td\" || tag === \"th\") {\n              parser = in_cell_mode;\n              return;\n            }\n          }\n        }\n      }\n      if (last) {\n        parser = in_body_mode;\n        return;\n      }\n    }\n  }\n\n\n  function parseRawText(name, attrs) {\n    insertHTMLElement(name, attrs);\n    tokenizer = rawtext_state;\n    originalInsertionMode = parser;\n    parser = text_mode;\n  }\n\n  function parseRCDATA(name, attrs) {\n    insertHTMLElement(name, attrs);\n    tokenizer = rcdata_state;\n    originalInsertionMode = parser;\n    parser = text_mode;\n  }\n\n  // Make a copy of element i on the list of active formatting\n  // elements, using its original attributes, not current\n  // attributes (which may have been modified by a script)\n  function afeclone(doc, i) {\n    return {\n      elt: createHTMLElt(doc, afe.list[i].localName, afe.attrs[i]),\n      attrs: afe.attrs[i],\n    };\n  }\n\n\n  function afereconstruct() {\n    if (afe.list.length === 0) return;\n    var entry = afe.list[afe.list.length-1];\n    // If the last is a marker , do nothing\n    if (entry === afe.MARKER) return;\n    // Or if it is an open element, do nothing\n    if (stack.elements.lastIndexOf(entry) !== -1) return;\n\n    // Loop backward through the list until we find a marker or an\n    // open element, and then move forward one from there.\n    for(var i = afe.list.length-2; i >= 0; i--) {\n      entry = afe.list[i];\n      if (entry === afe.MARKER) break;\n      if (stack.elements.lastIndexOf(entry) !== -1) break;\n    }\n\n    // Now loop forward, starting from the element after the current\n    // one, recreating formatting elements and pushing them back onto\n    // the list of open elements\n    for(i = i+1; i < afe.list.length; i++) {\n      var newelt = insertElement(function(doc) { return afeclone(doc, i).elt; });\n      afe.list[i] = newelt;\n    }\n  }\n\n  // Used by the adoptionAgency() function\n  var BOOKMARK = {localName:\"BM\"};\n\n  function adoptionAgency(tag) {\n    // If the current node is an HTML element whose tag name is subject,\n    // and the current node is not in the list of active formatting\n    // elements, then pop the current node off the stack of open\n    // elements and abort these steps.\n    if (isA(stack.top, tag) && afe.indexOf(stack.top) === -1) {\n      stack.pop();\n      return true; // no more handling required\n    }\n\n    // Let outer loop counter be zero.\n    var outer = 0;\n\n    // Outer loop: If outer loop counter is greater than or\n    // equal to eight, then abort these steps.\n    while(outer < 8) {\n      // Increment outer loop counter by one.\n      outer++;\n\n      // Let the formatting element be the last element in the list\n      // of active formatting elements that: is between the end of\n      // the list and the last scope marker in the list, if any, or\n      // the start of the list otherwise, and has the same tag name\n      // as the token.\n      var fmtelt = afe.findElementByTag(tag);\n\n      // If there is no such node, then abort these steps and instead\n      // act as described in the \"any other end tag\" entry below.\n      if (!fmtelt) {\n        return false; // false means handle by the default case\n      }\n\n      // Otherwise, if there is such a node, but that node is not in\n      // the stack of open elements, then this is a parse error;\n      // remove the element from the list, and abort these steps.\n      var index = stack.elements.lastIndexOf(fmtelt);\n      if (index === -1) {\n        afe.remove(fmtelt);\n        return true;   // true means no more handling required\n      }\n\n      // Otherwise, if there is such a node, and that node is also in\n      // the stack of open elements, but the element is not in scope,\n      // then this is a parse error; ignore the token, and abort\n      // these steps.\n      if (!stack.elementInScope(fmtelt)) {\n        return true;\n      }\n\n      // Let the furthest block be the topmost node in the stack of\n      // open elements that is lower in the stack than the formatting\n      // element, and is an element in the special category. There\n      // might not be one.\n      var furthestblock = null, furthestblockindex;\n      for(var i = index+1; i < stack.elements.length; i++) {\n        if (isA(stack.elements[i], specialSet)) {\n          furthestblock = stack.elements[i];\n          furthestblockindex = i;\n          break;\n        }\n      }\n\n      // If there is no furthest block, then the UA must skip the\n      // subsequent steps and instead just pop all the nodes from the\n      // bottom of the stack of open elements, from the current node\n      // up to and including the formatting element, and remove the\n      // formatting element from the list of active formatting\n      // elements.\n      if (!furthestblock) {\n        stack.popElement(fmtelt);\n        afe.remove(fmtelt);\n        return true;\n      }\n      else {\n        // Let the common ancestor be the element immediately above\n        // the formatting element in the stack of open elements.\n        var ancestor = stack.elements[index-1];\n\n        // Let a bookmark note the position of the formatting\n        // element in the list of active formatting elements\n        // relative to the elements on either side of it in the\n        // list.\n        afe.insertAfter(fmtelt, BOOKMARK);\n\n        // Let node and last node be the furthest block.\n        var node = furthestblock;\n        var lastnode = furthestblock;\n        var nodeindex = furthestblockindex;\n        var nodeafeindex;\n\n        // Let inner loop counter be zero.\n        var inner = 0;\n\n        while (true) {\n\n          // Increment inner loop counter by one.\n          inner++;\n\n          // Let node be the element immediately above node in\n          // the stack of open elements, or if node is no longer\n          // in the stack of open elements (e.g. because it got\n          // removed by this algorithm), the element that was\n          // immediately above node in the stack of open elements\n          // before node was removed.\n          node = stack.elements[--nodeindex];\n\n          // If node is the formatting element, then go\n          // to the next step in the overall algorithm.\n          if (node === fmtelt) break;\n\n          // If the inner loop counter is greater than three and node\n          // is in the list of active formatting elements, then remove\n          // node from the list of active formatting elements.\n          nodeafeindex = afe.indexOf(node);\n          if (inner > 3 && nodeafeindex !== -1) {\n            afe.remove(node);\n            nodeafeindex = -1;\n          }\n\n          // If node is not in the list of active formatting\n          // elements, then remove node from the stack of open\n          // elements and then go back to the step labeled inner\n          // loop.\n          if (nodeafeindex === -1) {\n            stack.removeElement(node);\n            continue;\n          }\n\n          // Create an element for the token for which the\n          // element node was created with common ancestor as\n          // the intended parent, replace the entry for node\n          // in the list of active formatting elements with an\n          // entry for the new element, replace the entry for\n          // node in the stack of open elements with an entry for\n          // the new element, and let node be the new element.\n          var newelt = afeclone(ancestor.ownerDocument, nodeafeindex);\n          afe.replace(node, newelt.elt, newelt.attrs);\n          stack.elements[nodeindex] = newelt.elt;\n          node = newelt.elt;\n\n          // If last node is the furthest block, then move the\n          // aforementioned bookmark to be immediately after the\n          // new node in the list of active formatting elements.\n          if (lastnode === furthestblock) {\n            afe.remove(BOOKMARK);\n            afe.insertAfter(newelt.elt, BOOKMARK);\n          }\n\n          // Insert last node into node, first removing it from\n          // its previous parent node if any.\n          node._appendChild(lastnode);\n\n          // Let last node be node.\n          lastnode = node;\n        }\n\n        // If the common ancestor node is a table, tbody, tfoot,\n        // thead, or tr element, then, foster parent whatever last\n        // node ended up being in the previous step, first removing\n        // it from its previous parent node if any.\n        if (foster_parent_mode && isA(ancestor, tablesectionrowSet)) {\n          fosterParent(function() { return lastnode; });\n        }\n        // Otherwise, append whatever last node ended up being in\n        // the previous step to the common ancestor node, first\n        // removing it from its previous parent node if any.\n        else if (ancestor instanceof impl.HTMLTemplateElement) {\n          ancestor.content._appendChild(lastnode);\n        } else {\n          ancestor._appendChild(lastnode);\n        }\n\n        // Create an element for the token for which the\n        // formatting element was created, with furthest block\n        // as the intended parent.\n        var newelt2 = afeclone(furthestblock.ownerDocument, afe.indexOf(fmtelt));\n\n        // Take all of the child nodes of the furthest block and\n        // append them to the element created in the last step.\n        while(furthestblock.hasChildNodes()) {\n          newelt2.elt._appendChild(furthestblock.firstChild);\n        }\n\n        // Append that new element to the furthest block.\n        furthestblock._appendChild(newelt2.elt);\n\n        // Remove the formatting element from the list of active\n        // formatting elements, and insert the new element into the\n        // list of active formatting elements at the position of\n        // the aforementioned bookmark.\n        afe.remove(fmtelt);\n        afe.replace(BOOKMARK, newelt2.elt, newelt2.attrs);\n\n        // Remove the formatting element from the stack of open\n        // elements, and insert the new element into the stack of\n        // open elements immediately below the position of the\n        // furthest block in that stack.\n        stack.removeElement(fmtelt);\n        var pos = stack.elements.lastIndexOf(furthestblock);\n        stack.elements.splice(pos+1, 0, newelt2.elt);\n      }\n    }\n\n    return true;\n  }\n\n  // We do this when we get /script in in_text_mode\n  function handleScriptEnd() {\n    // XXX:\n    // This is just a stub implementation right now and doesn't run scripts.\n    // Getting this method right involves the event loop, URL resolution\n    // script fetching etc. For now I just want to be able to parse\n    // documents and test the parser.\n\n    //var script = stack.top;\n    stack.pop();\n    parser = originalInsertionMode;\n    //script._prepare();\n    return;\n\n    // XXX: here is what this method is supposed to do\n\n    // Provide a stable state.\n\n    // Let script be the current node (which will be a script\n    // element).\n\n    // Pop the current node off the stack of open elements.\n\n    // Switch the insertion mode to the original insertion mode.\n\n    // Let the old insertion point have the same value as the current\n    // insertion point. Let the insertion point be just before the\n    // next input character.\n\n    // Increment the parser's script nesting level by one.\n\n    // Prepare the script. This might cause some script to execute,\n    // which might cause new characters to be inserted into the\n    // tokenizer, and might cause the tokenizer to output more tokens,\n    // resulting in a reentrant invocation of the parser.\n\n    // Decrement the parser's script nesting level by one. If the\n    // parser's script nesting level is zero, then set the parser\n    // pause flag to false.\n\n    // Let the insertion point have the value of the old insertion\n    // point. (In other words, restore the insertion point to its\n    // previous value. This value might be the \"undefined\" value.)\n\n    // At this stage, if there is a pending parsing-blocking script,\n    // then:\n\n    // If the script nesting level is not zero:\n\n    //   Set the parser pause flag to true, and abort the processing\n    //   of any nested invocations of the tokenizer, yielding\n    //   control back to the caller. (Tokenization will resume when\n    //   the caller returns to the \"outer\" tree construction stage.)\n\n    //   The tree construction stage of this particular parser is\n    //   being called reentrantly, say from a call to\n    //   document.write().\n\n    // Otherwise:\n\n    //     Run these steps:\n\n    //       Let the script be the pending parsing-blocking\n    //       script. There is no longer a pending\n    //       parsing-blocking script.\n\n    //       Block the tokenizer for this instance of the HTML\n    //       parser, such that the event loop will not run tasks\n    //       that invoke the tokenizer.\n\n    //       If the parser's Document has a style sheet that is\n    //       blocking scripts or the script's \"ready to be\n    //       parser-executed\" flag is not set: spin the event\n    //       loop until the parser's Document has no style sheet\n    //       that is blocking scripts and the script's \"ready to\n    //       be parser-executed\" flag is set.\n\n    //       Unblock the tokenizer for this instance of the HTML\n    //       parser, such that tasks that invoke the tokenizer\n    //       can again be run.\n\n    //       Let the insertion point be just before the next\n    //       input character.\n\n    //       Increment the parser's script nesting level by one\n    //       (it should be zero before this step, so this sets\n    //       it to one).\n\n    //       Execute the script.\n\n    //       Decrement the parser's script nesting level by\n    //       one. If the parser's script nesting level is zero\n    //       (which it always should be at this point), then set\n    //       the parser pause flag to false.\n\n    //       Let the insertion point be undefined again.\n\n    //       If there is once again a pending parsing-blocking\n    //       script, then repeat these steps from step 1.\n\n\n  }\n\n  function stopParsing() {\n    // XXX This is just a temporary implementation to get the parser working.\n    // A full implementation involves scripts and events and the event loop.\n\n    // Remove the link from document to parser.\n    // This is instead of \"set the insertion point to undefined\".\n    // It means that document.write() can't write into the doc anymore.\n    delete doc._parser;\n\n    stack.elements.length = 0; // pop everything off\n\n    // If there is a window object associated with the document\n    // then trigger an load event on it\n    if (doc.defaultView) {\n      doc.defaultView.dispatchEvent(new impl.Event(\"load\",{}));\n    }\n\n  }\n\n  /****\n   * Tokenizer states\n   */\n\n  /**\n   * This file was partially mechanically generated from\n   * http://www.whatwg.org/specs/web-apps/current-work/multipage/tokenization.html\n   *\n   * After mechanical conversion, it was further converted from\n   * prose to JS by hand, but the intent is that it is a very\n   * faithful rendering of the HTML tokenization spec in\n   * JavaScript.\n   *\n   * It is not a goal of this tokenizer to detect or report\n   * parse errors.\n   *\n   * XXX The tokenizer is supposed to work with straight UTF32\n   * codepoints. But I don't think it has any dependencies on\n   * any character outside of the BMP so I think it is safe to\n   * pass it UTF16 characters. I don't think it will ever change\n   * state in the middle of a surrogate pair.\n   */\n\n  /*\n   * Each state is represented by a function.  For most states, the\n   * scanner simply passes the next character (as an integer\n   * codepoint) to the current state function and automatically\n   * consumes the character.  If the state function can't process\n   * the character it can call pushback() to push it back to the\n   * scanner.\n   *\n   * Some states require lookahead, though.  If a state function has\n   * a lookahead property, then it is invoked differently.  In this\n   * case, the scanner invokes the function with 3 arguments: 1) the\n   * next codepoint 2) a string of lookahead text 3) a boolean that\n   * is true if the lookahead goes all the way to the EOF. (XXX\n   * actually maybe this third is not necessary... the lookahead\n   * could just include \\uFFFF?)\n   *\n   * If the lookahead property of a state function is an integer, it\n   * specifies the number of characters required. If it is a string,\n   * then the scanner will scan for that string and return all\n   * characters up to and including that sequence, or up to EOF.  If\n   * the lookahead property is a regexp, then the scanner will match\n   * the regexp at the current point and return the matching string.\n   *\n   * States that require lookahead are responsible for explicitly\n   * consuming the characters they process. They do this by\n   * incrementing nextchar by the number of processed characters.\n   */\n  function reconsume(c, new_state) {\n    tokenizer = new_state;\n    nextchar--; // pushback\n  }\n\n  function data_state(c) {\n    switch(c) {\n    case 0x0026: // AMPERSAND\n      return_state = data_state;\n      tokenizer = character_reference_state;\n      break;\n    case 0x003C: // LESS-THAN SIGN\n      if (emitSimpleTag()) // Shortcut for <p>, <dl>, </div> etc.\n        break;\n      tokenizer = tag_open_state;\n      break;\n    case 0x0000: // NULL\n      // Usually null characters emitted by the tokenizer will be\n      // ignored by the tree builder, but sometimes they'll be\n      // converted to \\uFFFD.  I don't want to have the search every\n      // string emitted to replace NULs, so I'll set a flag\n      // if I've emitted a NUL.\n      textrun.push(c);\n      textIncludesNUL = true;\n      break;\n    case -1: // EOF\n      emitEOF();\n      break;\n    default:\n      // Instead of just pushing a single character and then\n      // coming back to the very same place, lookahead and\n      // emit everything we can at once.\n      /*jshint -W030 */\n      emitCharsWhile(DATATEXT) || textrun.push(c);\n      break;\n    }\n  }\n\n  function rcdata_state(c) {\n    // Save the open tag so we can find a matching close tag\n    switch(c) {\n    case 0x0026: // AMPERSAND\n      return_state = rcdata_state;\n      tokenizer = character_reference_state;\n      break;\n    case 0x003C: // LESS-THAN SIGN\n      tokenizer = rcdata_less_than_sign_state;\n      break;\n    case 0x0000: // NULL\n      textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n      textIncludesNUL = true;\n      break;\n    case -1: // EOF\n      emitEOF();\n      break;\n    default:\n      textrun.push(c);\n      break;\n    }\n  }\n\n  function rawtext_state(c) {\n    switch(c) {\n    case 0x003C: // LESS-THAN SIGN\n      tokenizer = rawtext_less_than_sign_state;\n      break;\n    case 0x0000: // NULL\n      textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n      break;\n    case -1: // EOF\n      emitEOF();\n      break;\n    default:\n      /*jshint -W030 */\n      emitCharsWhile(RAWTEXT) || textrun.push(c);\n      break;\n    }\n  }\n\n  function script_data_state(c) {\n    switch(c) {\n    case 0x003C: // LESS-THAN SIGN\n      tokenizer = script_data_less_than_sign_state;\n      break;\n    case 0x0000: // NULL\n      textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n      break;\n    case -1: // EOF\n      emitEOF();\n      break;\n    default:\n      /*jshint -W030 */\n      emitCharsWhile(RAWTEXT) || textrun.push(c);\n      break;\n    }\n  }\n\n  function plaintext_state(c) {\n    switch(c) {\n    case 0x0000: // NULL\n      textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n      break;\n    case -1: // EOF\n      emitEOF();\n      break;\n    default:\n      /*jshint -W030 */\n      emitCharsWhile(PLAINTEXT) || textrun.push(c);\n      break;\n    }\n  }\n\n  function tag_open_state(c) {\n    switch(c) {\n    case 0x0021: // EXCLAMATION MARK\n      tokenizer = markup_declaration_open_state;\n      break;\n    case 0x002F: // SOLIDUS\n      tokenizer = end_tag_open_state;\n      break;\n    case 0x0041:  // [A-Z]\n    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:\n    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:\n    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:\n    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:\n    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:\n    case 0x0061:  // [a-z]\n    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:\n    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:\n    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:\n    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:\n    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:\n      beginTagName();\n      reconsume(c, tag_name_state);\n      break;\n    case 0x003F: // QUESTION MARK\n      reconsume(c, bogus_comment_state);\n      break;\n    default:\n      textrun.push(0x003C); // LESS-THAN SIGN\n      reconsume(c, data_state);\n      break;\n    }\n  }\n\n  function end_tag_open_state(c) {\n    switch(c) {\n    case 0x0041:  // [A-Z]\n    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:\n    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:\n    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:\n    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:\n    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:\n    case 0x0061:  // [a-z]\n    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:\n    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:\n    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:\n    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:\n    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:\n      beginEndTagName();\n      reconsume(c, tag_name_state);\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      tokenizer = data_state;\n      break;\n    case -1: // EOF\n      textrun.push(0x003C); // LESS-THAN SIGN\n      textrun.push(0x002F); // SOLIDUS\n      emitEOF();\n      break;\n    default:\n      reconsume(c, bogus_comment_state);\n      break;\n    }\n  }\n\n  function tag_name_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      tokenizer = before_attribute_name_state;\n      break;\n    case 0x002F: // SOLIDUS\n      tokenizer = self_closing_start_tag_state;\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      tokenizer = data_state;\n      emitTag();\n      break;\n    case 0x0041:  // [A-Z]\n    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:\n    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:\n    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:\n    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:\n    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:\n      tagnamebuf += String.fromCharCode(c + 0x0020);\n      break;\n    case 0x0000: // NULL\n      tagnamebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);\n      break;\n    case -1: // EOF\n      emitEOF();\n      break;\n    default:\n      tagnamebuf += getMatchingChars(TAGNAME);\n      break;\n    }\n  }\n\n  function rcdata_less_than_sign_state(c) {\n    /* identical to the RAWTEXT less-than sign state, except s/RAWTEXT/RCDATA/g */\n    if (c === 0x002F) {  // SOLIDUS\n      beginTempBuf();\n      tokenizer = rcdata_end_tag_open_state;\n    }\n    else {\n      textrun.push(0x003C); // LESS-THAN SIGN\n      reconsume(c, rcdata_state);\n    }\n  }\n\n  function rcdata_end_tag_open_state(c) {\n    /* identical to the RAWTEXT (and Script data) end tag open state, except s/RAWTEXT/RCDATA/g */\n    switch(c) {\n    case 0x0041:  // [A-Z]\n    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:\n    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:\n    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:\n    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:\n    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:\n    case 0x0061:  // [a-z]\n    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:\n    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:\n    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:\n    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:\n    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:\n      beginEndTagName();\n      reconsume(c, rcdata_end_tag_name_state);\n      break;\n    default:\n      textrun.push(0x003C); // LESS-THAN SIGN\n      textrun.push(0x002F); // SOLIDUS\n      reconsume(c, rcdata_state);\n      break;\n    }\n  }\n\n  function rcdata_end_tag_name_state(c) {\n    /* identical to the RAWTEXT (and Script data) end tag name state, except s/RAWTEXT/RCDATA/g */\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      if (appropriateEndTag(tagnamebuf)) {\n        tokenizer = before_attribute_name_state;\n        return;\n      }\n      break;\n    case 0x002F: // SOLIDUS\n      if (appropriateEndTag(tagnamebuf)) {\n        tokenizer = self_closing_start_tag_state;\n        return;\n      }\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      if (appropriateEndTag(tagnamebuf)) {\n        tokenizer = data_state;\n        emitTag();\n        return;\n      }\n      break;\n    case 0x0041:  // [A-Z]\n    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:\n    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:\n    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:\n    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:\n    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:\n\n      tagnamebuf += String.fromCharCode(c + 0x0020);\n      tempbuf.push(c);\n      return;\n    case 0x0061:  // [a-z]\n    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:\n    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:\n    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:\n    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:\n    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:\n\n      tagnamebuf += String.fromCharCode(c);\n      tempbuf.push(c);\n      return;\n    default:\n      break;\n    }\n\n    // If we don't return in one of the cases above, then this was not\n    // an appropriately matching close tag, so back out by emitting all\n    // the characters as text\n    textrun.push(0x003C); // LESS-THAN SIGN\n    textrun.push(0x002F); // SOLIDUS\n    pushAll(textrun, tempbuf);\n    reconsume(c, rcdata_state);\n  }\n\n  function rawtext_less_than_sign_state(c) {\n    /* identical to the RCDATA less-than sign state, except s/RCDATA/RAWTEXT/g\n     */\n    if (c === 0x002F) { // SOLIDUS\n      beginTempBuf();\n      tokenizer = rawtext_end_tag_open_state;\n    }\n    else {\n      textrun.push(0x003C); // LESS-THAN SIGN\n      reconsume(c, rawtext_state);\n    }\n  }\n\n  function rawtext_end_tag_open_state(c) {\n    /* identical to the RCDATA (and Script data) end tag open state, except s/RCDATA/RAWTEXT/g */\n    switch(c) {\n    case 0x0041:  // [A-Z]\n    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:\n    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:\n    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:\n    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:\n    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:\n    case 0x0061:  // [a-z]\n    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:\n    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:\n    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:\n    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:\n    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:\n      beginEndTagName();\n      reconsume(c, rawtext_end_tag_name_state);\n      break;\n    default:\n      textrun.push(0x003C); // LESS-THAN SIGN\n      textrun.push(0x002F); // SOLIDUS\n      reconsume(c, rawtext_state);\n      break;\n    }\n  }\n\n  function rawtext_end_tag_name_state(c) {\n    /* identical to the RCDATA (and Script data) end tag name state, except s/RCDATA/RAWTEXT/g */\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      if (appropriateEndTag(tagnamebuf)) {\n        tokenizer = before_attribute_name_state;\n        return;\n      }\n      break;\n    case 0x002F: // SOLIDUS\n      if (appropriateEndTag(tagnamebuf)) {\n        tokenizer = self_closing_start_tag_state;\n        return;\n      }\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      if (appropriateEndTag(tagnamebuf)) {\n        tokenizer = data_state;\n        emitTag();\n        return;\n      }\n      break;\n    case 0x0041:  // [A-Z]\n    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:\n    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:\n    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:\n    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:\n    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:\n      tagnamebuf += String.fromCharCode(c + 0x0020);\n      tempbuf.push(c);\n      return;\n    case 0x0061:  // [a-z]\n    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:\n    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:\n    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:\n    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:\n    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:\n      tagnamebuf += String.fromCharCode(c);\n      tempbuf.push(c);\n      return;\n    default:\n      break;\n    }\n\n    // If we don't return in one of the cases above, then this was not\n    // an appropriately matching close tag, so back out by emitting all\n    // the characters as text\n    textrun.push(0x003C); // LESS-THAN SIGN\n    textrun.push(0x002F); // SOLIDUS\n    pushAll(textrun,tempbuf);\n    reconsume(c, rawtext_state);\n  }\n\n  function script_data_less_than_sign_state(c) {\n    switch(c) {\n    case 0x002F: // SOLIDUS\n      beginTempBuf();\n      tokenizer = script_data_end_tag_open_state;\n      break;\n    case 0x0021: // EXCLAMATION MARK\n      tokenizer = script_data_escape_start_state;\n      textrun.push(0x003C); // LESS-THAN SIGN\n      textrun.push(0x0021); // EXCLAMATION MARK\n      break;\n    default:\n      textrun.push(0x003C); // LESS-THAN SIGN\n      reconsume(c, script_data_state);\n      break;\n    }\n  }\n\n  function script_data_end_tag_open_state(c) {\n    /* identical to the RCDATA (and RAWTEXT) end tag open state, except s/RCDATA/Script data/g */\n    switch(c) {\n    case 0x0041:  // [A-Z]\n    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:\n    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:\n    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:\n    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:\n    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:\n    case 0x0061:  // [a-z]\n    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:\n    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:\n    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:\n    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:\n    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:\n      beginEndTagName();\n      reconsume(c, script_data_end_tag_name_state);\n      break;\n    default:\n      textrun.push(0x003C); // LESS-THAN SIGN\n      textrun.push(0x002F); // SOLIDUS\n      reconsume(c, script_data_state);\n      break;\n    }\n  }\n\n  function script_data_end_tag_name_state(c) {\n    /* identical to the RCDATA (and RAWTEXT) end tag name state, except s/RCDATA/Script data/g */\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      if (appropriateEndTag(tagnamebuf)) {\n        tokenizer = before_attribute_name_state;\n        return;\n      }\n      break;\n    case 0x002F: // SOLIDUS\n      if (appropriateEndTag(tagnamebuf)) {\n        tokenizer = self_closing_start_tag_state;\n        return;\n      }\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      if (appropriateEndTag(tagnamebuf)) {\n        tokenizer = data_state;\n        emitTag();\n        return;\n      }\n      break;\n    case 0x0041:  // [A-Z]\n    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:\n    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:\n    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:\n    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:\n    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:\n\n      tagnamebuf += String.fromCharCode(c + 0x0020);\n      tempbuf.push(c);\n      return;\n    case 0x0061:  // [a-z]\n    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:\n    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:\n    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:\n    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:\n    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:\n\n      tagnamebuf += String.fromCharCode(c);\n      tempbuf.push(c);\n      return;\n    default:\n      break;\n    }\n\n    // If we don't return in one of the cases above, then this was not\n    // an appropriately matching close tag, so back out by emitting all\n    // the characters as text\n    textrun.push(0x003C); // LESS-THAN SIGN\n    textrun.push(0x002F); // SOLIDUS\n    pushAll(textrun,tempbuf);\n    reconsume(c, script_data_state);\n  }\n\n  function script_data_escape_start_state(c) {\n    if (c === 0x002D) { // HYPHEN-MINUS\n      tokenizer = script_data_escape_start_dash_state;\n      textrun.push(0x002D); // HYPHEN-MINUS\n    }\n    else {\n      reconsume(c, script_data_state);\n    }\n  }\n\n  function script_data_escape_start_dash_state(c) {\n    if (c === 0x002D) { // HYPHEN-MINUS\n      tokenizer = script_data_escaped_dash_dash_state;\n      textrun.push(0x002D); // HYPHEN-MINUS\n    }\n    else {\n      reconsume(c, script_data_state);\n    }\n  }\n\n  function script_data_escaped_state(c) {\n    switch(c) {\n    case 0x002D: // HYPHEN-MINUS\n      tokenizer = script_data_escaped_dash_state;\n      textrun.push(0x002D); // HYPHEN-MINUS\n      break;\n    case 0x003C: // LESS-THAN SIGN\n      tokenizer = script_data_escaped_less_than_sign_state;\n      break;\n    case 0x0000: // NULL\n      textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n      break;\n    case -1: // EOF\n      emitEOF();\n      break;\n    default:\n      textrun.push(c);\n      break;\n    }\n  }\n\n  function script_data_escaped_dash_state(c) {\n    switch(c) {\n    case 0x002D: // HYPHEN-MINUS\n      tokenizer = script_data_escaped_dash_dash_state;\n      textrun.push(0x002D); // HYPHEN-MINUS\n      break;\n    case 0x003C: // LESS-THAN SIGN\n      tokenizer = script_data_escaped_less_than_sign_state;\n      break;\n    case 0x0000: // NULL\n      tokenizer = script_data_escaped_state;\n      textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n      break;\n    case -1: // EOF\n      emitEOF();\n      break;\n    default:\n      tokenizer = script_data_escaped_state;\n      textrun.push(c);\n      break;\n    }\n  }\n\n  function script_data_escaped_dash_dash_state(c) {\n    switch(c) {\n    case 0x002D: // HYPHEN-MINUS\n      textrun.push(0x002D); // HYPHEN-MINUS\n      break;\n    case 0x003C: // LESS-THAN SIGN\n      tokenizer = script_data_escaped_less_than_sign_state;\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      tokenizer = script_data_state;\n      textrun.push(0x003E); // GREATER-THAN SIGN\n      break;\n    case 0x0000: // NULL\n      tokenizer = script_data_escaped_state;\n      textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n      break;\n    case -1: // EOF\n      emitEOF();\n      break;\n    default:\n      tokenizer = script_data_escaped_state;\n      textrun.push(c);\n      break;\n    }\n  }\n\n  function script_data_escaped_less_than_sign_state(c) {\n    switch(c) {\n    case 0x002F: // SOLIDUS\n      beginTempBuf();\n      tokenizer = script_data_escaped_end_tag_open_state;\n      break;\n    case 0x0041:  // [A-Z]\n    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:\n    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:\n    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:\n    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:\n    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:\n    case 0x0061:  // [a-z]\n    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:\n    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:\n    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:\n    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:\n    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:\n      beginTempBuf();\n      textrun.push(0x003C); // LESS-THAN SIGN\n      reconsume(c, script_data_double_escape_start_state);\n      break;\n    default:\n      textrun.push(0x003C); // LESS-THAN SIGN\n      reconsume(c, script_data_escaped_state);\n      break;\n    }\n  }\n\n  function script_data_escaped_end_tag_open_state(c) {\n    switch(c) {\n    case 0x0041:  // [A-Z]\n    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:\n    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:\n    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:\n    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:\n    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:\n    case 0x0061:  // [a-z]\n    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:\n    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:\n    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:\n    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:\n    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:\n      beginEndTagName();\n      reconsume(c, script_data_escaped_end_tag_name_state);\n      break;\n    default:\n      textrun.push(0x003C); // LESS-THAN SIGN\n      textrun.push(0x002F); // SOLIDUS\n      reconsume(c, script_data_escaped_state);\n      break;\n    }\n  }\n\n  function script_data_escaped_end_tag_name_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      if (appropriateEndTag(tagnamebuf)) {\n        tokenizer = before_attribute_name_state;\n        return;\n      }\n      break;\n    case 0x002F: // SOLIDUS\n      if (appropriateEndTag(tagnamebuf)) {\n        tokenizer = self_closing_start_tag_state;\n        return;\n      }\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      if (appropriateEndTag(tagnamebuf)) {\n        tokenizer = data_state;\n        emitTag();\n        return;\n      }\n      break;\n    case 0x0041:  // [A-Z]\n    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:\n    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:\n    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:\n    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:\n    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:\n      tagnamebuf += String.fromCharCode(c + 0x0020);\n      tempbuf.push(c);\n      return;\n    case 0x0061:  // [a-z]\n    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:\n    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:\n    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:\n    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:\n    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:\n      tagnamebuf += String.fromCharCode(c);\n      tempbuf.push(c);\n      return;\n    default:\n      break;\n    }\n\n    // We get here in the default case, and if the closing tagname\n    // is not an appropriate tagname.\n    textrun.push(0x003C); // LESS-THAN SIGN\n    textrun.push(0x002F); // SOLIDUS\n    pushAll(textrun,tempbuf);\n    reconsume(c, script_data_escaped_state);\n  }\n\n  function script_data_double_escape_start_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n    case 0x002F: // SOLIDUS\n    case 0x003E: // GREATER-THAN SIGN\n      if (buf2str(tempbuf) === \"script\") {\n        tokenizer = script_data_double_escaped_state;\n      }\n      else {\n        tokenizer = script_data_escaped_state;\n      }\n      textrun.push(c);\n      break;\n    case 0x0041:  // [A-Z]\n    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:\n    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:\n    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:\n    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:\n    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:\n      tempbuf.push(c + 0x0020);\n      textrun.push(c);\n      break;\n    case 0x0061:  // [a-z]\n    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:\n    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:\n    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:\n    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:\n    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:\n      tempbuf.push(c);\n      textrun.push(c);\n      break;\n    default:\n      reconsume(c, script_data_escaped_state);\n      break;\n    }\n  }\n\n  function script_data_double_escaped_state(c) {\n    switch(c) {\n    case 0x002D: // HYPHEN-MINUS\n      tokenizer = script_data_double_escaped_dash_state;\n      textrun.push(0x002D); // HYPHEN-MINUS\n      break;\n    case 0x003C: // LESS-THAN SIGN\n      tokenizer = script_data_double_escaped_less_than_sign_state;\n      textrun.push(0x003C); // LESS-THAN SIGN\n      break;\n    case 0x0000: // NULL\n      textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n      break;\n    case -1: // EOF\n      emitEOF();\n      break;\n    default:\n      textrun.push(c);\n      break;\n    }\n  }\n\n  function script_data_double_escaped_dash_state(c) {\n    switch(c) {\n    case 0x002D: // HYPHEN-MINUS\n      tokenizer = script_data_double_escaped_dash_dash_state;\n      textrun.push(0x002D); // HYPHEN-MINUS\n      break;\n    case 0x003C: // LESS-THAN SIGN\n      tokenizer = script_data_double_escaped_less_than_sign_state;\n      textrun.push(0x003C); // LESS-THAN SIGN\n      break;\n    case 0x0000: // NULL\n      tokenizer = script_data_double_escaped_state;\n      textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n      break;\n    case -1: // EOF\n      emitEOF();\n      break;\n    default:\n      tokenizer = script_data_double_escaped_state;\n      textrun.push(c);\n      break;\n    }\n  }\n\n  function script_data_double_escaped_dash_dash_state(c) {\n    switch(c) {\n    case 0x002D: // HYPHEN-MINUS\n      textrun.push(0x002D); // HYPHEN-MINUS\n      break;\n    case 0x003C: // LESS-THAN SIGN\n      tokenizer = script_data_double_escaped_less_than_sign_state;\n      textrun.push(0x003C); // LESS-THAN SIGN\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      tokenizer = script_data_state;\n      textrun.push(0x003E); // GREATER-THAN SIGN\n      break;\n    case 0x0000: // NULL\n      tokenizer = script_data_double_escaped_state;\n      textrun.push(0xFFFD); // REPLACEMENT CHARACTER\n      break;\n    case -1: // EOF\n      emitEOF();\n      break;\n    default:\n      tokenizer = script_data_double_escaped_state;\n      textrun.push(c);\n      break;\n    }\n  }\n\n  function script_data_double_escaped_less_than_sign_state(c) {\n    if (c === 0x002F) { // SOLIDUS\n      beginTempBuf();\n      tokenizer = script_data_double_escape_end_state;\n      textrun.push(0x002F); // SOLIDUS\n    }\n    else {\n      reconsume(c, script_data_double_escaped_state);\n    }\n  }\n\n  function script_data_double_escape_end_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n    case 0x002F: // SOLIDUS\n    case 0x003E: // GREATER-THAN SIGN\n      if (buf2str(tempbuf) === \"script\") {\n        tokenizer = script_data_escaped_state;\n      }\n      else {\n        tokenizer = script_data_double_escaped_state;\n      }\n      textrun.push(c);\n      break;\n    case 0x0041:  // [A-Z]\n    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:\n    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:\n    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:\n    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:\n    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:\n      tempbuf.push(c + 0x0020);\n      textrun.push(c);\n      break;\n    case 0x0061:  // [a-z]\n    case 0x0062:case 0x0063:case 0x0064:case 0x0065:case 0x0066:\n    case 0x0067:case 0x0068:case 0x0069:case 0x006A:case 0x006B:\n    case 0x006C:case 0x006D:case 0x006E:case 0x006F:case 0x0070:\n    case 0x0071:case 0x0072:case 0x0073:case 0x0074:case 0x0075:\n    case 0x0076:case 0x0077:case 0x0078:case 0x0079:case 0x007A:\n      tempbuf.push(c);\n      textrun.push(c);\n      break;\n    default:\n      reconsume(c, script_data_double_escaped_state);\n      break;\n    }\n  }\n\n  function before_attribute_name_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      /* Ignore the character. */\n      break;\n    // For SOLIDUS, GREATER-THAN SIGN, and EOF, spec says \"reconsume in\n    // the after attribute name state\", but in our implementation that\n    // state always has an active attribute in attrnamebuf.  Just clone\n    // the rules here, without the addAttribute business.\n    case 0x002F: // SOLIDUS\n      tokenizer = self_closing_start_tag_state;\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      tokenizer = data_state;\n      emitTag();\n      break;\n    case -1: // EOF\n      emitEOF();\n      break;\n    case 0x003D: // EQUALS SIGN\n      beginAttrName();\n      attrnamebuf += String.fromCharCode(c);\n      tokenizer = attribute_name_state;\n      break;\n    default:\n      if (handleSimpleAttribute()) break;\n      beginAttrName();\n      reconsume(c, attribute_name_state);\n      break;\n    }\n  }\n\n  // beginAttrName() must have been called before this point\n  // There is an active attribute in attrnamebuf (but not attrvaluebuf)\n  function attribute_name_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n    case 0x002F: // SOLIDUS\n    case 0x003E: // GREATER-THAN SIGN\n    case -1: // EOF\n      reconsume(c, after_attribute_name_state);\n      break;\n    case 0x003D: // EQUALS SIGN\n      tokenizer = before_attribute_value_state;\n      break;\n    case 0x0041:  // [A-Z]\n    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:\n    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:\n    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:\n    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:\n    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:\n      attrnamebuf += String.fromCharCode(c + 0x0020);\n      break;\n    case 0x0000: // NULL\n      attrnamebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);\n      break;\n    case 0x0022: // QUOTATION MARK\n    case 0x0027: // APOSTROPHE\n    case 0x003C: // LESS-THAN SIGN\n      /* falls through */\n    default:\n      attrnamebuf += getMatchingChars(ATTRNAME);\n      break;\n    }\n  }\n\n  // There is an active attribute in attrnamebuf, but not yet in attrvaluebuf.\n  function after_attribute_name_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      /* Ignore the character. */\n      break;\n    case 0x002F: // SOLIDUS\n      // Keep in sync with before_attribute_name_state.\n      addAttribute(attrnamebuf);\n      tokenizer = self_closing_start_tag_state;\n      break;\n    case 0x003D: // EQUALS SIGN\n      tokenizer = before_attribute_value_state;\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      // Keep in sync with before_attribute_name_state.\n      tokenizer = data_state;\n      addAttribute(attrnamebuf);\n      emitTag();\n      break;\n    case -1: // EOF\n      // Keep in sync with before_attribute_name_state.\n      addAttribute(attrnamebuf);\n      emitEOF();\n      break;\n    default:\n      addAttribute(attrnamebuf);\n      beginAttrName();\n      reconsume(c, attribute_name_state);\n      break;\n    }\n  }\n\n  function before_attribute_value_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      /* Ignore the character. */\n      break;\n    case 0x0022: // QUOTATION MARK\n      beginAttrValue();\n      tokenizer = attribute_value_double_quoted_state;\n      break;\n    case 0x0027: // APOSTROPHE\n      beginAttrValue();\n      tokenizer = attribute_value_single_quoted_state;\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      /* falls through */\n    default:\n      beginAttrValue();\n      reconsume(c, attribute_value_unquoted_state);\n      break;\n    }\n  }\n\n  function attribute_value_double_quoted_state(c) {\n    switch(c) {\n    case 0x0022: // QUOTATION MARK\n      addAttribute(attrnamebuf, attrvaluebuf);\n      tokenizer = after_attribute_value_quoted_state;\n      break;\n    case 0x0026: // AMPERSAND\n      return_state = attribute_value_double_quoted_state;\n      tokenizer = character_reference_state;\n      break;\n    case 0x0000: // NULL\n      attrvaluebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);\n      break;\n    case -1: // EOF\n      emitEOF();\n      break;\n    case 0x000A: // LF\n      // this could be a converted \\r, so don't use getMatchingChars\n      attrvaluebuf += String.fromCharCode(c);\n      break;\n    default:\n      attrvaluebuf += getMatchingChars(DBLQUOTEATTRVAL);\n      break;\n    }\n  }\n\n  function attribute_value_single_quoted_state(c) {\n    switch(c) {\n    case 0x0027: // APOSTROPHE\n      addAttribute(attrnamebuf, attrvaluebuf);\n      tokenizer = after_attribute_value_quoted_state;\n      break;\n    case 0x0026: // AMPERSAND\n      return_state = attribute_value_single_quoted_state;\n      tokenizer = character_reference_state;\n      break;\n    case 0x0000: // NULL\n      attrvaluebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);\n      break;\n    case -1: // EOF\n      emitEOF();\n      break;\n    case 0x000A: // LF\n      // this could be a converted \\r, so don't use getMatchingChars\n      attrvaluebuf += String.fromCharCode(c);\n      break;\n    default:\n      attrvaluebuf += getMatchingChars(SINGLEQUOTEATTRVAL);\n      break;\n    }\n  }\n\n  function attribute_value_unquoted_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      addAttribute(attrnamebuf, attrvaluebuf);\n      tokenizer = before_attribute_name_state;\n      break;\n    case 0x0026: // AMPERSAND\n      return_state = attribute_value_unquoted_state;\n      tokenizer = character_reference_state;\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      addAttribute(attrnamebuf, attrvaluebuf);\n      tokenizer = data_state;\n      emitTag();\n      break;\n    case 0x0000: // NULL\n      attrvaluebuf += String.fromCharCode(0xFFFD /* REPLACEMENT CHARACTER */);\n      break;\n    case -1: // EOF\n      nextchar--; // pushback\n      tokenizer = data_state;\n      break;\n    case 0x0022: // QUOTATION MARK\n    case 0x0027: // APOSTROPHE\n    case 0x003C: // LESS-THAN SIGN\n    case 0x003D: // EQUALS SIGN\n    case 0x0060: // GRAVE ACCENT\n      /* falls through */\n    default:\n      attrvaluebuf += getMatchingChars(UNQUOTEDATTRVAL);\n      break;\n    }\n  }\n\n  function after_attribute_value_quoted_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      tokenizer = before_attribute_name_state;\n      break;\n    case 0x002F: // SOLIDUS\n      tokenizer = self_closing_start_tag_state;\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      tokenizer = data_state;\n      emitTag();\n      break;\n    case -1: // EOF\n      emitEOF();\n      break;\n    default:\n      reconsume(c, before_attribute_name_state);\n      break;\n    }\n  }\n\n  function self_closing_start_tag_state(c) {\n    switch(c) {\n    case 0x003E: // GREATER-THAN SIGN\n      // Set the <i>self-closing flag</i> of the current tag token.\n      tokenizer = data_state;\n      emitSelfClosingTag(true);\n      break;\n    case -1: // EOF\n      emitEOF();\n      break;\n    default:\n      reconsume(c, before_attribute_name_state);\n      break;\n    }\n  }\n\n  function bogus_comment_state(c, lookahead, eof) {\n    var len = lookahead.length;\n\n    if (eof) {\n      nextchar += len-1; // don't consume the eof\n    }\n    else {\n      nextchar += len;\n    }\n\n    var comment = lookahead.substring(0, len-1);\n\n    comment = comment.replace(/\\u0000/g,\"\\uFFFD\");\n    comment = comment.replace(/\\u000D\\u000A/g,\"\\u000A\");\n    comment = comment.replace(/\\u000D/g,\"\\u000A\");\n\n    insertToken(COMMENT, comment);\n    tokenizer = data_state;\n  }\n  bogus_comment_state.lookahead = \">\";\n\n  function markup_declaration_open_state(c, lookahead, eof) {\n    if (lookahead[0] === \"-\" && lookahead[1] === \"-\") {\n      nextchar += 2;\n      beginComment();\n      tokenizer = comment_start_state;\n      return;\n    }\n\n    if (lookahead.toUpperCase() === \"DOCTYPE\") {\n      nextchar += 7;\n      tokenizer = doctype_state;\n    }\n    else if (lookahead === \"[CDATA[\" && cdataAllowed()) {\n      nextchar += 7;\n      tokenizer = cdata_section_state;\n    }\n    else {\n      tokenizer = bogus_comment_state;\n    }\n  }\n  markup_declaration_open_state.lookahead = 7;\n\n  function comment_start_state(c) {\n    beginComment();\n    switch(c) {\n    case 0x002D: // HYPHEN-MINUS\n      tokenizer = comment_start_dash_state;\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      tokenizer = data_state;\n      insertToken(COMMENT, buf2str(commentbuf));\n      break; /* see comment in comment end state */\n    default:\n      reconsume(c, comment_state);\n      break;\n    }\n  }\n\n  function comment_start_dash_state(c) {\n    switch(c) {\n    case 0x002D: // HYPHEN-MINUS\n      tokenizer = comment_end_state;\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      tokenizer = data_state;\n      insertToken(COMMENT, buf2str(commentbuf));\n      break;\n    case -1: // EOF\n      insertToken(COMMENT, buf2str(commentbuf));\n      emitEOF();\n      break; /* see comment in comment end state */\n    default:\n      commentbuf.push(0x002D /* HYPHEN-MINUS */);\n      reconsume(c, comment_state);\n      break;\n    }\n  }\n\n  function comment_state(c) {\n    switch(c) {\n    case 0x003C: // LESS-THAN SIGN\n      commentbuf.push(c);\n      tokenizer = comment_less_than_sign_state;\n      break;\n    case 0x002D: // HYPHEN-MINUS\n      tokenizer = comment_end_dash_state;\n      break;\n    case 0x0000: // NULL\n      commentbuf.push(0xFFFD /* REPLACEMENT CHARACTER */);\n      break;\n    case -1: // EOF\n      insertToken(COMMENT, buf2str(commentbuf));\n      emitEOF();\n      break; /* see comment in comment end state */\n    default:\n      commentbuf.push(c);\n      break;\n    }\n  }\n\n  function comment_less_than_sign_state(c) {\n    switch(c) {\n    case 0x0021: // EXCLAMATION MARK\n      commentbuf.push(c);\n      tokenizer = comment_less_than_sign_bang_state;\n      break;\n    case 0x003C: // LESS-THAN SIGN\n      commentbuf.push(c);\n      break;\n    default:\n      reconsume(c, comment_state);\n      break;\n    }\n  }\n\n  function comment_less_than_sign_bang_state(c) {\n    switch(c) {\n    case 0x002D: // HYPHEN-MINUS\n      tokenizer = comment_less_than_sign_bang_dash_state;\n      break;\n    default:\n      reconsume(c, comment_state);\n      break;\n    }\n  }\n\n  function comment_less_than_sign_bang_dash_state(c) {\n    switch(c) {\n    case 0x002D: // HYPHEN-MINUS\n      tokenizer = comment_less_than_sign_bang_dash_dash_state;\n      break;\n    default:\n      reconsume(c, comment_end_dash_state);\n      break;\n    }\n  }\n\n  function comment_less_than_sign_bang_dash_dash_state(c) {\n    switch(c) {\n    case 0x003E: // GREATER-THAN SIGN\n    case -1: // EOF\n      reconsume(c, comment_end_state);\n      break;\n    default:\n      // parse error\n      reconsume(c, comment_end_state);\n      break;\n    }\n  }\n\n  function comment_end_dash_state(c) {\n    switch(c) {\n    case 0x002D: // HYPHEN-MINUS\n      tokenizer = comment_end_state;\n      break;\n    case -1: // EOF\n      insertToken(COMMENT, buf2str(commentbuf));\n      emitEOF();\n      break; /* see comment in comment end state */\n    default:\n      commentbuf.push(0x002D /* HYPHEN-MINUS */);\n      reconsume(c, comment_state);\n      break;\n    }\n  }\n\n  function comment_end_state(c) {\n    switch(c) {\n    case 0x003E: // GREATER-THAN SIGN\n      tokenizer = data_state;\n      insertToken(COMMENT, buf2str(commentbuf));\n      break;\n    case 0x0021: // EXCLAMATION MARK\n      tokenizer = comment_end_bang_state;\n      break;\n    case 0x002D: // HYPHEN-MINUS\n      commentbuf.push(0x002D);\n      break;\n    case -1: // EOF\n      insertToken(COMMENT, buf2str(commentbuf));\n      emitEOF();\n      break; /* For security reasons: otherwise, hostile user could put a script in a comment e.g. in a blog comment and then DOS the server so that the end tag isn't read, and then the commented script tag would be treated as live code */\n    default:\n      commentbuf.push(0x002D);\n      commentbuf.push(0x002D);\n      reconsume(c, comment_state);\n      break;\n    }\n  }\n\n  function comment_end_bang_state(c) {\n    switch(c) {\n    case 0x002D: // HYPHEN-MINUS\n      commentbuf.push(0x002D);\n      commentbuf.push(0x002D);\n      commentbuf.push(0x0021);\n      tokenizer = comment_end_dash_state;\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      tokenizer = data_state;\n      insertToken(COMMENT, buf2str(commentbuf));\n      break;\n    case -1: // EOF\n      insertToken(COMMENT, buf2str(commentbuf));\n      emitEOF();\n      break; /* see comment in comment end state */\n    default:\n      commentbuf.push(0x002D);\n      commentbuf.push(0x002D);\n      commentbuf.push(0x0021);\n      reconsume(c, comment_state);\n      break;\n    }\n  }\n\n  function doctype_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      tokenizer = before_doctype_name_state;\n      break;\n    case -1: // EOF\n      beginDoctype();\n      forcequirks();\n      emitDoctype();\n      emitEOF();\n      break;\n    default:\n      reconsume(c, before_doctype_name_state);\n      break;\n    }\n  }\n\n  function before_doctype_name_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      /* Ignore the character. */\n      break;\n    case 0x0041:  // [A-Z]\n    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:\n    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:\n    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:\n    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:\n    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:\n      beginDoctype();\n      doctypenamebuf.push(c + 0x0020);\n      tokenizer = doctype_name_state;\n      break;\n    case 0x0000: // NULL\n      beginDoctype();\n      doctypenamebuf.push(0xFFFD);\n      tokenizer = doctype_name_state;\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      beginDoctype();\n      forcequirks();\n      tokenizer = data_state;\n      emitDoctype();\n      break;\n    case -1: // EOF\n      beginDoctype();\n      forcequirks();\n      emitDoctype();\n      emitEOF();\n      break;\n    default:\n      beginDoctype();\n      doctypenamebuf.push(c);\n      tokenizer = doctype_name_state;\n      break;\n    }\n  }\n\n  function doctype_name_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      tokenizer = after_doctype_name_state;\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      tokenizer = data_state;\n      emitDoctype();\n      break;\n    case 0x0041:  // [A-Z]\n    case 0x0042:case 0x0043:case 0x0044:case 0x0045:case 0x0046:\n    case 0x0047:case 0x0048:case 0x0049:case 0x004A:case 0x004B:\n    case 0x004C:case 0x004D:case 0x004E:case 0x004F:case 0x0050:\n    case 0x0051:case 0x0052:case 0x0053:case 0x0054:case 0x0055:\n    case 0x0056:case 0x0057:case 0x0058:case 0x0059:case 0x005A:\n      doctypenamebuf.push(c + 0x0020);\n      break;\n    case 0x0000: // NULL\n      doctypenamebuf.push(0xFFFD /* REPLACEMENT CHARACTER */);\n      break;\n    case -1: // EOF\n      forcequirks();\n      emitDoctype();\n      emitEOF();\n      break;\n    default:\n      doctypenamebuf.push(c);\n      break;\n    }\n  }\n\n  function after_doctype_name_state(c, lookahead, eof) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      /* Ignore the character. */\n      nextchar += 1;\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      tokenizer = data_state;\n      nextchar += 1;\n      emitDoctype();\n      break;\n    case -1: // EOF\n      forcequirks();\n      emitDoctype();\n      emitEOF();\n      break;\n    default:\n      lookahead = lookahead.toUpperCase();\n      if (lookahead === \"PUBLIC\") {\n        nextchar += 6;\n        tokenizer = after_doctype_public_keyword_state;\n      }\n      else if (lookahead === \"SYSTEM\") {\n        nextchar += 6;\n        tokenizer = after_doctype_system_keyword_state;\n      }\n      else {\n        forcequirks();\n        tokenizer = bogus_doctype_state;\n      }\n      break;\n    }\n  }\n  after_doctype_name_state.lookahead = 6;\n\n  function after_doctype_public_keyword_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      tokenizer = before_doctype_public_identifier_state;\n      break;\n    case 0x0022: // QUOTATION MARK\n      beginDoctypePublicId();\n      tokenizer = doctype_public_identifier_double_quoted_state;\n      break;\n    case 0x0027: // APOSTROPHE\n      beginDoctypePublicId();\n      tokenizer = doctype_public_identifier_single_quoted_state;\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      forcequirks();\n      tokenizer = data_state;\n      emitDoctype();\n      break;\n    case -1: // EOF\n      forcequirks();\n      emitDoctype();\n      emitEOF();\n      break;\n    default:\n      forcequirks();\n      tokenizer = bogus_doctype_state;\n      break;\n    }\n  }\n\n  function before_doctype_public_identifier_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      /* Ignore the character. */\n      break;\n    case 0x0022: // QUOTATION MARK\n      beginDoctypePublicId();\n      tokenizer = doctype_public_identifier_double_quoted_state;\n      break;\n    case 0x0027: // APOSTROPHE\n      beginDoctypePublicId();\n      tokenizer = doctype_public_identifier_single_quoted_state;\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      forcequirks();\n      tokenizer = data_state;\n      emitDoctype();\n      break;\n    case -1: // EOF\n      forcequirks();\n      emitDoctype();\n      emitEOF();\n      break;\n    default:\n      forcequirks();\n      tokenizer = bogus_doctype_state;\n      break;\n    }\n  }\n\n  function doctype_public_identifier_double_quoted_state(c) {\n    switch(c) {\n    case 0x0022: // QUOTATION MARK\n      tokenizer = after_doctype_public_identifier_state;\n      break;\n    case 0x0000: // NULL\n      doctypepublicbuf.push(0xFFFD /* REPLACEMENT CHARACTER */);\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      forcequirks();\n      tokenizer = data_state;\n      emitDoctype();\n      break;\n    case -1: // EOF\n      forcequirks();\n      emitDoctype();\n      emitEOF();\n      break;\n    default:\n      doctypepublicbuf.push(c);\n      break;\n    }\n  }\n\n  function doctype_public_identifier_single_quoted_state(c) {\n    switch(c) {\n    case 0x0027: // APOSTROPHE\n      tokenizer = after_doctype_public_identifier_state;\n      break;\n    case 0x0000: // NULL\n      doctypepublicbuf.push(0xFFFD /* REPLACEMENT CHARACTER */);\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      forcequirks();\n      tokenizer = data_state;\n      emitDoctype();\n      break;\n    case -1: // EOF\n      forcequirks();\n      emitDoctype();\n      emitEOF();\n      break;\n    default:\n      doctypepublicbuf.push(c);\n      break;\n    }\n  }\n\n  function after_doctype_public_identifier_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      tokenizer = between_doctype_public_and_system_identifiers_state;\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      tokenizer = data_state;\n      emitDoctype();\n      break;\n    case 0x0022: // QUOTATION MARK\n      beginDoctypeSystemId();\n      tokenizer = doctype_system_identifier_double_quoted_state;\n      break;\n    case 0x0027: // APOSTROPHE\n      beginDoctypeSystemId();\n      tokenizer = doctype_system_identifier_single_quoted_state;\n      break;\n    case -1: // EOF\n      forcequirks();\n      emitDoctype();\n      emitEOF();\n      break;\n    default:\n      forcequirks();\n      tokenizer = bogus_doctype_state;\n      break;\n    }\n  }\n\n  function between_doctype_public_and_system_identifiers_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE Ignore the character.\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      tokenizer = data_state;\n      emitDoctype();\n      break;\n    case 0x0022: // QUOTATION MARK\n      beginDoctypeSystemId();\n      tokenizer = doctype_system_identifier_double_quoted_state;\n      break;\n    case 0x0027: // APOSTROPHE\n      beginDoctypeSystemId();\n      tokenizer = doctype_system_identifier_single_quoted_state;\n      break;\n    case -1: // EOF\n      forcequirks();\n      emitDoctype();\n      emitEOF();\n      break;\n    default:\n      forcequirks();\n      tokenizer = bogus_doctype_state;\n      break;\n    }\n  }\n\n  function after_doctype_system_keyword_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      tokenizer = before_doctype_system_identifier_state;\n      break;\n    case 0x0022: // QUOTATION MARK\n      beginDoctypeSystemId();\n      tokenizer = doctype_system_identifier_double_quoted_state;\n      break;\n    case 0x0027: // APOSTROPHE\n      beginDoctypeSystemId();\n      tokenizer = doctype_system_identifier_single_quoted_state;\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      forcequirks();\n      tokenizer = data_state;\n      emitDoctype();\n      break;\n    case -1: // EOF\n      forcequirks();\n      emitDoctype();\n      emitEOF();\n      break;\n    default:\n      forcequirks();\n      tokenizer = bogus_doctype_state;\n      break;\n    }\n  }\n\n  function before_doctype_system_identifier_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE Ignore the character.\n      break;\n    case 0x0022: // QUOTATION MARK\n      beginDoctypeSystemId();\n      tokenizer = doctype_system_identifier_double_quoted_state;\n      break;\n    case 0x0027: // APOSTROPHE\n      beginDoctypeSystemId();\n      tokenizer = doctype_system_identifier_single_quoted_state;\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      forcequirks();\n      tokenizer = data_state;\n      emitDoctype();\n      break;\n    case -1: // EOF\n      forcequirks();\n      emitDoctype();\n      emitEOF();\n      break;\n    default:\n      forcequirks();\n      tokenizer = bogus_doctype_state;\n      break;\n    }\n  }\n\n  function doctype_system_identifier_double_quoted_state(c) {\n    switch(c) {\n    case 0x0022: // QUOTATION MARK\n      tokenizer = after_doctype_system_identifier_state;\n      break;\n    case 0x0000: // NULL\n      doctypesystembuf.push(0xFFFD /* REPLACEMENT CHARACTER */);\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      forcequirks();\n      tokenizer = data_state;\n      emitDoctype();\n      break;\n    case -1: // EOF\n      forcequirks();\n      emitDoctype();\n      emitEOF();\n      break;\n    default:\n      doctypesystembuf.push(c);\n      break;\n    }\n  }\n\n  function doctype_system_identifier_single_quoted_state(c) {\n    switch(c) {\n    case 0x0027: // APOSTROPHE\n      tokenizer = after_doctype_system_identifier_state;\n      break;\n    case 0x0000: // NULL\n      doctypesystembuf.push(0xFFFD /* REPLACEMENT CHARACTER */);\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      forcequirks();\n      tokenizer = data_state;\n      emitDoctype();\n      break;\n    case -1: // EOF\n      forcequirks();\n      emitDoctype();\n      emitEOF();\n      break;\n    default:\n      doctypesystembuf.push(c);\n      break;\n    }\n  }\n\n  function after_doctype_system_identifier_state(c) {\n    switch(c) {\n    case 0x0009: // CHARACTER TABULATION (tab)\n    case 0x000A: // LINE FEED (LF)\n    case 0x000C: // FORM FEED (FF)\n    case 0x0020: // SPACE\n      /* Ignore the character. */\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      tokenizer = data_state;\n      emitDoctype();\n      break;\n    case -1: // EOF\n      forcequirks();\n      emitDoctype();\n      emitEOF();\n      break;\n    default:\n      tokenizer = bogus_doctype_state;\n      /* This does *not* set the DOCTYPE token's force-quirks flag. */\n      break;\n    }\n  }\n\n  function bogus_doctype_state(c) {\n    switch(c) {\n    case 0x003E: // GREATER-THAN SIGN\n      tokenizer = data_state;\n      emitDoctype();\n      break;\n    case -1: // EOF\n      emitDoctype();\n      emitEOF();\n      break;\n    default:\n      /* Ignore the character. */\n      break;\n    }\n  }\n\n  function cdata_section_state(c) {\n    switch(c) {\n    case 0x005D: // RIGHT SQUARE BRACKET\n      tokenizer = cdata_section_bracket_state;\n      break;\n    case -1: // EOF\n      emitEOF();\n      break;\n    case 0x0000: // NULL\n      textIncludesNUL = true;\n      /* fall through */\n    default:\n      // Instead of just pushing a single character and then\n      // coming back to the very same place, lookahead and\n      // emit everything we can at once.\n      /*jshint -W030 */\n      emitCharsWhile(CDATATEXT) || textrun.push(c);\n      break;\n    }\n  }\n\n  function cdata_section_bracket_state(c) {\n    switch(c) {\n    case 0x005D: // RIGHT SQUARE BRACKET\n      tokenizer = cdata_section_end_state;\n      break;\n    default:\n      textrun.push(0x005D);\n      reconsume(c, cdata_section_state);\n      break;\n    }\n  }\n\n  function cdata_section_end_state(c) {\n    switch(c) {\n    case 0x005D: // RIGHT SQUARE BRACKET\n      textrun.push(0x005D);\n      break;\n    case 0x003E: // GREATER-THAN SIGN\n      flushText();\n      tokenizer = data_state;\n      break;\n    default:\n      textrun.push(0x005D);\n      textrun.push(0x005D);\n      reconsume(c, cdata_section_state);\n      break;\n    }\n  }\n\n  function character_reference_state(c) {\n    beginTempBuf();\n    tempbuf.push(0x0026);\n    switch(c) {\n    case 0x0009: // TAB\n    case 0x000A: // LINE FEED\n    case 0x000C: // FORM FEED\n    case 0x0020: // SPACE\n    case 0x003C: // LESS-THAN SIGN\n    case 0x0026: // AMPERSAND\n    case -1: // EOF\n      reconsume(c, character_reference_end_state);\n      break;\n    case 0x0023: // NUMBER SIGN\n      tempbuf.push(c);\n      tokenizer = numeric_character_reference_state;\n      break;\n    default:\n      reconsume(c, named_character_reference_state);\n      break;\n    }\n  }\n\n  function named_character_reference_state(c) {\n    NAMEDCHARREF.lastIndex = nextchar; // w/ lookahead no char has been consumed\n    var matched = NAMEDCHARREF.exec(chars);\n    if (!matched) throw new Error(\"should never happen\");\n    var name = matched[1];\n    if (!name) {\n      // If no match can be made, switch to the character reference end state\n      tokenizer = character_reference_end_state;\n      return;\n    }\n\n    // Consume the matched characters and append them to temporary buffer\n    nextchar += name.length;\n    pushAll(tempbuf, str2buf(name));\n\n    switch(return_state) {\n    case attribute_value_double_quoted_state:\n    case attribute_value_single_quoted_state:\n    case attribute_value_unquoted_state:\n      // If the character reference was consumed as part of an attribute...\n      if (name[name.length-1] !== ';') { // ...and the last char is not ;\n        if (/[=A-Za-z0-9]/.test(chars[nextchar])) {\n          tokenizer = character_reference_end_state;\n          return;\n        }\n      }\n      break;\n    default:\n      break;\n    }\n\n    beginTempBuf();\n    var rv = namedCharRefs[name];\n    if (typeof rv === 'number') {\n      tempbuf.push(rv);\n    } else {\n      pushAll(tempbuf, rv);\n    }\n    tokenizer = character_reference_end_state;\n  }\n  // We might need to pause tokenization until we have enough characters\n  // in the buffer for longest possible character reference.\n  named_character_reference_state.lookahead = -NAMEDCHARREF_MAXLEN;\n\n  function numeric_character_reference_state(c) {\n    character_reference_code = 0;\n    switch(c) {\n    case 0x0078: // x\n    case 0x0058: // X\n      tempbuf.push(c);\n      tokenizer = hexadecimal_character_reference_start_state;\n      break;\n    default:\n      reconsume(c, decimal_character_reference_start_state);\n      break;\n    }\n  }\n\n  function hexadecimal_character_reference_start_state(c) {\n    switch(c) {\n    case 0x0030: case 0x0031: case 0x0032: case 0x0033: case 0x0034:\n    case 0x0035: case 0x0036: case 0x0037: case 0x0038: case 0x0039: // [0-9]\n    case 0x0041: case 0x0042: case 0x0043: case 0x0044: case 0x0045:\n    case 0x0046: // [A-F]\n    case 0x0061: case 0x0062: case 0x0063: case 0x0064: case 0x0065:\n    case 0x0066: // [a-f]\n      reconsume(c, hexadecimal_character_reference_state);\n      break;\n    default:\n      reconsume(c, character_reference_end_state);\n      break;\n    }\n  }\n\n  function decimal_character_reference_start_state(c) {\n    switch(c) {\n    case 0x0030: case 0x0031: case 0x0032: case 0x0033: case 0x0034:\n    case 0x0035: case 0x0036: case 0x0037: case 0x0038: case 0x0039: // [0-9]\n      reconsume(c, decimal_character_reference_state);\n      break;\n    default:\n      reconsume(c, character_reference_end_state);\n      break;\n    }\n  }\n\n  function hexadecimal_character_reference_state(c) {\n    switch(c) {\n    case 0x0041: case 0x0042: case 0x0043: case 0x0044: case 0x0045:\n    case 0x0046: // [A-F]\n      character_reference_code *= 16;\n      character_reference_code += (c - 0x0037);\n      break;\n    case 0x0061: case 0x0062: case 0x0063: case 0x0064: case 0x0065:\n    case 0x0066: // [a-f]\n      character_reference_code *= 16;\n      character_reference_code += (c - 0x0057);\n      break;\n    case 0x0030: case 0x0031: case 0x0032: case 0x0033: case 0x0034:\n    case 0x0035: case 0x0036: case 0x0037: case 0x0038: case 0x0039: // [0-9]\n      character_reference_code *= 16;\n      character_reference_code += (c - 0x0030);\n      break;\n    case 0x003B: // SEMICOLON\n      tokenizer = numeric_character_reference_end_state;\n      break;\n    default:\n      reconsume(c, numeric_character_reference_end_state);\n      break;\n    }\n  }\n\n  function decimal_character_reference_state(c) {\n    switch(c) {\n    case 0x0030: case 0x0031: case 0x0032: case 0x0033: case 0x0034:\n    case 0x0035: case 0x0036: case 0x0037: case 0x0038: case 0x0039: // [0-9]\n      character_reference_code *= 10;\n      character_reference_code += (c - 0x0030);\n      break;\n    case 0x003B: // SEMICOLON\n      tokenizer = numeric_character_reference_end_state;\n      break;\n    default:\n      reconsume(c, numeric_character_reference_end_state);\n      break;\n    }\n  }\n\n  function numeric_character_reference_end_state(c) {\n    if (character_reference_code in numericCharRefReplacements) {\n      character_reference_code = numericCharRefReplacements[character_reference_code];\n    } else if (character_reference_code > 0x10FFFF || (character_reference_code >= 0xD800 && character_reference_code < 0xE000)) {\n      character_reference_code = 0xFFFD;\n    }\n\n    beginTempBuf();\n    if (character_reference_code <= 0xFFFF) {\n      tempbuf.push(character_reference_code);\n    } else {\n      character_reference_code = character_reference_code - 0x10000;\n      /* jshint bitwise: false */\n      tempbuf.push(0xD800 + (character_reference_code >> 10));\n      tempbuf.push(0xDC00 + (character_reference_code & 0x03FF));\n    }\n    reconsume(c, character_reference_end_state);\n  }\n\n  function character_reference_end_state(c) {\n    switch(return_state) {\n    case attribute_value_double_quoted_state:\n    case attribute_value_single_quoted_state:\n    case attribute_value_unquoted_state:\n      // append each character to the current attribute's value\n      attrvaluebuf += buf2str(tempbuf);\n      break;\n    default:\n      pushAll(textrun, tempbuf);\n      break;\n    }\n    reconsume(c, return_state);\n  }\n\n  /***\n   * The tree builder insertion modes\n   */\n\n  // 11.2.5.4.1 The \"initial\" insertion mode\n  function initial_mode(t, value, arg3, arg4) {\n    switch(t) {\n    case 1: // TEXT\n      value = value.replace(LEADINGWS, \"\"); // Ignore spaces\n      if (value.length === 0) return; // Are we done?\n      break; // Handle anything non-space text below\n    case 4: // COMMENT\n      doc._appendChild(doc.createComment(value));\n      return;\n    case 5: // DOCTYPE\n      var name = value;\n      var publicid = arg3;\n      var systemid = arg4;\n      // Use the constructor directly instead of\n      // implementation.createDocumentType because the create\n      // function throws errors on invalid characters, and\n      // we don't want the parser to throw them.\n      doc.appendChild(new DocumentType(doc, name, publicid, systemid));\n\n      // Note that there is no public API for setting quirks mode We can\n      // do this here because we have access to implementation details\n      if (force_quirks ||\n        name.toLowerCase() !== \"html\" ||\n        quirkyPublicIds.test(publicid) ||\n        (systemid && systemid.toLowerCase() === quirkySystemId) ||\n        (systemid === undefined &&\n         conditionallyQuirkyPublicIds.test(publicid)))\n        doc._quirks = true;\n      else if (limitedQuirkyPublicIds.test(publicid) ||\n           (systemid !== undefined &&\n            conditionallyQuirkyPublicIds.test(publicid)))\n        doc._limitedQuirks = true;\n      parser = before_html_mode;\n      return;\n    }\n\n    // tags or non-whitespace text\n    doc._quirks = true;\n    parser = before_html_mode;\n    parser(t,value,arg3,arg4);\n  }\n\n  // 11.2.5.4.2 The \"before html\" insertion mode\n  function before_html_mode(t,value,arg3,arg4) {\n    var elt;\n    switch(t) {\n    case 1: // TEXT\n      value = value.replace(LEADINGWS, \"\"); // Ignore spaces\n      if (value.length === 0) return; // Are we done?\n      break; // Handle anything non-space text below\n    case 5: // DOCTYPE\n      /* ignore the token */\n      return;\n    case 4: // COMMENT\n      doc._appendChild(doc.createComment(value));\n      return;\n    case 2: // TAG\n      if (value === \"html\") {\n        elt = createHTMLElt(doc, value, arg3);\n        stack.push(elt);\n        doc.appendChild(elt);\n        // XXX: handle application cache here\n        parser = before_head_mode;\n        return;\n      }\n      break;\n    case 3: // ENDTAG\n      switch(value) {\n      case \"html\":\n      case \"head\":\n      case \"body\":\n      case \"br\":\n        break;  // fall through on these\n      default:\n        return; // ignore most end tags\n      }\n    }\n\n    // Anything that didn't get handled above is handled like this:\n    elt = createHTMLElt(doc, \"html\", null);\n    stack.push(elt);\n    doc.appendChild(elt);\n    // XXX: handle application cache here\n    parser = before_head_mode;\n    parser(t,value,arg3,arg4);\n  }\n\n  // 11.2.5.4.3 The \"before head\" insertion mode\n  function before_head_mode(t,value,arg3,arg4) {\n    switch(t) {\n    case 1: // TEXT\n      value = value.replace(LEADINGWS, \"\");  // Ignore spaces\n      if (value.length === 0) return; // Are we done?\n      break;  // Handle anything non-space text below\n    case 5: // DOCTYPE\n      /* ignore the token */\n      return;\n    case 4: // COMMENT\n      insertComment(value);\n      return;\n    case 2: // TAG\n      switch(value) {\n      case \"html\":\n        in_body_mode(t,value,arg3,arg4);\n        return;\n      case \"head\":\n        var elt = insertHTMLElement(value, arg3);\n        head_element_pointer = elt;\n        parser = in_head_mode;\n        return;\n      }\n      break;\n    case 3: // ENDTAG\n      switch(value) {\n      case \"html\":\n      case \"head\":\n      case \"body\":\n      case \"br\":\n        break;\n      default:\n        return; // ignore most end tags\n      }\n    }\n\n    // If not handled explicitly above\n    before_head_mode(TAG, \"head\", null); // create a head tag\n    parser(t, value, arg3, arg4); // then try again with this token\n  }\n\n  function in_head_mode(t, value, arg3, arg4) {\n    switch(t) {\n    case 1: // TEXT\n      var ws = value.match(LEADINGWS);\n      if (ws) {\n        insertText(ws[0]);\n        value = value.substring(ws[0].length);\n      }\n      if (value.length === 0) return;\n      break; // Handle non-whitespace below\n    case 4: // COMMENT\n      insertComment(value);\n      return;\n    case 5: // DOCTYPE\n      return;\n    case 2: // TAG\n      switch(value) {\n      case \"html\":\n        in_body_mode(t, value, arg3, arg4);\n        return;\n      case \"meta\":\n        // XXX:\n        // May need to change the encoding based on this tag\n        /* falls through */\n      case \"base\":\n      case \"basefont\":\n      case \"bgsound\":\n      case \"link\":\n        insertHTMLElement(value, arg3);\n        stack.pop();\n        return;\n      case \"title\":\n        parseRCDATA(value, arg3);\n        return;\n      case \"noscript\":\n        if (!scripting_enabled) {\n          insertHTMLElement(value, arg3);\n          parser = in_head_noscript_mode;\n          return;\n        }\n        // Otherwise, if scripting is enabled...\n        /* falls through */\n      case \"noframes\":\n      case \"style\":\n        parseRawText(value,arg3);\n        return;\n      case \"script\":\n        insertElement(function(doc) {\n          var elt = createHTMLElt(doc, value, arg3);\n          elt._parser_inserted = true;\n          elt._force_async = false;\n          if (fragment) elt._already_started = true;\n          flushText();\n          return elt;\n        });\n        tokenizer = script_data_state;\n        originalInsertionMode = parser;\n        parser = text_mode;\n        return;\n      case \"template\":\n        insertHTMLElement(value, arg3);\n        afe.insertMarker();\n        frameset_ok = false;\n        parser = in_template_mode;\n        templateInsertionModes.push(parser);\n        return;\n      case \"head\":\n        return; // ignore it\n      }\n      break;\n    case 3: // ENDTAG\n      switch(value) {\n      case \"head\":\n        stack.pop();\n        parser = after_head_mode;\n        return;\n      case \"body\":\n      case \"html\":\n      case \"br\":\n        break; // handle these at the bottom of the function\n      case \"template\":\n        if (!stack.contains(\"template\")) {\n          return;\n        }\n        stack.generateImpliedEndTags(null, \"thorough\");\n        stack.popTag(\"template\");\n        afe.clearToMarker();\n        templateInsertionModes.pop();\n        resetInsertionMode();\n        return;\n      default:\n        // ignore any other end tag\n        return;\n      }\n      break;\n    }\n\n    // If not handled above\n    in_head_mode(ENDTAG, \"head\", null);   // synthetic </head>\n    parser(t, value, arg3, arg4);   // Then redo this one\n  }\n\n  // 13.2.5.4.5 The \"in head noscript\" insertion mode\n  function in_head_noscript_mode(t, value, arg3, arg4) {\n    switch(t) {\n    case 5: // DOCTYPE\n      return;\n    case 4: // COMMENT\n      in_head_mode(t, value);\n      return;\n    case 1: // TEXT\n      var ws = value.match(LEADINGWS);\n      if (ws) {\n        in_head_mode(t, ws[0]);\n        value = value.substring(ws[0].length);\n      }\n      if (value.length === 0) return; // no more text\n      break; // Handle non-whitespace below\n    case 2: // TAG\n      switch(value) {\n      case \"html\":\n        in_body_mode(t, value, arg3, arg4);\n        return;\n      case \"basefont\":\n      case \"bgsound\":\n      case \"link\":\n      case \"meta\":\n      case \"noframes\":\n      case \"style\":\n        in_head_mode(t, value, arg3);\n        return;\n      case \"head\":\n      case \"noscript\":\n        return;\n      }\n      break;\n    case 3: // ENDTAG\n      switch(value) {\n      case \"noscript\":\n        stack.pop();\n        parser = in_head_mode;\n        return;\n      case \"br\":\n        break;  // goes to the outer default\n      default:\n        return; // ignore other end tags\n      }\n      break;\n    }\n\n    // If not handled above\n    in_head_noscript_mode(ENDTAG, \"noscript\", null);\n    parser(t, value, arg3, arg4);\n  }\n\n  function after_head_mode(t, value, arg3, arg4) {\n    switch(t) {\n    case 1: // TEXT\n      var ws = value.match(LEADINGWS);\n      if (ws) {\n        insertText(ws[0]);\n        value = value.substring(ws[0].length);\n      }\n      if (value.length === 0) return;\n      break; // Handle non-whitespace below\n    case 4: // COMMENT\n      insertComment(value);\n      return;\n    case 5: // DOCTYPE\n      return;\n    case 2: // TAG\n      switch(value) {\n      case \"html\":\n        in_body_mode(t, value, arg3, arg4);\n        return;\n      case \"body\":\n        insertHTMLElement(value, arg3);\n        frameset_ok = false;\n        parser = in_body_mode;\n        return;\n      case \"frameset\":\n        insertHTMLElement(value, arg3);\n        parser = in_frameset_mode;\n        return;\n      case \"base\":\n      case \"basefont\":\n      case \"bgsound\":\n      case \"link\":\n      case \"meta\":\n      case \"noframes\":\n      case \"script\":\n      case \"style\":\n      case \"template\":\n      case \"title\":\n        stack.push(head_element_pointer);\n        in_head_mode(TAG, value, arg3);\n        stack.removeElement(head_element_pointer);\n        return;\n      case \"head\":\n        return;\n      }\n      break;\n    case 3: // ENDTAG\n      switch(value) {\n      case \"template\":\n        return in_head_mode(t, value, arg3, arg4);\n      case \"body\":\n      case \"html\":\n      case \"br\":\n        break;\n      default:\n        return;  // ignore any other end tag\n      }\n      break;\n    }\n\n    after_head_mode(TAG, \"body\", null);\n    frameset_ok = true;\n    parser(t, value, arg3, arg4);\n  }\n\n  // 13.2.5.4.7 The \"in body\" insertion mode\n  function in_body_mode(t,value,arg3,arg4) {\n    var body, i, node, elt;\n    switch(t) {\n    case 1: // TEXT\n      if (textIncludesNUL) {\n        value = value.replace(NULCHARS, \"\");\n        if (value.length === 0) return;\n      }\n      // If any non-space characters\n      if (frameset_ok && NONWS.test(value))\n        frameset_ok = false;\n      afereconstruct();\n      insertText(value);\n      return;\n    case 5: // DOCTYPE\n      return;\n    case 4: // COMMENT\n      insertComment(value);\n      return;\n    case -1: // EOF\n      if (templateInsertionModes.length) {\n        return in_template_mode(t);\n      }\n      stopParsing();\n      return;\n    case 2: // TAG\n      switch(value) {\n      case \"html\":\n        if (stack.contains(\"template\")) {\n          return;\n        }\n        transferAttributes(arg3, stack.elements[0]);\n        return;\n      case \"base\":\n      case \"basefont\":\n      case \"bgsound\":\n      case \"link\":\n      case \"meta\":\n      case \"noframes\":\n      case \"script\":\n      case \"style\":\n      case \"template\":\n      case \"title\":\n        in_head_mode(TAG, value, arg3);\n        return;\n      case \"body\":\n        body = stack.elements[1];\n        if (!body || !(body instanceof impl.HTMLBodyElement) ||\n            stack.contains(\"template\"))\n          return;\n        frameset_ok = false;\n        transferAttributes(arg3, body);\n        return;\n      case \"frameset\":\n        if (!frameset_ok) return;\n        body = stack.elements[1];\n        if (!body || !(body instanceof impl.HTMLBodyElement))\n          return;\n        if (body.parentNode) body.parentNode.removeChild(body);\n        while(!(stack.top instanceof impl.HTMLHtmlElement))\n          stack.pop();\n        insertHTMLElement(value, arg3);\n        parser = in_frameset_mode;\n        return;\n\n      case \"address\":\n      case \"article\":\n      case \"aside\":\n      case \"blockquote\":\n      case \"center\":\n      case \"details\":\n      case \"dialog\":\n      case \"dir\":\n      case \"div\":\n      case \"dl\":\n      case \"fieldset\":\n      case \"figcaption\":\n      case \"figure\":\n      case \"footer\":\n      case \"header\":\n      case \"hgroup\":\n      case \"main\":\n      case \"nav\":\n      case \"ol\":\n      case \"p\":\n      case \"section\":\n      case \"summary\":\n      case \"ul\":\n        if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n        insertHTMLElement(value, arg3);\n        return;\n\n      case \"menu\":\n        if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n        if (isA(stack.top, 'menuitem')) {\n          stack.pop();\n        }\n        insertHTMLElement(value, arg3);\n        return;\n\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n      case \"h4\":\n      case \"h5\":\n      case \"h6\":\n        if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n        if (stack.top instanceof impl.HTMLHeadingElement)\n          stack.pop();\n        insertHTMLElement(value, arg3);\n        return;\n\n      case \"pre\":\n      case \"listing\":\n        if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n        insertHTMLElement(value, arg3);\n        ignore_linefeed = true;\n        frameset_ok = false;\n        return;\n\n      case \"form\":\n        if (form_element_pointer && !stack.contains(\"template\")) return;\n        if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n        elt = insertHTMLElement(value, arg3);\n        if (!stack.contains(\"template\"))\n          form_element_pointer = elt;\n        return;\n\n      case \"li\":\n        frameset_ok = false;\n        for(i = stack.elements.length-1; i >= 0; i--) {\n          node = stack.elements[i];\n          if (node instanceof impl.HTMLLIElement) {\n            in_body_mode(ENDTAG, \"li\");\n            break;\n          }\n          if (isA(node, specialSet) && !isA(node, addressdivpSet))\n            break;\n        }\n        if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n        insertHTMLElement(value, arg3);\n        return;\n\n      case \"dd\":\n      case \"dt\":\n        frameset_ok = false;\n        for(i = stack.elements.length-1; i >= 0; i--) {\n          node = stack.elements[i];\n          if (isA(node, dddtSet)) {\n            in_body_mode(ENDTAG, node.localName);\n            break;\n          }\n          if (isA(node, specialSet) && !isA(node, addressdivpSet))\n            break;\n        }\n        if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n        insertHTMLElement(value, arg3);\n        return;\n\n      case \"plaintext\":\n        if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n        insertHTMLElement(value, arg3);\n        tokenizer = plaintext_state;\n        return;\n\n      case \"button\":\n        if (stack.inScope(\"button\")) {\n          in_body_mode(ENDTAG, \"button\");\n          parser(t, value, arg3, arg4);\n        }\n        else {\n          afereconstruct();\n          insertHTMLElement(value, arg3);\n          frameset_ok = false;\n        }\n        return;\n\n      case \"a\":\n        var activeElement = afe.findElementByTag(\"a\");\n        if (activeElement) {\n          in_body_mode(ENDTAG, value);\n          afe.remove(activeElement);\n          stack.removeElement(activeElement);\n        }\n        /* falls through */\n      case \"b\":\n      case \"big\":\n      case \"code\":\n      case \"em\":\n      case \"font\":\n      case \"i\":\n      case \"s\":\n      case \"small\":\n      case \"strike\":\n      case \"strong\":\n      case \"tt\":\n      case \"u\":\n        afereconstruct();\n        afe.push(insertHTMLElement(value,arg3), arg3);\n        return;\n\n      case \"nobr\":\n        afereconstruct();\n\n        if (stack.inScope(value)) {\n          in_body_mode(ENDTAG, value);\n          afereconstruct();\n        }\n        afe.push(insertHTMLElement(value,arg3), arg3);\n        return;\n\n      case \"applet\":\n      case \"marquee\":\n      case \"object\":\n        afereconstruct();\n        insertHTMLElement(value,arg3);\n        afe.insertMarker();\n        frameset_ok = false;\n        return;\n\n      case \"table\":\n        if (!doc._quirks && stack.inButtonScope(\"p\")) {\n          in_body_mode(ENDTAG, \"p\");\n        }\n        insertHTMLElement(value,arg3);\n        frameset_ok = false;\n        parser = in_table_mode;\n        return;\n\n      case \"area\":\n      case \"br\":\n      case \"embed\":\n      case \"img\":\n      case \"keygen\":\n      case \"wbr\":\n        afereconstruct();\n        insertHTMLElement(value,arg3);\n        stack.pop();\n        frameset_ok = false;\n        return;\n\n      case \"input\":\n        afereconstruct();\n        elt = insertHTMLElement(value,arg3);\n        stack.pop();\n        var type = elt.getAttribute(\"type\");\n        if (!type || type.toLowerCase() !== \"hidden\")\n          frameset_ok = false;\n        return;\n\n      case \"param\":\n      case \"source\":\n      case \"track\":\n        insertHTMLElement(value,arg3);\n        stack.pop();\n        return;\n\n      case \"hr\":\n        if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n        if (isA(stack.top, 'menuitem')) {\n          stack.pop();\n        }\n        insertHTMLElement(value,arg3);\n        stack.pop();\n        frameset_ok = false;\n        return;\n\n      case \"image\":\n        in_body_mode(TAG, \"img\", arg3, arg4);\n        return;\n\n      case \"textarea\":\n        insertHTMLElement(value,arg3);\n        ignore_linefeed = true;\n        frameset_ok = false;\n        tokenizer = rcdata_state;\n        originalInsertionMode = parser;\n        parser = text_mode;\n        return;\n\n      case \"xmp\":\n        if (stack.inButtonScope(\"p\")) in_body_mode(ENDTAG, \"p\");\n        afereconstruct();\n        frameset_ok = false;\n        parseRawText(value, arg3);\n        return;\n\n      case \"iframe\":\n        frameset_ok = false;\n        parseRawText(value, arg3);\n        return;\n\n      case \"noembed\":\n        parseRawText(value,arg3);\n        return;\n\n      case \"noscript\":\n        if (scripting_enabled) {\n          parseRawText(value,arg3);\n          return;\n        }\n        break;  // XXX Otherwise treat it as any other open tag?\n\n      case \"select\":\n        afereconstruct();\n        insertHTMLElement(value,arg3);\n        frameset_ok = false;\n        if (parser === in_table_mode ||\n          parser === in_caption_mode ||\n          parser === in_table_body_mode ||\n          parser === in_row_mode ||\n          parser === in_cell_mode)\n          parser = in_select_in_table_mode;\n        else\n          parser = in_select_mode;\n        return;\n\n      case \"optgroup\":\n      case \"option\":\n        if (stack.top instanceof impl.HTMLOptionElement) {\n          in_body_mode(ENDTAG, \"option\");\n        }\n        afereconstruct();\n        insertHTMLElement(value,arg3);\n        return;\n\n      case \"menuitem\":\n        if (isA(stack.top, 'menuitem')) {\n          stack.pop();\n        }\n        afereconstruct();\n        insertHTMLElement(value, arg3);\n        return;\n\n      case \"rb\":\n      case \"rtc\":\n        if (stack.inScope(\"ruby\")) {\n          stack.generateImpliedEndTags();\n        }\n        insertHTMLElement(value,arg3);\n        return;\n\n      case \"rp\":\n      case \"rt\":\n        if (stack.inScope(\"ruby\")) {\n          stack.generateImpliedEndTags(\"rtc\");\n        }\n        insertHTMLElement(value,arg3);\n        return;\n\n      case \"math\":\n        afereconstruct();\n        adjustMathMLAttributes(arg3);\n        adjustForeignAttributes(arg3);\n        insertForeignElement(value, arg3, NAMESPACE.MATHML);\n        if (arg4) // self-closing flag\n          stack.pop();\n        return;\n\n      case \"svg\":\n        afereconstruct();\n        adjustSVGAttributes(arg3);\n        adjustForeignAttributes(arg3);\n        insertForeignElement(value, arg3, NAMESPACE.SVG);\n        if (arg4) // self-closing flag\n          stack.pop();\n        return;\n\n      case \"caption\":\n      case \"col\":\n      case \"colgroup\":\n      case \"frame\":\n      case \"head\":\n      case \"tbody\":\n      case \"td\":\n      case \"tfoot\":\n      case \"th\":\n      case \"thead\":\n      case \"tr\":\n        // Ignore table tags if we're not in_table mode\n        return;\n      }\n\n      // Handle any other start tag here\n      // (and also noscript tags when scripting is disabled)\n      afereconstruct();\n      insertHTMLElement(value,arg3);\n      return;\n\n    case 3: // ENDTAG\n      switch(value) {\n      case \"template\":\n        in_head_mode(ENDTAG, value, arg3);\n        return;\n      case \"body\":\n        if (!stack.inScope(\"body\")) return;\n        parser = after_body_mode;\n        return;\n      case \"html\":\n        if (!stack.inScope(\"body\")) return;\n        parser = after_body_mode;\n        parser(t, value, arg3);\n        return;\n\n      case \"address\":\n      case \"article\":\n      case \"aside\":\n      case \"blockquote\":\n      case \"button\":\n      case \"center\":\n      case \"details\":\n      case \"dialog\":\n      case \"dir\":\n      case \"div\":\n      case \"dl\":\n      case \"fieldset\":\n      case \"figcaption\":\n      case \"figure\":\n      case \"footer\":\n      case \"header\":\n      case \"hgroup\":\n      case \"listing\":\n      case \"main\":\n      case \"menu\":\n      case \"nav\":\n      case \"ol\":\n      case \"pre\":\n      case \"section\":\n      case \"summary\":\n      case \"ul\":\n        // Ignore if there is not a matching open tag\n        if (!stack.inScope(value)) return;\n        stack.generateImpliedEndTags();\n        stack.popTag(value);\n        return;\n\n      case \"form\":\n        if (!stack.contains(\"template\")) {\n          var openform = form_element_pointer;\n          form_element_pointer = null;\n          if (!openform || !stack.elementInScope(openform)) return;\n          stack.generateImpliedEndTags();\n          stack.removeElement(openform);\n        } else {\n          if (!stack.inScope(\"form\")) return;\n          stack.generateImpliedEndTags();\n          stack.popTag(\"form\");\n        }\n        return;\n\n      case \"p\":\n        if (!stack.inButtonScope(value)) {\n          in_body_mode(TAG, value, null);\n          parser(t, value, arg3, arg4);\n        }\n        else {\n          stack.generateImpliedEndTags(value);\n          stack.popTag(value);\n        }\n        return;\n\n      case \"li\":\n        if (!stack.inListItemScope(value)) return;\n        stack.generateImpliedEndTags(value);\n        stack.popTag(value);\n        return;\n\n      case \"dd\":\n      case \"dt\":\n        if (!stack.inScope(value)) return;\n        stack.generateImpliedEndTags(value);\n        stack.popTag(value);\n        return;\n\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n      case \"h4\":\n      case \"h5\":\n      case \"h6\":\n        if (!stack.elementTypeInScope(impl.HTMLHeadingElement)) return;\n        stack.generateImpliedEndTags();\n        stack.popElementType(impl.HTMLHeadingElement);\n        return;\n\n      case \"sarcasm\":\n        // Take a deep breath, and then:\n        break;\n\n      case \"a\":\n      case \"b\":\n      case \"big\":\n      case \"code\":\n      case \"em\":\n      case \"font\":\n      case \"i\":\n      case \"nobr\":\n      case \"s\":\n      case \"small\":\n      case \"strike\":\n      case \"strong\":\n      case \"tt\":\n      case \"u\":\n        var result = adoptionAgency(value);\n        if (result) return;  // If we did something we're done\n        break;         // Go to the \"any other end tag\" case\n\n      case \"applet\":\n      case \"marquee\":\n      case \"object\":\n        if (!stack.inScope(value)) return;\n        stack.generateImpliedEndTags();\n        stack.popTag(value);\n        afe.clearToMarker();\n        return;\n\n      case \"br\":\n        in_body_mode(TAG, value, null);  // Turn </br> into <br>\n        return;\n      }\n\n      // Any other end tag goes here\n      for(i = stack.elements.length-1; i >= 0; i--) {\n        node = stack.elements[i];\n        if (isA(node, value)) {\n          stack.generateImpliedEndTags(value);\n          stack.popElement(node);\n          break;\n        }\n        else if (isA(node, specialSet)) {\n          return;\n        }\n      }\n\n      return;\n    }\n  }\n\n  function text_mode(t, value, arg3, arg4) {\n    switch(t) {\n    case 1: // TEXT\n      insertText(value);\n      return;\n    case -1: // EOF\n      if (stack.top instanceof impl.HTMLScriptElement)\n        stack.top._already_started = true;\n      stack.pop();\n      parser = originalInsertionMode;\n      parser(t);\n      return;\n    case 3: // ENDTAG\n      if (value === \"script\") {\n        handleScriptEnd();\n      }\n      else {\n        stack.pop();\n        parser = originalInsertionMode;\n      }\n      return;\n    default:\n      // We should never get any other token types\n      return;\n    }\n  }\n\n  function in_table_mode(t, value, arg3, arg4) {\n    function getTypeAttr(attrs) {\n      for(var i = 0, n = attrs.length; i < n; i++) {\n        if (attrs[i][0] === \"type\")\n          return attrs[i][1].toLowerCase();\n      }\n      return null;\n    }\n\n    switch(t) {\n    case 1: // TEXT\n      // XXX the text_integration_mode stuff is\n      // just a hack I made up\n      if (text_integration_mode) {\n        in_body_mode(t, value, arg3, arg4);\n        return;\n      }\n      else if (isA(stack.top, tablesectionrowSet)) {\n        pending_table_text = [];\n        originalInsertionMode = parser;\n        parser = in_table_text_mode;\n        parser(t, value, arg3, arg4);\n        return;\n      }\n      break;\n    case 4: // COMMENT\n      insertComment(value);\n      return;\n    case 5: // DOCTYPE\n      return;\n    case 2: // TAG\n      switch(value) {\n      case \"caption\":\n        stack.clearToContext(tableContextSet);\n        afe.insertMarker();\n        insertHTMLElement(value,arg3);\n        parser = in_caption_mode;\n        return;\n      case \"colgroup\":\n        stack.clearToContext(tableContextSet);\n        insertHTMLElement(value,arg3);\n        parser = in_column_group_mode;\n        return;\n      case \"col\":\n        in_table_mode(TAG, \"colgroup\", null);\n        parser(t, value, arg3, arg4);\n        return;\n      case \"tbody\":\n      case \"tfoot\":\n      case \"thead\":\n        stack.clearToContext(tableContextSet);\n        insertHTMLElement(value,arg3);\n        parser = in_table_body_mode;\n        return;\n      case \"td\":\n      case \"th\":\n      case \"tr\":\n        in_table_mode(TAG, \"tbody\", null);\n        parser(t, value, arg3, arg4);\n        return;\n\n      case \"table\":\n        if (!stack.inTableScope(value)) {\n          return; // Ignore the token\n        }\n        in_table_mode(ENDTAG, value);\n        parser(t, value, arg3, arg4);\n        return;\n\n      case \"style\":\n      case \"script\":\n      case \"template\":\n        in_head_mode(t, value, arg3, arg4);\n        return;\n\n      case \"input\":\n        var type = getTypeAttr(arg3);\n        if (type !== \"hidden\") break;  // to the anything else case\n        insertHTMLElement(value,arg3);\n        stack.pop();\n        return;\n\n      case \"form\":\n        if (form_element_pointer || stack.contains(\"template\")) return;\n        form_element_pointer = insertHTMLElement(value, arg3);\n        stack.popElement(form_element_pointer);\n        return;\n      }\n      break;\n    case 3: // ENDTAG\n      switch(value) {\n      case \"table\":\n        if (!stack.inTableScope(value)) return;\n        stack.popTag(value);\n        resetInsertionMode();\n        return;\n      case \"body\":\n      case \"caption\":\n      case \"col\":\n      case \"colgroup\":\n      case \"html\":\n      case \"tbody\":\n      case \"td\":\n      case \"tfoot\":\n      case \"th\":\n      case \"thead\":\n      case \"tr\":\n        return;\n      case \"template\":\n        in_head_mode(t, value, arg3, arg4);\n        return;\n      }\n\n      break;\n    case -1: // EOF\n      in_body_mode(t, value, arg3, arg4);\n      return;\n    }\n\n    // This is the anything else case\n    foster_parent_mode = true;\n    in_body_mode(t, value, arg3, arg4);\n    foster_parent_mode = false;\n  }\n\n  function in_table_text_mode(t, value, arg3, arg4) {\n    if (t === TEXT) {\n      if (textIncludesNUL) {\n        value = value.replace(NULCHARS, \"\");\n        if (value.length === 0) return;\n      }\n      pending_table_text.push(value);\n    }\n    else {\n      var s = pending_table_text.join(\"\");\n      pending_table_text.length = 0;\n      if (NONWS.test(s)) { // If any non-whitespace characters\n        // This must be the same code as the \"anything else\"\n        // case of the in_table mode above.\n        foster_parent_mode = true;\n        in_body_mode(TEXT, s);\n        foster_parent_mode = false;\n      }\n      else {\n        insertText(s);\n      }\n      parser = originalInsertionMode;\n      parser(t, value, arg3, arg4);\n    }\n  }\n\n\n  function in_caption_mode(t, value, arg3, arg4) {\n    function end_caption() {\n      if (!stack.inTableScope(\"caption\")) return false;\n      stack.generateImpliedEndTags();\n      stack.popTag(\"caption\");\n      afe.clearToMarker();\n      parser = in_table_mode;\n      return true;\n    }\n\n    switch(t) {\n    case 2: // TAG\n      switch(value) {\n      case \"caption\":\n      case \"col\":\n      case \"colgroup\":\n      case \"tbody\":\n      case \"td\":\n      case \"tfoot\":\n      case \"th\":\n      case \"thead\":\n      case \"tr\":\n        if (end_caption()) parser(t, value, arg3, arg4);\n        return;\n      }\n      break;\n    case 3: // ENDTAG\n      switch(value) {\n      case \"caption\":\n        end_caption();\n        return;\n      case \"table\":\n        if (end_caption()) parser(t, value, arg3, arg4);\n        return;\n      case \"body\":\n      case \"col\":\n      case \"colgroup\":\n      case \"html\":\n      case \"tbody\":\n      case \"td\":\n      case \"tfoot\":\n      case \"th\":\n      case \"thead\":\n      case \"tr\":\n        return;\n      }\n      break;\n    }\n\n    // The Anything Else case\n    in_body_mode(t, value, arg3, arg4);\n  }\n\n  function in_column_group_mode(t, value, arg3, arg4) {\n    switch(t) {\n    case 1: // TEXT\n      var ws = value.match(LEADINGWS);\n      if (ws) {\n        insertText(ws[0]);\n        value = value.substring(ws[0].length);\n      }\n      if (value.length === 0) return;\n      break; // Handle non-whitespace below\n\n    case 4: // COMMENT\n      insertComment(value);\n      return;\n    case 5: // DOCTYPE\n      return;\n    case 2: // TAG\n      switch(value) {\n      case \"html\":\n        in_body_mode(t, value, arg3, arg4);\n        return;\n      case \"col\":\n        insertHTMLElement(value, arg3);\n        stack.pop();\n        return;\n      case \"template\":\n        in_head_mode(t, value, arg3, arg4);\n        return;\n      }\n      break;\n    case 3: // ENDTAG\n      switch(value) {\n      case \"colgroup\":\n        if (!isA(stack.top, 'colgroup')) {\n          return; // Ignore the token.\n        }\n        stack.pop();\n        parser = in_table_mode;\n        return;\n      case \"col\":\n        return;\n      case \"template\":\n        in_head_mode(t, value, arg3, arg4);\n        return;\n      }\n      break;\n    case -1: // EOF\n      in_body_mode(t, value, arg3, arg4);\n      return;\n    }\n\n    // Anything else\n    if (!isA(stack.top, 'colgroup')) {\n      return; // Ignore the token.\n    }\n    in_column_group_mode(ENDTAG, \"colgroup\");\n    parser(t, value, arg3, arg4);\n  }\n\n  function in_table_body_mode(t, value, arg3, arg4) {\n    function endsect() {\n      if (!stack.inTableScope(\"tbody\") &&\n        !stack.inTableScope(\"thead\") &&\n        !stack.inTableScope(\"tfoot\"))\n        return;\n      stack.clearToContext(tableBodyContextSet);\n      in_table_body_mode(ENDTAG, stack.top.localName, null);\n      parser(t, value, arg3, arg4);\n    }\n\n    switch(t) {\n    case 2: // TAG\n      switch(value) {\n      case \"tr\":\n        stack.clearToContext(tableBodyContextSet);\n        insertHTMLElement(value, arg3);\n        parser = in_row_mode;\n        return;\n      case \"th\":\n      case \"td\":\n        in_table_body_mode(TAG, \"tr\", null);\n        parser(t, value, arg3, arg4);\n        return;\n      case \"caption\":\n      case \"col\":\n      case \"colgroup\":\n      case \"tbody\":\n      case \"tfoot\":\n      case \"thead\":\n        endsect();\n        return;\n      }\n      break;\n    case 3: // ENDTAG\n      switch(value) {\n      case \"table\":\n        endsect();\n        return;\n      case \"tbody\":\n      case \"tfoot\":\n      case \"thead\":\n        if (stack.inTableScope(value)) {\n          stack.clearToContext(tableBodyContextSet);\n          stack.pop();\n          parser = in_table_mode;\n        }\n        return;\n      case \"body\":\n      case \"caption\":\n      case \"col\":\n      case \"colgroup\":\n      case \"html\":\n      case \"td\":\n      case \"th\":\n      case \"tr\":\n        return;\n      }\n      break;\n    }\n\n    // Anything else:\n    in_table_mode(t, value, arg3, arg4);\n  }\n\n  function in_row_mode(t, value, arg3, arg4) {\n    function endrow() {\n      if (!stack.inTableScope(\"tr\")) return false;\n      stack.clearToContext(tableRowContextSet);\n      stack.pop();\n      parser = in_table_body_mode;\n      return true;\n    }\n\n    switch(t) {\n    case 2: // TAG\n      switch(value) {\n      case \"th\":\n      case \"td\":\n        stack.clearToContext(tableRowContextSet);\n        insertHTMLElement(value, arg3);\n        parser = in_cell_mode;\n        afe.insertMarker();\n        return;\n      case \"caption\":\n      case \"col\":\n      case \"colgroup\":\n      case \"tbody\":\n      case \"tfoot\":\n      case \"thead\":\n      case \"tr\":\n        if (endrow()) parser(t, value, arg3, arg4);\n        return;\n      }\n      break;\n    case 3: // ENDTAG\n      switch(value) {\n      case \"tr\":\n        endrow();\n        return;\n      case \"table\":\n        if (endrow()) parser(t, value, arg3, arg4);\n        return;\n      case \"tbody\":\n      case \"tfoot\":\n      case \"thead\":\n        if (stack.inTableScope(value)) {\n          if (endrow()) parser(t, value, arg3, arg4);\n        }\n        return;\n      case \"body\":\n      case \"caption\":\n      case \"col\":\n      case \"colgroup\":\n      case \"html\":\n      case \"td\":\n      case \"th\":\n        return;\n      }\n      break;\n    }\n\n    // anything else\n    in_table_mode(t, value, arg3, arg4);\n  }\n\n  function in_cell_mode(t, value, arg3, arg4) {\n    switch(t) {\n    case 2: // TAG\n      switch(value) {\n      case \"caption\":\n      case \"col\":\n      case \"colgroup\":\n      case \"tbody\":\n      case \"td\":\n      case \"tfoot\":\n      case \"th\":\n      case \"thead\":\n      case \"tr\":\n        if (stack.inTableScope(\"td\")) {\n          in_cell_mode(ENDTAG, \"td\");\n          parser(t, value, arg3, arg4);\n        }\n        else if (stack.inTableScope(\"th\")) {\n          in_cell_mode(ENDTAG, \"th\");\n          parser(t, value, arg3, arg4);\n        }\n        return;\n      }\n      break;\n    case 3: // ENDTAG\n      switch(value) {\n      case \"td\":\n      case \"th\":\n        if (!stack.inTableScope(value)) return;\n        stack.generateImpliedEndTags();\n        stack.popTag(value);\n        afe.clearToMarker();\n        parser = in_row_mode;\n        return;\n\n      case \"body\":\n      case \"caption\":\n      case \"col\":\n      case \"colgroup\":\n      case \"html\":\n        return;\n\n      case \"table\":\n      case \"tbody\":\n      case \"tfoot\":\n      case \"thead\":\n      case \"tr\":\n        if (!stack.inTableScope(value)) return;\n        in_cell_mode(ENDTAG, stack.inTableScope(\"td\") ? \"td\" : \"th\");\n        parser(t, value, arg3, arg4);\n        return;\n      }\n      break;\n    }\n\n    // anything else\n    in_body_mode(t, value, arg3, arg4);\n  }\n\n  function in_select_mode(t, value, arg3, arg4) {\n    switch(t) {\n    case 1: // TEXT\n      if (textIncludesNUL) {\n        value = value.replace(NULCHARS, \"\");\n        if (value.length === 0) return;\n      }\n      insertText(value);\n      return;\n    case 4: // COMMENT\n      insertComment(value);\n      return;\n    case 5: // DOCTYPE\n      return;\n    case -1: // EOF\n      in_body_mode(t, value, arg3, arg4);\n      return;\n    case 2: // TAG\n      switch(value) {\n      case \"html\":\n        in_body_mode(t, value, arg3, arg4);\n        return;\n      case \"option\":\n        if (stack.top instanceof impl.HTMLOptionElement)\n          in_select_mode(ENDTAG, value);\n        insertHTMLElement(value, arg3);\n        return;\n      case \"optgroup\":\n        if (stack.top instanceof impl.HTMLOptionElement)\n          in_select_mode(ENDTAG, \"option\");\n        if (stack.top instanceof impl.HTMLOptGroupElement)\n          in_select_mode(ENDTAG, value);\n        insertHTMLElement(value, arg3);\n        return;\n      case \"select\":\n        in_select_mode(ENDTAG, value); // treat it as a close tag\n        return;\n\n      case \"input\":\n      case \"keygen\":\n      case \"textarea\":\n        if (!stack.inSelectScope(\"select\")) return;\n        in_select_mode(ENDTAG, \"select\");\n        parser(t, value, arg3, arg4);\n        return;\n\n      case \"script\":\n      case \"template\":\n        in_head_mode(t, value, arg3, arg4);\n        return;\n      }\n      break;\n    case 3: // ENDTAG\n      switch(value) {\n      case \"optgroup\":\n        if (stack.top instanceof impl.HTMLOptionElement &&\n          stack.elements[stack.elements.length-2] instanceof\n          impl.HTMLOptGroupElement) {\n          in_select_mode(ENDTAG, \"option\");\n        }\n        if (stack.top instanceof impl.HTMLOptGroupElement)\n          stack.pop();\n\n        return;\n\n      case \"option\":\n        if (stack.top instanceof impl.HTMLOptionElement)\n          stack.pop();\n        return;\n\n      case \"select\":\n        if (!stack.inSelectScope(value)) return;\n        stack.popTag(value);\n        resetInsertionMode();\n        return;\n\n      case \"template\":\n        in_head_mode(t, value, arg3, arg4);\n        return;\n      }\n\n      break;\n    }\n\n    // anything else: just ignore the token\n  }\n\n  function in_select_in_table_mode(t, value, arg3, arg4) {\n    switch(value) {\n    case \"caption\":\n    case \"table\":\n    case \"tbody\":\n    case \"tfoot\":\n    case \"thead\":\n    case \"tr\":\n    case \"td\":\n    case \"th\":\n      switch(t) {\n      case 2: // TAG\n        in_select_in_table_mode(ENDTAG, \"select\");\n        parser(t, value, arg3, arg4);\n        return;\n      case 3: // ENDTAG\n        if (stack.inTableScope(value)) {\n          in_select_in_table_mode(ENDTAG, \"select\");\n          parser(t, value, arg3, arg4);\n        }\n        return;\n      }\n    }\n\n    // anything else\n    in_select_mode(t, value, arg3, arg4);\n  }\n\n  function in_template_mode(t, value, arg3, arg4) {\n    function switchModeAndReprocess(mode) {\n      parser = mode;\n      templateInsertionModes[templateInsertionModes.length-1] = parser;\n      parser(t, value, arg3, arg4);\n    }\n    switch(t) {\n    case 1: // TEXT\n    case 4: // COMMENT\n    case 5: // DOCTYPE\n      in_body_mode(t, value, arg3, arg4);\n      return;\n    case -1: // EOF\n      if (!stack.contains(\"template\")) {\n        stopParsing();\n      } else {\n        stack.popTag(\"template\");\n        afe.clearToMarker();\n        templateInsertionModes.pop();\n        resetInsertionMode();\n        parser(t, value, arg3, arg4);\n      }\n      return;\n    case 2: // TAG\n      switch(value) {\n      case \"base\":\n      case \"basefont\":\n      case \"bgsound\":\n      case \"link\":\n      case \"meta\":\n      case \"noframes\":\n      case \"script\":\n      case \"style\":\n      case \"template\":\n      case \"title\":\n        in_head_mode(t, value, arg3, arg4);\n        return;\n      case \"caption\":\n      case \"colgroup\":\n      case \"tbody\":\n      case \"tfoot\":\n      case \"thead\":\n        switchModeAndReprocess(in_table_mode);\n        return;\n      case \"col\":\n        switchModeAndReprocess(in_column_group_mode);\n        return;\n      case \"tr\":\n        switchModeAndReprocess(in_table_body_mode);\n        return;\n      case \"td\":\n      case \"th\":\n        switchModeAndReprocess(in_row_mode);\n        return;\n      }\n      switchModeAndReprocess(in_body_mode);\n      return;\n    case 3: // ENDTAG\n      switch(value) {\n      case \"template\":\n        in_head_mode(t, value, arg3, arg4);\n        return;\n      default:\n        return;\n      }\n    }\n  }\n\n  function after_body_mode(t, value, arg3, arg4) {\n    switch(t) {\n    case 1: // TEXT\n      // If any non-space chars, handle below\n      if (NONWS.test(value)) break;\n      in_body_mode(t, value);\n      return;\n    case 4: // COMMENT\n      // Append it to the <html> element\n      stack.elements[0]._appendChild(doc.createComment(value));\n      return;\n    case 5: // DOCTYPE\n      return;\n    case -1: // EOF\n      stopParsing();\n      return;\n    case 2: // TAG\n      if (value === \"html\") {\n        in_body_mode(t, value, arg3, arg4);\n        return;\n      }\n      break; // for any other tags\n    case 3: // ENDTAG\n      if (value === \"html\") {\n        if (fragment) return;\n        parser = after_after_body_mode;\n        return;\n      }\n      break; // for any other tags\n    }\n\n    // anything else\n    parser = in_body_mode;\n    parser(t, value, arg3, arg4);\n  }\n\n  function in_frameset_mode(t, value, arg3, arg4) {\n    switch(t) {\n    case 1: // TEXT\n      // Ignore any non-space characters\n      value = value.replace(ALLNONWS, \"\");\n      if (value.length > 0) insertText(value);\n      return;\n    case 4: // COMMENT\n      insertComment(value);\n      return;\n    case 5: // DOCTYPE\n      return;\n    case -1: // EOF\n      stopParsing();\n      return;\n    case 2: // TAG\n      switch(value) {\n      case \"html\":\n        in_body_mode(t, value, arg3, arg4);\n        return;\n      case \"frameset\":\n        insertHTMLElement(value, arg3);\n        return;\n      case \"frame\":\n        insertHTMLElement(value, arg3);\n        stack.pop();\n        return;\n      case \"noframes\":\n        in_head_mode(t, value, arg3, arg4);\n        return;\n      }\n      break;\n    case 3: // ENDTAG\n      if (value === \"frameset\") {\n        if (fragment && stack.top instanceof impl.HTMLHtmlElement)\n          return;\n        stack.pop();\n        if (!fragment &&\n          !(stack.top instanceof impl.HTMLFrameSetElement))\n          parser = after_frameset_mode;\n        return;\n      }\n      break;\n    }\n\n    // ignore anything else\n  }\n\n  function after_frameset_mode(t, value, arg3, arg4) {\n    switch(t) {\n    case 1: // TEXT\n      // Ignore any non-space characters\n      value = value.replace(ALLNONWS, \"\");\n      if (value.length > 0) insertText(value);\n      return;\n    case 4: // COMMENT\n      insertComment(value);\n      return;\n    case 5: // DOCTYPE\n      return;\n    case -1: // EOF\n      stopParsing();\n      return;\n    case 2: // TAG\n      switch(value) {\n      case \"html\":\n        in_body_mode(t, value, arg3, arg4);\n        return;\n      case \"noframes\":\n        in_head_mode(t, value, arg3, arg4);\n        return;\n      }\n      break;\n    case 3: // ENDTAG\n      if (value === \"html\") {\n        parser = after_after_frameset_mode;\n        return;\n      }\n      break;\n    }\n\n    // ignore anything else\n  }\n\n  function after_after_body_mode(t, value, arg3, arg4) {\n    switch(t) {\n    case 1: // TEXT\n      // If any non-space chars, handle below\n      if (NONWS.test(value)) break;\n      in_body_mode(t, value, arg3, arg4);\n      return;\n    case 4: // COMMENT\n      doc._appendChild(doc.createComment(value));\n      return;\n    case 5: // DOCTYPE\n      in_body_mode(t, value, arg3, arg4);\n      return;\n    case -1: // EOF\n      stopParsing();\n      return;\n    case 2: // TAG\n      if (value === \"html\") {\n        in_body_mode(t, value, arg3, arg4);\n        return;\n      }\n      break;\n    }\n\n    // anything else\n    parser = in_body_mode;\n    parser(t, value, arg3, arg4);\n  }\n\n  function after_after_frameset_mode(t, value, arg3, arg4) {\n    switch(t) {\n    case 1: // TEXT\n      // Ignore any non-space characters\n      value = value.replace(ALLNONWS, \"\");\n      if (value.length > 0)\n        in_body_mode(t, value, arg3, arg4);\n      return;\n    case 4: // COMMENT\n      doc._appendChild(doc.createComment(value));\n      return;\n    case 5: // DOCTYPE\n      in_body_mode(t, value, arg3, arg4);\n      return;\n    case -1: // EOF\n      stopParsing();\n      return;\n    case 2: // TAG\n      switch(value) {\n      case \"html\":\n        in_body_mode(t, value, arg3, arg4);\n        return;\n      case \"noframes\":\n        in_head_mode(t, value, arg3, arg4);\n        return;\n      }\n      break;\n    }\n\n    // ignore anything else\n  }\n\n\n  // 13.2.5.5 The rules for parsing tokens in foreign content\n  //\n  // This is like one of the insertion modes above, but is\n  // invoked somewhat differently when the current token is not HTML.\n  // See the insertToken() function.\n  function insertForeignToken(t, value, arg3, arg4) {\n    // A <font> tag is an HTML font tag if it has a color, font, or size\n    // attribute.  Otherwise we assume it is foreign content\n    function isHTMLFont(attrs) {\n      for(var i = 0, n = attrs.length; i < n; i++) {\n        switch(attrs[i][0]) {\n        case \"color\":\n        case \"face\":\n        case \"size\":\n          return true;\n        }\n      }\n      return false;\n    }\n\n    var current;\n\n    switch(t) {\n    case 1: // TEXT\n      // If any non-space, non-nul characters\n      if (frameset_ok && NONWSNONNUL.test(value))\n        frameset_ok = false;\n      if (textIncludesNUL) {\n        value = value.replace(NULCHARS, \"\\uFFFD\");\n      }\n      insertText(value);\n      return;\n    case 4: // COMMENT\n      insertComment(value);\n      return;\n    case 5: // DOCTYPE\n      // ignore it\n      return;\n    case 2: // TAG\n      switch(value) {\n      case \"font\":\n        if (!isHTMLFont(arg3)) break;\n        /* falls through */\n      case \"b\":\n      case \"big\":\n      case \"blockquote\":\n      case \"body\":\n      case \"br\":\n      case \"center\":\n      case \"code\":\n      case \"dd\":\n      case \"div\":\n      case \"dl\":\n      case \"dt\":\n      case \"em\":\n      case \"embed\":\n      case \"h1\":\n      case \"h2\":\n      case \"h3\":\n      case \"h4\":\n      case \"h5\":\n      case \"h6\":\n      case \"head\":\n      case \"hr\":\n      case \"i\":\n      case \"img\":\n      case \"li\":\n      case \"listing\":\n      case \"menu\":\n      case \"meta\":\n      case \"nobr\":\n      case \"ol\":\n      case \"p\":\n      case \"pre\":\n      case \"ruby\":\n      case \"s\":\n      case \"small\":\n      case \"span\":\n      case \"strong\":\n      case \"strike\":\n      case \"sub\":\n      case \"sup\":\n      case \"table\":\n      case \"tt\":\n      case \"u\":\n      case \"ul\":\n      case \"var\":\n        if (fragment) {\n          break;\n        }\n        do {\n          stack.pop();\n          current = stack.top;\n        } while(current.namespaceURI !== NAMESPACE.HTML &&\n            !isMathmlTextIntegrationPoint(current) &&\n            !isHTMLIntegrationPoint(current));\n\n        insertToken(t, value, arg3, arg4);  // reprocess\n        return;\n      }\n\n      // Any other start tag case goes here\n      current = (stack.elements.length===1 && fragment) ? fragmentContext :\n        stack.top;\n      if (current.namespaceURI === NAMESPACE.MATHML) {\n        adjustMathMLAttributes(arg3);\n      }\n      else if (current.namespaceURI === NAMESPACE.SVG) {\n        value = adjustSVGTagName(value);\n        adjustSVGAttributes(arg3);\n      }\n      adjustForeignAttributes(arg3);\n\n      insertForeignElement(value, arg3, current.namespaceURI);\n      if (arg4) { // the self-closing flag\n        if (value === 'script' && current.namespaceURI === NAMESPACE.SVG) {\n          // XXX deal with SVG scripts here\n        }\n        stack.pop();\n      }\n      return;\n\n    case 3: // ENDTAG\n      current = stack.top;\n      if (value === \"script\" &&\n        current.namespaceURI === NAMESPACE.SVG &&\n        current.localName === \"script\") {\n\n        stack.pop();\n\n        // XXX\n        // Deal with SVG scripts here\n      }\n      else {\n        // The any other end tag case\n        var i = stack.elements.length-1;\n        var node = stack.elements[i];\n        for(;;) {\n          if (node.localName.toLowerCase() === value) {\n            stack.popElement(node);\n            break;\n          }\n          node = stack.elements[--i];\n          // If non-html, keep looping\n          if (node.namespaceURI !== NAMESPACE.HTML)\n            continue;\n          // Otherwise process the end tag as html\n          parser(t, value, arg3, arg4);\n          break;\n        }\n      }\n      return;\n    }\n  }\n\n  /***\n   * Finally, this is the end of the HTMLParser() factory function.\n   * It returns the htmlparser object with the append() and end() methods.\n   */\n\n  // Sneak another method into the htmlparser object to allow us to run\n  // tokenizer tests.  This can be commented out in production code.\n  // This is a hook for testing the tokenizer. It has to be here\n  // because the tokenizer details are all hidden away within the closure.\n  // It should return an array of tokens generated while parsing the\n  // input string.\n  htmlparser.testTokenizer = function(input, initialState, lastStartTag, charbychar) {\n    var tokens = [];\n\n    switch(initialState) {\n    case \"PCDATA state\":\n      tokenizer = data_state;\n      break;\n    case \"RCDATA state\":\n      tokenizer = rcdata_state;\n      break;\n    case \"RAWTEXT state\":\n      tokenizer = rawtext_state;\n      break;\n    case \"PLAINTEXT state\":\n      tokenizer = plaintext_state;\n      break;\n    }\n\n    if (lastStartTag) {\n      lasttagname = lastStartTag;\n    }\n\n    insertToken = function(t, value, arg3, arg4) {\n      flushText();\n      switch(t) {\n      case 1: // TEXT\n        if (tokens.length > 0 &&\n          tokens[tokens.length-1][0] === \"Character\") {\n          tokens[tokens.length-1][1] += value;\n        }\n        else tokens.push([\"Character\", value]);\n        break;\n      case 4: // COMMENT\n        tokens.push([\"Comment\", value]);\n        break;\n      case 5: // DOCTYPE\n        tokens.push([\"DOCTYPE\", value,\n               arg3 === undefined ? null : arg3,\n               arg4 === undefined ? null : arg4,\n               !force_quirks]);\n        break;\n      case 2: // TAG\n        var attrs = Object.create(null);\n        for(var i = 0; i < arg3.length; i++) {\n          // XXX: does attribute order matter?\n          var a = arg3[i];\n          if (a.length === 1) {\n            attrs[a[0]] = \"\";\n          }\n          else {\n            attrs[a[0]] = a[1];\n          }\n        }\n        var token = [\"StartTag\", value, attrs];\n        if (arg4) token.push(true);\n        tokens.push(token);\n        break;\n      case 3: // ENDTAG\n        tokens.push([\"EndTag\", value]);\n        break;\n      case -1: // EOF\n        break;\n      }\n    };\n\n    if (!charbychar) {\n      this.parse(input, true);\n    }\n    else {\n      for(var i = 0; i < input.length; i++) {\n        this.parse(input[i]);\n      }\n      this.parse(\"\", true);\n    }\n    return tokens;\n  };\n\n  // Return the parser object from the HTMLParser() factory function\n  return htmlparser;\n}\n","\"use strict\";\nmodule.exports = Leaf;\n\nvar Node = require('./Node');\nvar NodeList = require('./NodeList');\nvar utils = require('./utils');\nvar HierarchyRequestError = utils.HierarchyRequestError;\nvar NotFoundError = utils.NotFoundError;\n\n// This class defines common functionality for node subtypes that\n// can never have children\nfunction Leaf() {\n  Node.call(this);\n}\n\nLeaf.prototype = Object.create(Node.prototype, {\n  hasChildNodes: { value: function() { return false; }},\n  firstChild: { value: null },\n  lastChild: { value: null },\n  insertBefore: { value: function(node, child) {\n    if (!node.nodeType) throw new TypeError('not a node');\n    HierarchyRequestError();\n  }},\n  replaceChild: { value: function(node, child) {\n    if (!node.nodeType) throw new TypeError('not a node');\n    HierarchyRequestError();\n  }},\n  removeChild: { value: function(node) {\n    if (!node.nodeType) throw new TypeError('not a node');\n    NotFoundError();\n  }},\n  removeChildren: { value: function() { /* no op */ }},\n  childNodes: { get: function() {\n    if (!this._childNodes) this._childNodes = new NodeList();\n    return this._childNodes;\n  }}\n});\n","\"use strict\";\nvar utils = require('./utils');\n\nvar LinkedList = module.exports = {\n    // basic validity tests on a circular linked list a\n    valid: function(a) {\n        utils.assert(a, \"list falsy\");\n        utils.assert(a._previousSibling, \"previous falsy\");\n        utils.assert(a._nextSibling, \"next falsy\");\n        // xxx check that list is actually circular\n        return true;\n    },\n    // insert a before b\n    insertBefore: function(a, b) {\n        utils.assert(LinkedList.valid(a) && LinkedList.valid(b));\n        var a_first = a, a_last = a._previousSibling;\n        var b_first = b, b_last = b._previousSibling;\n        a_first._previousSibling = b_last;\n        a_last._nextSibling = b_first;\n        b_last._nextSibling = a_first;\n        b_first._previousSibling = a_last;\n        utils.assert(LinkedList.valid(a) && LinkedList.valid(b));\n    },\n    // replace a single node a with a list b (which could be null)\n    replace: function(a, b) {\n        utils.assert(LinkedList.valid(a) && (b===null || LinkedList.valid(b)));\n        if (b!==null) {\n            LinkedList.insertBefore(b, a);\n        }\n        LinkedList.remove(a);\n        utils.assert(LinkedList.valid(a) && (b===null || LinkedList.valid(b)));\n    },\n    // remove single node a from its list\n    remove: function(a) {\n        utils.assert(LinkedList.valid(a));\n        var prev = a._previousSibling;\n        if (prev === a) { return; }\n        var next = a._nextSibling;\n        prev._nextSibling = next;\n        next._previousSibling = prev;\n        a._previousSibling = a._nextSibling = a;\n        utils.assert(LinkedList.valid(a));\n    }\n};\n","\"use strict\";\nvar URL = require('./URL');\nvar URLUtils = require('./URLUtils');\n\nmodule.exports = Location;\n\nfunction Location(window, href) {\n  this._window = window;\n  this._href = href;\n}\n\nLocation.prototype = Object.create(URLUtils.prototype, {\n  constructor: { value: Location },\n\n  // Special behavior when href is set\n  href: {\n    get: function() { return this._href; },\n    set: function(v) { this.assign(v); }\n  },\n\n  assign: { value: function(url) {\n    // Resolve the new url against the current one\n    // XXX:\n    // This is not actually correct. It should be resolved against\n    // the URL of the document of the script. For now, though, I only\n    // support a single window and there is only one base url.\n    // So this is good enough for now.\n    var current = new URL(this._href);\n    var newurl = current.resolve(url);\n\n    // Save the new url\n    this._href = newurl;\n\n    // Start loading the new document!\n    // XXX\n    // This is just something hacked together.\n    // The real algorithm is: http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html#navigate\n  }},\n\n  replace: { value: function(url) {\n    // XXX\n    // Since we aren't tracking history yet, replace is the same as assign\n    this.assign(url);\n  }},\n\n  reload: { value: function() {\n    // XXX:\n    // Actually, the spec is a lot more complicated than this\n    this.assign(this.href);\n  }},\n\n  toString: { value: function() {\n    return this.href;\n  }}\n\n});\n","\"use strict\";\nvar UIEvent = require('./UIEvent');\n\nmodule.exports = MouseEvent;\n\nfunction MouseEvent() {\n  // Just use the superclass constructor to initialize\n  UIEvent.call(this);\n\n  this.screenX = this.screenY = this.clientX = this.clientY = 0;\n  this.ctrlKey = this.altKey = this.shiftKey = this.metaKey = false;\n  this.button = 0;\n  this.buttons = 1;\n  this.relatedTarget = null;\n}\nMouseEvent.prototype = Object.create(UIEvent.prototype, {\n  constructor: { value: MouseEvent },\n  initMouseEvent: { value: function(type, bubbles, cancelable,\n    view, detail,\n    screenX, screenY, clientX, clientY,\n    ctrlKey, altKey, shiftKey, metaKey,\n    button, relatedTarget) {\n\n    this.initEvent(type, bubbles, cancelable, view, detail);\n    this.screenX = screenX;\n    this.screenY = screenY;\n    this.clientX = clientX;\n    this.clientY = clientY;\n    this.ctrlKey = ctrlKey;\n    this.altKey = altKey;\n    this.shiftKey = shiftKey;\n    this.metaKey = metaKey;\n    this.button = button;\n    switch(button) {\n    case 0: this.buttons = 1; break;\n    case 1: this.buttons = 4; break;\n    case 2: this.buttons = 2; break;\n    default: this.buttons = 0; break;\n    }\n    this.relatedTarget = relatedTarget;\n  }},\n\n  getModifierState: { value: function(key) {\n    switch(key) {\n    case \"Alt\": return this.altKey;\n    case \"Control\": return this.ctrlKey;\n    case \"Shift\": return this.shiftKey;\n    case \"Meta\": return this.metaKey;\n    default: return false;\n    }\n  }}\n});\n","\"use strict\";\nmodule.exports = {\n  VALUE: 1, // The value of a Text, Comment or PI node changed\n  ATTR: 2, // A new attribute was added or an attribute value and/or prefix changed\n  REMOVE_ATTR: 3, // An attribute was removed\n  REMOVE: 4, // A node was removed\n  MOVE: 5, // A node was moved\n  INSERT: 6 // A node (or a subtree of nodes) was inserted\n};","\"use strict\";\nmodule.exports = NamedNodeMap;\n\nvar utils = require('./utils');\n\n/* This is a hacky implementation of NamedNodeMap, intended primarily to\n * satisfy clients (like dompurify and the web-platform-tests) which check\n * to ensure that Node#attributes instanceof NamedNodeMap. */\n\nfunction NamedNodeMap(element) {\n  this.element = element;\n}\nObject.defineProperties(NamedNodeMap.prototype, {\n  length: { get: utils.shouldOverride },\n  item: { value: utils.shouldOverride },\n\n  getNamedItem: { value: function getNamedItem(qualifiedName) {\n    return this.element.getAttributeNode(qualifiedName);\n  } },\n  getNamedItemNS: { value: function getNamedItemNS(namespace, localName) {\n    return this.element.getAttributeNodeNS(namespace, localName);\n  } },\n  setNamedItem: { value: utils.nyi },\n  setNamedItemNS: { value: utils.nyi },\n  removeNamedItem: { value: function removeNamedItem(qualifiedName) {\n    var attr = this.element.getAttributeNode(qualifiedName);\n    if (attr) {\n      this.element.removeAttribute(qualifiedName);\n      return attr;\n    }\n    utils.NotFoundError();\n  } },\n  removeNamedItemNS: { value: function removeNamedItemNS(ns, lname) {\n    var attr = this.element.getAttributeNodeNS(ns, lname);\n    if (attr) {\n      this.element.removeAttributeNS(ns, lname);\n      return attr;\n    }\n    utils.NotFoundError();\n  } },\n});\n","\"use strict\";\n\n// https://html.spec.whatwg.org/multipage/webappapis.html#navigatorid\nvar NavigatorID = Object.create(null, {\n  appCodeName: { value: \"Mozilla\" },\n  appName: { value: \"Netscape\" },\n  appVersion: { value: \"4.0\" },\n  platform: { value: \"\" },\n  product: { value: \"Gecko\" },\n  productSub: { value: \"20100101\" },\n  userAgent: { value: \"\" },\n  vendor: { value: \"\" },\n  vendorSub: { value: \"\" },\n  taintEnabled: { value: function() { return false; } }\n});\n\nmodule.exports = NavigatorID;\n","\"use strict\";\nmodule.exports = Node;\n\nvar EventTarget = require('./EventTarget');\nvar LinkedList = require('./LinkedList');\nvar NodeUtils = require('./NodeUtils');\nvar utils = require('./utils');\n\n// All nodes have a nodeType and an ownerDocument.\n// Once inserted, they also have a parentNode.\n// This is an abstract class; all nodes in a document are instances\n// of a subtype, so all the properties are defined by more specific\n// constructors.\nfunction Node() {\n  EventTarget.call(this);\n  this.parentNode = null;\n  this._nextSibling = this._previousSibling = this;\n  this._index = undefined;\n}\n\nvar ELEMENT_NODE                = Node.ELEMENT_NODE = 1;\nvar ATTRIBUTE_NODE              = Node.ATTRIBUTE_NODE = 2;\nvar TEXT_NODE                   = Node.TEXT_NODE = 3;\nvar CDATA_SECTION_NODE          = Node.CDATA_SECTION_NODE = 4;\nvar ENTITY_REFERENCE_NODE       = Node.ENTITY_REFERENCE_NODE = 5;\nvar ENTITY_NODE                 = Node.ENTITY_NODE = 6;\nvar PROCESSING_INSTRUCTION_NODE = Node.PROCESSING_INSTRUCTION_NODE = 7;\nvar COMMENT_NODE                = Node.COMMENT_NODE = 8;\nvar DOCUMENT_NODE               = Node.DOCUMENT_NODE = 9;\nvar DOCUMENT_TYPE_NODE          = Node.DOCUMENT_TYPE_NODE = 10;\nvar DOCUMENT_FRAGMENT_NODE      = Node.DOCUMENT_FRAGMENT_NODE = 11;\nvar NOTATION_NODE               = Node.NOTATION_NODE = 12;\n\nvar DOCUMENT_POSITION_DISCONNECTED            = Node.DOCUMENT_POSITION_DISCONNECTED = 0x01;\nvar DOCUMENT_POSITION_PRECEDING               = Node.DOCUMENT_POSITION_PRECEDING = 0x02;\nvar DOCUMENT_POSITION_FOLLOWING               = Node.DOCUMENT_POSITION_FOLLOWING = 0x04;\nvar DOCUMENT_POSITION_CONTAINS                = Node.DOCUMENT_POSITION_CONTAINS = 0x08;\nvar DOCUMENT_POSITION_CONTAINED_BY            = Node.DOCUMENT_POSITION_CONTAINED_BY = 0x10;\nvar DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;\n\nNode.prototype = Object.create(EventTarget.prototype, {\n\n  // Node that are not inserted into the tree inherit a null parent\n\n  // XXX: the baseURI attribute is defined by dom core, but\n  // a correct implementation of it requires HTML features, so\n  // we'll come back to this later.\n  baseURI: { get: utils.nyi },\n\n  parentElement: { get: function() {\n    return (this.parentNode && this.parentNode.nodeType===ELEMENT_NODE) ? this.parentNode : null;\n  }},\n\n  hasChildNodes: { value: utils.shouldOverride },\n\n  firstChild: { get: utils.shouldOverride },\n\n  lastChild: { get: utils.shouldOverride },\n\n  previousSibling: { get: function() {\n    var parent = this.parentNode;\n    if (!parent) return null;\n    if (this === parent.firstChild) return null;\n    return this._previousSibling;\n  }},\n\n  nextSibling: { get: function() {\n    var parent = this.parentNode, next = this._nextSibling;\n    if (!parent) return null;\n    if (next === parent.firstChild) return null;\n    return next;\n  }},\n\n  textContent: {\n    // Should override for DocumentFragment/Element/Attr/Text/PI/Comment\n    get: function() { return null; },\n    set: function(v) { /* do nothing */ },\n  },\n\n  _countChildrenOfType: { value: function(type) {\n    var sum = 0;\n    for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {\n      if (kid.nodeType === type) sum++;\n    }\n    return sum;\n  }},\n\n  _ensureInsertValid: { value: function _ensureInsertValid(node, child, isPreinsert) {\n    var parent = this, i, kid;\n    if (!node.nodeType) throw new TypeError('not a node');\n    // 1. If parent is not a Document, DocumentFragment, or Element\n    // node, throw a HierarchyRequestError.\n    switch (parent.nodeType) {\n    case DOCUMENT_NODE:\n    case DOCUMENT_FRAGMENT_NODE:\n    case ELEMENT_NODE:\n      break;\n    default: utils.HierarchyRequestError();\n    }\n    // 2. If node is a host-including inclusive ancestor of parent,\n    // throw a HierarchyRequestError.\n    if (node.isAncestor(parent)) utils.HierarchyRequestError();\n    // 3. If child is not null and its parent is not parent, then\n    // throw a NotFoundError. (replaceChild omits the 'child is not null'\n    // and throws a TypeError here if child is null.)\n    if (child !== null || !isPreinsert) {\n      if (child.parentNode !== parent) utils.NotFoundError();\n    }\n    // 4. If node is not a DocumentFragment, DocumentType, Element,\n    // Text, ProcessingInstruction, or Comment node, throw a\n    // HierarchyRequestError.\n    switch (node.nodeType) {\n    case DOCUMENT_FRAGMENT_NODE:\n    case DOCUMENT_TYPE_NODE:\n    case ELEMENT_NODE:\n    case TEXT_NODE:\n    case PROCESSING_INSTRUCTION_NODE:\n    case COMMENT_NODE:\n      break;\n    default: utils.HierarchyRequestError();\n    }\n    // 5. If either node is a Text node and parent is a document, or\n    // node is a doctype and parent is not a document, throw a\n    // HierarchyRequestError.\n    // 6. If parent is a document, and any of the statements below, switched\n    // on node, are true, throw a HierarchyRequestError.\n    if (parent.nodeType === DOCUMENT_NODE) {\n      switch (node.nodeType) {\n      case TEXT_NODE:\n        utils.HierarchyRequestError();\n        break;\n      case DOCUMENT_FRAGMENT_NODE:\n        // 6a1. If node has more than one element child or has a Text\n        // node child.\n        if (node._countChildrenOfType(TEXT_NODE) > 0)\n          utils.HierarchyRequestError();\n        switch (node._countChildrenOfType(ELEMENT_NODE)) {\n        case 0:\n          break;\n        case 1:\n          // 6a2. Otherwise, if node has one element child and either\n          // parent has an element child, child is a doctype, or child\n          // is not null and a doctype is following child. [preinsert]\n          // 6a2. Otherwise, if node has one element child and either\n          // parent has an element child that is not child or a\n          // doctype is following child. [replaceWith]\n          if (child !== null /* always true here for replaceWith */) {\n            if (isPreinsert && child.nodeType === DOCUMENT_TYPE_NODE)\n              utils.HierarchyRequestError();\n            for (kid = child.nextSibling; kid !== null; kid = kid.nextSibling) {\n              if (kid.nodeType === DOCUMENT_TYPE_NODE)\n                utils.HierarchyRequestError();\n            }\n          }\n          i = parent._countChildrenOfType(ELEMENT_NODE);\n          if (isPreinsert) {\n            // \"parent has an element child\"\n            if (i > 0)\n              utils.HierarchyRequestError();\n          } else {\n            // \"parent has an element child that is not child\"\n            if (i > 1 || (i === 1 && child.nodeType !== ELEMENT_NODE))\n              utils.HierarchyRequestError();\n          }\n          break;\n        default: // 6a1, continued. (more than one Element child)\n          utils.HierarchyRequestError();\n        }\n        break;\n      case ELEMENT_NODE:\n        // 6b. parent has an element child, child is a doctype, or\n        // child is not null and a doctype is following child. [preinsert]\n        // 6b. parent has an element child that is not child or a\n        // doctype is following child. [replaceWith]\n        if (child !== null /* always true here for replaceWith */) {\n          if (isPreinsert && child.nodeType === DOCUMENT_TYPE_NODE)\n            utils.HierarchyRequestError();\n          for (kid = child.nextSibling; kid !== null; kid = kid.nextSibling) {\n            if (kid.nodeType === DOCUMENT_TYPE_NODE)\n              utils.HierarchyRequestError();\n          }\n        }\n        i = parent._countChildrenOfType(ELEMENT_NODE);\n        if (isPreinsert) {\n          // \"parent has an element child\"\n          if (i > 0)\n            utils.HierarchyRequestError();\n        } else {\n          // \"parent has an element child that is not child\"\n          if (i > 1 || (i === 1 && child.nodeType !== ELEMENT_NODE))\n            utils.HierarchyRequestError();\n        }\n        break;\n      case DOCUMENT_TYPE_NODE:\n        // 6c. parent has a doctype child, child is non-null and an\n        // element is preceding child, or child is null and parent has\n        // an element child. [preinsert]\n        // 6c. parent has a doctype child that is not child, or an\n        // element is preceding child. [replaceWith]\n        if (child === null) {\n          if (parent._countChildrenOfType(ELEMENT_NODE))\n            utils.HierarchyRequestError();\n        } else {\n          // child is always non-null for [replaceWith] case\n          for (kid = parent.firstChild; kid !== null; kid = kid.nextSibling) {\n            if (kid === child) break;\n            if (kid.nodeType === ELEMENT_NODE)\n              utils.HierarchyRequestError();\n          }\n        }\n        i = parent._countChildrenOfType(DOCUMENT_TYPE_NODE);\n        if (isPreinsert) {\n          // \"parent has an doctype child\"\n          if (i > 0)\n            utils.HierarchyRequestError();\n        } else {\n          // \"parent has an doctype child that is not child\"\n          if (i > 1 || (i === 1 && child.nodeType !== DOCUMENT_TYPE_NODE))\n            utils.HierarchyRequestError();\n        }\n        break;\n      }\n    } else {\n      // 5, continued: (parent is not a document)\n      if (node.nodeType === DOCUMENT_TYPE_NODE) utils.HierarchyRequestError();\n    }\n  }},\n\n  insertBefore: { value: function insertBefore(node, child) {\n    var parent = this;\n    // 1. Ensure pre-insertion validity\n    parent._ensureInsertValid(node, child, true);\n    // 2. Let reference child be child.\n    var refChild = child;\n    // 3. If reference child is node, set it to node's next sibling\n    if (refChild === node) { refChild = node.nextSibling; }\n    // 4. Adopt node into parent's node document.\n    parent.doc.adoptNode(node);\n    // 5. Insert node into parent before reference child.\n    node._insertOrReplace(parent, refChild, false);\n    // 6. Return node\n    return node;\n  }},\n\n\n  appendChild: { value: function(child) {\n    // This invokes _appendChild after doing validity checks.\n    return this.insertBefore(child, null);\n  }},\n\n  _appendChild: { value: function(child) {\n    child._insertOrReplace(this, null, false);\n  }},\n\n  removeChild: { value: function removeChild(child) {\n    var parent = this;\n    if (!child.nodeType) throw new TypeError('not a node');\n    if (child.parentNode !== parent) utils.NotFoundError();\n    child.remove();\n    return child;\n  }},\n\n  // To replace a `child` with `node` within a `parent` (this)\n  replaceChild: { value: function replaceChild(node, child) {\n    var parent = this;\n    // Ensure validity (slight differences from pre-insertion check)\n    parent._ensureInsertValid(node, child, false);\n    // Adopt node into parent's node document.\n    if (node.doc !== parent.doc) {\n      // XXX adoptNode has side-effect of removing node from its parent\n      // and generating a mutation event, thus causing the _insertOrReplace\n      // to generate two deletes and an insert instead of a 'move'\n      // event.  It looks like the new MutationObserver stuff avoids\n      // this problem, but for now let's only adopt (ie, remove `node`\n      // from its parent) here if we need to.\n      parent.doc.adoptNode(node);\n    }\n    // Do the replace.\n    node._insertOrReplace(parent, child, true);\n    return child;\n  }},\n\n  // See: http://ejohn.org/blog/comparing-document-position/\n  contains: { value: function contains(node) {\n    if (node === null) { return false; }\n    if (this === node) { return true; /* inclusive descendant */ }\n    /* jshint bitwise: false */\n    return (this.compareDocumentPosition(node) &\n            DOCUMENT_POSITION_CONTAINED_BY) !== 0;\n  }},\n\n  compareDocumentPosition: { value: function compareDocumentPosition(that){\n    // Basic algorithm for finding the relative position of two nodes.\n    // Make a list the ancestors of each node, starting with the\n    // document element and proceeding down to the nodes themselves.\n    // Then, loop through the lists, looking for the first element\n    // that differs.  The order of those two elements give the\n    // order of their descendant nodes.  Or, if one list is a prefix\n    // of the other one, then that node contains the other.\n\n    if (this === that) return 0;\n\n    // If they're not owned by the same document or if one is rooted\n    // and one is not, then they're disconnected.\n    if (this.doc !== that.doc ||\n      this.rooted !== that.rooted)\n      return (DOCUMENT_POSITION_DISCONNECTED +\n          DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC);\n\n    // Get arrays of ancestors for this and that\n    var these = [], those = [];\n    for(var n = this; n !== null; n = n.parentNode) these.push(n);\n    for(n = that; n !== null; n = n.parentNode) those.push(n);\n    these.reverse();  // So we start with the outermost\n    those.reverse();\n\n    if (these[0] !== those[0]) // No common ancestor\n      return (DOCUMENT_POSITION_DISCONNECTED +\n          DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC);\n\n    n = Math.min(these.length, those.length);\n    for(var i = 1; i < n; i++) {\n      if (these[i] !== those[i]) {\n        // We found two different ancestors, so compare\n        // their positions\n        if (these[i].index < those[i].index)\n          return DOCUMENT_POSITION_FOLLOWING;\n        else\n          return DOCUMENT_POSITION_PRECEDING;\n      }\n    }\n\n    // If we get to here, then one of the nodes (the one with the\n    // shorter list of ancestors) contains the other one.\n    if (these.length < those.length)\n      return (DOCUMENT_POSITION_FOLLOWING +\n          DOCUMENT_POSITION_CONTAINED_BY);\n    else\n      return (DOCUMENT_POSITION_PRECEDING +\n          DOCUMENT_POSITION_CONTAINS);\n  }},\n\n  isSameNode: {value : function isSameNode(node) {\n    return this === node;\n  }},\n\n\n  // This method implements the generic parts of node equality testing\n  // and defers to the (non-recursive) type-specific isEqual() method\n  // defined by subclasses\n  isEqualNode: { value: function isEqualNode(node) {\n    if (!node) return false;\n    if (node.nodeType !== this.nodeType) return false;\n\n    // Check type-specific properties for equality\n    if (!this.isEqual(node)) return false;\n\n    // Now check children for number and equality\n    for (var c1 = this.firstChild, c2 = node.firstChild;\n         c1 && c2;\n         c1 = c1.nextSibling, c2 = c2.nextSibling) {\n      if (!c1.isEqualNode(c2)) return false;\n    }\n    return c1 === null && c2 === null;\n  }},\n\n  // This method delegates shallow cloning to a clone() method\n  // that each concrete subclass must implement\n  cloneNode: { value: function(deep) {\n    // Clone this node\n    var clone = this.clone();\n\n    // Handle the recursive case if necessary\n    if (deep) {\n      for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {\n        clone._appendChild(kid.cloneNode(true));\n      }\n    }\n\n    return clone;\n  }},\n\n  lookupPrefix: { value: function lookupPrefix(ns) {\n    var e;\n    if (ns === '' || ns === null || ns === undefined) return null;\n    switch(this.nodeType) {\n    case ELEMENT_NODE:\n      return this._lookupNamespacePrefix(ns, this);\n    case DOCUMENT_NODE:\n      e = this.documentElement;\n      return e ? e.lookupPrefix(ns) : null;\n    case ENTITY_NODE:\n    case NOTATION_NODE:\n    case DOCUMENT_FRAGMENT_NODE:\n    case DOCUMENT_TYPE_NODE:\n      return null;\n    case ATTRIBUTE_NODE:\n      e = this.ownerElement;\n      return e ? e.lookupPrefix(ns) : null;\n    default:\n      e = this.parentElement;\n      return e ? e.lookupPrefix(ns) : null;\n    }\n  }},\n\n\n  lookupNamespaceURI: {value: function lookupNamespaceURI(prefix) {\n    if (prefix === '' || prefix === undefined) { prefix = null; }\n    var e;\n    switch(this.nodeType) {\n    case ELEMENT_NODE:\n      return utils.shouldOverride();\n    case DOCUMENT_NODE:\n      e = this.documentElement;\n      return e ? e.lookupNamespaceURI(prefix) : null;\n    case ENTITY_NODE:\n    case NOTATION_NODE:\n    case DOCUMENT_TYPE_NODE:\n    case DOCUMENT_FRAGMENT_NODE:\n      return null;\n    case ATTRIBUTE_NODE:\n      e = this.ownerElement;\n      return e ? e.lookupNamespaceURI(prefix) : null;\n    default:\n      e = this.parentElement;\n      return e ? e.lookupNamespaceURI(prefix) : null;\n    }\n  }},\n\n  isDefaultNamespace: { value: function isDefaultNamespace(ns) {\n    if (ns === '' || ns === undefined) { ns = null; }\n    var defaultNamespace = this.lookupNamespaceURI(null);\n    return (defaultNamespace === ns);\n  }},\n\n  // Utility methods for nodes.  Not part of the DOM\n\n  // Return the index of this node in its parent.\n  // Throw if no parent, or if this node is not a child of its parent\n  index: { get: function() {\n    var parent = this.parentNode;\n    if (this === parent.firstChild) return 0; // fast case\n    var kids = parent.childNodes;\n    if (this._index === undefined || kids[this._index] !== this) {\n      // Ensure that we don't have an O(N^2) blowup if none of the\n      // kids have defined indices yet and we're traversing via\n      // nextSibling or previousSibling\n      for (var i=0; i<kids.length; i++) {\n        kids[i]._index = i;\n      }\n      utils.assert(kids[this._index] === this);\n    }\n    return this._index;\n  }},\n\n  // Return true if this node is equal to or is an ancestor of that node\n  // Note that nodes are considered to be ancestors of themselves\n  isAncestor: { value: function(that) {\n    // If they belong to different documents, then they're unrelated.\n    if (this.doc !== that.doc) return false;\n    // If one is rooted and one isn't then they're not related\n    if (this.rooted !== that.rooted) return false;\n\n    // Otherwise check by traversing the parentNode chain\n    for(var e = that; e; e = e.parentNode) {\n      if (e === this) return true;\n    }\n    return false;\n  }},\n\n  // DOMINO Changed the behavior to conform with the specs. See:\n  // https://groups.google.com/d/topic/mozilla.dev.platform/77sIYcpdDmc/discussion\n  ensureSameDoc: { value: function(that) {\n    if (that.ownerDocument === null) {\n      that.ownerDocument = this.doc;\n    }\n    else if(that.ownerDocument !== this.doc) {\n      utils.WrongDocumentError();\n    }\n  }},\n\n  removeChildren: { value: utils.shouldOverride },\n\n  // Insert this node as a child of parent before the specified child,\n  // or insert as the last child of parent if specified child is null,\n  // or replace the specified child with this node, firing mutation events as\n  // necessary\n  _insertOrReplace: { value: function _insertOrReplace(parent, before, isReplace) {\n    var child = this, before_index, i;\n\n    if (child.nodeType === DOCUMENT_FRAGMENT_NODE && child.rooted) {\n      utils.HierarchyRequestError();\n    }\n\n    /* Ensure index of `before` is cached before we (possibly) remove it. */\n    if (parent._childNodes) {\n      before_index = (before === null) ? parent._childNodes.length :\n        before.index; /* ensure _index is cached */\n\n      // If we are already a child of the specified parent, then\n      // the index may have to be adjusted.\n      if (child.parentNode === parent) {\n        var child_index = child.index;\n        // If the child is before the spot it is to be inserted at,\n        // then when it is removed, the index of that spot will be\n        // reduced.\n        if (child_index < before_index) {\n          before_index--;\n        }\n      }\n    }\n\n    // Delete the old child\n    if (isReplace) {\n      if (before.rooted) before.doc.mutateRemove(before);\n      before.parentNode = null;\n    }\n\n    var n = before;\n    if (n === null) { n = parent.firstChild; }\n\n    // If both the child and the parent are rooted, then we want to\n    // transplant the child without uprooting and rerooting it.\n    var bothRooted = child.rooted && parent.rooted;\n    if (child.nodeType === DOCUMENT_FRAGMENT_NODE) {\n      var spliceArgs = [0, isReplace ? 1 : 0], next;\n      for (var kid = child.firstChild; kid !== null; kid = next) {\n        next = kid.nextSibling;\n        spliceArgs.push(kid);\n        kid.parentNode = parent;\n      }\n      var len = spliceArgs.length;\n      // Add all nodes to the new parent, overwriting the old child\n      if (isReplace) {\n        LinkedList.replace(n, len > 2 ? spliceArgs[2] : null);\n      } else if (len > 2 && n !== null) {\n        LinkedList.insertBefore(spliceArgs[2], n);\n      }\n      if (parent._childNodes) {\n        spliceArgs[0] = (before === null) ?\n          parent._childNodes.length : before._index;\n        parent._childNodes.splice.apply(parent._childNodes, spliceArgs);\n        for (i=2; i<len; i++) {\n          spliceArgs[i]._index = spliceArgs[0] + (i - 2);\n        }\n      } else if (parent._firstChild === before) {\n        if (len > 2) {\n          parent._firstChild = spliceArgs[2];\n        } else if (isReplace) {\n          parent._firstChild = null;\n        }\n      }\n      // Remove all nodes from the document fragment\n      if (child._childNodes) {\n        child._childNodes.length = 0;\n      } else {\n        child._firstChild = null;\n      }\n      // Call the mutation handlers\n      // Use spliceArgs since the original array has been destroyed. The\n      // liveness guarantee requires us to clone the array so that\n      // references to the childNodes of the DocumentFragment will be empty\n      // when the insertion handlers are called.\n      if (parent.rooted) {\n        parent.modify();\n        for (i = 2; i < len; i++) {\n          parent.doc.mutateInsert(spliceArgs[i]);\n        }\n      }\n    } else {\n      if (before === child) { return; }\n      if (bothRooted) {\n        // Remove the child from its current position in the tree\n        // without calling remove(), since we don't want to uproot it.\n        child._remove();\n      } else if (child.parentNode) {\n        child.remove();\n      }\n\n      // Insert it as a child of its new parent\n      child.parentNode = parent;\n      if (isReplace) {\n        LinkedList.replace(n, child);\n        if (parent._childNodes) {\n          child._index = before_index;\n          parent._childNodes[before_index] = child;\n        } else if (parent._firstChild === before) {\n          parent._firstChild = child;\n        }\n      } else {\n        if (n !== null) {\n          LinkedList.insertBefore(child, n);\n        }\n        if (parent._childNodes) {\n          child._index = before_index;\n          parent._childNodes.splice(before_index, 0, child);\n        } else if (parent._firstChild === before) {\n          parent._firstChild = child;\n        }\n      }\n      if (bothRooted) {\n        parent.modify();\n        // Generate a move mutation event\n        parent.doc.mutateMove(child);\n      } else if (parent.rooted) {\n        parent.modify();\n        parent.doc.mutateInsert(child);\n      }\n    }\n  }},\n\n\n  // Return the lastModTime value for this node. (For use as a\n  // cache invalidation mechanism. If the node does not already\n  // have one, initialize it from the owner document's modclock\n  // property. (Note that modclock does not return the actual\n  // time; it is simply a counter incremented on each document\n  // modification)\n  lastModTime: { get: function() {\n    if (!this._lastModTime) {\n      this._lastModTime = this.doc.modclock;\n    }\n    return this._lastModTime;\n  }},\n\n  // Increment the owner document's modclock and use the new\n  // value to update the lastModTime value for this node and\n  // all of its ancestors. Nodes that have never had their\n  // lastModTime value queried do not need to have a\n  // lastModTime property set on them since there is no\n  // previously queried value to ever compare the new value\n  // against, so only update nodes that already have a\n  // _lastModTime property.\n  modify: { value: function() {\n    if (this.doc.modclock) { // Skip while doc.modclock == 0\n      var time = ++this.doc.modclock;\n      for(var n = this; n; n = n.parentElement) {\n        if (n._lastModTime) {\n          n._lastModTime = time;\n        }\n      }\n    }\n  }},\n\n  // This attribute is not part of the DOM but is quite helpful.\n  // It returns the document with which a node is associated.  Usually\n  // this is the ownerDocument. But ownerDocument is null for the\n  // document object itself, so this is a handy way to get the document\n  // regardless of the node type\n  doc: { get: function() {\n    return this.ownerDocument || this;\n  }},\n\n\n  // If the node has a nid (node id), then it is rooted in a document\n  rooted: { get: function() {\n    return !!this._nid;\n  }},\n\n  normalize: { value: function() {\n    var next;\n    for (var child=this.firstChild; child !== null; child=next) {\n      next = child.nextSibling;\n\n      if (child.normalize) {\n        child.normalize();\n      }\n\n      if (child.nodeType !== Node.TEXT_NODE) {\n        continue;\n      }\n\n      if (child.nodeValue === \"\") {\n        this.removeChild(child);\n        continue;\n      }\n\n      var prevChild = child.previousSibling;\n      if (prevChild === null) {\n        continue;\n      } else if (prevChild.nodeType === Node.TEXT_NODE) {\n        // merge this with previous and remove the child\n        prevChild.appendData(child.nodeValue);\n        this.removeChild(child);\n      }\n    }\n  }},\n\n  // Convert the children of a node to an HTML string.\n  // This is used by the innerHTML getter\n  // The serialization spec is at:\n  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#serializing-html-fragments\n  //\n  // The serialization logic is intentionally implemented in a separate\n  // `NodeUtils` helper instead of the more obvious choice of a private\n  // `_serializeOne()` method on the `Node.prototype` in order to avoid\n  // the megamorphic `this._serializeOne` property access, which reduces\n  // performance unnecessarily. If you need specialized behavior for a\n  // certain subclass, you'll need to implement that in `NodeUtils`.\n  // See https://github.com/fgnass/domino/pull/142 for more information.\n  serialize: { value: function() {\n    var s = '';\n    for (var kid = this.firstChild; kid !== null; kid = kid.nextSibling) {\n      s += NodeUtils.serializeOne(kid, this);\n    }\n    return s;\n  }},\n\n  // Non-standard, but often useful for debugging.\n  outerHTML: {\n    get: function() {\n      return NodeUtils.serializeOne(this, { nodeType: 0 });\n    },\n    set: utils.nyi,\n  },\n\n  // mirror node type properties in the prototype, so they are present\n  // in instances of Node (and subclasses)\n  ELEMENT_NODE:                { value: ELEMENT_NODE },\n  ATTRIBUTE_NODE:              { value: ATTRIBUTE_NODE },\n  TEXT_NODE:                   { value: TEXT_NODE },\n  CDATA_SECTION_NODE:          { value: CDATA_SECTION_NODE },\n  ENTITY_REFERENCE_NODE:       { value: ENTITY_REFERENCE_NODE },\n  ENTITY_NODE:                 { value: ENTITY_NODE },\n  PROCESSING_INSTRUCTION_NODE: { value: PROCESSING_INSTRUCTION_NODE },\n  COMMENT_NODE:                { value: COMMENT_NODE },\n  DOCUMENT_NODE:               { value: DOCUMENT_NODE },\n  DOCUMENT_TYPE_NODE:          { value: DOCUMENT_TYPE_NODE },\n  DOCUMENT_FRAGMENT_NODE:      { value: DOCUMENT_FRAGMENT_NODE },\n  NOTATION_NODE:               { value: NOTATION_NODE },\n\n  DOCUMENT_POSITION_DISCONNECTED: { value: DOCUMENT_POSITION_DISCONNECTED },\n  DOCUMENT_POSITION_PRECEDING:    { value: DOCUMENT_POSITION_PRECEDING },\n  DOCUMENT_POSITION_FOLLOWING:    { value: DOCUMENT_POSITION_FOLLOWING },\n  DOCUMENT_POSITION_CONTAINS:     { value: DOCUMENT_POSITION_CONTAINS },\n  DOCUMENT_POSITION_CONTAINED_BY: { value: DOCUMENT_POSITION_CONTAINED_BY },\n  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: { value: DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC },\n});\n","\"use strict\";\nvar NodeFilter = {\n  // Constants for acceptNode()\n  FILTER_ACCEPT: 1,\n  FILTER_REJECT: 2,\n  FILTER_SKIP: 3,\n\n  // Constants for whatToShow\n  SHOW_ALL: 0xFFFFFFFF,\n  SHOW_ELEMENT: 0x1,\n  SHOW_ATTRIBUTE: 0x2, // historical\n  SHOW_TEXT: 0x4,\n  SHOW_CDATA_SECTION: 0x8, // historical\n  SHOW_ENTITY_REFERENCE: 0x10, // historical\n  SHOW_ENTITY: 0x20, // historical\n  SHOW_PROCESSING_INSTRUCTION: 0x40,\n  SHOW_COMMENT: 0x80,\n  SHOW_DOCUMENT: 0x100,\n  SHOW_DOCUMENT_TYPE: 0x200,\n  SHOW_DOCUMENT_FRAGMENT: 0x400,\n  SHOW_NOTATION: 0x800 // historical\n};\n\nmodule.exports = (NodeFilter.constructor = NodeFilter.prototype = NodeFilter);\n","\"use strict\";\nmodule.exports = NodeIterator;\n\nvar NodeFilter = require('./NodeFilter');\nvar NodeTraversal = require('./NodeTraversal');\nvar utils = require('./utils');\n\n/* Private methods and helpers */\n\n/**\n * @based on WebKit's NodeIterator::moveToNext and NodeIterator::moveToPrevious\n * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeIterator.cpp?rev=186279#L51\n */\nfunction move(node, stayWithin, directionIsNext) {\n  if (directionIsNext) {\n    return NodeTraversal.next(node, stayWithin);\n  } else {\n    if (node === stayWithin) {\n      return null;\n    }\n    return NodeTraversal.previous(node, null);\n  }\n}\n\nfunction isInclusiveAncestor(node, possibleChild) {\n  for ( ; possibleChild; possibleChild = possibleChild.parentNode) {\n    if (node === possibleChild) { return true; }\n  }\n  return false;\n}\n\n/**\n * @spec http://www.w3.org/TR/dom/#concept-nodeiterator-traverse\n * @method\n * @access private\n * @param {NodeIterator} ni\n * @param {string} direction One of 'next' or 'previous'.\n * @return {Node|null}\n */\nfunction traverse(ni, directionIsNext) {\n  var node, beforeNode;\n  node = ni._referenceNode;\n  beforeNode = ni._pointerBeforeReferenceNode;\n  while (true) {\n    if (beforeNode === directionIsNext) {\n      beforeNode = !beforeNode;\n    } else {\n      node = move(node, ni._root, directionIsNext);\n      if (node === null) {\n        return null;\n      }\n    }\n    var result = ni._internalFilter(node);\n    if (result === NodeFilter.FILTER_ACCEPT) {\n      break;\n    }\n  }\n  ni._referenceNode = node;\n  ni._pointerBeforeReferenceNode = beforeNode;\n  return node;\n}\n\n/* Public API */\n\n/**\n * Implemented version: http://www.w3.org/TR/2015/WD-dom-20150618/#nodeiterator\n * Latest version: http://www.w3.org/TR/dom/#nodeiterator\n *\n * @constructor\n * @param {Node} root\n * @param {number} whatToShow [optional]\n * @param {Function|NodeFilter} filter [optional]\n * @throws Error\n */\nfunction NodeIterator(root, whatToShow, filter) {\n  if (!root || !root.nodeType) {\n    utils.NotSupportedError();\n  }\n\n  // Read-only properties\n  this._root = root;\n  this._referenceNode = root;\n  this._pointerBeforeReferenceNode = true;\n  this._whatToShow = Number(whatToShow) || 0;\n  this._filter = filter || null;\n  this._active = false;\n  // Record active node iterators in the document, in order to perform\n  // \"node iterator pre-removal steps\".\n  root.doc._attachNodeIterator(this);\n}\n\nObject.defineProperties(NodeIterator.prototype, {\n  root: { get: function root() {\n    return this._root;\n  } },\n  referenceNode: { get: function referenceNode() {\n    return this._referenceNode;\n  } },\n  pointerBeforeReferenceNode: { get: function pointerBeforeReferenceNode() {\n    return this._pointerBeforeReferenceNode;\n  } },\n  whatToShow: { get: function whatToShow() {\n    return this._whatToShow;\n  } },\n  filter: { get: function filter() {\n    return this._filter;\n  } },\n\n  /**\n   * @method\n   * @param {Node} node\n   * @return {Number} Constant NodeFilter.FILTER_ACCEPT,\n   *  NodeFilter.FILTER_REJECT or NodeFilter.FILTER_SKIP.\n   */\n  _internalFilter: { value: function _internalFilter(node) {\n    /* jshint bitwise: false */\n    var result, filter;\n    if (this._active) {\n      utils.InvalidStateError();\n    }\n\n    // Maps nodeType to whatToShow\n    if (!(((1 << (node.nodeType - 1)) & this._whatToShow))) {\n      return NodeFilter.FILTER_SKIP;\n    }\n\n    filter = this._filter;\n    if (filter === null) {\n      result = NodeFilter.FILTER_ACCEPT;\n    } else {\n      this._active = true;\n      try {\n        if (typeof filter === 'function') {\n          result = filter(node);\n        } else {\n          result = filter.acceptNode(node);\n        }\n      } finally {\n        this._active = false;\n      }\n    }\n\n    // Note that coercing to a number means that\n    //  `true` becomes `1` (which is NodeFilter.FILTER_ACCEPT)\n    //  `false` becomes `0` (neither accept, reject, or skip)\n    return (+result);\n  } },\n\n  /**\n   * @spec https://dom.spec.whatwg.org/#nodeiterator-pre-removing-steps\n   * @method\n   * @return void\n   */\n  _preremove: { value: function _preremove(toBeRemovedNode) {\n    if (isInclusiveAncestor(toBeRemovedNode, this._root)) { return; }\n    if (!isInclusiveAncestor(toBeRemovedNode, this._referenceNode)) { return; }\n    if (this._pointerBeforeReferenceNode) {\n      var next = toBeRemovedNode;\n      while (next.lastChild) {\n        next = next.lastChild;\n      }\n      next = NodeTraversal.next(next, this.root);\n      if (next) {\n        this._referenceNode = next;\n        return;\n      }\n      this._pointerBeforeReferenceNode = false;\n      // fall through\n    }\n    if (toBeRemovedNode.previousSibling === null) {\n      this._referenceNode = toBeRemovedNode.parentNode;\n    } else {\n      this._referenceNode = toBeRemovedNode.previousSibling;\n      var lastChild;\n      for (lastChild = this._referenceNode.lastChild;\n           lastChild;\n           lastChild = this._referenceNode.lastChild) {\n        this._referenceNode = lastChild;\n      }\n    }\n  } },\n\n  /**\n   * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-nextnode\n   * @method\n   * @return {Node|null}\n   */\n  nextNode: { value: function nextNode() {\n    return traverse(this, true);\n  } },\n\n  /**\n   * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-previousnode\n   * @method\n   * @return {Node|null}\n   */\n  previousNode: { value: function previousNode() {\n    return traverse(this, false);\n  } },\n\n  /**\n   * @spec http://www.w3.org/TR/dom/#dom-nodeiterator-detach\n   * @method\n   * @return void\n   */\n  detach: { value: function detach() {\n    /* \"The detach() method must do nothing.\n     * Its functionality (disabling a NodeIterator object) was removed,\n     * but the method itself is preserved for compatibility.\n     */\n  } },\n\n  /** For compatibility with web-platform-tests. */\n  toString: { value: function toString() {\n    return \"[object NodeIterator]\";\n  } },\n});\n","\"use strict\";\n\n// No support for subclassing array, return an actual Array object.\nfunction item(i) {\n    /* jshint validthis: true */\n    return this[i] || null;\n}\n\nfunction NodeList(a) {\n    if (!a) a = [];\n    a.item = item;\n    return a;\n}\n\nmodule.exports = NodeList;\n","/* jshint esversion: 6 */\n\"use strict\";\n\nmodule.exports = class NodeList extends Array {\n    constructor(a) {\n        super((a && a.length) || 0);\n        if (a) {\n            for (var idx in a) { this[idx] = a[idx]; }\n        }\n    }\n    item(i) { return this[i] || null; }\n};\n","\"use strict\";\n\nvar NodeList;\n\ntry {\n    // Attempt to use ES6-style Array subclass if possible.\n    NodeList = require('./NodeList.es6.js');\n} catch (e) {\n    // No support for subclassing array, return an actual Array object.\n    NodeList = require('./NodeList.es5.js');\n}\n\nmodule.exports = NodeList;\n","\"use strict\";\n/* exported NodeTraversal */\nvar NodeTraversal = module.exports = {\n  nextSkippingChildren: nextSkippingChildren,\n  nextAncestorSibling: nextAncestorSibling,\n  next: next,\n  previous: previous,\n  deepLastChild: deepLastChild\n};\n\n/**\n * @based on WebKit's NodeTraversal::nextSkippingChildren\n * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.h?rev=179143#L109\n */\nfunction nextSkippingChildren(node, stayWithin) {\n  if (node === stayWithin) {\n    return null;\n  }\n  if (node.nextSibling !== null) {\n    return node.nextSibling;\n  }\n  return nextAncestorSibling(node, stayWithin);\n}\n\n/**\n * @based on WebKit's NodeTraversal::nextAncestorSibling\n * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.cpp?rev=179143#L93\n */\nfunction nextAncestorSibling(node, stayWithin) {\n  for (node = node.parentNode; node !== null; node = node.parentNode) {\n    if (node === stayWithin) {\n      return null;\n    }\n    if (node.nextSibling !== null) {\n      return node.nextSibling;\n    }\n  }\n  return null;\n}\n\n/**\n * @based on WebKit's NodeTraversal::next\n * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.h?rev=179143#L99\n */\nfunction next(node, stayWithin) {\n  var n;\n  n = node.firstChild;\n  if (n !== null) {\n    return n;\n  }\n  if (node === stayWithin) {\n    return null;\n  }\n  n = node.nextSibling;\n  if (n !== null) {\n    return n;\n  }\n  return nextAncestorSibling(node, stayWithin);\n}\n\n/**\n * @based on WebKit's NodeTraversal::deepLastChild\n * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.cpp?rev=179143#L116\n */\nfunction deepLastChild(node) {\n  while (node.lastChild) {\n    node = node.lastChild;\n  }\n  return node;\n}\n\n/**\n * @based on WebKit's NodeTraversal::previous\n * https://trac.webkit.org/browser/trunk/Source/WebCore/dom/NodeTraversal.h?rev=179143#L121\n */\nfunction previous(node, stayWithin) {\n  var p;\n  p = node.previousSibling;\n  if (p !== null) {\n    return deepLastChild(p);\n  }\n  p = node.parentNode;\n  if (p === stayWithin) {\n    return null;\n  }\n  return p;\n}\n","\"use strict\";\nmodule.exports = {\n  // NOTE: The `serializeOne()` function used to live on the `Node.prototype`\n  // as a private method `Node#_serializeOne(child)`, however that requires\n  // a megamorphic property access `this._serializeOne` just to get to the\n  // method, and this is being done on lots of different `Node` subclasses,\n  // which puts a lot of pressure on V8's megamorphic stub cache. So by\n  // moving the helper off of the `Node.prototype` and into a separate\n  // function in this helper module, we get a monomorphic property access\n  // `NodeUtils.serializeOne` to get to the function and reduce pressure\n  // on the megamorphic stub cache.\n  // See https://github.com/fgnass/domino/pull/142 for more information.\n  serializeOne: serializeOne\n};\n\nvar utils = require('./utils');\nvar NAMESPACE = utils.NAMESPACE;\n\nvar hasRawContent = {\n  STYLE: true,\n  SCRIPT: true,\n  XMP: true,\n  IFRAME: true,\n  NOEMBED: true,\n  NOFRAMES: true,\n  PLAINTEXT: true\n};\n\nvar emptyElements = {\n  area: true,\n  base: true,\n  basefont: true,\n  bgsound: true,\n  br: true,\n  col: true,\n  embed: true,\n  frame: true,\n  hr: true,\n  img: true,\n  input: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n};\n\nvar extraNewLine = {\n  /* Removed in https://github.com/whatwg/html/issues/944\n  pre: true,\n  textarea: true,\n  listing: true\n  */\n};\n\nfunction escape(s) {\n  return s.replace(/[&<>\\u00A0]/g, function(c) {\n    switch(c) {\n    case '&': return '&amp;';\n    case '<': return '&lt;';\n    case '>': return '&gt;';\n    case '\\u00A0': return '&nbsp;';\n    }\n  });\n}\n\nfunction escapeAttr(s) {\n  var toEscape = /[&\"\\u00A0]/g;\n  if (!toEscape.test(s)) {\n      // nothing to do, fast path\n      return s;\n  } else {\n      return s.replace(toEscape, function(c) {\n        switch(c) {\n        case '&': return '&amp;';\n        case '\"': return '&quot;';\n        case '\\u00A0': return '&nbsp;';\n        }\n      });\n  }\n}\n\nfunction attrname(a) {\n  var ns = a.namespaceURI;\n  if (!ns)\n    return a.localName;\n  if (ns === NAMESPACE.XML)\n    return 'xml:' + a.localName;\n  if (ns === NAMESPACE.XLINK)\n    return 'xlink:' + a.localName;\n\n  if (ns === NAMESPACE.XMLNS) {\n    if (a.localName === 'xmlns') return 'xmlns';\n    else return 'xmlns:' + a.localName;\n  }\n  return a.name;\n}\n\nfunction serializeOne(kid, parent) {\n  var s = '';\n  switch(kid.nodeType) {\n    case 1: //ELEMENT_NODE\n      var ns = kid.namespaceURI;\n      var html = ns === NAMESPACE.HTML;\n      var tagname = (html || ns === NAMESPACE.SVG || ns === NAMESPACE.MATHML) ? kid.localName : kid.tagName;\n\n      s += '<' + tagname;\n\n      for(var j = 0, k = kid._numattrs; j < k; j++) {\n        var a = kid._attr(j);\n        s += ' ' + attrname(a);\n        if (a.value !== undefined) s += '=\"' + escapeAttr(a.value) + '\"';\n      }\n      s += '>';\n\n      if (!(html && emptyElements[tagname])) {\n        var ss = kid.serialize();\n        if (html && extraNewLine[tagname] && ss.charAt(0)==='\\n') s += '\\n';\n        // Serialize children and add end tag for all others\n        s += ss;\n        s += '</' + tagname + '>';\n      }\n      break;\n    case 3: //TEXT_NODE\n    case 4: //CDATA_SECTION_NODE\n      var parenttag;\n      if (parent.nodeType === 1 /*ELEMENT_NODE*/ &&\n        parent.namespaceURI === NAMESPACE.HTML)\n        parenttag = parent.tagName;\n      else\n        parenttag = '';\n\n      if (hasRawContent[parenttag] ||\n          (parenttag==='NOSCRIPT' && parent.ownerDocument._scripting_enabled)) {\n        s += kid.data;\n      } else {\n        s += escape(kid.data);\n      }\n      break;\n    case 8: //COMMENT_NODE\n      s += '<!--' + kid.data + '-->';\n      break;\n    case 7: //PROCESSING_INSTRUCTION_NODE\n      s += '<?' + kid.target + ' ' + kid.data + '?>';\n      break;\n    case 10: //DOCUMENT_TYPE_NODE\n      s += '<!DOCTYPE ' + kid.name;\n\n      if (false) {\n        // Latest HTML serialization spec omits the public/system ID\n        if (kid.publicID) {\n          s += ' PUBLIC \"' + kid.publicId + '\"';\n        }\n\n        if (kid.systemId) {\n          s += ' \"' + kid.systemId + '\"';\n        }\n      }\n\n      s += '>';\n      break;\n    default:\n      utils.InvalidStateError();\n  }\n  return s;\n}\n","\"use strict\";\nvar Node = require('./Node');\n\nvar NonDocumentTypeChildNode = {\n\n  nextElementSibling: { get: function() {\n    if (this.parentNode) {\n      for (var kid = this.nextSibling; kid !== null; kid = kid.nextSibling) {\n        if (kid.nodeType === Node.ELEMENT_NODE) return kid;\n      }\n    }\n    return null;\n  }},\n\n  previousElementSibling: { get: function() {\n    if (this.parentNode) {\n      for (var kid = this.previousSibling; kid !== null; kid = kid.previousSibling) {\n        if (kid.nodeType === Node.ELEMENT_NODE) return kid;\n      }\n    }\n    return null;\n  }}\n\n};\n\nmodule.exports = NonDocumentTypeChildNode;\n","\"use strict\";\nmodule.exports = ProcessingInstruction;\n\nvar Node = require('./Node');\nvar CharacterData = require('./CharacterData');\n\nfunction ProcessingInstruction(doc, target, data) {\n  CharacterData.call(this);\n  this.nodeType = Node.PROCESSING_INSTRUCTION_NODE;\n  this.ownerDocument = doc;\n  this.target = target;\n  this._data = data;\n}\n\nvar nodeValue = {\n  get: function() { return this._data; },\n  set: function(v) {\n    if (v === null || v === undefined) { v = ''; } else { v = String(v); }\n    this._data = v;\n    if (this.rooted) this.ownerDocument.mutateValue(this);\n  }\n};\n\nProcessingInstruction.prototype = Object.create(CharacterData.prototype, {\n  nodeName: { get: function() { return this.target; }},\n  nodeValue: nodeValue,\n  textContent: nodeValue,\n  data: {\n    get: nodeValue.get,\n    set: function(v) {\n      nodeValue.set.call(this, v===null ? '' : String(v));\n    },\n  },\n\n  // Utility methods\n  clone: { value: function clone() {\n      return new ProcessingInstruction(this.ownerDocument, this.target, this._data);\n  }},\n  isEqual: { value: function isEqual(n) {\n      return this.target === n.target && this._data === n._data;\n  }}\n\n});\n","\"use strict\";\nmodule.exports = Text;\n\nvar utils = require('./utils');\nvar Node = require('./Node');\nvar CharacterData = require('./CharacterData');\n\nfunction Text(doc, data) {\n  CharacterData.call(this);\n  this.nodeType = Node.TEXT_NODE;\n  this.ownerDocument = doc;\n  this._data = data;\n  this._index = undefined;\n}\n\nvar nodeValue = {\n  get: function() { return this._data; },\n  set: function(v) {\n    if (v === null || v === undefined) { v = ''; } else { v = String(v); }\n    if (v === this._data) return;\n    this._data = v;\n    if (this.rooted)\n      this.ownerDocument.mutateValue(this);\n    if (this.parentNode &&\n      this.parentNode._textchangehook)\n      this.parentNode._textchangehook(this);\n  }\n};\n\nText.prototype = Object.create(CharacterData.prototype, {\n  nodeName: { value: \"#text\" },\n  // These three attributes are all the same.\n  // The data attribute has a [TreatNullAs=EmptyString] but we'll\n  // implement that at the interface level\n  nodeValue: nodeValue,\n  textContent: nodeValue,\n  data: {\n    get: nodeValue.get,\n    set: function(v) {\n      nodeValue.set.call(this, v===null ? '' : String(v));\n    },\n  },\n\n  splitText: { value: function splitText(offset) {\n    if (offset > this._data.length || offset < 0) utils.IndexSizeError();\n\n    var newdata = this._data.substring(offset),\n      newnode = this.ownerDocument.createTextNode(newdata);\n    this.data = this.data.substring(0, offset);\n\n    var parent = this.parentNode;\n    if (parent !== null)\n      parent.insertBefore(newnode, this.nextSibling);\n\n    return newnode;\n  }},\n\n  wholeText: { get: function wholeText() {\n    var result = this.textContent;\n    for (var next = this.nextSibling; next; next = next.nextSibling) {\n      if (next.nodeType !== Node.TEXT_NODE) { break; }\n      result += next.textContent;\n    }\n    return result;\n  }},\n  // Obsolete, removed from spec.\n  replaceWholeText: { value: utils.nyi },\n\n  // Utility methods\n  clone: { value: function clone() {\n    return new Text(this.ownerDocument, this._data);\n  }},\n\n});\n","\"use strict\";\nmodule.exports = TreeWalker;\n\nvar Node = require('./Node');\nvar NodeFilter = require('./NodeFilter');\nvar NodeTraversal = require('./NodeTraversal');\nvar utils = require('./utils');\n\nvar mapChild = {\n  first: 'firstChild',\n  last: 'lastChild',\n  next: 'firstChild',\n  previous: 'lastChild'\n};\n\nvar mapSibling = {\n  first: 'nextSibling',\n  last: 'previousSibling',\n  next: 'nextSibling',\n  previous: 'previousSibling'\n};\n\n/* Private methods and helpers */\n\n/**\n * @spec https://dom.spec.whatwg.org/#concept-traverse-children\n * @method\n * @access private\n * @param {TreeWalker} tw\n * @param {string} type One of 'first' or 'last'.\n * @return {Node|null}\n */\nfunction traverseChildren(tw, type) {\n  var child, node, parent, result, sibling;\n  node = tw._currentNode[mapChild[type]];\n  while (node !== null) {\n    result = tw._internalFilter(node);\n    if (result === NodeFilter.FILTER_ACCEPT) {\n      tw._currentNode = node;\n      return node;\n    }\n    if (result === NodeFilter.FILTER_SKIP) {\n      child = node[mapChild[type]];\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    }\n    while (node !== null) {\n      sibling = node[mapSibling[type]];\n      if (sibling !== null) {\n        node = sibling;\n        break;\n      }\n      parent = node.parentNode;\n      if (parent === null || parent === tw.root || parent === tw._currentNode) {\n        return null;\n      } else {\n        node = parent;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * @spec https://dom.spec.whatwg.org/#concept-traverse-siblings\n * @method\n * @access private\n * @param {TreeWalker} tw\n * @param {TreeWalker} type One of 'next' or 'previous'.\n * @return {Node|nul}\n */\nfunction traverseSiblings(tw, type) {\n  var node, result, sibling;\n  node = tw._currentNode;\n  if (node === tw.root) {\n    return null;\n  }\n  while (true) {\n    sibling = node[mapSibling[type]];\n    while (sibling !== null) {\n      node = sibling;\n      result = tw._internalFilter(node);\n      if (result === NodeFilter.FILTER_ACCEPT) {\n        tw._currentNode = node;\n        return node;\n      }\n      sibling = node[mapChild[type]];\n      if (result === NodeFilter.FILTER_REJECT || sibling === null) {\n        sibling = node[mapSibling[type]];\n      }\n    }\n    node = node.parentNode;\n    if (node === null || node === tw.root) {\n      return null;\n    }\n    if (tw._internalFilter(node) === NodeFilter.FILTER_ACCEPT) {\n      return null;\n    }\n  }\n}\n\n\n/* Public API */\n\n/**\n * Latest version: https://dom.spec.whatwg.org/#treewalker\n *\n * @constructor\n * @param {Node} root\n * @param {number} whatToShow [optional]\n * @param {Function|NodeFilter} filter [optional]\n * @throws Error\n */\nfunction TreeWalker(root, whatToShow, filter) {\n  if (!root || !root.nodeType) {\n    utils.NotSupportedError();\n  }\n\n  // Read-only properties\n  this._root = root;\n  this._whatToShow = Number(whatToShow) || 0;\n  this._filter = filter || null;\n  this._active = false;\n  // Read-write property\n  this._currentNode = root;\n}\n\nObject.defineProperties(TreeWalker.prototype, {\n  root: { get: function() { return this._root; } },\n  whatToShow: { get: function() { return this._whatToShow; } },\n  filter: { get: function() { return this._filter; } },\n\n  currentNode: {\n    get: function currentNode() {\n      return this._currentNode;\n    },\n    set: function setCurrentNode(v) {\n      if (!(v instanceof Node)) {\n        throw new TypeError(\"Not a Node\"); // `null` is also not a node\n      }\n      this._currentNode = v;\n    },\n  },\n\n  /**\n   * @method\n   * @param {Node} node\n   * @return {Number} Constant NodeFilter.FILTER_ACCEPT,\n   *  NodeFilter.FILTER_REJECT or NodeFilter.FILTER_SKIP.\n   */\n  _internalFilter: { value: function _internalFilter(node) {\n    /* jshint bitwise: false */\n    var result, filter;\n    if (this._active) {\n      utils.InvalidStateError();\n    }\n\n    // Maps nodeType to whatToShow\n    if (!(((1 << (node.nodeType - 1)) & this._whatToShow))) {\n      return NodeFilter.FILTER_SKIP;\n    }\n\n    filter = this._filter;\n    if (filter === null) {\n      result = NodeFilter.FILTER_ACCEPT;\n    } else {\n      this._active = true;\n      try {\n        if (typeof filter === 'function') {\n          result = filter(node);\n        } else {\n          result = filter.acceptNode(node);\n        }\n      } finally {\n        this._active = false;\n      }\n    }\n\n    // Note that coercing to a number means that\n    //  `true` becomes `1` (which is NodeFilter.FILTER_ACCEPT)\n    //  `false` becomes `0` (neither accept, reject, or skip)\n    return (+result);\n  }},\n\n  /**\n   * @spec https://dom.spec.whatwg.org/#dom-treewalker-parentnode\n   * @based on WebKit's TreeWalker::parentNode\n   * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/dom/TreeWalker.cpp?rev=220453#L50\n   * @method\n   * @return {Node|null}\n   */\n  parentNode: { value: function parentNode() {\n    var node = this._currentNode;\n    while (node !== this.root) {\n      node = node.parentNode;\n      if (node === null) {\n        return null;\n      }\n      if (this._internalFilter(node) === NodeFilter.FILTER_ACCEPT) {\n        this._currentNode = node;\n        return node;\n      }\n    }\n    return null;\n  }},\n\n  /**\n   * @spec https://dom.spec.whatwg.org/#dom-treewalker-firstchild\n   * @method\n   * @return {Node|null}\n   */\n  firstChild: { value: function firstChild() {\n    return traverseChildren(this, 'first');\n  }},\n\n  /**\n   * @spec https://dom.spec.whatwg.org/#dom-treewalker-lastchild\n   * @method\n   * @return {Node|null}\n   */\n  lastChild: { value: function lastChild() {\n    return traverseChildren(this, 'last');\n  }},\n\n  /**\n   * @spec http://www.w3.org/TR/dom/#dom-treewalker-previoussibling\n   * @method\n   * @return {Node|null}\n   */\n  previousSibling: { value: function previousSibling() {\n    return traverseSiblings(this, 'previous');\n  }},\n\n  /**\n   * @spec http://www.w3.org/TR/dom/#dom-treewalker-nextsibling\n   * @method\n   * @return {Node|null}\n   */\n  nextSibling: { value: function nextSibling() {\n    return traverseSiblings(this, 'next');\n  }},\n\n  /**\n   * @spec https://dom.spec.whatwg.org/#dom-treewalker-previousnode\n   * @based on WebKit's TreeWalker::previousNode\n   * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/dom/TreeWalker.cpp?rev=220453#L181\n   * @method\n   * @return {Node|null}\n   */\n  previousNode: { value: function previousNode() {\n    var node, result, previousSibling, lastChild;\n    node = this._currentNode;\n    while (node !== this._root) {\n      for (previousSibling = node.previousSibling;\n           previousSibling;\n           previousSibling = node.previousSibling) {\n        node = previousSibling;\n        result = this._internalFilter(node);\n        if (result === NodeFilter.FILTER_REJECT) {\n          continue;\n        }\n        for (lastChild = node.lastChild;\n             lastChild;\n             lastChild = node.lastChild) {\n          node = lastChild;\n          result = this._internalFilter(node);\n          if (result === NodeFilter.FILTER_REJECT) {\n            break;\n          }\n        }\n        if (result === NodeFilter.FILTER_ACCEPT) {\n          this._currentNode = node;\n          return node;\n        }\n      }\n      if (node === this.root || node.parentNode === null) {\n        return null;\n      }\n      node = node.parentNode;\n      if (this._internalFilter(node) === NodeFilter.FILTER_ACCEPT) {\n        this._currentNode = node;\n        return node;\n      }\n    }\n    return null;\n  }},\n\n  /**\n   * @spec https://dom.spec.whatwg.org/#dom-treewalker-nextnode\n   * @based on WebKit's TreeWalker::nextNode\n   * https://trac.webkit.org/browser/webkit/trunk/Source/WebCore/dom/TreeWalker.cpp?rev=220453#L228\n   * @method\n   * @return {Node|null}\n   */\n  nextNode: { value: function nextNode() {\n    var node, result, firstChild, nextSibling;\n    node = this._currentNode;\n    result = NodeFilter.FILTER_ACCEPT;\n\n    CHILDREN:\n    while (true) {\n      for (firstChild = node.firstChild;\n           firstChild;\n           firstChild = node.firstChild) {\n        node = firstChild;\n        result = this._internalFilter(node);\n        if (result === NodeFilter.FILTER_ACCEPT) {\n          this._currentNode = node;\n          return node;\n        } else if (result === NodeFilter.FILTER_REJECT) {\n          break;\n        }\n      }\n      for (nextSibling = NodeTraversal.nextSkippingChildren(node, this.root);\n           nextSibling;\n           nextSibling = NodeTraversal.nextSkippingChildren(node, this.root)) {\n        node = nextSibling;\n        result = this._internalFilter(node);\n        if (result === NodeFilter.FILTER_ACCEPT) {\n          this._currentNode = node;\n          return node;\n        } else if (result === NodeFilter.FILTER_SKIP) {\n          continue CHILDREN;\n        }\n      }\n      return null;\n    }\n  }},\n\n  /** For compatibility with web-platform-tests. */\n  toString: { value: function toString() {\n    return \"[object TreeWalker]\";\n  }},\n});\n","\"use strict\";\nvar Event = require('./Event');\n\nmodule.exports = UIEvent;\n\nfunction UIEvent() {\n  // Just use the superclass constructor to initialize\n  Event.call(this);\n  this.view = null; // FF uses the current window\n  this.detail = 0;\n}\nUIEvent.prototype = Object.create(Event.prototype, {\n  constructor: { value: UIEvent },\n  initUIEvent: { value: function(type, bubbles, cancelable, view, detail) {\n    this.initEvent(type, bubbles, cancelable);\n    this.view = view;\n    this.detail = detail;\n  }}\n});\n","\"use strict\";\nmodule.exports = URL;\n\nfunction URL(url) {\n  if (!url) return Object.create(URL.prototype);\n  // Can't use String.trim() since it defines whitespace differently than HTML\n  this.url = url.replace(/^[ \\t\\n\\r\\f]+|[ \\t\\n\\r\\f]+$/g, \"\");\n\n  // See http://tools.ietf.org/html/rfc3986#appendix-B\n  // and https://url.spec.whatwg.org/#parsing\n  var match = URL.pattern.exec(this.url);\n  if (match) {\n    if (match[2]) this.scheme = match[2];\n    if (match[4]) {\n      // parse username/password\n      var userinfo = match[4].match(URL.userinfoPattern);\n      if (userinfo) {\n        this.username = userinfo[1];\n        this.password = userinfo[3];\n        match[4] = match[4].substring(userinfo[0].length);\n      }\n      if (match[4].match(URL.portPattern)) {\n        var pos = match[4].lastIndexOf(':');\n        this.host = match[4].substring(0, pos);\n        this.port = match[4].substring(pos+1);\n      }\n      else {\n        this.host = match[4];\n      }\n    }\n    if (match[5]) this.path = match[5];\n    if (match[6]) this.query = match[7];\n    if (match[8]) this.fragment = match[9];\n  }\n}\n\nURL.pattern = /^(([^:\\/?#]+):)?(\\/\\/([^\\/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$/;\nURL.userinfoPattern = /^([^@:]*)(:([^@]*))?@/;\nURL.portPattern = /:\\d+$/;\nURL.authorityPattern = /^[^:\\/?#]+:\\/\\//;\nURL.hierarchyPattern = /^[^:\\/?#]+:\\//;\n\n// Return a percentEncoded version of s.\n// S should be a single-character string\n// XXX: needs to do utf-8 encoding?\nURL.percentEncode = function percentEncode(s) {\n  var c = s.charCodeAt(0);\n  if (c < 256) return \"%\" + c.toString(16);\n  else throw Error(\"can't percent-encode codepoints > 255 yet\");\n};\n\nURL.prototype = {\n  constructor: URL,\n\n  // XXX: not sure if this is the precise definition of absolute\n  isAbsolute: function() { return !!this.scheme; },\n  isAuthorityBased: function() {\n    return URL.authorityPattern.test(this.url);\n  },\n  isHierarchical: function() {\n    return URL.hierarchyPattern.test(this.url);\n  },\n\n  toString: function() {\n    var s = \"\";\n    if (this.scheme !== undefined) s += this.scheme + \":\";\n    if (this.isAbsolute()) {\n      s += '//';\n      if (this.username || this.password) {\n        s += this.username || '';\n        if (this.password) {\n          s += ':' + this.password;\n        }\n        s += '@';\n      }\n      if (this.host) {\n        s += this.host;\n      }\n    }\n    if (this.port !== undefined) s += \":\" + this.port;\n    if (this.path !== undefined) s += this.path;\n    if (this.query !== undefined) s += \"?\" + this.query;\n    if (this.fragment !== undefined) s += \"#\" + this.fragment;\n    return s;\n  },\n\n  // See: http://tools.ietf.org/html/rfc3986#section-5.2\n  // and https://url.spec.whatwg.org/#constructors\n  resolve: function(relative) {\n    var base = this;           // The base url we're resolving against\n    var r = new URL(relative); // The relative reference url to resolve\n    var t = new URL();         // The absolute target url we will return\n\n    if (r.scheme !== undefined) {\n      t.scheme = r.scheme;\n      t.username = r.username;\n      t.password = r.password;\n      t.host = r.host;\n      t.port = r.port;\n      t.path = remove_dot_segments(r.path);\n      t.query = r.query;\n    }\n    else {\n      t.scheme = base.scheme;\n      if (r.host !== undefined) {\n        t.username = r.username;\n        t.password = r.password;\n        t.host = r.host;\n        t.port = r.port;\n        t.path = remove_dot_segments(r.path);\n        t.query = r.query;\n      }\n      else {\n        t.username = base.username;\n        t.password = base.password;\n        t.host = base.host;\n        t.port = base.port;\n        if (!r.path) { // undefined or empty\n          t.path = base.path;\n          if (r.query !== undefined)\n            t.query = r.query;\n          else\n            t.query = base.query;\n        }\n        else {\n          if (r.path.charAt(0) === \"/\") {\n            t.path = remove_dot_segments(r.path);\n          }\n          else {\n            t.path = merge(base.path, r.path);\n            t.path = remove_dot_segments(t.path);\n          }\n          t.query = r.query;\n        }\n      }\n    }\n    t.fragment = r.fragment;\n\n    return t.toString();\n\n\n    function merge(basepath, refpath) {\n      if (base.host !== undefined && !base.path)\n        return \"/\" + refpath;\n\n      var lastslash = basepath.lastIndexOf(\"/\");\n      if (lastslash === -1)\n        return refpath;\n      else\n        return basepath.substring(0, lastslash+1) + refpath;\n    }\n\n    function remove_dot_segments(path) {\n      if (!path) return path; // For \"\" or undefined\n\n      var output = \"\";\n      while(path.length > 0) {\n        if (path === \".\" || path === \"..\") {\n          path = \"\";\n          break;\n        }\n\n        var twochars = path.substring(0,2);\n        var threechars = path.substring(0,3);\n        var fourchars = path.substring(0,4);\n        if (threechars === \"../\") {\n          path = path.substring(3);\n        }\n        else if (twochars === \"./\") {\n          path = path.substring(2);\n        }\n        else if (threechars === \"/./\") {\n          path = \"/\" + path.substring(3);\n        }\n        else if (twochars === \"/.\" && path.length === 2) {\n          path = \"/\";\n        }\n        else if (fourchars === \"/../\" ||\n             (threechars === \"/..\" && path.length === 3)) {\n          path = \"/\" + path.substring(4);\n\n          output = output.replace(/\\/?[^\\/]*$/, \"\");\n        }\n        else {\n          var segment = path.match(/(\\/?([^\\/]*))/)[0];\n          output += segment;\n          path = path.substring(segment.length);\n        }\n      }\n\n      return output;\n    }\n  },\n};\n","\"use strict\";\nvar URL = require('./URL');\n\nmodule.exports = URLUtils;\n\n// Allow the `x == null` pattern.  This is eslint's \"null: 'ignore'\" option,\n// but jshint doesn't support this.\n/* jshint eqeqeq: false */\n\n// This is an abstract superclass for Location, HTMLAnchorElement and\n// other types that have the standard complement of \"URL decomposition\n// IDL attributes\".  This is now standardized as URLUtils, see:\n// https://url.spec.whatwg.org/#urlutils\n// Subclasses must define a getter/setter on href.\n// The getter and setter methods parse and rebuild the URL on each\n// invocation; there is no attempt to cache the value and be more efficient\nfunction URLUtils() {}\nURLUtils.prototype = Object.create(Object.prototype, {\n\n  _url: { get: function() {\n    // XXX: this should do the \"Reinitialize url\" steps, and \"null\" should\n    // be a valid return value.\n    return new URL(this.href);\n  } },\n\n  protocol: {\n    get: function() {\n      var url = this._url;\n      if (url && url.scheme) return url.scheme + \":\";\n      else return \":\";\n    },\n    set: function(v) {\n      var output = this.href;\n      var url = new URL(output);\n      if (url.isAbsolute()) {\n        v = v.replace(/:+$/, \"\");\n        v = v.replace(/[^-+\\.a-zA-Z0-9]/g, URL.percentEncode);\n        if (v.length > 0) {\n          url.scheme = v;\n          output = url.toString();\n        }\n      }\n      this.href = output;\n    },\n  },\n\n  host: {\n    get: function() {\n      var url = this._url;\n      if (url.isAbsolute() && url.isAuthorityBased())\n        return url.host + (url.port ? (\":\" + url.port) : \"\");\n      else\n        return \"\";\n    },\n    set: function(v) {\n      var output = this.href;\n      var url = new URL(output);\n      if (url.isAbsolute() && url.isAuthorityBased()) {\n        v = v.replace(/[^-+\\._~!$&'()*,;:=a-zA-Z0-9]/g, URL.percentEncode);\n        if (v.length > 0) {\n          url.host = v;\n          delete url.port;\n          output = url.toString();\n        }\n      }\n      this.href = output;\n    },\n  },\n\n  hostname: {\n    get: function() {\n      var url = this._url;\n      if (url.isAbsolute() && url.isAuthorityBased())\n        return url.host;\n      else\n        return \"\";\n    },\n    set: function(v) {\n      var output = this.href;\n      var url = new URL(output);\n      if (url.isAbsolute() && url.isAuthorityBased()) {\n        v = v.replace(/^\\/+/, \"\");\n        v = v.replace(/[^-+\\._~!$&'()*,;:=a-zA-Z0-9]/g, URL.percentEncode);\n        if (v.length > 0) {\n          url.host = v;\n          output = url.toString();\n        }\n      }\n      this.href = output;\n    },\n  },\n\n  port: {\n    get: function() {\n      var url = this._url;\n      if (url.isAbsolute() && url.isAuthorityBased() && url.port!==undefined)\n        return url.port;\n      else\n        return \"\";\n    },\n    set: function(v) {\n      var output = this.href;\n      var url = new URL(output);\n      if (url.isAbsolute() && url.isAuthorityBased()) {\n        v = '' + v;\n        v = v.replace(/[^0-9].*$/, \"\");\n        v = v.replace(/^0+/, \"\");\n        if (v.length === 0) v = \"0\";\n        if (parseInt(v, 10) <= 65535) {\n          url.port = v;\n          output = url.toString();\n        }\n      }\n      this.href = output;\n    },\n  },\n\n  pathname: {\n    get: function() {\n      var url = this._url;\n      if (url.isAbsolute() && url.isHierarchical())\n        return url.path;\n      else\n        return \"\";\n    },\n    set: function(v) {\n      var output = this.href;\n      var url = new URL(output);\n      if (url.isAbsolute() && url.isHierarchical()) {\n        if (v.charAt(0) !== \"/\")\n          v = \"/\" + v;\n        v = v.replace(/[^-+\\._~!$&'()*,;:=@\\/a-zA-Z0-9]/g, URL.percentEncode);\n        url.path = v;\n        output = url.toString();\n      }\n      this.href = output;\n    },\n  },\n\n  search: {\n    get: function() {\n      var url = this._url;\n      if (url.isAbsolute() && url.isHierarchical() && url.query!==undefined)\n        return \"?\" + url.query;\n      else\n        return \"\";\n    },\n    set: function(v) {\n      var output = this.href;\n      var url = new URL(output);\n      if (url.isAbsolute() && url.isHierarchical()) {\n        if (v.charAt(0) === \"?\") v = v.substring(1);\n        v = v.replace(/[^-+\\._~!$&'()*,;:=@\\/?a-zA-Z0-9]/g, URL.percentEncode);\n        url.query = v;\n        output = url.toString();\n      }\n      this.href = output;\n    },\n  },\n\n  hash: {\n    get: function() {\n      var url = this._url;\n      if (url == null || url.fragment == null || url.fragment === '') {\n        return \"\";\n      } else {\n        return \"#\" + url.fragment;\n      }\n    },\n    set: function(v) {\n      var output = this.href;\n      var url = new URL(output);\n\n      if (v.charAt(0) === \"#\") v = v.substring(1);\n      v = v.replace(/[^-+\\._~!$&'()*,;:=@\\/?a-zA-Z0-9]/g, URL.percentEncode);\n      url.fragment = v;\n      output = url.toString();\n\n      this.href = output;\n    },\n  },\n\n  username: {\n    get: function() {\n      var url = this._url;\n      return url.username || '';\n    },\n    set: function(v) {\n      var output = this.href;\n      var url = new URL(output);\n      if (url.isAbsolute()) {\n        v = v.replace(/[\\x00-\\x1F\\x7F-\\uFFFF \"#<>?`\\/@\\\\:]/g, URL.percentEncode);\n        url.username = v;\n        output = url.toString();\n      }\n      this.href = output;\n    },\n  },\n\n  password: {\n    get: function() {\n      var url = this._url;\n      return url.password || '';\n    },\n    set: function(v) {\n      var output = this.href;\n      var url = new URL(output);\n      if (url.isAbsolute()) {\n        if (v==='') {\n          url.password = null;\n        } else {\n          v = v.replace(/[\\x00-\\x1F\\x7F-\\uFFFF \"#<>?`\\/@\\\\]/g, URL.percentEncode);\n          url.password = v;\n        }\n        output = url.toString();\n      }\n      this.href = output;\n    },\n  },\n\n  origin: { get: function() {\n    var url = this._url;\n    if (url == null) { return ''; }\n    var originForPort = function(defaultPort) {\n      var origin = [url.scheme, url.host, +url.port || defaultPort];\n      // XXX should be \"unicode serialization\"\n      return origin[0] + '://' + origin[1] +\n        (origin[2] === defaultPort ? '' : (':' + origin[2]));\n    };\n    switch (url.scheme) {\n    case 'ftp':\n      return originForPort(21);\n    case 'gopher':\n      return originForPort(70);\n    case 'http':\n    case 'ws':\n      return originForPort(80);\n    case 'https':\n    case 'wss':\n      return originForPort(443);\n    default:\n      // this is what chrome does\n      return url.scheme + '://';\n    }\n  } },\n\n  /*\n  searchParams: {\n    get: function() {\n      var url = this._url;\n      // XXX\n    },\n    set: function(v) {\n      var output = this.href;\n      var url = new URL(output);\n      // XXX\n      this.href = output;\n    },\n  },\n  */\n});\n\nURLUtils._inherit = function(proto) {\n  // copy getters/setters from URLUtils to o.\n  Object.getOwnPropertyNames(URLUtils.prototype).forEach(function(p) {\n    if (p==='constructor' || p==='href') { return; }\n    var desc = Object.getOwnPropertyDescriptor(URLUtils.prototype, p);\n    Object.defineProperty(proto, p, desc);\n  });\n};\n","\"use strict\";\nvar DOMImplementation = require('./DOMImplementation');\nvar EventTarget = require('./EventTarget');\nvar Location = require('./Location');\nvar sloppy = require('./sloppy');\nvar utils = require('./utils');\n\nmodule.exports = Window;\n\nfunction Window(document) {\n  this.document = document || new DOMImplementation(null).createHTMLDocument(\"\");\n  this.document._scripting_enabled = true;\n  this.document.defaultView = this;\n  this.location = new Location(this, this.document._address || 'about:blank');\n}\n\nWindow.prototype = Object.create(EventTarget.prototype, {\n  _run: { value: sloppy.Window_run },\n  console: { value: console },\n  history: { value: {\n    back: utils.nyi,\n    forward: utils.nyi,\n    go: utils.nyi\n  }},\n  navigator: { value: require(\"./NavigatorID\") },\n\n  // Self-referential properties\n  window: { get: function() { return this; }},\n  self: { get: function() { return this; }},\n  frames: { get: function() { return this; }},\n\n  // Self-referential properties for a top-level window\n  parent: { get: function() { return this; }},\n  top: { get: function() { return this; }},\n\n  // We don't support any other windows for now\n  length: { value: 0 },           // no frames\n  frameElement: { value: null },  // not part of a frame\n  opener: { value: null },        // not opened by another window\n\n  // The onload event handler.\n  // XXX: need to support a bunch of other event types, too,\n  // and have them interoperate with document.body.\n\n  onload: {\n    get: function() {\n      return this._getEventHandler(\"load\");\n    },\n    set: function(v) {\n      this._setEventHandler(\"load\", v);\n    }\n  },\n\n  // XXX This is a completely broken implementation\n  getComputedStyle: { value: function getComputedStyle(elt) {\n    return elt.style;\n  }}\n\n});\n\nutils.expose(require('./WindowTimers'), Window);\nutils.expose(require('./impl'), Window);\n","\"use strict\";\n\n// https://html.spec.whatwg.org/multipage/webappapis.html#windowtimers\nvar WindowTimers = {\n  setTimeout: setTimeout,\n  clearTimeout: clearTimeout,\n  setInterval: setInterval,\n  clearInterval: clearInterval\n};\n\nmodule.exports = WindowTimers;\n","\"use strict\";\nvar utils = require('./utils');\n\nexports.property = function(attr) {\n  if (Array.isArray(attr.type)) {\n    var valid = Object.create(null);\n    attr.type.forEach(function(val) {\n      valid[val.value || val] = val.alias || val;\n    });\n    var missingValueDefault = attr.missing;\n    if (missingValueDefault===undefined) { missingValueDefault = null; }\n    var invalidValueDefault = attr.invalid;\n    if (invalidValueDefault===undefined) { invalidValueDefault = missingValueDefault; }\n    return {\n      get: function() {\n        var v = this._getattr(attr.name);\n        if (v === null) return missingValueDefault;\n\n        v = valid[v.toLowerCase()];\n        if (v !== undefined) return v;\n        if (invalidValueDefault !== null) return invalidValueDefault;\n        return v;\n      },\n      set: function(v) {\n        this._setattr(attr.name, v);\n      }\n    };\n  }\n  else if (attr.type === Boolean) {\n    return {\n      get: function() {\n        return this.hasAttribute(attr.name);\n      },\n      set: function(v) {\n        if (v) {\n          this._setattr(attr.name, '');\n        }\n        else {\n          this.removeAttribute(attr.name);\n        }\n      }\n    };\n  }\n  else if (attr.type === Number ||\n           attr.type === \"long\" ||\n           attr.type === \"unsigned long\" ||\n           attr.type === \"limited unsigned long with fallback\") {\n    return numberPropDesc(attr);\n  }\n  else if (!attr.type || attr.type === String) {\n    return {\n      get: function() { return this._getattr(attr.name) || ''; },\n      set: function(v) {\n        if (attr.treatNullAsEmptyString && v === null) { v = ''; }\n        this._setattr(attr.name, v);\n      }\n    };\n  }\n  else if (typeof attr.type === 'function') {\n    return attr.type(attr.name, attr);\n  }\n  throw new Error('Invalid attribute definition');\n};\n\n// See http://www.whatwg.org/specs/web-apps/current-work/#reflect\n//\n// defval is the default value. If it is a function, then that function\n// will be invoked as a method of the element to obtain the default.\n// If no default is specified for a given attribute, then the default\n// depends on the type of the attribute, but since this function handles\n// 4 integer cases, you must specify the default value in each call\n//\n// min and max define a valid range for getting the attribute.\n//\n// setmin defines a minimum value when setting.  If the value is less\n// than that, then throw INDEX_SIZE_ERR.\n//\n// Conveniently, JavaScript's parseInt function appears to be\n// compatible with HTML's 'rules for parsing integers'\nfunction numberPropDesc(a) {\n  var def;\n  if(typeof a.default === 'function') {\n    def = a.default;\n  }\n  else if(typeof a.default === 'number') {\n    def = function() { return a.default; };\n  }\n  else {\n    def = function() { utils.assert(false, typeof a.default); };\n  }\n  var unsigned_long = (a.type === 'unsigned long');\n  var signed_long = (a.type === 'long');\n  var unsigned_fallback = (a.type === 'limited unsigned long with fallback');\n  var min = a.min, max = a.max, setmin = a.setmin;\n  if (min === undefined) {\n    if (unsigned_long) min = 0;\n    if (signed_long) min = -0x80000000;\n    if (unsigned_fallback) min = 1;\n  }\n  if (max === undefined) {\n    if (unsigned_long || signed_long || unsigned_fallback) max = 0x7FFFFFFF;\n  }\n\n  return {\n    get: function() {\n      var v = this._getattr(a.name);\n      var n = a.float ? parseFloat(v) : parseInt(v, 10);\n      if (v === null || !isFinite(n) || (min !== undefined && n < min) || (max !== undefined && n > max)) {\n        return def.call(this);\n      }\n      if (unsigned_long || signed_long || unsigned_fallback) {\n        if (!/^[ \\t\\n\\f\\r]*[-+]?[0-9]/.test(v)) { return def.call(this); }\n        n = n|0; // jshint ignore:line\n      }\n      return n;\n    },\n    set: function(v) {\n      if (!a.float) { v = Math.floor(v); }\n      if (setmin !== undefined && v < setmin) {\n        utils.IndexSizeError(a.name + ' set to ' + v);\n      }\n      if (unsigned_long) {\n        v = (v < 0 || v > 0x7FFFFFFF) ? def.call(this) :\n          (v|0);  // jshint ignore:line\n      } else if (unsigned_fallback) {\n        v = (v < 1 || v > 0x7FFFFFFF) ? def.call(this) :\n          (v|0); // jshint ignore:line\n      } else if (signed_long) {\n        v = (v < -0x80000000 || v > 0x7FFFFFFF) ? def.call(this) :\n          (v|0); // jshint ignore:line\n      }\n      this._setattr(a.name, String(v));\n    }\n  };\n}\n\n// This is a utility function for setting up change handler functions\n// for attributes like 'id' that require special handling when they change.\nexports.registerChangeHandler = function(c, name, handler) {\n  var p = c.prototype;\n\n  // If p does not already have its own _attributeChangeHandlers\n  // then create one for it, inheriting from the inherited\n  // _attributeChangeHandlers. At the top (for the Element class) the\n  // _attributeChangeHandlers object will be created with a null prototype.\n  if (!Object.prototype.hasOwnProperty.call(p, '_attributeChangeHandlers')) {\n    p._attributeChangeHandlers =\n      Object.create(p._attributeChangeHandlers || null);\n  }\n\n  p._attributeChangeHandlers[name] = handler;\n};\n","/*\n * This file defines Domino behaviour that can be externally configured.\n * To change these settings, set the relevant global property *before*\n * you call `require(\"domino\")`.\n */\n\nexports.isApiWritable = !global.__domino_frozen__;\n","/* jshint node:true, latedef:false */\n\"use strict\"; // jshint ignore:line\n/*!\nParser-Lib\nCopyright (c) 2009-2011 Nicholas C. Zakas. All rights reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n/* Version v0.2.5+domino1, Build time: 30-January-2016 05:13:03 */\nvar parserlib = Object.create(null);\n(function(){\n\n/**\n * A generic base to inherit from for any object\n * that needs event handling.\n * @class EventTarget\n * @constructor\n */\nfunction EventTarget(){\n\n    /**\n     * The array of listeners for various events.\n     * @type Object\n     * @property _listeners\n     * @private\n     */\n    this._listeners = Object.create(null);\n}\n\nEventTarget.prototype = {\n\n    //restore constructor\n    constructor: EventTarget,\n\n    /**\n     * Adds a listener for a given event type.\n     * @param {String} type The type of event to add a listener for.\n     * @param {Function} listener The function to call when the event occurs.\n     * @return {void}\n     * @method addListener\n     */\n    addListener: function(type, listener){\n        if (!this._listeners[type]){\n            this._listeners[type] = [];\n        }\n\n        this._listeners[type].push(listener);\n    },\n\n    /**\n     * Fires an event based on the passed-in object.\n     * @param {Object|String} event An object with at least a 'type' attribute\n     *      or a string indicating the event name.\n     * @return {void}\n     * @method fire\n     */\n    fire: function(event){\n        if (typeof event === \"string\"){\n            event = { type: event };\n        }\n        if (typeof event.target !== \"undefined\"){\n            event.target = this;\n        }\n\n        if (typeof event.type === \"undefined\"){\n            throw new Error(\"Event object missing 'type' property.\");\n        }\n\n        if (this._listeners[event.type]){\n\n            //create a copy of the array and use that so listeners can't chane\n            var listeners = this._listeners[event.type].concat();\n            for (var i=0, len=listeners.length; i < len; i++){\n                listeners[i].call(this, event);\n            }\n        }\n    },\n\n    /**\n     * Removes a listener for a given event type.\n     * @param {String} type The type of event to remove a listener from.\n     * @param {Function} listener The function to remove from the event.\n     * @return {void}\n     * @method removeListener\n     */\n    removeListener: function(type, listener){\n        if (this._listeners[type]){\n            var listeners = this._listeners[type];\n            for (var i=0, len=listeners.length; i < len; i++){\n                if (listeners[i] === listener){\n                    listeners.splice(i, 1);\n                    break;\n                }\n            }\n\n\n        }\n    }\n};\n/**\n * Convenient way to read through strings.\n * @namespace parserlib.util\n * @class StringReader\n * @constructor\n * @param {String} text The text to read.\n */\nfunction StringReader(text){\n\n    /**\n     * The input text with line endings normalized.\n     * @property _input\n     * @type String\n     * @private\n     */\n    this._input = text.replace(/(\\r|\\n){1,2}/g, \"\\n\");\n\n\n    /**\n     * The row for the character to be read next.\n     * @property _line\n     * @type int\n     * @private\n     */\n    this._line = 1;\n\n\n    /**\n     * The column for the character to be read next.\n     * @property _col\n     * @type int\n     * @private\n     */\n    this._col = 1;\n\n    /**\n     * The index of the character in the input to be read next.\n     * @property _cursor\n     * @type int\n     * @private\n     */\n    this._cursor = 0;\n}\n\nStringReader.prototype = {\n\n    //restore constructor\n    constructor: StringReader,\n\n    //-------------------------------------------------------------------------\n    // Position info\n    //-------------------------------------------------------------------------\n\n    /**\n     * Returns the column of the character to be read next.\n     * @return {int} The column of the character to be read next.\n     * @method getCol\n     */\n    getCol: function(){\n        return this._col;\n    },\n\n    /**\n     * Returns the row of the character to be read next.\n     * @return {int} The row of the character to be read next.\n     * @method getLine\n     */\n    getLine: function(){\n        return this._line ;\n    },\n\n    /**\n     * Determines if you're at the end of the input.\n     * @return {Boolean} True if there's no more input, false otherwise.\n     * @method eof\n     */\n    eof: function(){\n        return (this._cursor === this._input.length);\n    },\n\n    //-------------------------------------------------------------------------\n    // Basic reading\n    //-------------------------------------------------------------------------\n\n    /**\n     * Reads the next character without advancing the cursor.\n     * @param {int} count How many characters to look ahead (default is 1).\n     * @return {String} The next character or null if there is no next character.\n     * @method peek\n     */\n    peek: function(count){\n        var c = null;\n        count = (typeof count === \"undefined\" ? 1 : count);\n\n        //if we're not at the end of the input...\n        if (this._cursor < this._input.length){\n\n            //get character and increment cursor and column\n            c = this._input.charAt(this._cursor + count - 1);\n        }\n\n        return c;\n    },\n\n    /**\n     * Reads the next character from the input and adjusts the row and column\n     * accordingly.\n     * @return {String} The next character or null if there is no next character.\n     * @method read\n     */\n    read: function(){\n        var c = null;\n\n        //if we're not at the end of the input...\n        if (this._cursor < this._input.length){\n\n            //if the last character was a newline, increment row count\n            //and reset column count\n            if (this._input.charAt(this._cursor) === \"\\n\"){\n                this._line++;\n                this._col=1;\n            } else {\n                this._col++;\n            }\n\n            //get character and increment cursor and column\n            c = this._input.charAt(this._cursor++);\n        }\n\n        return c;\n    },\n\n    //-------------------------------------------------------------------------\n    // Misc\n    //-------------------------------------------------------------------------\n\n    /**\n     * Saves the current location so it can be returned to later.\n     * @method mark\n     * @return {void}\n     */\n    mark: function(){\n        this._bookmark = {\n            cursor: this._cursor,\n            line:   this._line,\n            col:    this._col\n        };\n    },\n\n    reset: function(){\n        if (this._bookmark){\n            this._cursor = this._bookmark.cursor;\n            this._line = this._bookmark.line;\n            this._col = this._bookmark.col;\n            delete this._bookmark;\n        }\n    },\n\n    //-------------------------------------------------------------------------\n    // Advanced reading\n    //-------------------------------------------------------------------------\n\n    /**\n     * Reads up to and including the given string. Throws an error if that\n     * string is not found.\n     * @param {String} pattern The string to read.\n     * @return {String} The string when it is found.\n     * @throws Error when the string pattern is not found.\n     * @method readTo\n     */\n    readTo: function(pattern){\n\n        var buffer = \"\",\n            c;\n\n        /*\n         * First, buffer must be the same length as the pattern.\n         * Then, buffer must end with the pattern or else reach the\n         * end of the input.\n         */\n        while (buffer.length < pattern.length || buffer.lastIndexOf(pattern) !== buffer.length - pattern.length){\n            c = this.read();\n            if (c){\n                buffer += c;\n            } else {\n                throw new Error(\"Expected \\\"\" + pattern + \"\\\" at line \" + this._line  + \", col \" + this._col + \".\");\n            }\n        }\n\n        return buffer;\n\n    },\n\n    /**\n     * Reads characters while each character causes the given\n     * filter function to return true. The function is passed\n     * in each character and either returns true to continue\n     * reading or false to stop.\n     * @param {Function} filter The function to read on each character.\n     * @return {String} The string made up of all characters that passed the\n     *      filter check.\n     * @method readWhile\n     */\n    readWhile: function(filter){\n\n        var buffer = \"\",\n            c = this.read();\n\n        while(c !== null && filter(c)){\n            buffer += c;\n            c = this.read();\n        }\n\n        return buffer;\n\n    },\n\n    /**\n     * Reads characters that match either text or a regular expression and\n     * returns those characters. If a match is found, the row and column\n     * are adjusted; if no match is found, the reader's state is unchanged.\n     * reading or false to stop.\n     * @param {String|RegExp} matchter If a string, then the literal string\n     *      value is searched for. If a regular expression, then any string\n     *      matching the pattern is search for.\n     * @return {String} The string made up of all characters that matched or\n     *      null if there was no match.\n     * @method readMatch\n     */\n    readMatch: function(matcher){\n\n        var source = this._input.substring(this._cursor),\n            value = null;\n\n        //if it's a string, just do a straight match\n        if (typeof matcher === \"string\"){\n            if (source.indexOf(matcher) === 0){\n                value = this.readCount(matcher.length);\n            }\n        } else if (matcher instanceof RegExp){\n            if (matcher.test(source)){\n                value = this.readCount(RegExp.lastMatch.length);\n            }\n        }\n\n        return value;\n    },\n\n\n    /**\n     * Reads a given number of characters. If the end of the input is reached,\n     * it reads only the remaining characters and does not throw an error.\n     * @param {int} count The number of characters to read.\n     * @return {String} The string made up the read characters.\n     * @method readCount\n     */\n    readCount: function(count){\n        var buffer = \"\";\n\n        while(count--){\n            buffer += this.read();\n        }\n\n        return buffer;\n    }\n\n};\n/**\n * Type to use when a syntax error occurs.\n * @class SyntaxError\n * @namespace parserlib.util\n * @constructor\n * @param {String} message The error message.\n * @param {int} line The line at which the error occurred.\n * @param {int} col The column at which the error occurred.\n */\nfunction SyntaxError(message, line, col){\n    Error.call(this);\n    this.name = this.constructor.name;\n\n    /**\n     * The column at which the error occurred.\n     * @type int\n     * @property col\n     */\n    this.col = col;\n\n    /**\n     * The line at which the error occurred.\n     * @type int\n     * @property line\n     */\n    this.line = line;\n\n    /**\n     * The text representation of the unit.\n     * @type String\n     * @property text\n     */\n    this.message = message;\n\n}\n\n//inherit from Error\nSyntaxError.prototype = Object.create(Error.prototype); // jshint ignore:line\nSyntaxError.prototype.constructor = SyntaxError; // jshint ignore:line\n/**\n * Base type to represent a single syntactic unit.\n * @class SyntaxUnit\n * @namespace parserlib.util\n * @constructor\n * @param {String} text The text of the unit.\n * @param {int} line The line of text on which the unit resides.\n * @param {int} col The column of text on which the unit resides.\n */\nfunction SyntaxUnit(text, line, col, type){\n\n\n    /**\n     * The column of text on which the unit resides.\n     * @type int\n     * @property col\n     */\n    this.col = col;\n\n    /**\n     * The line of text on which the unit resides.\n     * @type int\n     * @property line\n     */\n    this.line = line;\n\n    /**\n     * The text representation of the unit.\n     * @type String\n     * @property text\n     */\n    this.text = text;\n\n    /**\n     * The type of syntax unit.\n     * @type int\n     * @property type\n     */\n    this.type = type;\n}\n\n/**\n * Create a new syntax unit based solely on the given token.\n * Convenience method for creating a new syntax unit when\n * it represents a single token instead of multiple.\n * @param {Object} token The token object to represent.\n * @return {parserlib.util.SyntaxUnit} The object representing the token.\n * @static\n * @method fromToken\n */\nSyntaxUnit.fromToken = function(token){\n    return new SyntaxUnit(token.value, token.startLine, token.startCol);\n};\n\nSyntaxUnit.prototype = {\n\n    //restore constructor\n    constructor: SyntaxUnit,\n\n    /**\n     * Returns the text representation of the unit.\n     * @return {String} The text representation of the unit.\n     * @method valueOf\n     */\n    valueOf: function(){\n        return this.toString();\n    },\n\n    /**\n     * Returns the text representation of the unit.\n     * @return {String} The text representation of the unit.\n     * @method toString\n     */\n    toString: function(){\n        return this.text;\n    }\n\n};\n\n/**\n * Generic TokenStream providing base functionality.\n * @class TokenStreamBase\n * @namespace parserlib.util\n * @constructor\n * @param {String|StringReader} input The text to tokenize or a reader from\n *      which to read the input.\n */\nfunction TokenStreamBase(input, tokenData){\n\n    /**\n     * The string reader for easy access to the text.\n     * @type StringReader\n     * @property _reader\n     * @private\n     */\n    this._reader = input ? new StringReader(input.toString()) : null;\n\n    /**\n     * Token object for the last consumed token.\n     * @type Token\n     * @property _token\n     * @private\n     */\n    this._token = null;\n\n    /**\n     * The array of token information.\n     * @type Array\n     * @property _tokenData\n     * @private\n     */\n    this._tokenData = tokenData;\n\n    /**\n     * Lookahead token buffer.\n     * @type Array\n     * @property _lt\n     * @private\n     */\n    this._lt = [];\n\n    /**\n     * Lookahead token buffer index.\n     * @type int\n     * @property _ltIndex\n     * @private\n     */\n    this._ltIndex = 0;\n\n    this._ltIndexCache = [];\n}\n\n/**\n * Accepts an array of token information and outputs\n * an array of token data containing key-value mappings\n * and matching functions that the TokenStream needs.\n * @param {Array} tokens An array of token descriptors.\n * @return {Array} An array of processed token data.\n * @method createTokenData\n * @static\n */\nTokenStreamBase.createTokenData = function(tokens){\n\n    var nameMap     = [],\n        typeMap     = Object.create(null),\n        tokenData     = tokens.concat([]),\n        i            = 0,\n        len            = tokenData.length+1;\n\n    tokenData.UNKNOWN = -1;\n    tokenData.unshift({name:\"EOF\"});\n\n    for (; i < len; i++){\n        nameMap.push(tokenData[i].name);\n        tokenData[tokenData[i].name] = i;\n        if (tokenData[i].text){\n            typeMap[tokenData[i].text] = i;\n        }\n    }\n\n    tokenData.name = function(tt){\n        return nameMap[tt];\n    };\n\n    tokenData.type = function(c){\n        return typeMap[c];\n    };\n\n    return tokenData;\n};\n\nTokenStreamBase.prototype = {\n\n    //restore constructor\n    constructor: TokenStreamBase,\n\n    //-------------------------------------------------------------------------\n    // Matching methods\n    //-------------------------------------------------------------------------\n\n    /**\n     * Determines if the next token matches the given token type.\n     * If so, that token is consumed; if not, the token is placed\n     * back onto the token stream. You can pass in any number of\n     * token types and this will return true if any of the token\n     * types is found.\n     * @param {int|int[]} tokenTypes Either a single token type or an array of\n     *      token types that the next token might be. If an array is passed,\n     *      it's assumed that the token can be any of these.\n     * @param {variant} channel (Optional) The channel to read from. If not\n     *      provided, reads from the default (unnamed) channel.\n     * @return {Boolean} True if the token type matches, false if not.\n     * @method match\n     */\n    match: function(tokenTypes, channel){\n\n        //always convert to an array, makes things easier\n        if (!(tokenTypes instanceof Array)){\n            tokenTypes = [tokenTypes];\n        }\n\n        var tt  = this.get(channel),\n            i   = 0,\n            len = tokenTypes.length;\n\n        while(i < len){\n            if (tt === tokenTypes[i++]){\n                return true;\n            }\n        }\n\n        //no match found, put the token back\n        this.unget();\n        return false;\n    },\n\n    /**\n     * Determines if the next token matches the given token type.\n     * If so, that token is consumed; if not, an error is thrown.\n     * @param {int|int[]} tokenTypes Either a single token type or an array of\n     *      token types that the next token should be. If an array is passed,\n     *      it's assumed that the token must be one of these.\n     * @param {variant} channel (Optional) The channel to read from. If not\n     *      provided, reads from the default (unnamed) channel.\n     * @return {void}\n     * @method mustMatch\n     */\n    mustMatch: function(tokenTypes, channel){\n\n        var token;\n\n        //always convert to an array, makes things easier\n        if (!(tokenTypes instanceof Array)){\n            tokenTypes = [tokenTypes];\n        }\n\n        if (!this.match.apply(this, arguments)){\n            token = this.LT(1);\n            throw new SyntaxError(\"Expected \" + this._tokenData[tokenTypes[0]].name +\n                \" at line \" + token.startLine + \", col \" + token.startCol + \".\", token.startLine, token.startCol);\n        }\n    },\n\n    //-------------------------------------------------------------------------\n    // Consuming methods\n    //-------------------------------------------------------------------------\n\n    /**\n     * Keeps reading from the token stream until either one of the specified\n     * token types is found or until the end of the input is reached.\n     * @param {int|int[]} tokenTypes Either a single token type or an array of\n     *      token types that the next token should be. If an array is passed,\n     *      it's assumed that the token must be one of these.\n     * @param {variant} channel (Optional) The channel to read from. If not\n     *      provided, reads from the default (unnamed) channel.\n     * @return {void}\n     * @method advance\n     */\n    advance: function(tokenTypes, channel){\n\n        while(this.LA(0) !== 0 && !this.match(tokenTypes, channel)){\n            this.get();\n        }\n\n        return this.LA(0);\n    },\n\n    /**\n     * Consumes the next token from the token stream.\n     * @return {int} The token type of the token that was just consumed.\n     * @method get\n     */\n    get: function(channel){\n\n        var tokenInfo   = this._tokenData,\n            i           =0,\n            token,\n            info;\n\n        //check the lookahead buffer first\n        if (this._lt.length && this._ltIndex >= 0 && this._ltIndex < this._lt.length){\n\n            i++;\n            this._token = this._lt[this._ltIndex++];\n            info = tokenInfo[this._token.type];\n\n            //obey channels logic\n            while((info.channel !== undefined && channel !== info.channel) &&\n                    this._ltIndex < this._lt.length){\n                this._token = this._lt[this._ltIndex++];\n                info = tokenInfo[this._token.type];\n                i++;\n            }\n\n            //here be dragons\n            if ((info.channel === undefined || channel === info.channel) &&\n                    this._ltIndex <= this._lt.length){\n                this._ltIndexCache.push(i);\n                return this._token.type;\n            }\n        }\n\n        //call token retriever method\n        token = this._getToken();\n\n        //if it should be hidden, don't save a token\n        if (token.type > -1 && !tokenInfo[token.type].hide){\n\n            //apply token channel\n            token.channel = tokenInfo[token.type].channel;\n\n            //save for later\n            this._token = token;\n            this._lt.push(token);\n\n            //save space that will be moved (must be done before array is truncated)\n            this._ltIndexCache.push(this._lt.length - this._ltIndex + i);\n\n            //keep the buffer under 5 items\n            if (this._lt.length > 5){\n                this._lt.shift();\n            }\n\n            //also keep the shift buffer under 5 items\n            if (this._ltIndexCache.length > 5){\n                this._ltIndexCache.shift();\n            }\n\n            //update lookahead index\n            this._ltIndex = this._lt.length;\n        }\n\n        /*\n         * Skip to the next token if:\n         * 1. The token type is marked as hidden.\n         * 2. The token type has a channel specified and it isn't the current channel.\n         */\n        info = tokenInfo[token.type];\n        if (info &&\n                (info.hide ||\n                (info.channel !== undefined && channel !== info.channel))){\n            return this.get(channel);\n        } else {\n            //return just the type\n            return token.type;\n        }\n    },\n\n    /**\n     * Looks ahead a certain number of tokens and returns the token type at\n     * that position. This will throw an error if you lookahead past the\n     * end of input, past the size of the lookahead buffer, or back past\n     * the first token in the lookahead buffer.\n     * @param {int} The index of the token type to retrieve. 0 for the\n     *      current token, 1 for the next, -1 for the previous, etc.\n     * @return {int} The token type of the token in the given position.\n     * @method LA\n     */\n    LA: function(index){\n        var total = index,\n            tt;\n        if (index > 0){\n            //TODO: Store 5 somewhere\n            if (index > 5){\n                throw new Error(\"Too much lookahead.\");\n            }\n\n            //get all those tokens\n            while(total){\n                tt = this.get();\n                total--;\n            }\n\n            //unget all those tokens\n            while(total < index){\n                this.unget();\n                total++;\n            }\n        } else if (index < 0){\n\n            if(this._lt[this._ltIndex+index]){\n                tt = this._lt[this._ltIndex+index].type;\n            } else {\n                throw new Error(\"Too much lookbehind.\");\n            }\n\n        } else {\n            tt = this._token.type;\n        }\n\n        return tt;\n\n    },\n\n    /**\n     * Looks ahead a certain number of tokens and returns the token at\n     * that position. This will throw an error if you lookahead past the\n     * end of input, past the size of the lookahead buffer, or back past\n     * the first token in the lookahead buffer.\n     * @param {int} The index of the token type to retrieve. 0 for the\n     *      current token, 1 for the next, -1 for the previous, etc.\n     * @return {Object} The token of the token in the given position.\n     * @method LA\n     */\n    LT: function(index){\n\n        //lookahead first to prime the token buffer\n        this.LA(index);\n\n        //now find the token, subtract one because _ltIndex is already at the next index\n        return this._lt[this._ltIndex+index-1];\n    },\n\n    /**\n     * Returns the token type for the next token in the stream without\n     * consuming it.\n     * @return {int} The token type of the next token in the stream.\n     * @method peek\n     */\n    peek: function(){\n        return this.LA(1);\n    },\n\n    /**\n     * Returns the actual token object for the last consumed token.\n     * @return {Token} The token object for the last consumed token.\n     * @method token\n     */\n    token: function(){\n        return this._token;\n    },\n\n    /**\n     * Returns the name of the token for the given token type.\n     * @param {int} tokenType The type of token to get the name of.\n     * @return {String} The name of the token or \"UNKNOWN_TOKEN\" for any\n     *      invalid token type.\n     * @method tokenName\n     */\n    tokenName: function(tokenType){\n        if (tokenType < 0 || tokenType > this._tokenData.length){\n            return \"UNKNOWN_TOKEN\";\n        } else {\n            return this._tokenData[tokenType].name;\n        }\n    },\n\n    /**\n     * Returns the token type value for the given token name.\n     * @param {String} tokenName The name of the token whose value should be returned.\n     * @return {int} The token type value for the given token name or -1\n     *      for an unknown token.\n     * @method tokenName\n     */\n    tokenType: function(tokenName){\n        return this._tokenData[tokenName] || -1;\n    },\n\n    /**\n     * Returns the last consumed token to the token stream.\n     * @method unget\n     */\n    unget: function(){\n        //if (this._ltIndex > -1){\n        if (this._ltIndexCache.length){\n            this._ltIndex -= this._ltIndexCache.pop();//--;\n            this._token = this._lt[this._ltIndex - 1];\n        } else {\n            throw new Error(\"Too much lookahead.\");\n        }\n    }\n\n};\n\n\nparserlib.util = {\n__proto__   : null,\nStringReader: StringReader,\nSyntaxError : SyntaxError,\nSyntaxUnit  : SyntaxUnit,\nEventTarget : EventTarget,\nTokenStreamBase : TokenStreamBase\n};\n})();\n/*\nParser-Lib\nCopyright (c) 2009-2011 Nicholas C. Zakas. All rights reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n/* Version v0.2.5+domino1, Build time: 30-January-2016 05:13:03 */\n(function(){\nvar EventTarget = parserlib.util.EventTarget,\nTokenStreamBase = parserlib.util.TokenStreamBase,\nStringReader = parserlib.util.StringReader, // jshint ignore:line\nSyntaxError = parserlib.util.SyntaxError,\nSyntaxUnit  = parserlib.util.SyntaxUnit;\n\nvar Colors = {\n    __proto__       :null,\n    aliceblue       :\"#f0f8ff\",\n    antiquewhite    :\"#faebd7\",\n    aqua            :\"#00ffff\",\n    aquamarine      :\"#7fffd4\",\n    azure           :\"#f0ffff\",\n    beige           :\"#f5f5dc\",\n    bisque          :\"#ffe4c4\",\n    black           :\"#000000\",\n    blanchedalmond  :\"#ffebcd\",\n    blue            :\"#0000ff\",\n    blueviolet      :\"#8a2be2\",\n    brown           :\"#a52a2a\",\n    burlywood       :\"#deb887\",\n    cadetblue       :\"#5f9ea0\",\n    chartreuse      :\"#7fff00\",\n    chocolate       :\"#d2691e\",\n    coral           :\"#ff7f50\",\n    cornflowerblue  :\"#6495ed\",\n    cornsilk        :\"#fff8dc\",\n    crimson         :\"#dc143c\",\n    cyan            :\"#00ffff\",\n    darkblue        :\"#00008b\",\n    darkcyan        :\"#008b8b\",\n    darkgoldenrod   :\"#b8860b\",\n    darkgray        :\"#a9a9a9\",\n    darkgrey        :\"#a9a9a9\",\n    darkgreen       :\"#006400\",\n    darkkhaki       :\"#bdb76b\",\n    darkmagenta     :\"#8b008b\",\n    darkolivegreen  :\"#556b2f\",\n    darkorange      :\"#ff8c00\",\n    darkorchid      :\"#9932cc\",\n    darkred         :\"#8b0000\",\n    darksalmon      :\"#e9967a\",\n    darkseagreen    :\"#8fbc8f\",\n    darkslateblue   :\"#483d8b\",\n    darkslategray   :\"#2f4f4f\",\n    darkslategrey   :\"#2f4f4f\",\n    darkturquoise   :\"#00ced1\",\n    darkviolet      :\"#9400d3\",\n    deeppink        :\"#ff1493\",\n    deepskyblue     :\"#00bfff\",\n    dimgray         :\"#696969\",\n    dimgrey         :\"#696969\",\n    dodgerblue      :\"#1e90ff\",\n    firebrick       :\"#b22222\",\n    floralwhite     :\"#fffaf0\",\n    forestgreen     :\"#228b22\",\n    fuchsia         :\"#ff00ff\",\n    gainsboro       :\"#dcdcdc\",\n    ghostwhite      :\"#f8f8ff\",\n    gold            :\"#ffd700\",\n    goldenrod       :\"#daa520\",\n    gray            :\"#808080\",\n    grey            :\"#808080\",\n    green           :\"#008000\",\n    greenyellow     :\"#adff2f\",\n    honeydew        :\"#f0fff0\",\n    hotpink         :\"#ff69b4\",\n    indianred       :\"#cd5c5c\",\n    indigo          :\"#4b0082\",\n    ivory           :\"#fffff0\",\n    khaki           :\"#f0e68c\",\n    lavender        :\"#e6e6fa\",\n    lavenderblush   :\"#fff0f5\",\n    lawngreen       :\"#7cfc00\",\n    lemonchiffon    :\"#fffacd\",\n    lightblue       :\"#add8e6\",\n    lightcoral      :\"#f08080\",\n    lightcyan       :\"#e0ffff\",\n    lightgoldenrodyellow  :\"#fafad2\",\n    lightgray       :\"#d3d3d3\",\n    lightgrey       :\"#d3d3d3\",\n    lightgreen      :\"#90ee90\",\n    lightpink       :\"#ffb6c1\",\n    lightsalmon     :\"#ffa07a\",\n    lightseagreen   :\"#20b2aa\",\n    lightskyblue    :\"#87cefa\",\n    lightslategray  :\"#778899\",\n    lightslategrey  :\"#778899\",\n    lightsteelblue  :\"#b0c4de\",\n    lightyellow     :\"#ffffe0\",\n    lime            :\"#00ff00\",\n    limegreen       :\"#32cd32\",\n    linen           :\"#faf0e6\",\n    magenta         :\"#ff00ff\",\n    maroon          :\"#800000\",\n    mediumaquamarine:\"#66cdaa\",\n    mediumblue      :\"#0000cd\",\n    mediumorchid    :\"#ba55d3\",\n    mediumpurple    :\"#9370d8\",\n    mediumseagreen  :\"#3cb371\",\n    mediumslateblue :\"#7b68ee\",\n    mediumspringgreen   :\"#00fa9a\",\n    mediumturquoise :\"#48d1cc\",\n    mediumvioletred :\"#c71585\",\n    midnightblue    :\"#191970\",\n    mintcream       :\"#f5fffa\",\n    mistyrose       :\"#ffe4e1\",\n    moccasin        :\"#ffe4b5\",\n    navajowhite     :\"#ffdead\",\n    navy            :\"#000080\",\n    oldlace         :\"#fdf5e6\",\n    olive           :\"#808000\",\n    olivedrab       :\"#6b8e23\",\n    orange          :\"#ffa500\",\n    orangered       :\"#ff4500\",\n    orchid          :\"#da70d6\",\n    palegoldenrod   :\"#eee8aa\",\n    palegreen       :\"#98fb98\",\n    paleturquoise   :\"#afeeee\",\n    palevioletred   :\"#d87093\",\n    papayawhip      :\"#ffefd5\",\n    peachpuff       :\"#ffdab9\",\n    peru            :\"#cd853f\",\n    pink            :\"#ffc0cb\",\n    plum            :\"#dda0dd\",\n    powderblue      :\"#b0e0e6\",\n    purple          :\"#800080\",\n    red             :\"#ff0000\",\n    rosybrown       :\"#bc8f8f\",\n    royalblue       :\"#4169e1\",\n    saddlebrown     :\"#8b4513\",\n    salmon          :\"#fa8072\",\n    sandybrown      :\"#f4a460\",\n    seagreen        :\"#2e8b57\",\n    seashell        :\"#fff5ee\",\n    sienna          :\"#a0522d\",\n    silver          :\"#c0c0c0\",\n    skyblue         :\"#87ceeb\",\n    slateblue       :\"#6a5acd\",\n    slategray       :\"#708090\",\n    slategrey       :\"#708090\",\n    snow            :\"#fffafa\",\n    springgreen     :\"#00ff7f\",\n    steelblue       :\"#4682b4\",\n    tan             :\"#d2b48c\",\n    teal            :\"#008080\",\n    thistle         :\"#d8bfd8\",\n    tomato          :\"#ff6347\",\n    turquoise       :\"#40e0d0\",\n    violet          :\"#ee82ee\",\n    wheat           :\"#f5deb3\",\n    white           :\"#ffffff\",\n    whitesmoke      :\"#f5f5f5\",\n    yellow          :\"#ffff00\",\n    yellowgreen     :\"#9acd32\",\n    //'currentColor' color keyword http://www.w3.org/TR/css3-color/#currentcolor\n    currentColor        :\"The value of the 'color' property.\",\n    //CSS2 system colors http://www.w3.org/TR/css3-color/#css2-system\n    activeBorder        :\"Active window border.\",\n    activecaption       :\"Active window caption.\",\n    appworkspace        :\"Background color of multiple document interface.\",\n    background          :\"Desktop background.\",\n    buttonface          :\"The face background color for 3-D elements that appear 3-D due to one layer of surrounding border.\",\n    buttonhighlight     :\"The color of the border facing the light source for 3-D elements that appear 3-D due to one layer of surrounding border.\",\n    buttonshadow        :\"The color of the border away from the light source for 3-D elements that appear 3-D due to one layer of surrounding border.\",\n    buttontext          :\"Text on push buttons.\",\n    captiontext         :\"Text in caption, size box, and scrollbar arrow box.\",\n    graytext            :\"Grayed (disabled) text. This color is set to #000 if the current display driver does not support a solid gray color.\",\n    greytext            :\"Greyed (disabled) text. This color is set to #000 if the current display driver does not support a solid grey color.\",\n    highlight           :\"Item(s) selected in a control.\",\n    highlighttext       :\"Text of item(s) selected in a control.\",\n    inactiveborder      :\"Inactive window border.\",\n    inactivecaption     :\"Inactive window caption.\",\n    inactivecaptiontext :\"Color of text in an inactive caption.\",\n    infobackground      :\"Background color for tooltip controls.\",\n    infotext            :\"Text color for tooltip controls.\",\n    menu                :\"Menu background.\",\n    menutext            :\"Text in menus.\",\n    scrollbar           :\"Scroll bar gray area.\",\n    threeddarkshadow    :\"The color of the darker (generally outer) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\n    threedface          :\"The face background color for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\n    threedhighlight     :\"The color of the lighter (generally outer) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\n    threedlightshadow   :\"The color of the darker (generally inner) of the two borders facing the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\n    threedshadow        :\"The color of the lighter (generally inner) of the two borders away from the light source for 3-D elements that appear 3-D due to two concentric layers of surrounding border.\",\n    window              :\"Window background.\",\n    windowframe         :\"Window frame.\",\n    windowtext          :\"Text in windows.\"\n};\n/**\n * Represents a selector combinator (whitespace, +, >).\n * @namespace parserlib.css\n * @class Combinator\n * @extends parserlib.util.SyntaxUnit\n * @constructor\n * @param {String} text The text representation of the unit.\n * @param {int} line The line of text on which the unit resides.\n * @param {int} col The column of text on which the unit resides.\n */\nfunction Combinator(text, line, col){\n\n    SyntaxUnit.call(this, text, line, col, Parser.COMBINATOR_TYPE);\n\n    /**\n     * The type of modifier.\n     * @type String\n     * @property type\n     */\n    this.type = \"unknown\";\n\n    //pretty simple\n    if (/^\\s+$/.test(text)){\n        this.type = \"descendant\";\n    } else if (text === \">\"){\n        this.type = \"child\";\n    } else if (text === \"+\"){\n        this.type = \"adjacent-sibling\";\n    } else if (text === \"~\"){\n        this.type = \"sibling\";\n    }\n\n}\n\nCombinator.prototype = new SyntaxUnit();\nCombinator.prototype.constructor = Combinator;\n\n/**\n * Represents a media feature, such as max-width:500.\n * @namespace parserlib.css\n * @class MediaFeature\n * @extends parserlib.util.SyntaxUnit\n * @constructor\n * @param {SyntaxUnit} name The name of the feature.\n * @param {SyntaxUnit} value The value of the feature or null if none.\n */\nfunction MediaFeature(name, value){\n\n    SyntaxUnit.call(this, \"(\" + name + (value !== null ? \":\" + value : \"\") + \")\", name.startLine, name.startCol, Parser.MEDIA_FEATURE_TYPE);\n\n    /**\n     * The name of the media feature\n     * @type String\n     * @property name\n     */\n    this.name = name;\n\n    /**\n     * The value for the feature or null if there is none.\n     * @type SyntaxUnit\n     * @property value\n     */\n    this.value = value;\n}\n\nMediaFeature.prototype = new SyntaxUnit();\nMediaFeature.prototype.constructor = MediaFeature;\n\n/**\n * Represents an individual media query.\n * @namespace parserlib.css\n * @class MediaQuery\n * @extends parserlib.util.SyntaxUnit\n * @constructor\n * @param {String} modifier The modifier \"not\" or \"only\" (or null).\n * @param {String} mediaType The type of media (i.e., \"print\").\n * @param {Array} parts Array of selectors parts making up this selector.\n * @param {int} line The line of text on which the unit resides.\n * @param {int} col The column of text on which the unit resides.\n */\nfunction MediaQuery(modifier, mediaType, features, line, col){\n\n    SyntaxUnit.call(this, (modifier ? modifier + \" \": \"\") + (mediaType ? mediaType : \"\") + (mediaType && features.length > 0 ? \" and \" : \"\") + features.join(\" and \"), line, col, Parser.MEDIA_QUERY_TYPE);\n\n    /**\n     * The media modifier (\"not\" or \"only\")\n     * @type String\n     * @property modifier\n     */\n    this.modifier = modifier;\n\n    /**\n     * The mediaType (i.e., \"print\")\n     * @type String\n     * @property mediaType\n     */\n    this.mediaType = mediaType;\n\n    /**\n     * The parts that make up the selector.\n     * @type Array\n     * @property features\n     */\n    this.features = features;\n\n}\n\nMediaQuery.prototype = new SyntaxUnit();\nMediaQuery.prototype.constructor = MediaQuery;\n\n\n/**\n * A CSS3 parser.\n * @namespace parserlib.css\n * @class Parser\n * @constructor\n * @param {Object} options (Optional) Various options for the parser:\n *      starHack (true|false) to allow IE6 star hack as valid,\n *      underscoreHack (true|false) to interpret leading underscores\n *      as IE6-7 targeting for known properties, ieFilters (true|false)\n *      to indicate that IE < 8 filters should be accepted and not throw\n *      syntax errors.\n */\nfunction Parser(options){\n\n    //inherit event functionality\n    EventTarget.call(this);\n\n\n    this.options = options || {};\n\n    this._tokenStream = null;\n}\n\n//Static constants\nParser.DEFAULT_TYPE = 0;\nParser.COMBINATOR_TYPE = 1;\nParser.MEDIA_FEATURE_TYPE = 2;\nParser.MEDIA_QUERY_TYPE = 3;\nParser.PROPERTY_NAME_TYPE = 4;\nParser.PROPERTY_VALUE_TYPE = 5;\nParser.PROPERTY_VALUE_PART_TYPE = 6;\nParser.SELECTOR_TYPE = 7;\nParser.SELECTOR_PART_TYPE = 8;\nParser.SELECTOR_SUB_PART_TYPE = 9;\n\nParser.prototype = function(){\n\n    var proto = new EventTarget(),  //new prototype\n        prop,\n        additions =  {\n            __proto__: null,\n\n            //restore constructor\n            constructor: Parser,\n\n            //instance constants - yuck\n            DEFAULT_TYPE : 0,\n            COMBINATOR_TYPE : 1,\n            MEDIA_FEATURE_TYPE : 2,\n            MEDIA_QUERY_TYPE : 3,\n            PROPERTY_NAME_TYPE : 4,\n            PROPERTY_VALUE_TYPE : 5,\n            PROPERTY_VALUE_PART_TYPE : 6,\n            SELECTOR_TYPE : 7,\n            SELECTOR_PART_TYPE : 8,\n            SELECTOR_SUB_PART_TYPE : 9,\n\n            //-----------------------------------------------------------------\n            // Grammar\n            //-----------------------------------------------------------------\n\n            _stylesheet: function(){\n\n                /*\n                 * stylesheet\n                 *  : [ CHARSET_SYM S* STRING S* ';' ]?\n                 *    [S|CDO|CDC]* [ import [S|CDO|CDC]* ]*\n                 *    [ namespace [S|CDO|CDC]* ]*\n                 *    [ [ ruleset | media | page | font_face | keyframes ] [S|CDO|CDC]* ]*\n                 *  ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    count,\n                    token,\n                    tt;\n\n                this.fire(\"startstylesheet\");\n\n                //try to read character set\n                this._charset();\n\n                this._skipCruft();\n\n                //try to read imports - may be more than one\n                while (tokenStream.peek() === Tokens.IMPORT_SYM){\n                    this._import();\n                    this._skipCruft();\n                }\n\n                //try to read namespaces - may be more than one\n                while (tokenStream.peek() === Tokens.NAMESPACE_SYM){\n                    this._namespace();\n                    this._skipCruft();\n                }\n\n                //get the next token\n                tt = tokenStream.peek();\n\n                //try to read the rest\n                while(tt > Tokens.EOF){\n\n                    try {\n\n                        switch(tt){\n                            case Tokens.MEDIA_SYM:\n                                this._media();\n                                this._skipCruft();\n                                break;\n                            case Tokens.PAGE_SYM:\n                                this._page();\n                                this._skipCruft();\n                                break;\n                            case Tokens.FONT_FACE_SYM:\n                                this._font_face();\n                                this._skipCruft();\n                                break;\n                            case Tokens.KEYFRAMES_SYM:\n                                this._keyframes();\n                                this._skipCruft();\n                                break;\n                            case Tokens.VIEWPORT_SYM:\n                                this._viewport();\n                                this._skipCruft();\n                                break;\n                            case Tokens.DOCUMENT_SYM:\n                                this._document();\n                                this._skipCruft();\n                                break;\n                            case Tokens.UNKNOWN_SYM:  //unknown @ rule\n                                tokenStream.get();\n                                if (!this.options.strict){\n\n                                    //fire error event\n                                    this.fire({\n                                        type:       \"error\",\n                                        error:      null,\n                                        message:    \"Unknown @ rule: \" + tokenStream.LT(0).value + \".\",\n                                        line:       tokenStream.LT(0).startLine,\n                                        col:        tokenStream.LT(0).startCol\n                                    });\n\n                                    //skip braces\n                                    count=0;\n                                    while (tokenStream.advance([Tokens.LBRACE, Tokens.RBRACE]) === Tokens.LBRACE){\n                                        count++;    //keep track of nesting depth\n                                    }\n\n                                    while(count){\n                                        tokenStream.advance([Tokens.RBRACE]);\n                                        count--;\n                                    }\n\n                                } else {\n                                    //not a syntax error, rethrow it\n                                    throw new SyntaxError(\"Unknown @ rule.\", tokenStream.LT(0).startLine, tokenStream.LT(0).startCol);\n                                }\n                                break;\n                            case Tokens.S:\n                                this._readWhitespace();\n                                break;\n                            default:\n                                if(!this._ruleset()){\n\n                                    //error handling for known issues\n                                    switch(tt){\n                                        case Tokens.CHARSET_SYM:\n                                            token = tokenStream.LT(1);\n                                            this._charset(false);\n                                            throw new SyntaxError(\"@charset not allowed here.\", token.startLine, token.startCol);\n                                        case Tokens.IMPORT_SYM:\n                                            token = tokenStream.LT(1);\n                                            this._import(false);\n                                            throw new SyntaxError(\"@import not allowed here.\", token.startLine, token.startCol);\n                                        case Tokens.NAMESPACE_SYM:\n                                            token = tokenStream.LT(1);\n                                            this._namespace(false);\n                                            throw new SyntaxError(\"@namespace not allowed here.\", token.startLine, token.startCol);\n                                        default:\n                                            tokenStream.get();  //get the last token\n                                            this._unexpectedToken(tokenStream.token());\n                                    }\n\n                                }\n                        }\n                    } catch(ex) {\n                        if (ex instanceof SyntaxError && !this.options.strict){\n                            this.fire({\n                                type:       \"error\",\n                                error:      ex,\n                                message:    ex.message,\n                                line:       ex.line,\n                                col:        ex.col\n                            });\n                        } else {\n                            throw ex;\n                        }\n                    }\n\n                    tt = tokenStream.peek();\n                }\n\n                if (tt !== Tokens.EOF){\n                    this._unexpectedToken(tokenStream.token());\n                }\n\n                this.fire(\"endstylesheet\");\n            },\n\n            _charset: function(emit){\n                var tokenStream = this._tokenStream,\n                    charset,\n                    token,\n                    line,\n                    col;\n\n                if (tokenStream.match(Tokens.CHARSET_SYM)){\n                    line = tokenStream.token().startLine;\n                    col = tokenStream.token().startCol;\n\n                    this._readWhitespace();\n                    tokenStream.mustMatch(Tokens.STRING);\n\n                    token = tokenStream.token();\n                    charset = token.value;\n\n                    this._readWhitespace();\n                    tokenStream.mustMatch(Tokens.SEMICOLON);\n\n                    if (emit !== false){\n                        this.fire({\n                            type:   \"charset\",\n                            charset:charset,\n                            line:   line,\n                            col:    col\n                        });\n                    }\n                }\n            },\n\n            _import: function(emit){\n                /*\n                 * import\n                 *   : IMPORT_SYM S*\n                 *    [STRING|URI] S* media_query_list? ';' S*\n                 */\n\n                var tokenStream = this._tokenStream,\n                    uri,\n                    importToken,\n                    mediaList   = [];\n\n                //read import symbol\n                tokenStream.mustMatch(Tokens.IMPORT_SYM);\n                importToken = tokenStream.token();\n                this._readWhitespace();\n\n                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);\n\n                //grab the URI value\n                uri = tokenStream.token().value.replace(/^(?:url\\()?[\"']?([^\"']+?)[\"']?\\)?$/, \"$1\");\n\n                this._readWhitespace();\n\n                mediaList = this._media_query_list();\n\n                //must end with a semicolon\n                tokenStream.mustMatch(Tokens.SEMICOLON);\n                this._readWhitespace();\n\n                if (emit !== false){\n                    this.fire({\n                        type:   \"import\",\n                        uri:    uri,\n                        media:  mediaList,\n                        line:   importToken.startLine,\n                        col:    importToken.startCol\n                    });\n                }\n\n            },\n\n            _namespace: function(emit){\n                /*\n                 * namespace\n                 *   : NAMESPACE_SYM S* [namespace_prefix S*]? [STRING|URI] S* ';' S*\n                 */\n\n                var tokenStream = this._tokenStream,\n                    line,\n                    col,\n                    prefix,\n                    uri;\n\n                //read import symbol\n                tokenStream.mustMatch(Tokens.NAMESPACE_SYM);\n                line = tokenStream.token().startLine;\n                col = tokenStream.token().startCol;\n                this._readWhitespace();\n\n                //it's a namespace prefix - no _namespace_prefix() method because it's just an IDENT\n                if (tokenStream.match(Tokens.IDENT)){\n                    prefix = tokenStream.token().value;\n                    this._readWhitespace();\n                }\n\n                tokenStream.mustMatch([Tokens.STRING, Tokens.URI]);\n                /*if (!tokenStream.match(Tokens.STRING)){\n                    tokenStream.mustMatch(Tokens.URI);\n                }*/\n\n                //grab the URI value\n                uri = tokenStream.token().value.replace(/(?:url\\()?[\"']([^\"']+)[\"']\\)?/, \"$1\");\n\n                this._readWhitespace();\n\n                //must end with a semicolon\n                tokenStream.mustMatch(Tokens.SEMICOLON);\n                this._readWhitespace();\n\n                if (emit !== false){\n                    this.fire({\n                        type:   \"namespace\",\n                        prefix: prefix,\n                        uri:    uri,\n                        line:   line,\n                        col:    col\n                    });\n                }\n\n            },\n\n            _media: function(){\n                /*\n                 * media\n                 *   : MEDIA_SYM S* media_query_list S* '{' S* ruleset* '}' S*\n                 *   ;\n                 */\n                var tokenStream     = this._tokenStream,\n                    line,\n                    col,\n                    mediaList;//       = [];\n\n                //look for @media\n                tokenStream.mustMatch(Tokens.MEDIA_SYM);\n                line = tokenStream.token().startLine;\n                col = tokenStream.token().startCol;\n\n                this._readWhitespace();\n\n                mediaList = this._media_query_list();\n\n                tokenStream.mustMatch(Tokens.LBRACE);\n                this._readWhitespace();\n\n                this.fire({\n                    type:   \"startmedia\",\n                    media:  mediaList,\n                    line:   line,\n                    col:    col\n                });\n\n                while(true) {\n                    if (tokenStream.peek() === Tokens.PAGE_SYM){\n                        this._page();\n                    } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM){\n                        this._font_face();\n                    } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM){\n                        this._viewport();\n                    } else if (tokenStream.peek() === Tokens.DOCUMENT_SYM){\n                        this._document();\n                    } else if (!this._ruleset()){\n                        break;\n                    }\n                }\n\n                tokenStream.mustMatch(Tokens.RBRACE);\n                this._readWhitespace();\n\n                this.fire({\n                    type:   \"endmedia\",\n                    media:  mediaList,\n                    line:   line,\n                    col:    col\n                });\n            },\n\n\n            //CSS3 Media Queries\n            _media_query_list: function(){\n                /*\n                 * media_query_list\n                 *   : S* [media_query [ ',' S* media_query ]* ]?\n                 *   ;\n                 */\n                var tokenStream = this._tokenStream,\n                    mediaList   = [];\n\n\n                this._readWhitespace();\n\n                if (tokenStream.peek() === Tokens.IDENT || tokenStream.peek() === Tokens.LPAREN){\n                    mediaList.push(this._media_query());\n                }\n\n                while(tokenStream.match(Tokens.COMMA)){\n                    this._readWhitespace();\n                    mediaList.push(this._media_query());\n                }\n\n                return mediaList;\n            },\n\n            /*\n             * Note: \"expression\" in the grammar maps to the _media_expression\n             * method.\n\n             */\n            _media_query: function(){\n                /*\n                 * media_query\n                 *   : [ONLY | NOT]? S* media_type S* [ AND S* expression ]*\n                 *   | expression [ AND S* expression ]*\n                 *   ;\n                 */\n                var tokenStream = this._tokenStream,\n                    type        = null,\n                    ident       = null,\n                    token       = null,\n                    expressions = [];\n\n                if (tokenStream.match(Tokens.IDENT)){\n                    ident = tokenStream.token().value.toLowerCase();\n\n                    //since there's no custom tokens for these, need to manually check\n                    if (ident !== \"only\" && ident !== \"not\"){\n                        tokenStream.unget();\n                        ident = null;\n                    } else {\n                        token = tokenStream.token();\n                    }\n                }\n\n                this._readWhitespace();\n\n                if (tokenStream.peek() === Tokens.IDENT){\n                    type = this._media_type();\n                    if (token === null){\n                        token = tokenStream.token();\n                    }\n                } else if (tokenStream.peek() === Tokens.LPAREN){\n                    if (token === null){\n                        token = tokenStream.LT(1);\n                    }\n                    expressions.push(this._media_expression());\n                }\n\n                if (type === null && expressions.length === 0){\n                    return null;\n                } else {\n                    this._readWhitespace();\n                    while (tokenStream.match(Tokens.IDENT)){\n                        if (tokenStream.token().value.toLowerCase() !== \"and\"){\n                            this._unexpectedToken(tokenStream.token());\n                        }\n\n                        this._readWhitespace();\n                        expressions.push(this._media_expression());\n                    }\n                }\n\n                return new MediaQuery(ident, type, expressions, token.startLine, token.startCol);\n            },\n\n            //CSS3 Media Queries\n            _media_type: function(){\n                /*\n                 * media_type\n                 *   : IDENT\n                 *   ;\n                 */\n                return this._media_feature();\n            },\n\n            /**\n             * Note: in CSS3 Media Queries, this is called \"expression\".\n             * Renamed here to avoid conflict with CSS3 Selectors\n             * definition of \"expression\". Also note that \"expr\" in the\n             * grammar now maps to \"expression\" from CSS3 selectors.\n             * @method _media_expression\n             * @private\n             */\n            _media_expression: function(){\n                /*\n                 * expression\n                 *  : '(' S* media_feature S* [ ':' S* expr ]? ')' S*\n                 *  ;\n                 */\n                var tokenStream = this._tokenStream,\n                    feature     = null,\n                    token,\n                    expression  = null;\n\n                tokenStream.mustMatch(Tokens.LPAREN);\n\n                feature = this._media_feature();\n                this._readWhitespace();\n\n                if (tokenStream.match(Tokens.COLON)){\n                    this._readWhitespace();\n                    token = tokenStream.LT(1);\n                    expression = this._expression();\n                }\n\n                tokenStream.mustMatch(Tokens.RPAREN);\n                this._readWhitespace();\n\n                return new MediaFeature(feature, (expression ? new SyntaxUnit(expression, token.startLine, token.startCol) : null));\n            },\n\n            //CSS3 Media Queries\n            _media_feature: function(){\n                /*\n                 * media_feature\n                 *   : IDENT\n                 *   ;\n                 */\n                var tokenStream = this._tokenStream;\n\n                this._readWhitespace();\n\n                tokenStream.mustMatch(Tokens.IDENT);\n\n                return SyntaxUnit.fromToken(tokenStream.token());\n            },\n\n            //CSS3 Paged Media\n            _page: function(){\n                /*\n                 * page:\n                 *    PAGE_SYM S* IDENT? pseudo_page? S*\n                 *    '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*\n                 *    ;\n                 */\n                var tokenStream = this._tokenStream,\n                    line,\n                    col,\n                    identifier  = null,\n                    pseudoPage  = null;\n\n                //look for @page\n                tokenStream.mustMatch(Tokens.PAGE_SYM);\n                line = tokenStream.token().startLine;\n                col = tokenStream.token().startCol;\n\n                this._readWhitespace();\n\n                if (tokenStream.match(Tokens.IDENT)){\n                    identifier = tokenStream.token().value;\n\n                    //The value 'auto' may not be used as a page name and MUST be treated as a syntax error.\n                    if (identifier.toLowerCase() === \"auto\"){\n                        this._unexpectedToken(tokenStream.token());\n                    }\n                }\n\n                //see if there's a colon upcoming\n                if (tokenStream.peek() === Tokens.COLON){\n                    pseudoPage = this._pseudo_page();\n                }\n\n                this._readWhitespace();\n\n                this.fire({\n                    type:   \"startpage\",\n                    id:     identifier,\n                    pseudo: pseudoPage,\n                    line:   line,\n                    col:    col\n                });\n\n                this._readDeclarations(true, true);\n\n                this.fire({\n                    type:   \"endpage\",\n                    id:     identifier,\n                    pseudo: pseudoPage,\n                    line:   line,\n                    col:    col\n                });\n\n            },\n\n            //CSS3 Paged Media\n            _margin: function(){\n                /*\n                 * margin :\n                 *    margin_sym S* '{' declaration [ ';' S* declaration? ]* '}' S*\n                 *    ;\n                 */\n                var tokenStream = this._tokenStream,\n                    line,\n                    col,\n                    marginSym   = this._margin_sym();\n\n                if (marginSym){\n                    line = tokenStream.token().startLine;\n                    col = tokenStream.token().startCol;\n\n                    this.fire({\n                        type: \"startpagemargin\",\n                        margin: marginSym,\n                        line:   line,\n                        col:    col\n                    });\n\n                    this._readDeclarations(true);\n\n                    this.fire({\n                        type: \"endpagemargin\",\n                        margin: marginSym,\n                        line:   line,\n                        col:    col\n                    });\n                    return true;\n                } else {\n                    return false;\n                }\n            },\n\n            //CSS3 Paged Media\n            _margin_sym: function(){\n\n                /*\n                 * margin_sym :\n                 *    TOPLEFTCORNER_SYM |\n                 *    TOPLEFT_SYM |\n                 *    TOPCENTER_SYM |\n                 *    TOPRIGHT_SYM |\n                 *    TOPRIGHTCORNER_SYM |\n                 *    BOTTOMLEFTCORNER_SYM |\n                 *    BOTTOMLEFT_SYM |\n                 *    BOTTOMCENTER_SYM |\n                 *    BOTTOMRIGHT_SYM |\n                 *    BOTTOMRIGHTCORNER_SYM |\n                 *    LEFTTOP_SYM |\n                 *    LEFTMIDDLE_SYM |\n                 *    LEFTBOTTOM_SYM |\n                 *    RIGHTTOP_SYM |\n                 *    RIGHTMIDDLE_SYM |\n                 *    RIGHTBOTTOM_SYM\n                 *    ;\n                 */\n\n                var tokenStream = this._tokenStream;\n\n                if(tokenStream.match([Tokens.TOPLEFTCORNER_SYM, Tokens.TOPLEFT_SYM,\n                        Tokens.TOPCENTER_SYM, Tokens.TOPRIGHT_SYM, Tokens.TOPRIGHTCORNER_SYM,\n                        Tokens.BOTTOMLEFTCORNER_SYM, Tokens.BOTTOMLEFT_SYM,\n                        Tokens.BOTTOMCENTER_SYM, Tokens.BOTTOMRIGHT_SYM,\n                        Tokens.BOTTOMRIGHTCORNER_SYM, Tokens.LEFTTOP_SYM,\n                        Tokens.LEFTMIDDLE_SYM, Tokens.LEFTBOTTOM_SYM, Tokens.RIGHTTOP_SYM,\n                        Tokens.RIGHTMIDDLE_SYM, Tokens.RIGHTBOTTOM_SYM]))\n                {\n                    return SyntaxUnit.fromToken(tokenStream.token());\n                } else {\n                    return null;\n                }\n\n            },\n\n            _pseudo_page: function(){\n                /*\n                 * pseudo_page\n                 *   : ':' IDENT\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream;\n\n                tokenStream.mustMatch(Tokens.COLON);\n                tokenStream.mustMatch(Tokens.IDENT);\n\n                //TODO: CSS3 Paged Media says only \"left\", \"center\", and \"right\" are allowed\n\n                return tokenStream.token().value;\n            },\n\n            _font_face: function(){\n                /*\n                 * font_face\n                 *   : FONT_FACE_SYM S*\n                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*\n                 *   ;\n                 */\n                var tokenStream = this._tokenStream,\n                    line,\n                    col;\n\n                //look for @page\n                tokenStream.mustMatch(Tokens.FONT_FACE_SYM);\n                line = tokenStream.token().startLine;\n                col = tokenStream.token().startCol;\n\n                this._readWhitespace();\n\n                this.fire({\n                    type:   \"startfontface\",\n                    line:   line,\n                    col:    col\n                });\n\n                this._readDeclarations(true);\n\n                this.fire({\n                    type:   \"endfontface\",\n                    line:   line,\n                    col:    col\n                });\n            },\n\n            _viewport: function(){\n                /*\n                 * viewport\n                 *   : VIEWPORT_SYM S*\n                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*\n                 *   ;\n                 */\n                 var tokenStream = this._tokenStream,\n                    line,\n                    col;\n\n                    tokenStream.mustMatch(Tokens.VIEWPORT_SYM);\n                    line = tokenStream.token().startLine;\n                    col = tokenStream.token().startCol;\n\n                    this._readWhitespace();\n\n                    this.fire({\n                        type:   \"startviewport\",\n                        line:   line,\n                        col:    col\n                    });\n\n                    this._readDeclarations(true);\n\n                    this.fire({\n                        type:   \"endviewport\",\n                        line:   line,\n                        col:    col\n                    });\n\n            },\n\n            _document: function(){\n                /*\n                 * document\n                 *   : DOCUMENT_SYM S*\n                 *     _document_function [ ',' S* _document_function ]* S*\n                 *     '{' S* ruleset* '}'\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    token,\n                    functions = [],\n                    prefix = \"\";\n\n                tokenStream.mustMatch(Tokens.DOCUMENT_SYM);\n                token = tokenStream.token();\n                if (/^@\\-([^\\-]+)\\-/.test(token.value)) {\n                    prefix = RegExp.$1;\n                }\n\n                this._readWhitespace();\n                functions.push(this._document_function());\n\n                while(tokenStream.match(Tokens.COMMA)) {\n                    this._readWhitespace();\n                    functions.push(this._document_function());\n                }\n\n                tokenStream.mustMatch(Tokens.LBRACE);\n                this._readWhitespace();\n\n                this.fire({\n                    type:      \"startdocument\",\n                    functions: functions,\n                    prefix:    prefix,\n                    line:      token.startLine,\n                    col:       token.startCol\n                });\n\n                while(true) {\n                    if (tokenStream.peek() === Tokens.PAGE_SYM){\n                        this._page();\n                    } else if (tokenStream.peek() === Tokens.FONT_FACE_SYM){\n                        this._font_face();\n                    } else if (tokenStream.peek() === Tokens.VIEWPORT_SYM){\n                        this._viewport();\n                    } else if (tokenStream.peek() === Tokens.MEDIA_SYM){\n                        this._media();\n                    } else if (!this._ruleset()){\n                        break;\n                    }\n                }\n\n                tokenStream.mustMatch(Tokens.RBRACE);\n                this._readWhitespace();\n\n                this.fire({\n                    type:      \"enddocument\",\n                    functions: functions,\n                    prefix:    prefix,\n                    line:      token.startLine,\n                    col:       token.startCol\n                });\n            },\n\n            _document_function: function(){\n                /*\n                 * document_function\n                 *   : function | URI S*\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    value;\n\n                if (tokenStream.match(Tokens.URI)) {\n                    value = tokenStream.token().value;\n                    this._readWhitespace();\n                } else {\n                    value = this._function();\n                }\n\n                return value;\n            },\n\n            _operator: function(inFunction){\n\n                /*\n                 * operator (outside function)\n                 *  : '/' S* | ',' S* | /( empty )/\n                 * operator (inside function)\n                 *  : '/' S* | '+' S* | '*' S* | '-' S* /( empty )/\n                 *  ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    token       = null;\n\n                if (tokenStream.match([Tokens.SLASH, Tokens.COMMA]) ||\n                    (inFunction && tokenStream.match([Tokens.PLUS, Tokens.STAR, Tokens.MINUS]))){\n                    token =  tokenStream.token();\n                    this._readWhitespace();\n                }\n                return token ? PropertyValuePart.fromToken(token) : null;\n\n            },\n\n            _combinator: function(){\n\n                /*\n                 * combinator\n                 *  : PLUS S* | GREATER S* | TILDE S* | S+\n                 *  ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    value       = null,\n                    token;\n\n                if(tokenStream.match([Tokens.PLUS, Tokens.GREATER, Tokens.TILDE])){\n                    token = tokenStream.token();\n                    value = new Combinator(token.value, token.startLine, token.startCol);\n                    this._readWhitespace();\n                }\n\n                return value;\n            },\n\n            _unary_operator: function(){\n\n                /*\n                 * unary_operator\n                 *  : '-' | '+'\n                 *  ;\n                 */\n\n                var tokenStream = this._tokenStream;\n\n                if (tokenStream.match([Tokens.MINUS, Tokens.PLUS])){\n                    return tokenStream.token().value;\n                } else {\n                    return null;\n                }\n            },\n\n            _property: function(){\n\n                /*\n                 * property\n                 *   : IDENT S*\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    value       = null,\n                    hack        = null,\n                    tokenValue,\n                    token,\n                    line,\n                    col;\n\n                //check for star hack - throws error if not allowed\n                if (tokenStream.peek() === Tokens.STAR && this.options.starHack){\n                    tokenStream.get();\n                    token = tokenStream.token();\n                    hack = token.value;\n                    line = token.startLine;\n                    col = token.startCol;\n                }\n\n                if(tokenStream.match(Tokens.IDENT)){\n                    token = tokenStream.token();\n                    tokenValue = token.value;\n\n                    //check for underscore hack - no error if not allowed because it's valid CSS syntax\n                    if (tokenValue.charAt(0) === \"_\" && this.options.underscoreHack){\n                        hack = \"_\";\n                        tokenValue = tokenValue.substring(1);\n                    }\n\n                    value = new PropertyName(tokenValue, hack, (line||token.startLine), (col||token.startCol));\n                    this._readWhitespace();\n                }\n\n                return value;\n            },\n\n            //Augmented with CSS3 Selectors\n            _ruleset: function(){\n                /*\n                 * ruleset\n                 *   : selectors_group\n                 *     '{' S* declaration? [ ';' S* declaration? ]* '}' S*\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    tt,\n                    selectors;\n\n\n                /*\n                 * Error Recovery: If even a single selector fails to parse,\n                 * then the entire ruleset should be thrown away.\n                 */\n                try {\n                    selectors = this._selectors_group();\n                } catch (ex){\n                    if (ex instanceof SyntaxError && !this.options.strict){\n\n                        //fire error event\n                        this.fire({\n                            type:       \"error\",\n                            error:      ex,\n                            message:    ex.message,\n                            line:       ex.line,\n                            col:        ex.col\n                        });\n\n                        //skip over everything until closing brace\n                        tt = tokenStream.advance([Tokens.RBRACE]);\n                        if (tt === Tokens.RBRACE){\n                            //if there's a right brace, the rule is finished so don't do anything\n                        } else {\n                            //otherwise, rethrow the error because it wasn't handled properly\n                            throw ex;\n                        }\n\n                    } else {\n                        //not a syntax error, rethrow it\n                        throw ex;\n                    }\n\n                    //trigger parser to continue\n                    return true;\n                }\n\n                //if it got here, all selectors parsed\n                if (selectors){\n\n                    this.fire({\n                        type:       \"startrule\",\n                        selectors:  selectors,\n                        line:       selectors[0].line,\n                        col:        selectors[0].col\n                    });\n\n                    this._readDeclarations(true);\n\n                    this.fire({\n                        type:       \"endrule\",\n                        selectors:  selectors,\n                        line:       selectors[0].line,\n                        col:        selectors[0].col\n                    });\n\n                }\n\n                return selectors;\n\n            },\n\n            //CSS3 Selectors\n            _selectors_group: function(){\n\n                /*\n                 * selectors_group\n                 *   : selector [ COMMA S* selector ]*\n                 *   ;\n                 */\n                var tokenStream = this._tokenStream,\n                    selectors   = [],\n                    selector;\n\n                selector = this._selector();\n                if (selector !== null){\n\n                    selectors.push(selector);\n                    while(tokenStream.match(Tokens.COMMA)){\n                        this._readWhitespace();\n                        selector = this._selector();\n                        if (selector !== null){\n                            selectors.push(selector);\n                        } else {\n                            this._unexpectedToken(tokenStream.LT(1));\n                        }\n                    }\n                }\n\n                return selectors.length ? selectors : null;\n            },\n\n            //CSS3 Selectors\n            _selector: function(){\n                /*\n                 * selector\n                 *   : simple_selector_sequence [ combinator simple_selector_sequence ]*\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    selector    = [],\n                    nextSelector = null,\n                    combinator  = null,\n                    ws          = null;\n\n                //if there's no simple selector, then there's no selector\n                nextSelector = this._simple_selector_sequence();\n                if (nextSelector === null){\n                    return null;\n                }\n\n                selector.push(nextSelector);\n\n                do {\n\n                    //look for a combinator\n                    combinator = this._combinator();\n\n                    if (combinator !== null){\n                        selector.push(combinator);\n                        nextSelector = this._simple_selector_sequence();\n\n                        //there must be a next selector\n                        if (nextSelector === null){\n                            this._unexpectedToken(tokenStream.LT(1));\n                        } else {\n\n                            //nextSelector is an instance of SelectorPart\n                            selector.push(nextSelector);\n                        }\n                    } else {\n\n                        //if there's not whitespace, we're done\n                        if (this._readWhitespace()){\n\n                            //add whitespace separator\n                            ws = new Combinator(tokenStream.token().value, tokenStream.token().startLine, tokenStream.token().startCol);\n\n                            //combinator is not required\n                            combinator = this._combinator();\n\n                            //selector is required if there's a combinator\n                            nextSelector = this._simple_selector_sequence();\n                            if (nextSelector === null){\n                                if (combinator !== null){\n                                    this._unexpectedToken(tokenStream.LT(1));\n                                }\n                            } else {\n\n                                if (combinator !== null){\n                                    selector.push(combinator);\n                                } else {\n                                    selector.push(ws);\n                                }\n\n                                selector.push(nextSelector);\n                            }\n                        } else {\n                            break;\n                        }\n\n                    }\n                } while(true);\n\n                return new Selector(selector, selector[0].line, selector[0].col);\n            },\n\n            //CSS3 Selectors\n            _simple_selector_sequence: function(){\n                /*\n                 * simple_selector_sequence\n                 *   : [ type_selector | universal ]\n                 *     [ HASH | class | attrib | pseudo | negation ]*\n                 *   | [ HASH | class | attrib | pseudo | negation ]+\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n\n                    //parts of a simple selector\n                    elementName = null,\n                    modifiers   = [],\n\n                    //complete selector text\n                    selectorText= \"\",\n\n                    //the different parts after the element name to search for\n                    components  = [\n                        //HASH\n                        function(){\n                            return tokenStream.match(Tokens.HASH) ?\n                                    new SelectorSubPart(tokenStream.token().value, \"id\", tokenStream.token().startLine, tokenStream.token().startCol) :\n                                    null;\n                        },\n                        this._class,\n                        this._attrib,\n                        this._pseudo,\n                        this._negation\n                    ],\n                    i           = 0,\n                    len         = components.length,\n                    component   = null,\n                    line,\n                    col;\n\n\n                //get starting line and column for the selector\n                line = tokenStream.LT(1).startLine;\n                col = tokenStream.LT(1).startCol;\n\n                elementName = this._type_selector();\n                if (!elementName){\n                    elementName = this._universal();\n                }\n\n                if (elementName !== null){\n                    selectorText += elementName;\n                }\n\n                while(true){\n\n                    //whitespace means we're done\n                    if (tokenStream.peek() === Tokens.S){\n                        break;\n                    }\n\n                    //check for each component\n                    while(i < len && component === null){\n                        component = components[i++].call(this);\n                    }\n\n                    if (component === null){\n\n                        //we don't have a selector\n                        if (selectorText === \"\"){\n                            return null;\n                        } else {\n                            break;\n                        }\n                    } else {\n                        i = 0;\n                        modifiers.push(component);\n                        selectorText += component.toString();\n                        component = null;\n                    }\n                }\n\n\n                return selectorText !== \"\" ?\n                        new SelectorPart(elementName, modifiers, selectorText, line, col) :\n                        null;\n            },\n\n            //CSS3 Selectors\n            _type_selector: function(){\n                /*\n                 * type_selector\n                 *   : [ namespace_prefix ]? element_name\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    ns          = this._namespace_prefix(),\n                    elementName = this._element_name();\n\n                if (!elementName){\n                    /*\n                     * Need to back out the namespace that was read due to both\n                     * type_selector and universal reading namespace_prefix\n                     * first. Kind of hacky, but only way I can figure out\n                     * right now how to not change the grammar.\n                     */\n                    if (ns){\n                        tokenStream.unget();\n                        if (ns.length > 1){\n                            tokenStream.unget();\n                        }\n                    }\n\n                    return null;\n                } else {\n                    if (ns){\n                        elementName.text = ns + elementName.text;\n                        elementName.col -= ns.length;\n                    }\n                    return elementName;\n                }\n            },\n\n            //CSS3 Selectors\n            _class: function(){\n                /*\n                 * class\n                 *   : '.' IDENT\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    token;\n\n                if (tokenStream.match(Tokens.DOT)){\n                    tokenStream.mustMatch(Tokens.IDENT);\n                    token = tokenStream.token();\n                    return new SelectorSubPart(\".\" + token.value, \"class\", token.startLine, token.startCol - 1);\n                } else {\n                    return null;\n                }\n\n            },\n\n            //CSS3 Selectors\n            _element_name: function(){\n                /*\n                 * element_name\n                 *   : IDENT\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    token;\n\n                if (tokenStream.match(Tokens.IDENT)){\n                    token = tokenStream.token();\n                    return new SelectorSubPart(token.value, \"elementName\", token.startLine, token.startCol);\n\n                } else {\n                    return null;\n                }\n            },\n\n            //CSS3 Selectors\n            _namespace_prefix: function(){\n                /*\n                 * namespace_prefix\n                 *   : [ IDENT | '*' ]? '|'\n                 *   ;\n                 */\n                var tokenStream = this._tokenStream,\n                    value       = \"\";\n\n                //verify that this is a namespace prefix\n                if (tokenStream.LA(1) === Tokens.PIPE || tokenStream.LA(2) === Tokens.PIPE){\n\n                    if(tokenStream.match([Tokens.IDENT, Tokens.STAR])){\n                        value += tokenStream.token().value;\n                    }\n\n                    tokenStream.mustMatch(Tokens.PIPE);\n                    value += \"|\";\n\n                }\n\n                return value.length ? value : null;\n            },\n\n            //CSS3 Selectors\n            _universal: function(){\n                /*\n                 * universal\n                 *   : [ namespace_prefix ]? '*'\n                 *   ;\n                 */\n                var tokenStream = this._tokenStream,\n                    value       = \"\",\n                    ns;\n\n                ns = this._namespace_prefix();\n                if(ns){\n                    value += ns;\n                }\n\n                if(tokenStream.match(Tokens.STAR)){\n                    value += \"*\";\n                }\n\n                return value.length ? value : null;\n\n           },\n\n            //CSS3 Selectors\n            _attrib: function(){\n                /*\n                 * attrib\n                 *   : '[' S* [ namespace_prefix ]? IDENT S*\n                 *         [ [ PREFIXMATCH |\n                 *             SUFFIXMATCH |\n                 *             SUBSTRINGMATCH |\n                 *             '=' |\n                 *             INCLUDES |\n                 *             DASHMATCH ] S* [ IDENT | STRING ] S*\n                 *         ]? ']'\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    value       = null,\n                    ns,\n                    token;\n\n                if (tokenStream.match(Tokens.LBRACKET)){\n                    token = tokenStream.token();\n                    value = token.value;\n                    value += this._readWhitespace();\n\n                    ns = this._namespace_prefix();\n\n                    if (ns){\n                        value += ns;\n                    }\n\n                    tokenStream.mustMatch(Tokens.IDENT);\n                    value += tokenStream.token().value;\n                    value += this._readWhitespace();\n\n                    if(tokenStream.match([Tokens.PREFIXMATCH, Tokens.SUFFIXMATCH, Tokens.SUBSTRINGMATCH,\n                            Tokens.EQUALS, Tokens.INCLUDES, Tokens.DASHMATCH])){\n\n                        value += tokenStream.token().value;\n                        value += this._readWhitespace();\n\n                        tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);\n                        value += tokenStream.token().value;\n                        value += this._readWhitespace();\n                    }\n\n                    tokenStream.mustMatch(Tokens.RBRACKET);\n\n                    return new SelectorSubPart(value + \"]\", \"attribute\", token.startLine, token.startCol);\n                } else {\n                    return null;\n                }\n            },\n\n            //CSS3 Selectors\n            _pseudo: function(){\n\n                /*\n                 * pseudo\n                 *   : ':' ':'? [ IDENT | functional_pseudo ]\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    pseudo      = null,\n                    colons      = \":\",\n                    line,\n                    col;\n\n                if (tokenStream.match(Tokens.COLON)){\n\n                    if (tokenStream.match(Tokens.COLON)){\n                        colons += \":\";\n                    }\n\n                    if (tokenStream.match(Tokens.IDENT)){\n                        pseudo = tokenStream.token().value;\n                        line = tokenStream.token().startLine;\n                        col = tokenStream.token().startCol - colons.length;\n                    } else if (tokenStream.peek() === Tokens.FUNCTION){\n                        line = tokenStream.LT(1).startLine;\n                        col = tokenStream.LT(1).startCol - colons.length;\n                        pseudo = this._functional_pseudo();\n                    }\n\n                    if (pseudo){\n                        pseudo = new SelectorSubPart(colons + pseudo, \"pseudo\", line, col);\n                    }\n                }\n\n                return pseudo;\n            },\n\n            //CSS3 Selectors\n            _functional_pseudo: function(){\n                /*\n                 * functional_pseudo\n                 *   : FUNCTION S* expression ')'\n                 *   ;\n                */\n\n                var tokenStream = this._tokenStream,\n                    value = null;\n\n                if(tokenStream.match(Tokens.FUNCTION)){\n                    value = tokenStream.token().value;\n                    value += this._readWhitespace();\n                    value += this._expression();\n                    tokenStream.mustMatch(Tokens.RPAREN);\n                    value += \")\";\n                }\n\n                return value;\n            },\n\n            //CSS3 Selectors\n            _expression: function(){\n                /*\n                 * expression\n                 *   : [ [ PLUS | '-' | DIMENSION | NUMBER | STRING | IDENT ] S* ]+\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    value       = \"\";\n\n                while(tokenStream.match([Tokens.PLUS, Tokens.MINUS, Tokens.DIMENSION,\n                        Tokens.NUMBER, Tokens.STRING, Tokens.IDENT, Tokens.LENGTH,\n                        Tokens.FREQ, Tokens.ANGLE, Tokens.TIME,\n                        Tokens.RESOLUTION, Tokens.SLASH])){\n\n                    value += tokenStream.token().value;\n                    value += this._readWhitespace();\n                }\n\n                return value.length ? value : null;\n\n            },\n\n            //CSS3 Selectors\n            _negation: function(){\n                /*\n                 * negation\n                 *   : NOT S* negation_arg S* ')'\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    line,\n                    col,\n                    value       = \"\",\n                    arg,\n                    subpart     = null;\n\n                if (tokenStream.match(Tokens.NOT)){\n                    value = tokenStream.token().value;\n                    line = tokenStream.token().startLine;\n                    col = tokenStream.token().startCol;\n                    value += this._readWhitespace();\n                    arg = this._negation_arg();\n                    value += arg;\n                    value += this._readWhitespace();\n                    tokenStream.match(Tokens.RPAREN);\n                    value += tokenStream.token().value;\n\n                    subpart = new SelectorSubPart(value, \"not\", line, col);\n                    subpart.args.push(arg);\n                }\n\n                return subpart;\n            },\n\n            //CSS3 Selectors\n            _negation_arg: function(){\n                /*\n                 * negation_arg\n                 *   : type_selector | universal | HASH | class | attrib | pseudo\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    args        = [\n                        this._type_selector,\n                        this._universal,\n                        function(){\n                            return tokenStream.match(Tokens.HASH) ?\n                                    new SelectorSubPart(tokenStream.token().value, \"id\", tokenStream.token().startLine, tokenStream.token().startCol) :\n                                    null;\n                        },\n                        this._class,\n                        this._attrib,\n                        this._pseudo\n                    ],\n                    arg         = null,\n                    i           = 0,\n                    len         = args.length,\n                    line,\n                    col,\n                    part;\n\n                line = tokenStream.LT(1).startLine;\n                col = tokenStream.LT(1).startCol;\n\n                while(i < len && arg === null){\n\n                    arg = args[i].call(this);\n                    i++;\n                }\n\n                //must be a negation arg\n                if (arg === null){\n                    this._unexpectedToken(tokenStream.LT(1));\n                }\n\n                //it's an element name\n                if (arg.type === \"elementName\"){\n                    part = new SelectorPart(arg, [], arg.toString(), line, col);\n                } else {\n                    part = new SelectorPart(null, [arg], arg.toString(), line, col);\n                }\n\n                return part;\n            },\n\n            _declaration: function(){\n\n                /*\n                 * declaration\n                 *   : property ':' S* expr prio?\n                 *   | /( empty )/\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    property    = null,\n                    expr        = null,\n                    prio        = null,\n                    invalid     = null,\n                    propertyName= \"\";\n\n                property = this._property();\n                if (property !== null){\n\n                    tokenStream.mustMatch(Tokens.COLON);\n                    this._readWhitespace();\n\n                    expr = this._expr();\n\n                    //if there's no parts for the value, it's an error\n                    if (!expr || expr.length === 0){\n                        this._unexpectedToken(tokenStream.LT(1));\n                    }\n\n                    prio = this._prio();\n\n                    /*\n                     * If hacks should be allowed, then only check the root\n                     * property. If hacks should not be allowed, treat\n                     * _property or *property as invalid properties.\n                     */\n                    propertyName = property.toString();\n                    if (this.options.starHack && property.hack === \"*\" ||\n                            this.options.underscoreHack && property.hack === \"_\") {\n\n                        propertyName = property.text;\n                    }\n\n                    try {\n                        this._validateProperty(propertyName, expr);\n                    } catch (ex) {\n                        invalid = ex;\n                    }\n\n                    this.fire({\n                        type:       \"property\",\n                        property:   property,\n                        value:      expr,\n                        important:  prio,\n                        line:       property.line,\n                        col:        property.col,\n                        invalid:    invalid\n                    });\n\n                    return true;\n                } else {\n                    return false;\n                }\n            },\n\n            _prio: function(){\n                /*\n                 * prio\n                 *   : IMPORTANT_SYM S*\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    result      = tokenStream.match(Tokens.IMPORTANT_SYM);\n\n                this._readWhitespace();\n                return result;\n            },\n\n            _expr: function(inFunction){\n                /*\n                 * expr\n                 *   : term [ operator term ]*\n                 *   ;\n                 */\n\n                var values      = [],\n\t\t\t\t\t//valueParts\t= [],\n                    value       = null,\n                    operator    = null;\n\n                value = this._term(inFunction);\n                if (value !== null){\n\n                    values.push(value);\n\n                    do {\n                        operator = this._operator(inFunction);\n\n                        //if there's an operator, keep building up the value parts\n                        if (operator){\n                            values.push(operator);\n                        } /*else {\n                            //if there's not an operator, you have a full value\n\t\t\t\t\t\t\tvalues.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));\n\t\t\t\t\t\t\tvalueParts = [];\n\t\t\t\t\t\t}*/\n\n                        value = this._term(inFunction);\n\n                        if (value === null){\n                            break;\n                        } else {\n                            values.push(value);\n                        }\n                    } while(true);\n                }\n\n\t\t\t\t//cleanup\n                /*if (valueParts.length){\n                    values.push(new PropertyValue(valueParts, valueParts[0].line, valueParts[0].col));\n                }*/\n\n                return values.length > 0 ? new PropertyValue(values, values[0].line, values[0].col) : null;\n            },\n\n            _term: function(inFunction){\n\n                /*\n                 * term\n                 *   : unary_operator?\n                 *     [ NUMBER S* | PERCENTAGE S* | LENGTH S* | ANGLE S* |\n                 *       TIME S* | FREQ S* | function | ie_function ]\n                 *   | STRING S* | IDENT S* | URI S* | UNICODERANGE S* | hexcolor\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    unary       = null,\n                    value       = null,\n                    endChar     = null,\n                    token,\n                    line,\n                    col;\n\n                //returns the operator or null\n                unary = this._unary_operator();\n                if (unary !== null){\n                    line = tokenStream.token().startLine;\n                    col = tokenStream.token().startCol;\n                }\n\n                //exception for IE filters\n                if (tokenStream.peek() === Tokens.IE_FUNCTION && this.options.ieFilters){\n\n                    value = this._ie_function();\n                    if (unary === null){\n                        line = tokenStream.token().startLine;\n                        col = tokenStream.token().startCol;\n                    }\n\n                //see if it's a simple block\n                } else if (inFunction && tokenStream.match([Tokens.LPAREN, Tokens.LBRACE, Tokens.LBRACKET])){\n\n                    token = tokenStream.token();\n                    endChar = token.endChar;\n                    value = token.value + this._expr(inFunction).text;\n                    if (unary === null){\n                        line = tokenStream.token().startLine;\n                        col = tokenStream.token().startCol;\n                    }\n                    tokenStream.mustMatch(Tokens.type(endChar));\n                    value += endChar;\n                    this._readWhitespace();\n\n                //see if there's a simple match\n                } else if (tokenStream.match([Tokens.NUMBER, Tokens.PERCENTAGE, Tokens.LENGTH,\n                        Tokens.ANGLE, Tokens.TIME,\n                        Tokens.FREQ, Tokens.STRING, Tokens.IDENT, Tokens.URI, Tokens.UNICODE_RANGE])){\n\n                    value = tokenStream.token().value;\n                    if (unary === null){\n                        line = tokenStream.token().startLine;\n                        col = tokenStream.token().startCol;\n                    }\n                    this._readWhitespace();\n                } else {\n\n                    //see if it's a color\n                    token = this._hexcolor();\n                    if (token === null){\n\n                        //if there's no unary, get the start of the next token for line/col info\n                        if (unary === null){\n                            line = tokenStream.LT(1).startLine;\n                            col = tokenStream.LT(1).startCol;\n                        }\n\n                        //has to be a function\n                        if (value === null){\n\n                            /*\n                             * This checks for alpha(opacity=0) style of IE\n                             * functions. IE_FUNCTION only presents progid: style.\n                             */\n                            if (tokenStream.LA(3) === Tokens.EQUALS && this.options.ieFilters){\n                                value = this._ie_function();\n                            } else {\n                                value = this._function();\n                            }\n                        }\n\n                        /*if (value === null){\n                            return null;\n                            //throw new Error(\"Expected identifier at line \" + tokenStream.token().startLine + \", character \" +  tokenStream.token().startCol + \".\");\n                        }*/\n\n                    } else {\n                        value = token.value;\n                        if (unary === null){\n                            line = token.startLine;\n                            col = token.startCol;\n                        }\n                    }\n\n                }\n\n                return value !== null ?\n                        new PropertyValuePart(unary !== null ? unary + value : value, line, col) :\n                        null;\n\n            },\n\n            _function: function(){\n\n                /*\n                 * function\n                 *   : FUNCTION S* expr ')' S*\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    functionText = null,\n                    expr        = null,\n                    lt;\n\n                if (tokenStream.match(Tokens.FUNCTION)){\n                    functionText = tokenStream.token().value;\n                    this._readWhitespace();\n                    expr = this._expr(true);\n                    functionText += expr;\n\n                    //START: Horrible hack in case it's an IE filter\n                    if (this.options.ieFilters && tokenStream.peek() === Tokens.EQUALS){\n                        do {\n\n                            if (this._readWhitespace()){\n                                functionText += tokenStream.token().value;\n                            }\n\n                            //might be second time in the loop\n                            if (tokenStream.LA(0) === Tokens.COMMA){\n                                functionText += tokenStream.token().value;\n                            }\n\n                            tokenStream.match(Tokens.IDENT);\n                            functionText += tokenStream.token().value;\n\n                            tokenStream.match(Tokens.EQUALS);\n                            functionText += tokenStream.token().value;\n\n                            //functionText += this._term();\n                            lt = tokenStream.peek();\n                            while(lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN){\n                                tokenStream.get();\n                                functionText += tokenStream.token().value;\n                                lt = tokenStream.peek();\n                            }\n                        } while(tokenStream.match([Tokens.COMMA, Tokens.S]));\n                    }\n\n                    //END: Horrible Hack\n\n                    tokenStream.match(Tokens.RPAREN);\n                    functionText += \")\";\n                    this._readWhitespace();\n                }\n\n                return functionText;\n            },\n\n            _ie_function: function(){\n\n                /* (My own extension)\n                 * ie_function\n                 *   : IE_FUNCTION S* IDENT '=' term [S* ','? IDENT '=' term]+ ')' S*\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    functionText = null,\n                    lt;\n\n                //IE function can begin like a regular function, too\n                if (tokenStream.match([Tokens.IE_FUNCTION, Tokens.FUNCTION])){\n                    functionText = tokenStream.token().value;\n\n                    do {\n\n                        if (this._readWhitespace()){\n                            functionText += tokenStream.token().value;\n                        }\n\n                        //might be second time in the loop\n                        if (tokenStream.LA(0) === Tokens.COMMA){\n                            functionText += tokenStream.token().value;\n                        }\n\n                        tokenStream.match(Tokens.IDENT);\n                        functionText += tokenStream.token().value;\n\n                        tokenStream.match(Tokens.EQUALS);\n                        functionText += tokenStream.token().value;\n\n                        //functionText += this._term();\n                        lt = tokenStream.peek();\n                        while(lt !== Tokens.COMMA && lt !== Tokens.S && lt !== Tokens.RPAREN){\n                            tokenStream.get();\n                            functionText += tokenStream.token().value;\n                            lt = tokenStream.peek();\n                        }\n                    } while(tokenStream.match([Tokens.COMMA, Tokens.S]));\n\n                    tokenStream.match(Tokens.RPAREN);\n                    functionText += \")\";\n                    this._readWhitespace();\n                }\n\n                return functionText;\n            },\n\n            _hexcolor: function(){\n                /*\n                 * There is a constraint on the color that it must\n                 * have either 3 or 6 hex-digits (i.e., [0-9a-fA-F])\n                 * after the \"#\"; e.g., \"#000\" is OK, but \"#abcd\" is not.\n                 *\n                 * hexcolor\n                 *   : HASH S*\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    token = null,\n                    color;\n\n                if(tokenStream.match(Tokens.HASH)){\n\n                    //need to do some validation here\n\n                    token = tokenStream.token();\n                    color = token.value;\n                    if (!/#[a-f0-9]{3,6}/i.test(color)){\n                        throw new SyntaxError(\"Expected a hex color but found '\" + color + \"' at line \" + token.startLine + \", col \" + token.startCol + \".\", token.startLine, token.startCol);\n                    }\n                    this._readWhitespace();\n                }\n\n                return token;\n            },\n\n            //-----------------------------------------------------------------\n            // Animations methods\n            //-----------------------------------------------------------------\n\n            _keyframes: function(){\n\n                /*\n                 * keyframes:\n                 *   : KEYFRAMES_SYM S* keyframe_name S* '{' S* keyframe_rule* '}' {\n                 *   ;\n                 */\n                var tokenStream = this._tokenStream,\n                    token,\n                    tt,\n                    name,\n                    prefix = \"\";\n\n                tokenStream.mustMatch(Tokens.KEYFRAMES_SYM);\n                token = tokenStream.token();\n                if (/^@\\-([^\\-]+)\\-/.test(token.value)) {\n                    prefix = RegExp.$1;\n                }\n\n                this._readWhitespace();\n                name = this._keyframe_name();\n\n                this._readWhitespace();\n                tokenStream.mustMatch(Tokens.LBRACE);\n\n                this.fire({\n                    type:   \"startkeyframes\",\n                    name:   name,\n                    prefix: prefix,\n                    line:   token.startLine,\n                    col:    token.startCol\n                });\n\n                this._readWhitespace();\n                tt = tokenStream.peek();\n\n                //check for key\n                while(tt === Tokens.IDENT || tt === Tokens.PERCENTAGE) {\n                    this._keyframe_rule();\n                    this._readWhitespace();\n                    tt = tokenStream.peek();\n                }\n\n                this.fire({\n                    type:   \"endkeyframes\",\n                    name:   name,\n                    prefix: prefix,\n                    line:   token.startLine,\n                    col:    token.startCol\n                });\n\n                this._readWhitespace();\n                tokenStream.mustMatch(Tokens.RBRACE);\n\n            },\n\n            _keyframe_name: function(){\n\n                /*\n                 * keyframe_name:\n                 *   : IDENT\n                 *   | STRING\n                 *   ;\n                 */\n                var tokenStream = this._tokenStream;\n\n                tokenStream.mustMatch([Tokens.IDENT, Tokens.STRING]);\n                return SyntaxUnit.fromToken(tokenStream.token());\n            },\n\n            _keyframe_rule: function(){\n\n                /*\n                 * keyframe_rule:\n                 *   : key_list S*\n                 *     '{' S* declaration [ ';' S* declaration ]* '}' S*\n                 *   ;\n                 */\n                var keyList = this._key_list();\n\n                this.fire({\n                    type:   \"startkeyframerule\",\n                    keys:   keyList,\n                    line:   keyList[0].line,\n                    col:    keyList[0].col\n                });\n\n                this._readDeclarations(true);\n\n                this.fire({\n                    type:   \"endkeyframerule\",\n                    keys:   keyList,\n                    line:   keyList[0].line,\n                    col:    keyList[0].col\n                });\n\n            },\n\n            _key_list: function(){\n\n                /*\n                 * key_list:\n                 *   : key [ S* ',' S* key]*\n                 *   ;\n                 */\n                var tokenStream = this._tokenStream,\n                    keyList = [];\n\n                //must be least one key\n                keyList.push(this._key());\n\n                this._readWhitespace();\n\n                while(tokenStream.match(Tokens.COMMA)){\n                    this._readWhitespace();\n                    keyList.push(this._key());\n                    this._readWhitespace();\n                }\n\n                return keyList;\n            },\n\n            _key: function(){\n                /*\n                 * There is a restriction that IDENT can be only \"from\" or \"to\".\n                 *\n                 * key\n                 *   : PERCENTAGE\n                 *   | IDENT\n                 *   ;\n                 */\n\n                var tokenStream = this._tokenStream,\n                    token;\n\n                if (tokenStream.match(Tokens.PERCENTAGE)){\n                    return SyntaxUnit.fromToken(tokenStream.token());\n                } else if (tokenStream.match(Tokens.IDENT)){\n                    token = tokenStream.token();\n\n                    if (/from|to/i.test(token.value)){\n                        return SyntaxUnit.fromToken(token);\n                    }\n\n                    tokenStream.unget();\n                }\n\n                //if it gets here, there wasn't a valid token, so time to explode\n                this._unexpectedToken(tokenStream.LT(1));\n            },\n\n            //-----------------------------------------------------------------\n            // Helper methods\n            //-----------------------------------------------------------------\n\n            /**\n             * Not part of CSS grammar, but useful for skipping over\n             * combination of white space and HTML-style comments.\n             * @return {void}\n             * @method _skipCruft\n             * @private\n             */\n            _skipCruft: function(){\n                while(this._tokenStream.match([Tokens.S, Tokens.CDO, Tokens.CDC])){\n                    //noop\n                }\n            },\n\n            /**\n             * Not part of CSS grammar, but this pattern occurs frequently\n             * in the official CSS grammar. Split out here to eliminate\n             * duplicate code.\n             * @param {Boolean} checkStart Indicates if the rule should check\n             *      for the left brace at the beginning.\n             * @param {Boolean} readMargins Indicates if the rule should check\n             *      for margin patterns.\n             * @return {void}\n             * @method _readDeclarations\n             * @private\n             */\n            _readDeclarations: function(checkStart, readMargins){\n                /*\n                 * Reads the pattern\n                 * S* '{' S* declaration [ ';' S* declaration ]* '}' S*\n                 * or\n                 * S* '{' S* [ declaration | margin ]? [ ';' S* [ declaration | margin ]? ]* '}' S*\n                 * Note that this is how it is described in CSS3 Paged Media, but is actually incorrect.\n                 * A semicolon is only necessary following a declaration if there's another declaration\n                 * or margin afterwards.\n                 */\n                var tokenStream = this._tokenStream,\n                    tt;\n\n\n                this._readWhitespace();\n\n                if (checkStart){\n                    tokenStream.mustMatch(Tokens.LBRACE);\n                }\n\n                this._readWhitespace();\n\n                try {\n\n                    while(true){\n\n                        if (tokenStream.match(Tokens.SEMICOLON) || (readMargins && this._margin())){\n                            //noop\n                        } else if (this._declaration()){\n                            if (!tokenStream.match(Tokens.SEMICOLON)){\n                                break;\n                            }\n                        } else {\n                            break;\n                        }\n\n                        //if ((!this._margin() && !this._declaration()) || !tokenStream.match(Tokens.SEMICOLON)){\n                        //    break;\n                        //}\n                        this._readWhitespace();\n                    }\n\n                    tokenStream.mustMatch(Tokens.RBRACE);\n                    this._readWhitespace();\n\n                } catch (ex) {\n                    if (ex instanceof SyntaxError && !this.options.strict){\n\n                        //fire error event\n                        this.fire({\n                            type:       \"error\",\n                            error:      ex,\n                            message:    ex.message,\n                            line:       ex.line,\n                            col:        ex.col\n                        });\n\n                        //see if there's another declaration\n                        tt = tokenStream.advance([Tokens.SEMICOLON, Tokens.RBRACE]);\n                        if (tt === Tokens.SEMICOLON){\n                            //if there's a semicolon, then there might be another declaration\n                            this._readDeclarations(false, readMargins);\n                        } else if (tt !== Tokens.RBRACE){\n                            //if there's a right brace, the rule is finished so don't do anything\n                            //otherwise, rethrow the error because it wasn't handled properly\n                            throw ex;\n                        }\n\n                    } else {\n                        //not a syntax error, rethrow it\n                        throw ex;\n                    }\n                }\n\n            },\n\n            /**\n             * In some cases, you can end up with two white space tokens in a\n             * row. Instead of making a change in every function that looks for\n             * white space, this function is used to match as much white space\n             * as necessary.\n             * @method _readWhitespace\n             * @return {String} The white space if found, empty string if not.\n             * @private\n             */\n            _readWhitespace: function(){\n\n                var tokenStream = this._tokenStream,\n                    ws = \"\";\n\n                while(tokenStream.match(Tokens.S)){\n                    ws += tokenStream.token().value;\n                }\n\n                return ws;\n            },\n\n\n            /**\n             * Throws an error when an unexpected token is found.\n             * @param {Object} token The token that was found.\n             * @method _unexpectedToken\n             * @return {void}\n             * @private\n             */\n            _unexpectedToken: function(token){\n                throw new SyntaxError(\"Unexpected token '\" + token.value + \"' at line \" + token.startLine + \", col \" + token.startCol + \".\", token.startLine, token.startCol);\n            },\n\n            /**\n             * Helper method used for parsing subparts of a style sheet.\n             * @return {void}\n             * @method _verifyEnd\n             * @private\n             */\n            _verifyEnd: function(){\n                if (this._tokenStream.LA(1) !== Tokens.EOF){\n                    this._unexpectedToken(this._tokenStream.LT(1));\n                }\n            },\n\n            //-----------------------------------------------------------------\n            // Validation methods\n            //-----------------------------------------------------------------\n            _validateProperty: function(property, value){\n                Validation.validate(property, value);\n            },\n\n            //-----------------------------------------------------------------\n            // Parsing methods\n            //-----------------------------------------------------------------\n\n            parse: function(input){\n                this._tokenStream = new TokenStream(input, Tokens);\n                this._stylesheet();\n            },\n\n            parseStyleSheet: function(input){\n                //just passthrough\n                return this.parse(input);\n            },\n\n            parseMediaQuery: function(input){\n                this._tokenStream = new TokenStream(input, Tokens);\n                var result = this._media_query();\n\n                //if there's anything more, then it's an invalid selector\n                this._verifyEnd();\n\n                //otherwise return result\n                return result;\n            },\n\n            /**\n             * Parses a property value (everything after the semicolon).\n             * @return {parserlib.css.PropertyValue} The property value.\n             * @throws parserlib.util.SyntaxError If an unexpected token is found.\n             * @method parserPropertyValue\n             */\n            parsePropertyValue: function(input){\n\n                this._tokenStream = new TokenStream(input, Tokens);\n                this._readWhitespace();\n\n                var result = this._expr();\n\n                //okay to have a trailing white space\n                this._readWhitespace();\n\n                //if there's anything more, then it's an invalid selector\n                this._verifyEnd();\n\n                //otherwise return result\n                return result;\n            },\n\n            /**\n             * Parses a complete CSS rule, including selectors and\n             * properties.\n             * @param {String} input The text to parser.\n             * @return {Boolean} True if the parse completed successfully, false if not.\n             * @method parseRule\n             */\n            parseRule: function(input){\n                this._tokenStream = new TokenStream(input, Tokens);\n\n                //skip any leading white space\n                this._readWhitespace();\n\n                var result = this._ruleset();\n\n                //skip any trailing white space\n                this._readWhitespace();\n\n                //if there's anything more, then it's an invalid selector\n                this._verifyEnd();\n\n                //otherwise return result\n                return result;\n            },\n\n            /**\n             * Parses a single CSS selector (no comma)\n             * @param {String} input The text to parse as a CSS selector.\n             * @return {Selector} An object representing the selector.\n             * @throws parserlib.util.SyntaxError If an unexpected token is found.\n             * @method parseSelector\n             */\n            parseSelector: function(input){\n\n                this._tokenStream = new TokenStream(input, Tokens);\n\n                //skip any leading white space\n                this._readWhitespace();\n\n                var result = this._selector();\n\n                //skip any trailing white space\n                this._readWhitespace();\n\n                //if there's anything more, then it's an invalid selector\n                this._verifyEnd();\n\n                //otherwise return result\n                return result;\n            },\n\n            /**\n             * Parses an HTML style attribute: a set of CSS declarations\n             * separated by semicolons.\n             * @param {String} input The text to parse as a style attribute\n             * @return {void}\n             * @method parseStyleAttribute\n             */\n            parseStyleAttribute: function(input){\n                input += \"}\"; // for error recovery in _readDeclarations()\n                this._tokenStream = new TokenStream(input, Tokens);\n                this._readDeclarations();\n            }\n        };\n\n    //copy over onto prototype\n    for (prop in additions){\n        if (Object.prototype.hasOwnProperty.call(additions, prop)){\n            proto[prop] = additions[prop];\n        }\n    }\n\n    return proto;\n}();\n\n\n/*\nnth\n  : S* [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]? |\n         ['-'|'+']? INTEGER | {O}{D}{D} | {E}{V}{E}{N} ] S*\n  ;\n*/\nvar Properties = {\n    __proto__: null,\n\n    //A\n    \"align-items\"                   : \"flex-start | flex-end | center | baseline | stretch\",\n    \"align-content\"                 : \"flex-start | flex-end | center | space-between | space-around | stretch\",\n    \"align-self\"                    : \"auto | flex-start | flex-end | center | baseline | stretch\",\n    \"-webkit-align-items\"           : \"flex-start | flex-end | center | baseline | stretch\",\n    \"-webkit-align-content\"         : \"flex-start | flex-end | center | space-between | space-around | stretch\",\n    \"-webkit-align-self\"            : \"auto | flex-start | flex-end | center | baseline | stretch\",\n    \"alignment-adjust\"              : \"auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical | <percentage> | <length>\",\n    \"alignment-baseline\"            : \"baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical\",\n    \"animation\"                     : 1,\n    \"animation-delay\"               : { multi: \"<time>\", comma: true },\n    \"animation-direction\"           : { multi: \"normal | alternate\", comma: true },\n    \"animation-duration\"            : { multi: \"<time>\", comma: true },\n    \"animation-fill-mode\"           : { multi: \"none | forwards | backwards | both\", comma: true },\n    \"animation-iteration-count\"     : { multi: \"<number> | infinite\", comma: true },\n    \"animation-name\"                : { multi: \"none | <ident>\", comma: true },\n    \"animation-play-state\"          : { multi: \"running | paused\", comma: true },\n    \"animation-timing-function\"     : 1,\n\n    //vendor prefixed\n    \"-moz-animation-delay\"               : { multi: \"<time>\", comma: true },\n    \"-moz-animation-direction\"           : { multi: \"normal | alternate\", comma: true },\n    \"-moz-animation-duration\"            : { multi: \"<time>\", comma: true },\n    \"-moz-animation-iteration-count\"     : { multi: \"<number> | infinite\", comma: true },\n    \"-moz-animation-name\"                : { multi: \"none | <ident>\", comma: true },\n    \"-moz-animation-play-state\"          : { multi: \"running | paused\", comma: true },\n\n    \"-ms-animation-delay\"               : { multi: \"<time>\", comma: true },\n    \"-ms-animation-direction\"           : { multi: \"normal | alternate\", comma: true },\n    \"-ms-animation-duration\"            : { multi: \"<time>\", comma: true },\n    \"-ms-animation-iteration-count\"     : { multi: \"<number> | infinite\", comma: true },\n    \"-ms-animation-name\"                : { multi: \"none | <ident>\", comma: true },\n    \"-ms-animation-play-state\"          : { multi: \"running | paused\", comma: true },\n\n    \"-webkit-animation-delay\"               : { multi: \"<time>\", comma: true },\n    \"-webkit-animation-direction\"           : { multi: \"normal | alternate\", comma: true },\n    \"-webkit-animation-duration\"            : { multi: \"<time>\", comma: true },\n    \"-webkit-animation-fill-mode\"           : { multi: \"none | forwards | backwards | both\", comma: true },\n    \"-webkit-animation-iteration-count\"     : { multi: \"<number> | infinite\", comma: true },\n    \"-webkit-animation-name\"                : { multi: \"none | <ident>\", comma: true },\n    \"-webkit-animation-play-state\"          : { multi: \"running | paused\", comma: true },\n\n    \"-o-animation-delay\"               : { multi: \"<time>\", comma: true },\n    \"-o-animation-direction\"           : { multi: \"normal | alternate\", comma: true },\n    \"-o-animation-duration\"            : { multi: \"<time>\", comma: true },\n    \"-o-animation-iteration-count\"     : { multi: \"<number> | infinite\", comma: true },\n    \"-o-animation-name\"                : { multi: \"none | <ident>\", comma: true },\n    \"-o-animation-play-state\"          : { multi: \"running | paused\", comma: true },\n\n    \"appearance\"                    : \"icon | window | desktop | workspace | document | tooltip | dialog | button | push-button | hyperlink | radio | radio-button | checkbox | menu-item | tab | menu | menubar | pull-down-menu | pop-up-menu | list-menu | radio-group | checkbox-group | outline-tree | range | field | combo-box | signature | password | normal | none | inherit\",\n    \"azimuth\"                       : function (expression) {\n        var simple      = \"<angle> | leftwards | rightwards | inherit\",\n            direction   = \"left-side | far-left | left | center-left | center | center-right | right | far-right | right-side\",\n            behind      = false,\n            valid       = false,\n            part;\n\n        if (!ValidationTypes.isAny(expression, simple)) {\n            if (ValidationTypes.isAny(expression, \"behind\")) {\n                behind = true;\n                valid = true;\n            }\n\n            if (ValidationTypes.isAny(expression, direction)) {\n                valid = true;\n                if (!behind) {\n                    ValidationTypes.isAny(expression, \"behind\");\n                }\n            }\n        }\n\n        if (expression.hasNext()) {\n            part = expression.next();\n            if (valid) {\n                throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\n            } else {\n                throw new ValidationError(\"Expected (<'azimuth'>) but found '\" + part + \"'.\", part.line, part.col);\n            }\n        }\n    },\n\n    //B\n    \"backface-visibility\"           : \"visible | hidden\",\n    \"background\"                    : 1,\n    \"background-attachment\"         : { multi: \"<attachment>\", comma: true },\n    \"background-clip\"               : { multi: \"<box>\", comma: true },\n    \"background-color\"              : \"<color> | inherit\",\n    \"background-image\"              : { multi: \"<bg-image>\", comma: true },\n    \"background-origin\"             : { multi: \"<box>\", comma: true },\n    \"background-position\"           : { multi: \"<bg-position>\", comma: true },\n    \"background-repeat\"             : { multi: \"<repeat-style>\" },\n    \"background-size\"               : { multi: \"<bg-size>\", comma: true },\n    \"baseline-shift\"                : \"baseline | sub | super | <percentage> | <length>\",\n    \"behavior\"                      : 1,\n    \"binding\"                       : 1,\n    \"bleed\"                         : \"<length>\",\n    \"bookmark-label\"                : \"<content> | <attr> | <string>\",\n    \"bookmark-level\"                : \"none | <integer>\",\n    \"bookmark-state\"                : \"open | closed\",\n    \"bookmark-target\"               : \"none | <uri> | <attr>\",\n    \"border\"                        : \"<border-width> || <border-style> || <color>\",\n    \"border-bottom\"                 : \"<border-width> || <border-style> || <color>\",\n    \"border-bottom-color\"           : \"<color> | inherit\",\n    \"border-bottom-left-radius\"     :  \"<x-one-radius>\",\n    \"border-bottom-right-radius\"    :  \"<x-one-radius>\",\n    \"border-bottom-style\"           : \"<border-style>\",\n    \"border-bottom-width\"           : \"<border-width>\",\n    \"border-collapse\"               : \"collapse | separate | inherit\",\n    \"border-color\"                  : { multi: \"<color> | inherit\", max: 4 },\n    \"border-image\"                  : 1,\n    \"border-image-outset\"           : { multi: \"<length> | <number>\", max: 4 },\n    \"border-image-repeat\"           : { multi: \"stretch | repeat | round\", max: 2 },\n    \"border-image-slice\"            : function(expression) {\n\n        var valid   = false,\n            numeric = \"<number> | <percentage>\",\n            fill    = false,\n            count   = 0,\n            max     = 4,\n            part;\n\n        if (ValidationTypes.isAny(expression, \"fill\")) {\n            fill = true;\n            valid = true;\n        }\n\n        while (expression.hasNext() && count < max) {\n            valid = ValidationTypes.isAny(expression, numeric);\n            if (!valid) {\n                break;\n            }\n            count++;\n        }\n\n\n        if (!fill) {\n            ValidationTypes.isAny(expression, \"fill\");\n        } else {\n            valid = true;\n        }\n\n        if (expression.hasNext()) {\n            part = expression.next();\n            if (valid) {\n                throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\n            } else {\n                throw new ValidationError(\"Expected ([<number> | <percentage>]{1,4} && fill?) but found '\" + part + \"'.\", part.line, part.col);\n            }\n        }\n    },\n    \"border-image-source\"           : \"<image> | none\",\n    \"border-image-width\"            : { multi: \"<length> | <percentage> | <number> | auto\", max: 4 },\n    \"border-left\"                   : \"<border-width> || <border-style> || <color>\",\n    \"border-left-color\"             : \"<color> | inherit\",\n    \"border-left-style\"             : \"<border-style>\",\n    \"border-left-width\"             : \"<border-width>\",\n    \"border-radius\"                 : function(expression) {\n\n        var valid   = false,\n            simple = \"<length> | <percentage> | inherit\",\n            slash   = false,\n            count   = 0,\n            max     = 8,\n            part;\n\n        while (expression.hasNext() && count < max) {\n            valid = ValidationTypes.isAny(expression, simple);\n            if (!valid) {\n\n                if (String(expression.peek()) === \"/\" && count > 0 && !slash) {\n                    slash = true;\n                    max = count + 5;\n                    expression.next();\n                } else {\n                    break;\n                }\n            }\n            count++;\n        }\n\n        if (expression.hasNext()) {\n            part = expression.next();\n            if (valid) {\n                throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\n            } else {\n                throw new ValidationError(\"Expected (<'border-radius'>) but found '\" + part + \"'.\", part.line, part.col);\n            }\n        }\n    },\n    \"border-right\"                  : \"<border-width> || <border-style> || <color>\",\n    \"border-right-color\"            : \"<color> | inherit\",\n    \"border-right-style\"            : \"<border-style>\",\n    \"border-right-width\"            : \"<border-width>\",\n    \"border-spacing\"                : { multi: \"<length> | inherit\", max: 2 },\n    \"border-style\"                  : { multi: \"<border-style>\", max: 4 },\n    \"border-top\"                    : \"<border-width> || <border-style> || <color>\",\n    \"border-top-color\"              : \"<color> | inherit\",\n    \"border-top-left-radius\"        : \"<x-one-radius>\",\n    \"border-top-right-radius\"       : \"<x-one-radius>\",\n    \"border-top-style\"              : \"<border-style>\",\n    \"border-top-width\"              : \"<border-width>\",\n    \"border-width\"                  : { multi: \"<border-width>\", max: 4 },\n    \"bottom\"                        : \"<margin-width> | inherit\",\n    \"-moz-box-align\"                : \"start | end | center | baseline | stretch\",\n    \"-moz-box-decoration-break\"     : \"slice |clone\",\n    \"-moz-box-direction\"            : \"normal | reverse | inherit\",\n    \"-moz-box-flex\"                 : \"<number>\",\n    \"-moz-box-flex-group\"           : \"<integer>\",\n    \"-moz-box-lines\"                : \"single | multiple\",\n    \"-moz-box-ordinal-group\"        : \"<integer>\",\n    \"-moz-box-orient\"               : \"horizontal | vertical | inline-axis | block-axis | inherit\",\n    \"-moz-box-pack\"                 : \"start | end | center | justify\",\n    \"-o-box-decoration-break\"       : \"slice | clone\",\n    \"-webkit-box-align\"             : \"start | end | center | baseline | stretch\",\n    \"-webkit-box-decoration-break\"  : \"slice |clone\",\n    \"-webkit-box-direction\"         : \"normal | reverse | inherit\",\n    \"-webkit-box-flex\"              : \"<number>\",\n    \"-webkit-box-flex-group\"        : \"<integer>\",\n    \"-webkit-box-lines\"             : \"single | multiple\",\n    \"-webkit-box-ordinal-group\"     : \"<integer>\",\n    \"-webkit-box-orient\"            : \"horizontal | vertical | inline-axis | block-axis | inherit\",\n    \"-webkit-box-pack\"              : \"start | end | center | justify\",\n    \"box-decoration-break\"          : \"slice | clone\",\n    \"box-shadow\"                    : function (expression) {\n        var part;\n\n        if (!ValidationTypes.isAny(expression, \"none\")) {\n            Validation.multiProperty(\"<shadow>\", expression, true, Infinity);\n        } else {\n            if (expression.hasNext()) {\n                part = expression.next();\n                throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\n            }\n        }\n    },\n    \"box-sizing\"                    : \"content-box | border-box | inherit\",\n    \"break-after\"                   : \"auto | always | avoid | left | right | page | column | avoid-page | avoid-column\",\n    \"break-before\"                  : \"auto | always | avoid | left | right | page | column | avoid-page | avoid-column\",\n    \"break-inside\"                  : \"auto | avoid | avoid-page | avoid-column\",\n\n    //C\n    \"caption-side\"                  : \"top | bottom | inherit\",\n    \"clear\"                         : \"none | right | left | both | inherit\",\n    \"clip\"                          : 1,\n    \"color\"                         : \"<color> | inherit\",\n    \"color-profile\"                 : 1,\n    \"column-count\"                  : \"<integer> | auto\",                      //http://www.w3.org/TR/css3-multicol/\n    \"column-fill\"                   : \"auto | balance\",\n    \"column-gap\"                    : \"<length> | normal\",\n    \"column-rule\"                   : \"<border-width> || <border-style> || <color>\",\n    \"column-rule-color\"             : \"<color>\",\n    \"column-rule-style\"             : \"<border-style>\",\n    \"column-rule-width\"             : \"<border-width>\",\n    \"column-span\"                   : \"none | all\",\n    \"column-width\"                  : \"<length> | auto\",\n    \"columns\"                       : 1,\n    \"content\"                       : 1,\n    \"counter-increment\"             : 1,\n    \"counter-reset\"                 : 1,\n    \"crop\"                          : \"<shape> | auto\",\n    \"cue\"                           : \"cue-after | cue-before | inherit\",\n    \"cue-after\"                     : 1,\n    \"cue-before\"                    : 1,\n    \"cursor\"                        : 1,\n\n    //D\n    \"direction\"                     : \"ltr | rtl | inherit\",\n    \"display\"                       : \"inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | none | inherit | -moz-box | -moz-inline-block | -moz-inline-box | -moz-inline-grid | -moz-inline-stack | -moz-inline-table | -moz-grid | -moz-grid-group | -moz-grid-line | -moz-groupbox | -moz-deck | -moz-popup | -moz-stack | -moz-marker | -webkit-box | -webkit-inline-box | -ms-flexbox | -ms-inline-flexbox | flex | -webkit-flex | inline-flex | -webkit-inline-flex\",\n    \"dominant-baseline\"             : 1,\n    \"drop-initial-after-adjust\"     : \"central | middle | after-edge | text-after-edge | ideographic | alphabetic | mathematical | <percentage> | <length>\",\n    \"drop-initial-after-align\"      : \"baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical\",\n    \"drop-initial-before-adjust\"    : \"before-edge | text-before-edge | central | middle | hanging | mathematical | <percentage> | <length>\",\n    \"drop-initial-before-align\"     : \"caps-height | baseline | use-script | before-edge | text-before-edge | after-edge | text-after-edge | central | middle | ideographic | alphabetic | hanging | mathematical\",\n    \"drop-initial-size\"             : \"auto | line | <length> | <percentage>\",\n    \"drop-initial-value\"            : \"initial | <integer>\",\n\n    //E\n    \"elevation\"                     : \"<angle> | below | level | above | higher | lower | inherit\",\n    \"empty-cells\"                   : \"show | hide | inherit\",\n\n    //F\n    \"filter\"                        : 1,\n    \"fit\"                           : \"fill | hidden | meet | slice\",\n    \"fit-position\"                  : 1,\n    \"flex\"                          : \"<flex>\",\n    \"flex-basis\"                    : \"<width>\",\n    \"flex-direction\"                : \"row | row-reverse | column | column-reverse\",\n    \"flex-flow\"                     : \"<flex-direction> || <flex-wrap>\",\n    \"flex-grow\"                     : \"<number>\",\n    \"flex-shrink\"                   : \"<number>\",\n    \"flex-wrap\"                     : \"nowrap | wrap | wrap-reverse\",\n    \"-webkit-flex\"                  : \"<flex>\",\n    \"-webkit-flex-basis\"            : \"<width>\",\n    \"-webkit-flex-direction\"        : \"row | row-reverse | column | column-reverse\",\n    \"-webkit-flex-flow\"             : \"<flex-direction> || <flex-wrap>\",\n    \"-webkit-flex-grow\"             : \"<number>\",\n    \"-webkit-flex-shrink\"           : \"<number>\",\n    \"-webkit-flex-wrap\"             : \"nowrap | wrap | wrap-reverse\",\n    \"-ms-flex\"                      : \"<flex>\",\n    \"-ms-flex-align\"                : \"start | end | center | stretch | baseline\",\n    \"-ms-flex-direction\"            : \"row | row-reverse | column | column-reverse | inherit\",\n    \"-ms-flex-order\"                : \"<number>\",\n    \"-ms-flex-pack\"                 : \"start | end | center | justify\",\n    \"-ms-flex-wrap\"                 : \"nowrap | wrap | wrap-reverse\",\n    \"float\"                         : \"left | right | none | inherit\",\n    \"float-offset\"                  : 1,\n    \"font\"                          : 1,\n    \"font-family\"                   : 1,\n    \"font-feature-settings\"         : \"<feature-tag-value> | normal | inherit\",\n    \"font-kerning\"                  : \"auto | normal | none | initial | inherit | unset\",\n    \"font-size\"                     : \"<absolute-size> | <relative-size> | <length> | <percentage> | inherit\",\n    \"font-size-adjust\"              : \"<number> | none | inherit\",\n    \"font-stretch\"                  : \"normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | inherit\",\n    \"font-style\"                    : \"normal | italic | oblique | inherit\",\n    \"font-variant\"                  : \"normal | small-caps | inherit\",\n    \"font-variant-caps\"             : \"normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps\",\n    \"font-variant-position\"         : \"normal | sub | super | inherit | initial | unset\",\n    \"font-weight\"                   : \"normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900 | inherit\",\n\n    //G\n    \"grid\"                          : 1,\n    \"grid-area\"                     : 1,\n    \"grid-auto-columns\"             : 1,\n    \"grid-auto-flow\"                : 1,\n    \"grid-auto-position\"            : 1,\n    \"grid-auto-rows\"                : 1,\n    \"grid-cell-stacking\"            : \"columns | rows | layer\",\n    \"grid-column\"                   : 1,\n    \"grid-columns\"                  : 1,\n    \"grid-column-align\"             : \"start | end | center | stretch\",\n    \"grid-column-sizing\"            : 1,\n    \"grid-column-start\"             : 1,\n    \"grid-column-end\"               : 1,\n    \"grid-column-span\"              : \"<integer>\",\n    \"grid-flow\"                     : \"none | rows | columns\",\n    \"grid-layer\"                    : \"<integer>\",\n    \"grid-row\"                      : 1,\n    \"grid-rows\"                     : 1,\n    \"grid-row-align\"                : \"start | end | center | stretch\",\n    \"grid-row-start\"                : 1,\n    \"grid-row-end\"                  : 1,\n    \"grid-row-span\"                 : \"<integer>\",\n    \"grid-row-sizing\"               : 1,\n    \"grid-template\"                 : 1,\n    \"grid-template-areas\"           : 1,\n    \"grid-template-columns\"         : 1,\n    \"grid-template-rows\"            : 1,\n\n    //H\n    \"hanging-punctuation\"           : 1,\n    \"height\"                        : \"<margin-width> | <content-sizing> | inherit\",\n    \"hyphenate-after\"               : \"<integer> | auto\",\n    \"hyphenate-before\"              : \"<integer> | auto\",\n    \"hyphenate-character\"           : \"<string> | auto\",\n    \"hyphenate-lines\"               : \"no-limit | <integer>\",\n    \"hyphenate-resource\"            : 1,\n    \"hyphens\"                       : \"none | manual | auto\",\n\n    //I\n    \"icon\"                          : 1,\n    \"image-orientation\"             : \"angle | auto\",\n    \"image-rendering\"               : 1,\n    \"image-resolution\"              : 1,\n    \"ime-mode\"                      : \"auto | normal | active | inactive | disabled | inherit\",\n    \"inline-box-align\"              : \"initial | last | <integer>\",\n\n    //J\n    \"justify-content\"               : \"flex-start | flex-end | center | space-between | space-around\",\n    \"-webkit-justify-content\"       : \"flex-start | flex-end | center | space-between | space-around\",\n\n    //L\n    \"left\"                          : \"<margin-width> | inherit\",\n    \"letter-spacing\"                : \"<length> | normal | inherit\",\n    \"line-height\"                   : \"<number> | <length> | <percentage> | normal | inherit\",\n    \"line-break\"                    : \"auto | loose | normal | strict\",\n    \"line-stacking\"                 : 1,\n    \"line-stacking-ruby\"            : \"exclude-ruby | include-ruby\",\n    \"line-stacking-shift\"           : \"consider-shifts | disregard-shifts\",\n    \"line-stacking-strategy\"        : \"inline-line-height | block-line-height | max-height | grid-height\",\n    \"list-style\"                    : 1,\n    \"list-style-image\"              : \"<uri> | none | inherit\",\n    \"list-style-position\"           : \"inside | outside | inherit\",\n    \"list-style-type\"               : \"disc | circle | square | decimal | decimal-leading-zero | lower-roman | upper-roman | lower-greek | lower-latin | upper-latin | armenian | georgian | lower-alpha | upper-alpha | none | inherit\",\n\n    //M\n    \"margin\"                        : { multi: \"<margin-width> | inherit\", max: 4 },\n    \"margin-bottom\"                 : \"<margin-width> | inherit\",\n    \"margin-left\"                   : \"<margin-width> | inherit\",\n    \"margin-right\"                  : \"<margin-width> | inherit\",\n    \"margin-top\"                    : \"<margin-width> | inherit\",\n    \"mark\"                          : 1,\n    \"mark-after\"                    : 1,\n    \"mark-before\"                   : 1,\n    \"marks\"                         : 1,\n    \"marquee-direction\"             : 1,\n    \"marquee-play-count\"            : 1,\n    \"marquee-speed\"                 : 1,\n    \"marquee-style\"                 : 1,\n    \"max-height\"                    : \"<length> | <percentage> | <content-sizing> | none | inherit\",\n    \"max-width\"                     : \"<length> | <percentage> | <content-sizing> | none | inherit\",\n    \"min-height\"                    : \"<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit\",\n    \"min-width\"                     : \"<length> | <percentage> | <content-sizing> | contain-floats | -moz-contain-floats | -webkit-contain-floats | inherit\",\n    \"move-to\"                       : 1,\n\n    //N\n    \"nav-down\"                      : 1,\n    \"nav-index\"                     : 1,\n    \"nav-left\"                      : 1,\n    \"nav-right\"                     : 1,\n    \"nav-up\"                        : 1,\n\n    //O\n    \"object-fit\"                    : \"fill | contain | cover | none | scale-down\",\n    \"object-position\"               : \"<bg-position>\",\n    \"opacity\"                       : \"<number> | inherit\",\n    \"order\"                         : \"<integer>\",\n    \"-webkit-order\"                 : \"<integer>\",\n    \"orphans\"                       : \"<integer> | inherit\",\n    \"outline\"                       : 1,\n    \"outline-color\"                 : \"<color> | invert | inherit\",\n    \"outline-offset\"                : 1,\n    \"outline-style\"                 : \"<border-style> | inherit\",\n    \"outline-width\"                 : \"<border-width> | inherit\",\n    \"overflow\"                      : \"visible | hidden | scroll | auto | inherit\",\n    \"overflow-style\"                : 1,\n    \"overflow-wrap\"                 : \"normal | break-word\",\n    \"overflow-x\"                    : 1,\n    \"overflow-y\"                    : 1,\n\n    //P\n    \"padding\"                       : { multi: \"<padding-width> | inherit\", max: 4 },\n    \"padding-bottom\"                : \"<padding-width> | inherit\",\n    \"padding-left\"                  : \"<padding-width> | inherit\",\n    \"padding-right\"                 : \"<padding-width> | inherit\",\n    \"padding-top\"                   : \"<padding-width> | inherit\",\n    \"page\"                          : 1,\n    \"page-break-after\"              : \"auto | always | avoid | left | right | inherit\",\n    \"page-break-before\"             : \"auto | always | avoid | left | right | inherit\",\n    \"page-break-inside\"             : \"auto | avoid | inherit\",\n    \"page-policy\"                   : 1,\n    \"pause\"                         : 1,\n    \"pause-after\"                   : 1,\n    \"pause-before\"                  : 1,\n    \"perspective\"                   : 1,\n    \"perspective-origin\"            : 1,\n    \"phonemes\"                      : 1,\n    \"pitch\"                         : 1,\n    \"pitch-range\"                   : 1,\n    \"play-during\"                   : 1,\n    \"pointer-events\"                : \"auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit\",\n    \"position\"                      : \"static | relative | absolute | fixed | inherit\",\n    \"presentation-level\"            : 1,\n    \"punctuation-trim\"              : 1,\n\n    //Q\n    \"quotes\"                        : 1,\n\n    //R\n    \"rendering-intent\"              : 1,\n    \"resize\"                        : 1,\n    \"rest\"                          : 1,\n    \"rest-after\"                    : 1,\n    \"rest-before\"                   : 1,\n    \"richness\"                      : 1,\n    \"right\"                         : \"<margin-width> | inherit\",\n    \"rotation\"                      : 1,\n    \"rotation-point\"                : 1,\n    \"ruby-align\"                    : 1,\n    \"ruby-overhang\"                 : 1,\n    \"ruby-position\"                 : 1,\n    \"ruby-span\"                     : 1,\n\n    //S\n    \"size\"                          : 1,\n    \"speak\"                         : \"normal | none | spell-out | inherit\",\n    \"speak-header\"                  : \"once | always | inherit\",\n    \"speak-numeral\"                 : \"digits | continuous | inherit\",\n    \"speak-punctuation\"             : \"code | none | inherit\",\n    \"speech-rate\"                   : 1,\n    \"src\"                           : 1,\n    \"stress\"                        : 1,\n    \"string-set\"                    : 1,\n\n    \"table-layout\"                  : \"auto | fixed | inherit\",\n    \"tab-size\"                      : \"<integer> | <length>\",\n    \"target\"                        : 1,\n    \"target-name\"                   : 1,\n    \"target-new\"                    : 1,\n    \"target-position\"               : 1,\n    \"text-align\"                    : \"left | right | center | justify | match-parent | start | end | inherit\" ,\n    \"text-align-last\"               : 1,\n    \"text-decoration\"               : 1,\n    \"text-emphasis\"                 : 1,\n    \"text-height\"                   : 1,\n    \"text-indent\"                   : \"<length> | <percentage> | inherit\",\n    \"text-justify\"                  : \"auto | none | inter-word | inter-ideograph | inter-cluster | distribute | kashida\",\n    \"text-outline\"                  : 1,\n    \"text-overflow\"                 : 1,\n    \"text-rendering\"                : \"auto | optimizeSpeed | optimizeLegibility | geometricPrecision | inherit\",\n    \"text-shadow\"                   : 1,\n    \"text-transform\"                : \"capitalize | uppercase | lowercase | none | inherit\",\n    \"text-wrap\"                     : \"normal | none | avoid\",\n    \"top\"                           : \"<margin-width> | inherit\",\n    \"-ms-touch-action\"              : \"auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation\",\n    \"touch-action\"                  : \"auto | none | pan-x | pan-y | pan-left | pan-right | pan-up | pan-down | manipulation\",\n    \"transform\"                     : 1,\n    \"transform-origin\"              : 1,\n    \"transform-style\"               : 1,\n    \"transition\"                    : 1,\n    \"transition-delay\"              : 1,\n    \"transition-duration\"           : 1,\n    \"transition-property\"           : 1,\n    \"transition-timing-function\"    : 1,\n\n    //U\n    \"unicode-bidi\"                  : \"normal | embed | isolate | bidi-override | isolate-override | plaintext | inherit\",\n    \"user-modify\"                   : \"read-only | read-write | write-only | inherit\",\n    \"user-select\"                   : \"none | text | toggle | element | elements | all | inherit\",\n\n    //V\n    \"vertical-align\"                : \"auto | use-script | baseline | sub | super | top | text-top | central | middle | bottom | text-bottom | <percentage> | <length> | inherit\",\n    \"visibility\"                    : \"visible | hidden | collapse | inherit\",\n    \"voice-balance\"                 : 1,\n    \"voice-duration\"                : 1,\n    \"voice-family\"                  : 1,\n    \"voice-pitch\"                   : 1,\n    \"voice-pitch-range\"             : 1,\n    \"voice-rate\"                    : 1,\n    \"voice-stress\"                  : 1,\n    \"voice-volume\"                  : 1,\n    \"volume\"                        : 1,\n\n    //W\n    \"white-space\"                   : \"normal | pre | nowrap | pre-wrap | pre-line | inherit | -pre-wrap | -o-pre-wrap | -moz-pre-wrap | -hp-pre-wrap\", //http://perishablepress.com/wrapping-content/\n    \"white-space-collapse\"          : 1,\n    \"widows\"                        : \"<integer> | inherit\",\n    \"width\"                         : \"<length> | <percentage> | <content-sizing> | auto | inherit\",\n    \"will-change\"                   : { multi: \"<ident>\", comma: true },\n    \"word-break\"                    : \"normal | keep-all | break-all\",\n    \"word-spacing\"                  : \"<length> | normal | inherit\",\n    \"word-wrap\"                     : \"normal | break-word\",\n    \"writing-mode\"                  : \"horizontal-tb | vertical-rl | vertical-lr | lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb | inherit\",\n\n    //Z\n    \"z-index\"                       : \"<integer> | auto | inherit\",\n    \"zoom\"                          : \"<number> | <percentage> | normal\"\n};\n/**\n * Represents a selector combinator (whitespace, +, >).\n * @namespace parserlib.css\n * @class PropertyName\n * @extends parserlib.util.SyntaxUnit\n * @constructor\n * @param {String} text The text representation of the unit.\n * @param {String} hack The type of IE hack applied (\"*\", \"_\", or null).\n * @param {int} line The line of text on which the unit resides.\n * @param {int} col The column of text on which the unit resides.\n */\nfunction PropertyName(text, hack, line, col){\n\n    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_NAME_TYPE);\n\n    /**\n     * The type of IE hack applied (\"*\", \"_\", or null).\n     * @type String\n     * @property hack\n     */\n    this.hack = hack;\n\n}\n\nPropertyName.prototype = new SyntaxUnit();\nPropertyName.prototype.constructor = PropertyName;\nPropertyName.prototype.toString = function(){\n    return (this.hack ? this.hack : \"\") + this.text;\n};\n/**\n * Represents a single part of a CSS property value, meaning that it represents\n * just everything single part between \":\" and \";\". If there are multiple values\n * separated by commas, this type represents just one of the values.\n * @param {String[]} parts An array of value parts making up this value.\n * @param {int} line The line of text on which the unit resides.\n * @param {int} col The column of text on which the unit resides.\n * @namespace parserlib.css\n * @class PropertyValue\n * @extends parserlib.util.SyntaxUnit\n * @constructor\n */\nfunction PropertyValue(parts, line, col){\n\n    SyntaxUnit.call(this, parts.join(\" \"), line, col, Parser.PROPERTY_VALUE_TYPE);\n\n    /**\n     * The parts that make up the selector.\n     * @type Array\n     * @property parts\n     */\n    this.parts = parts;\n\n}\n\nPropertyValue.prototype = new SyntaxUnit();\nPropertyValue.prototype.constructor = PropertyValue;\n\n/**\n * A utility class that allows for easy iteration over the various parts of a\n * property value.\n * @param {parserlib.css.PropertyValue} value The property value to iterate over.\n * @namespace parserlib.css\n * @class PropertyValueIterator\n * @constructor\n */\nfunction PropertyValueIterator(value){\n\n    /**\n     * Iterator value\n     * @type int\n     * @property _i\n     * @private\n     */\n    this._i = 0;\n\n    /**\n     * The parts that make up the value.\n     * @type Array\n     * @property _parts\n     * @private\n     */\n    this._parts = value.parts;\n\n    /**\n     * Keeps track of bookmarks along the way.\n     * @type Array\n     * @property _marks\n     * @private\n     */\n    this._marks = [];\n\n    /**\n     * Holds the original property value.\n     * @type parserlib.css.PropertyValue\n     * @property value\n     */\n    this.value = value;\n\n}\n\n/**\n * Returns the total number of parts in the value.\n * @return {int} The total number of parts in the value.\n * @method count\n */\nPropertyValueIterator.prototype.count = function(){\n    return this._parts.length;\n};\n\n/**\n * Indicates if the iterator is positioned at the first item.\n * @return {Boolean} True if positioned at first item, false if not.\n * @method isFirst\n */\nPropertyValueIterator.prototype.isFirst = function(){\n    return this._i === 0;\n};\n\n/**\n * Indicates if there are more parts of the property value.\n * @return {Boolean} True if there are more parts, false if not.\n * @method hasNext\n */\nPropertyValueIterator.prototype.hasNext = function(){\n    return (this._i < this._parts.length);\n};\n\n/**\n * Marks the current spot in the iteration so it can be restored to\n * later on.\n * @return {void}\n * @method mark\n */\nPropertyValueIterator.prototype.mark = function(){\n    this._marks.push(this._i);\n};\n\n/**\n * Returns the next part of the property value or null if there is no next\n * part. Does not move the internal counter forward.\n * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next\n * part.\n * @method peek\n */\nPropertyValueIterator.prototype.peek = function(count){\n    return this.hasNext() ? this._parts[this._i + (count || 0)] : null;\n};\n\n/**\n * Returns the next part of the property value or null if there is no next\n * part.\n * @return {parserlib.css.PropertyValuePart} The next part of the property value or null if there is no next\n * part.\n * @method next\n */\nPropertyValueIterator.prototype.next = function(){\n    return this.hasNext() ? this._parts[this._i++] : null;\n};\n\n/**\n * Returns the previous part of the property value or null if there is no\n * previous part.\n * @return {parserlib.css.PropertyValuePart} The previous part of the\n * property value or null if there is no previous part.\n * @method previous\n */\nPropertyValueIterator.prototype.previous = function(){\n    return this._i > 0 ? this._parts[--this._i] : null;\n};\n\n/**\n * Restores the last saved bookmark.\n * @return {void}\n * @method restore\n */\nPropertyValueIterator.prototype.restore = function(){\n    if (this._marks.length){\n        this._i = this._marks.pop();\n    }\n};\n\n/**\n * Represents a single part of a CSS property value, meaning that it represents\n * just one part of the data between \":\" and \";\".\n * @param {String} text The text representation of the unit.\n * @param {int} line The line of text on which the unit resides.\n * @param {int} col The column of text on which the unit resides.\n * @namespace parserlib.css\n * @class PropertyValuePart\n * @extends parserlib.util.SyntaxUnit\n * @constructor\n */\nfunction PropertyValuePart(text, line, col){\n\n    SyntaxUnit.call(this, text, line, col, Parser.PROPERTY_VALUE_PART_TYPE);\n\n    /**\n     * Indicates the type of value unit.\n     * @type String\n     * @property type\n     */\n    this.type = \"unknown\";\n\n    //figure out what type of data it is\n\n    var temp;\n\n    //it is a measurement?\n    if (/^([+\\-]?[\\d\\.]+)([a-z]+)$/i.test(text)){  //dimension\n        this.type = \"dimension\";\n        this.value = +RegExp.$1;\n        this.units = RegExp.$2;\n\n        //try to narrow down\n        switch(this.units.toLowerCase()){\n\n            case \"em\":\n            case \"rem\":\n            case \"ex\":\n            case \"px\":\n            case \"cm\":\n            case \"mm\":\n            case \"in\":\n            case \"pt\":\n            case \"pc\":\n            case \"ch\":\n            case \"vh\":\n            case \"vw\":\n            case \"vmax\":\n            case \"vmin\":\n                this.type = \"length\";\n                break;\n                \n            case \"fr\":\n                this.type = \"grid\";\n                break;\n\n            case \"deg\":\n            case \"rad\":\n            case \"grad\":\n                this.type = \"angle\";\n                break;\n\n            case \"ms\":\n            case \"s\":\n                this.type = \"time\";\n                break;\n\n            case \"hz\":\n            case \"khz\":\n                this.type = \"frequency\";\n                break;\n\n            case \"dpi\":\n            case \"dpcm\":\n                this.type = \"resolution\";\n                break;\n\n            //default\n\n        }\n\n    } else if (/^([+\\-]?[\\d\\.]+)%$/i.test(text)){  //percentage\n        this.type = \"percentage\";\n        this.value = +RegExp.$1;\n    } else if (/^([+\\-]?\\d+)$/i.test(text)){  //integer\n        this.type = \"integer\";\n        this.value = +RegExp.$1;\n    } else if (/^([+\\-]?[\\d\\.]+)$/i.test(text)){  //number\n        this.type = \"number\";\n        this.value = +RegExp.$1;\n\n    } else if (/^#([a-f0-9]{3,6})/i.test(text)){  //hexcolor\n        this.type = \"color\";\n        temp = RegExp.$1;\n        if (temp.length === 3){\n            this.red    = parseInt(temp.charAt(0)+temp.charAt(0),16);\n            this.green  = parseInt(temp.charAt(1)+temp.charAt(1),16);\n            this.blue   = parseInt(temp.charAt(2)+temp.charAt(2),16);\n        } else {\n            this.red    = parseInt(temp.substring(0,2),16);\n            this.green  = parseInt(temp.substring(2,4),16);\n            this.blue   = parseInt(temp.substring(4,6),16);\n        }\n    } else if (/^rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)/i.test(text)){ //rgb() color with absolute numbers\n        this.type   = \"color\";\n        this.red    = +RegExp.$1;\n        this.green  = +RegExp.$2;\n        this.blue   = +RegExp.$3;\n    } else if (/^rgb\\(\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)/i.test(text)){ //rgb() color with percentages\n        this.type   = \"color\";\n        this.red    = +RegExp.$1 * 255 / 100;\n        this.green  = +RegExp.$2 * 255 / 100;\n        this.blue   = +RegExp.$3 * 255 / 100;\n    } else if (/^rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*([\\d\\.]+)\\s*\\)/i.test(text)){ //rgba() color with absolute numbers\n        this.type   = \"color\";\n        this.red    = +RegExp.$1;\n        this.green  = +RegExp.$2;\n        this.blue   = +RegExp.$3;\n        this.alpha  = +RegExp.$4;\n    } else if (/^rgba\\(\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*([\\d\\.]+)\\s*\\)/i.test(text)){ //rgba() color with percentages\n        this.type   = \"color\";\n        this.red    = +RegExp.$1 * 255 / 100;\n        this.green  = +RegExp.$2 * 255 / 100;\n        this.blue   = +RegExp.$3 * 255 / 100;\n        this.alpha  = +RegExp.$4;\n    } else if (/^hsl\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)/i.test(text)){ //hsl()\n        this.type   = \"color\";\n        this.hue    = +RegExp.$1;\n        this.saturation = +RegExp.$2 / 100;\n        this.lightness  = +RegExp.$3 / 100;\n    } else if (/^hsla\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*([\\d\\.]+)\\s*\\)/i.test(text)){ //hsla() color with percentages\n        this.type   = \"color\";\n        this.hue    = +RegExp.$1;\n        this.saturation = +RegExp.$2 / 100;\n        this.lightness  = +RegExp.$3 / 100;\n        this.alpha  = +RegExp.$4;\n    } else if (/^url\\([\"']?([^\\)\"']+)[\"']?\\)/i.test(text)){ //URI\n        this.type   = \"uri\";\n        this.uri    = RegExp.$1;\n    } else if (/^([^\\(]+)\\(/i.test(text)){\n        this.type   = \"function\";\n        this.name   = RegExp.$1;\n        this.value  = text;\n    } else if (/^\"([^\\n\\r\\f\\\\\"]|\\\\\\r\\n|\\\\[^\\r0-9a-f]|\\\\[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?)*\"/i.test(text)){    //double-quoted string\n        this.type   = \"string\";\n        this.value  = PropertyValuePart.parseString(text);\n    } else if (/^'([^\\n\\r\\f\\\\']|\\\\\\r\\n|\\\\[^\\r0-9a-f]|\\\\[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?)*'/i.test(text)){    //single-quoted string\n        this.type   = \"string\";\n        this.value  = PropertyValuePart.parseString(text);\n    } else if (Colors[text.toLowerCase()]){  //named color\n        this.type   = \"color\";\n        temp        = Colors[text.toLowerCase()].substring(1);\n        this.red    = parseInt(temp.substring(0,2),16);\n        this.green  = parseInt(temp.substring(2,4),16);\n        this.blue   = parseInt(temp.substring(4,6),16);\n    } else if (/^[\\,\\/]$/.test(text)){\n        this.type   = \"operator\";\n        this.value  = text;\n    } else if (/^[a-z\\-_\\u0080-\\uFFFF][a-z0-9\\-_\\u0080-\\uFFFF]*$/i.test(text)){\n        this.type   = \"identifier\";\n        this.value  = text;\n    }\n\n}\n\nPropertyValuePart.prototype = new SyntaxUnit();\nPropertyValuePart.prototype.constructor = PropertyValuePart;\n\n/**\n * Helper method to parse a CSS string.\n */\nPropertyValuePart.parseString = function(str) {\n    str = str.slice(1, -1); // Strip surrounding single/double quotes\n    var replacer = function(match, esc) {\n        if (/^(\\n|\\r\\n|\\r|\\f)$/.test(esc)) { return ''; }\n        var m = /^[0-9a-f]{1,6}/i.exec(esc);\n        if (m) {\n            var codePoint = parseInt(m[0], 16);\n            if (String.fromCodePoint) {\n                return String.fromCodePoint(codePoint);\n            } else {\n                // XXX No support for surrogates on old JavaScript engines.\n                return String.fromCharCode(codePoint);\n            }\n        }\n        return esc;\n    };\n    return str.replace(/\\\\(\\r\\n|[^\\r0-9a-f]|[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?)/ig,\n                       replacer);\n};\n\n/**\n * Helper method to serialize a CSS string.\n */\nPropertyValuePart.serializeString = function(value) {\n    var replacer = function(match, c) {\n        if (c === '\"') {\n            return \"\\\\\" + c;\n        }\n        var cp = String.codePointAt ? String.codePointAt(0) :\n            // We only escape non-surrogate chars, so using charCodeAt\n            // is harmless here.\n            String.charCodeAt(0);\n        return \"\\\\\" + cp.toString(16) + \" \";\n    };\n    return '\"' + value.replace(/[\"\\r\\n\\f]/g, replacer) + '\"';\n};\n\n/**\n * Create a new syntax unit based solely on the given token.\n * Convenience method for creating a new syntax unit when\n * it represents a single token instead of multiple.\n * @param {Object} token The token object to represent.\n * @return {parserlib.css.PropertyValuePart} The object representing the token.\n * @static\n * @method fromToken\n */\nPropertyValuePart.fromToken = function(token){\n    return new PropertyValuePart(token.value, token.startLine, token.startCol);\n};\nvar Pseudos = {\n    __proto__:       null,\n    \":first-letter\": 1,\n    \":first-line\":   1,\n    \":before\":       1,\n    \":after\":        1\n};\n\nPseudos.ELEMENT = 1;\nPseudos.CLASS = 2;\n\nPseudos.isElement = function(pseudo){\n    return pseudo.indexOf(\"::\") === 0 || Pseudos[pseudo.toLowerCase()] === Pseudos.ELEMENT;\n};\n/**\n * Represents an entire single selector, including all parts but not\n * including multiple selectors (those separated by commas).\n * @namespace parserlib.css\n * @class Selector\n * @extends parserlib.util.SyntaxUnit\n * @constructor\n * @param {Array} parts Array of selectors parts making up this selector.\n * @param {int} line The line of text on which the unit resides.\n * @param {int} col The column of text on which the unit resides.\n */\nfunction Selector(parts, line, col){\n\n    SyntaxUnit.call(this, parts.join(\" \"), line, col, Parser.SELECTOR_TYPE);\n\n    /**\n     * The parts that make up the selector.\n     * @type Array\n     * @property parts\n     */\n    this.parts = parts;\n\n    /**\n     * The specificity of the selector.\n     * @type parserlib.css.Specificity\n     * @property specificity\n     */\n    this.specificity = Specificity.calculate(this);\n\n}\n\nSelector.prototype = new SyntaxUnit();\nSelector.prototype.constructor = Selector;\n\n/**\n * Represents a single part of a selector string, meaning a single set of\n * element name and modifiers. This does not include combinators such as\n * spaces, +, >, etc.\n * @namespace parserlib.css\n * @class SelectorPart\n * @extends parserlib.util.SyntaxUnit\n * @constructor\n * @param {String} elementName The element name in the selector or null\n *      if there is no element name.\n * @param {Array} modifiers Array of individual modifiers for the element.\n *      May be empty if there are none.\n * @param {String} text The text representation of the unit.\n * @param {int} line The line of text on which the unit resides.\n * @param {int} col The column of text on which the unit resides.\n */\nfunction SelectorPart(elementName, modifiers, text, line, col){\n\n    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_PART_TYPE);\n\n    /**\n     * The tag name of the element to which this part\n     * of the selector affects.\n     * @type String\n     * @property elementName\n     */\n    this.elementName = elementName;\n\n    /**\n     * The parts that come after the element name, such as class names, IDs,\n     * pseudo classes/elements, etc.\n     * @type Array\n     * @property modifiers\n     */\n    this.modifiers = modifiers;\n\n}\n\nSelectorPart.prototype = new SyntaxUnit();\nSelectorPart.prototype.constructor = SelectorPart;\n\n/**\n * Represents a selector modifier string, meaning a class name, element name,\n * element ID, pseudo rule, etc.\n * @namespace parserlib.css\n * @class SelectorSubPart\n * @extends parserlib.util.SyntaxUnit\n * @constructor\n * @param {String} text The text representation of the unit.\n * @param {String} type The type of selector modifier.\n * @param {int} line The line of text on which the unit resides.\n * @param {int} col The column of text on which the unit resides.\n */\nfunction SelectorSubPart(text, type, line, col){\n\n    SyntaxUnit.call(this, text, line, col, Parser.SELECTOR_SUB_PART_TYPE);\n\n    /**\n     * The type of modifier.\n     * @type String\n     * @property type\n     */\n    this.type = type;\n\n    /**\n     * Some subparts have arguments, this represents them.\n     * @type Array\n     * @property args\n     */\n    this.args = [];\n\n}\n\nSelectorSubPart.prototype = new SyntaxUnit();\nSelectorSubPart.prototype.constructor = SelectorSubPart;\n\n/**\n * Represents a selector's specificity.\n * @namespace parserlib.css\n * @class Specificity\n * @constructor\n * @param {int} a Should be 1 for inline styles, zero for stylesheet styles\n * @param {int} b Number of ID selectors\n * @param {int} c Number of classes and pseudo classes\n * @param {int} d Number of element names and pseudo elements\n */\nfunction Specificity(a, b, c, d){\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n}\n\nSpecificity.prototype = {\n    constructor: Specificity,\n\n    /**\n     * Compare this specificity to another.\n     * @param {Specificity} other The other specificity to compare to.\n     * @return {int} -1 if the other specificity is larger, 1 if smaller, 0 if equal.\n     * @method compare\n     */\n    compare: function(other){\n        var comps = [\"a\", \"b\", \"c\", \"d\"],\n            i, len;\n\n        for (i=0, len=comps.length; i < len; i++){\n            if (this[comps[i]] < other[comps[i]]){\n                return -1;\n            } else if (this[comps[i]] > other[comps[i]]){\n                return 1;\n            }\n        }\n\n        return 0;\n    },\n\n    /**\n     * Creates a numeric value for the specificity.\n     * @return {int} The numeric value for the specificity.\n     * @method valueOf\n     */\n    valueOf: function(){\n        return (this.a * 1000) + (this.b * 100) + (this.c * 10) + this.d;\n    },\n\n    /**\n     * Returns a string representation for specificity.\n     * @return {String} The string representation of specificity.\n     * @method toString\n     */\n    toString: function(){\n        return this.a + \",\" + this.b + \",\" + this.c + \",\" + this.d;\n    }\n\n};\n\n/**\n * Calculates the specificity of the given selector.\n * @param {parserlib.css.Selector} The selector to calculate specificity for.\n * @return {parserlib.css.Specificity} The specificity of the selector.\n * @static\n * @method calculate\n */\nSpecificity.calculate = function(selector){\n\n    var i, len,\n        part,\n        b=0, c=0, d=0;\n\n    function updateValues(part){\n\n        var i, j, len, num,\n            elementName = part.elementName ? part.elementName.text : \"\",\n            modifier;\n\n        if (elementName && elementName.charAt(elementName.length-1) !== \"*\") {\n            d++;\n        }\n\n        for (i=0, len=part.modifiers.length; i < len; i++){\n            modifier = part.modifiers[i];\n            switch(modifier.type){\n                case \"class\":\n                case \"attribute\":\n                    c++;\n                    break;\n\n                case \"id\":\n                    b++;\n                    break;\n\n                case \"pseudo\":\n                    if (Pseudos.isElement(modifier.text)){\n                        d++;\n                    } else {\n                        c++;\n                    }\n                    break;\n\n                case \"not\":\n                    for (j=0, num=modifier.args.length; j < num; j++){\n                        updateValues(modifier.args[j]);\n                    }\n            }\n         }\n    }\n\n    for (i=0, len=selector.parts.length; i < len; i++){\n        part = selector.parts[i];\n\n        if (part instanceof SelectorPart){\n            updateValues(part);\n        }\n    }\n\n    return new Specificity(0, b, c, d);\n};\n\nvar h = /^[0-9a-fA-F]$/,\n    //nonascii = /^[\\u0080-\\uFFFF]$/,\n    nl = /\\n|\\r\\n|\\r|\\f/;\n\n//-----------------------------------------------------------------------------\n// Helper functions\n//-----------------------------------------------------------------------------\n\n\nfunction isHexDigit(c){\n    return c !== null && h.test(c);\n}\n\nfunction isDigit(c){\n    return c !== null && /\\d/.test(c);\n}\n\nfunction isWhitespace(c){\n    return c !== null && /\\s/.test(c);\n}\n\nfunction isNewLine(c){\n    return c !== null && nl.test(c);\n}\n\nfunction isNameStart(c){\n    return c !== null && (/[a-z_\\u0080-\\uFFFF\\\\]/i.test(c));\n}\n\nfunction isNameChar(c){\n    return c !== null && (isNameStart(c) || /[0-9\\-\\\\]/.test(c));\n}\n\nfunction isIdentStart(c){\n    return c !== null && (isNameStart(c) || /\\-\\\\/.test(c));\n}\n\nfunction mix(receiver, supplier){\n\tfor (var prop in supplier){\n\t\tif (Object.prototype.hasOwnProperty.call(supplier, prop)){\n\t\t\treceiver[prop] = supplier[prop];\n\t\t}\n\t}\n\treturn receiver;\n}\n\n//-----------------------------------------------------------------------------\n// CSS Token Stream\n//-----------------------------------------------------------------------------\n\n\n/**\n * A token stream that produces CSS tokens.\n * @param {String|Reader} input The source of text to tokenize.\n * @constructor\n * @class TokenStream\n * @namespace parserlib.css\n */\nfunction TokenStream(input){\n\tTokenStreamBase.call(this, input, Tokens);\n}\n\nTokenStream.prototype = mix(new TokenStreamBase(), {\n\n    /**\n     * Overrides the TokenStreamBase method of the same name\n     * to produce CSS tokens.\n     * @param {variant} channel The name of the channel to use\n     *      for the next token.\n     * @return {Object} A token object representing the next token.\n     * @method _getToken\n     * @private\n     */\n    _getToken: function(channel){\n\n        var c,\n            reader = this._reader,\n            token   = null,\n            startLine   = reader.getLine(),\n            startCol    = reader.getCol();\n\n        c = reader.read();\n\n\n        while(c){\n            switch(c){\n\n                /*\n                 * Potential tokens:\n                 * - COMMENT\n                 * - SLASH\n                 * - CHAR\n                 */\n                case \"/\":\n\n                    if(reader.peek() === \"*\"){\n                        token = this.commentToken(c, startLine, startCol);\n                    } else {\n                        token = this.charToken(c, startLine, startCol);\n                    }\n                    break;\n\n                /*\n                 * Potential tokens:\n                 * - DASHMATCH\n                 * - INCLUDES\n                 * - PREFIXMATCH\n                 * - SUFFIXMATCH\n                 * - SUBSTRINGMATCH\n                 * - CHAR\n                 */\n                case \"|\":\n                case \"~\":\n                case \"^\":\n                case \"$\":\n                case \"*\":\n                    if(reader.peek() === \"=\"){\n                        token = this.comparisonToken(c, startLine, startCol);\n                    } else {\n                        token = this.charToken(c, startLine, startCol);\n                    }\n                    break;\n\n                /*\n                 * Potential tokens:\n                 * - STRING\n                 * - INVALID\n                 */\n                case \"\\\"\":\n                case \"'\":\n                    token = this.stringToken(c, startLine, startCol);\n                    break;\n\n                /*\n                 * Potential tokens:\n                 * - HASH\n                 * - CHAR\n                 */\n                case \"#\":\n                    if (isNameChar(reader.peek())){\n                        token = this.hashToken(c, startLine, startCol);\n                    } else {\n                        token = this.charToken(c, startLine, startCol);\n                    }\n                    break;\n\n                /*\n                 * Potential tokens:\n                 * - DOT\n                 * - NUMBER\n                 * - DIMENSION\n                 * - PERCENTAGE\n                 */\n                case \".\":\n                    if (isDigit(reader.peek())){\n                        token = this.numberToken(c, startLine, startCol);\n                    } else {\n                        token = this.charToken(c, startLine, startCol);\n                    }\n                    break;\n\n                /*\n                 * Potential tokens:\n                 * - CDC\n                 * - MINUS\n                 * - NUMBER\n                 * - DIMENSION\n                 * - PERCENTAGE\n                 */\n                case \"-\":\n                    if (reader.peek() === \"-\"){  //could be closing HTML-style comment\n                        token = this.htmlCommentEndToken(c, startLine, startCol);\n                    } else if (isNameStart(reader.peek())){\n                        token = this.identOrFunctionToken(c, startLine, startCol);\n                    } else {\n                        token = this.charToken(c, startLine, startCol);\n                    }\n                    break;\n\n                /*\n                 * Potential tokens:\n                 * - IMPORTANT_SYM\n                 * - CHAR\n                 */\n                case \"!\":\n                    token = this.importantToken(c, startLine, startCol);\n                    break;\n\n                /*\n                 * Any at-keyword or CHAR\n                 */\n                case \"@\":\n                    token = this.atRuleToken(c, startLine, startCol);\n                    break;\n\n                /*\n                 * Potential tokens:\n                 * - NOT\n                 * - CHAR\n                 */\n                case \":\":\n                    token = this.notToken(c, startLine, startCol);\n                    break;\n\n                /*\n                 * Potential tokens:\n                 * - CDO\n                 * - CHAR\n                 */\n                case \"<\":\n                    token = this.htmlCommentStartToken(c, startLine, startCol);\n                    break;\n\n                /*\n                 * Potential tokens:\n                 * - UNICODE_RANGE\n                 * - URL\n                 * - CHAR\n                 */\n                case \"U\":\n                case \"u\":\n                    if (reader.peek() === \"+\"){\n                        token = this.unicodeRangeToken(c, startLine, startCol);\n                        break;\n                    }\n                    /* falls through */\n                default:\n\n                    /*\n                     * Potential tokens:\n                     * - NUMBER\n                     * - DIMENSION\n                     * - LENGTH\n                     * - FREQ\n                     * - TIME\n                     * - EMS\n                     * - EXS\n                     * - ANGLE\n                     */\n                    if (isDigit(c)){\n                        token = this.numberToken(c, startLine, startCol);\n                    } else\n\n                    /*\n                     * Potential tokens:\n                     * - S\n                     */\n                    if (isWhitespace(c)){\n                        token = this.whitespaceToken(c, startLine, startCol);\n                    } else\n\n                    /*\n                     * Potential tokens:\n                     * - IDENT\n                     */\n                    if (isIdentStart(c)){\n                        token = this.identOrFunctionToken(c, startLine, startCol);\n                    } else\n\n                    /*\n                     * Potential tokens:\n                     * - CHAR\n                     * - PLUS\n                     */\n                    {\n                        token = this.charToken(c, startLine, startCol);\n                    }\n\n\n\n\n\n\n            }\n\n            //make sure this token is wanted\n            //TODO: check channel\n            break;\n        }\n\n        if (!token && c === null){\n            token = this.createToken(Tokens.EOF,null,startLine,startCol);\n        }\n\n        return token;\n    },\n\n    //-------------------------------------------------------------------------\n    // Methods to create tokens\n    //-------------------------------------------------------------------------\n\n    /**\n     * Produces a token based on available data and the current\n     * reader position information. This method is called by other\n     * private methods to create tokens and is never called directly.\n     * @param {int} tt The token type.\n     * @param {String} value The text value of the token.\n     * @param {int} startLine The beginning line for the character.\n     * @param {int} startCol The beginning column for the character.\n     * @param {Object} options (Optional) Specifies a channel property\n     *      to indicate that a different channel should be scanned\n     *      and/or a hide property indicating that the token should\n     *      be hidden.\n     * @return {Object} A token object.\n     * @method createToken\n     */\n    createToken: function(tt, value, startLine, startCol, options){\n        var reader = this._reader;\n        options = options || {};\n\n        return {\n            value:      value,\n            type:       tt,\n            channel:    options.channel,\n            endChar:    options.endChar,\n            hide:       options.hide || false,\n            startLine:  startLine,\n            startCol:   startCol,\n            endLine:    reader.getLine(),\n            endCol:     reader.getCol()\n        };\n    },\n\n    //-------------------------------------------------------------------------\n    // Methods to create specific tokens\n    //-------------------------------------------------------------------------\n\n    /**\n     * Produces a token for any at-rule. If the at-rule is unknown, then\n     * the token is for a single \"@\" character.\n     * @param {String} first The first character for the token.\n     * @param {int} startLine The beginning line for the character.\n     * @param {int} startCol The beginning column for the character.\n     * @return {Object} A token object.\n     * @method atRuleToken\n     */\n    atRuleToken: function(first, startLine, startCol){\n        var rule    = first,\n            reader  = this._reader,\n            tt      = Tokens.CHAR,\n            ident;\n\n        /*\n         * First, mark where we are. There are only four @ rules,\n         * so anything else is really just an invalid token.\n         * Basically, if this doesn't match one of the known @\n         * rules, just return '@' as an unknown token and allow\n         * parsing to continue after that point.\n         */\n        reader.mark();\n\n        //try to find the at-keyword\n        ident = this.readName();\n        rule = first + ident;\n        tt = Tokens.type(rule.toLowerCase());\n\n        //if it's not valid, use the first character only and reset the reader\n        if (tt === Tokens.CHAR || tt === Tokens.UNKNOWN){\n            if (rule.length > 1){\n                tt = Tokens.UNKNOWN_SYM;\n            } else {\n                tt = Tokens.CHAR;\n                rule = first;\n                reader.reset();\n            }\n        }\n\n        return this.createToken(tt, rule, startLine, startCol);\n    },\n\n    /**\n     * Produces a character token based on the given character\n     * and location in the stream. If there's a special (non-standard)\n     * token name, this is used; otherwise CHAR is used.\n     * @param {String} c The character for the token.\n     * @param {int} startLine The beginning line for the character.\n     * @param {int} startCol The beginning column for the character.\n     * @return {Object} A token object.\n     * @method charToken\n     */\n    charToken: function(c, startLine, startCol){\n        var tt = Tokens.type(c);\n        var opts = {};\n\n        if (tt === -1){\n            tt = Tokens.CHAR;\n        } else {\n            opts.endChar = Tokens[tt].endChar;\n        }\n\n        return this.createToken(tt, c, startLine, startCol, opts);\n    },\n\n    /**\n     * Produces a character token based on the given character\n     * and location in the stream. If there's a special (non-standard)\n     * token name, this is used; otherwise CHAR is used.\n     * @param {String} first The first character for the token.\n     * @param {int} startLine The beginning line for the character.\n     * @param {int} startCol The beginning column for the character.\n     * @return {Object} A token object.\n     * @method commentToken\n     */\n    commentToken: function(first, startLine, startCol){\n        var comment = this.readComment(first);\n\n        return this.createToken(Tokens.COMMENT, comment, startLine, startCol);\n    },\n\n    /**\n     * Produces a comparison token based on the given character\n     * and location in the stream. The next character must be\n     * read and is already known to be an equals sign.\n     * @param {String} c The character for the token.\n     * @param {int} startLine The beginning line for the character.\n     * @param {int} startCol The beginning column for the character.\n     * @return {Object} A token object.\n     * @method comparisonToken\n     */\n    comparisonToken: function(c, startLine, startCol){\n        var reader  = this._reader,\n            comparison  = c + reader.read(),\n            tt      = Tokens.type(comparison) || Tokens.CHAR;\n\n        return this.createToken(tt, comparison, startLine, startCol);\n    },\n\n    /**\n     * Produces a hash token based on the specified information. The\n     * first character provided is the pound sign (#) and then this\n     * method reads a name afterward.\n     * @param {String} first The first character (#) in the hash name.\n     * @param {int} startLine The beginning line for the character.\n     * @param {int} startCol The beginning column for the character.\n     * @return {Object} A token object.\n     * @method hashToken\n     */\n    hashToken: function(first, startLine, startCol){\n        var name    = this.readName(first);\n\n        return this.createToken(Tokens.HASH, name, startLine, startCol);\n    },\n\n    /**\n     * Produces a CDO or CHAR token based on the specified information. The\n     * first character is provided and the rest is read by the function to determine\n     * the correct token to create.\n     * @param {String} first The first character in the token.\n     * @param {int} startLine The beginning line for the character.\n     * @param {int} startCol The beginning column for the character.\n     * @return {Object} A token object.\n     * @method htmlCommentStartToken\n     */\n    htmlCommentStartToken: function(first, startLine, startCol){\n        var reader      = this._reader,\n            text        = first;\n\n        reader.mark();\n        text += reader.readCount(3);\n\n        if (text === \"<!--\"){\n            return this.createToken(Tokens.CDO, text, startLine, startCol);\n        } else {\n            reader.reset();\n            return this.charToken(first, startLine, startCol);\n        }\n    },\n\n    /**\n     * Produces a CDC or CHAR token based on the specified information. The\n     * first character is provided and the rest is read by the function to determine\n     * the correct token to create.\n     * @param {String} first The first character in the token.\n     * @param {int} startLine The beginning line for the character.\n     * @param {int} startCol The beginning column for the character.\n     * @return {Object} A token object.\n     * @method htmlCommentEndToken\n     */\n    htmlCommentEndToken: function(first, startLine, startCol){\n        var reader      = this._reader,\n            text        = first;\n\n        reader.mark();\n        text += reader.readCount(2);\n\n        if (text === \"-->\"){\n            return this.createToken(Tokens.CDC, text, startLine, startCol);\n        } else {\n            reader.reset();\n            return this.charToken(first, startLine, startCol);\n        }\n    },\n\n    /**\n     * Produces an IDENT or FUNCTION token based on the specified information. The\n     * first character is provided and the rest is read by the function to determine\n     * the correct token to create.\n     * @param {String} first The first character in the identifier.\n     * @param {int} startLine The beginning line for the character.\n     * @param {int} startCol The beginning column for the character.\n     * @return {Object} A token object.\n     * @method identOrFunctionToken\n     */\n    identOrFunctionToken: function(first, startLine, startCol){\n        var reader  = this._reader,\n            ident   = this.readName(first),\n            tt      = Tokens.IDENT,\n            uriFns  = [\"url(\", \"url-prefix(\", \"domain(\"];\n\n        //if there's a left paren immediately after, it's a URI or function\n        if (reader.peek() === \"(\"){\n            ident += reader.read();\n            if (uriFns.indexOf(ident.toLowerCase()) > -1){\n                tt = Tokens.URI;\n                ident = this.readURI(ident);\n\n                //didn't find a valid URL or there's no closing paren\n                if (uriFns.indexOf(ident.toLowerCase()) > -1){\n                    tt = Tokens.FUNCTION;\n                }\n            } else {\n                tt = Tokens.FUNCTION;\n            }\n        } else if (reader.peek() === \":\"){  //might be an IE function\n\n            //IE-specific functions always being with progid:\n            if (ident.toLowerCase() === \"progid\"){\n                ident += reader.readTo(\"(\");\n                tt = Tokens.IE_FUNCTION;\n            }\n        }\n\n        return this.createToken(tt, ident, startLine, startCol);\n    },\n\n    /**\n     * Produces an IMPORTANT_SYM or CHAR token based on the specified information. The\n     * first character is provided and the rest is read by the function to determine\n     * the correct token to create.\n     * @param {String} first The first character in the token.\n     * @param {int} startLine The beginning line for the character.\n     * @param {int} startCol The beginning column for the character.\n     * @return {Object} A token object.\n     * @method importantToken\n     */\n    importantToken: function(first, startLine, startCol){\n        var reader      = this._reader,\n            important   = first,\n            tt          = Tokens.CHAR,\n            temp,\n            c;\n\n        reader.mark();\n        c = reader.read();\n\n        while(c){\n\n            //there can be a comment in here\n            if (c === \"/\"){\n\n                //if the next character isn't a star, then this isn't a valid !important token\n                if (reader.peek() !== \"*\"){\n                    break;\n                } else {\n                    temp = this.readComment(c);\n                    if (temp === \"\"){    //broken!\n                        break;\n                    }\n                }\n            } else if (isWhitespace(c)){\n                important += c + this.readWhitespace();\n            } else if (/i/i.test(c)){\n                temp = reader.readCount(8);\n                if (/mportant/i.test(temp)){\n                    important += c + temp;\n                    tt = Tokens.IMPORTANT_SYM;\n\n                }\n                break;  //we're done\n            } else {\n                break;\n            }\n\n            c = reader.read();\n        }\n\n        if (tt === Tokens.CHAR){\n            reader.reset();\n            return this.charToken(first, startLine, startCol);\n        } else {\n            return this.createToken(tt, important, startLine, startCol);\n        }\n\n\n    },\n\n    /**\n     * Produces a NOT or CHAR token based on the specified information. The\n     * first character is provided and the rest is read by the function to determine\n     * the correct token to create.\n     * @param {String} first The first character in the token.\n     * @param {int} startLine The beginning line for the character.\n     * @param {int} startCol The beginning column for the character.\n     * @return {Object} A token object.\n     * @method notToken\n     */\n    notToken: function(first, startLine, startCol){\n        var reader      = this._reader,\n            text        = first;\n\n        reader.mark();\n        text += reader.readCount(4);\n\n        if (text.toLowerCase() === \":not(\"){\n            return this.createToken(Tokens.NOT, text, startLine, startCol);\n        } else {\n            reader.reset();\n            return this.charToken(first, startLine, startCol);\n        }\n    },\n\n    /**\n     * Produces a number token based on the given character\n     * and location in the stream. This may return a token of\n     * NUMBER, EMS, EXS, LENGTH, ANGLE, TIME, FREQ, DIMENSION,\n     * or PERCENTAGE.\n     * @param {String} first The first character for the token.\n     * @param {int} startLine The beginning line for the character.\n     * @param {int} startCol The beginning column for the character.\n     * @return {Object} A token object.\n     * @method numberToken\n     */\n    numberToken: function(first, startLine, startCol){\n        var reader  = this._reader,\n            value   = this.readNumber(first),\n            ident,\n            tt      = Tokens.NUMBER,\n            c       = reader.peek();\n\n        if (isIdentStart(c)){\n            ident = this.readName(reader.read());\n            value += ident;\n\n            if (/^em$|^ex$|^px$|^gd$|^rem$|^vw$|^vh$|^vmax$|^vmin$|^ch$|^cm$|^mm$|^in$|^pt$|^pc$/i.test(ident)){\n                tt = Tokens.LENGTH;\n            } else if (/^deg|^rad$|^grad$/i.test(ident)){\n                tt = Tokens.ANGLE;\n            } else if (/^ms$|^s$/i.test(ident)){\n                tt = Tokens.TIME;\n            } else if (/^hz$|^khz$/i.test(ident)){\n                tt = Tokens.FREQ;\n            } else if (/^dpi$|^dpcm$/i.test(ident)){\n                tt = Tokens.RESOLUTION;\n            } else {\n                tt = Tokens.DIMENSION;\n            }\n\n        } else if (c === \"%\"){\n            value += reader.read();\n            tt = Tokens.PERCENTAGE;\n        }\n\n        return this.createToken(tt, value, startLine, startCol);\n    },\n\n    /**\n     * Produces a string token based on the given character\n     * and location in the stream. Since strings may be indicated\n     * by single or double quotes, a failure to match starting\n     * and ending quotes results in an INVALID token being generated.\n     * The first character in the string is passed in and then\n     * the rest are read up to and including the final quotation mark.\n     * @param {String} first The first character in the string.\n     * @param {int} startLine The beginning line for the character.\n     * @param {int} startCol The beginning column for the character.\n     * @return {Object} A token object.\n     * @method stringToken\n     */\n    stringToken: function(first, startLine, startCol){\n        var delim   = first,\n            string  = first,\n            reader  = this._reader,\n            prev    = first,\n            tt      = Tokens.STRING,\n            c       = reader.read();\n\n        while(c){\n            string += c;\n\n            //if the delimiter is found with an escapement, we're done.\n            if (c === delim && prev !== \"\\\\\"){\n                break;\n            }\n\n            //if there's a newline without an escapement, it's an invalid string\n            if (isNewLine(reader.peek()) && c !== \"\\\\\"){\n                tt = Tokens.INVALID;\n                break;\n            }\n\n            //save previous and get next\n            prev = c;\n            c = reader.read();\n        }\n\n        //if c is null, that means we're out of input and the string was never closed\n        if (c === null){\n            tt = Tokens.INVALID;\n        }\n\n        return this.createToken(tt, string, startLine, startCol);\n    },\n\n    unicodeRangeToken: function(first, startLine, startCol){\n        var reader  = this._reader,\n            value   = first,\n            temp,\n            tt      = Tokens.CHAR;\n\n        //then it should be a unicode range\n        if (reader.peek() === \"+\"){\n            reader.mark();\n            value += reader.read();\n            value += this.readUnicodeRangePart(true);\n\n            //ensure there's an actual unicode range here\n            if (value.length === 2){\n                reader.reset();\n            } else {\n\n                tt = Tokens.UNICODE_RANGE;\n\n                //if there's a ? in the first part, there can't be a second part\n                if (value.indexOf(\"?\") === -1){\n\n                    if (reader.peek() === \"-\"){\n                        reader.mark();\n                        temp = reader.read();\n                        temp += this.readUnicodeRangePart(false);\n\n                        //if there's not another value, back up and just take the first\n                        if (temp.length === 1){\n                            reader.reset();\n                        } else {\n                            value += temp;\n                        }\n                    }\n\n                }\n            }\n        }\n\n        return this.createToken(tt, value, startLine, startCol);\n    },\n\n    /**\n     * Produces a S token based on the specified information. Since whitespace\n     * may have multiple characters, this consumes all whitespace characters\n     * into a single token.\n     * @param {String} first The first character in the token.\n     * @param {int} startLine The beginning line for the character.\n     * @param {int} startCol The beginning column for the character.\n     * @return {Object} A token object.\n     * @method whitespaceToken\n     */\n    whitespaceToken: function(first, startLine, startCol){\n        var value   = first + this.readWhitespace();\n        return this.createToken(Tokens.S, value, startLine, startCol);\n    },\n\n\n\n\n    //-------------------------------------------------------------------------\n    // Methods to read values from the string stream\n    //-------------------------------------------------------------------------\n\n    readUnicodeRangePart: function(allowQuestionMark){\n        var reader  = this._reader,\n            part = \"\",\n            c       = reader.peek();\n\n        //first read hex digits\n        while(isHexDigit(c) && part.length < 6){\n            reader.read();\n            part += c;\n            c = reader.peek();\n        }\n\n        //then read question marks if allowed\n        if (allowQuestionMark){\n            while(c === \"?\" && part.length < 6){\n                reader.read();\n                part += c;\n                c = reader.peek();\n            }\n        }\n\n        //there can't be any other characters after this point\n\n        return part;\n    },\n\n    readWhitespace: function(){\n        var reader  = this._reader,\n            whitespace = \"\",\n            c       = reader.peek();\n\n        while(isWhitespace(c)){\n            reader.read();\n            whitespace += c;\n            c = reader.peek();\n        }\n\n        return whitespace;\n    },\n    readNumber: function(first){\n        var reader  = this._reader,\n            number  = first,\n            hasDot  = (first === \".\"),\n            c       = reader.peek();\n\n\n        while(c){\n            if (isDigit(c)){\n                number += reader.read();\n            } else if (c === \".\"){\n                if (hasDot){\n                    break;\n                } else {\n                    hasDot = true;\n                    number += reader.read();\n                }\n            } else {\n                break;\n            }\n\n            c = reader.peek();\n        }\n\n        return number;\n    },\n    readString: function(){\n        var reader  = this._reader,\n            delim   = reader.read(),\n            string  = delim,\n            prev    = delim,\n            c       = reader.peek();\n\n        while(c){\n            c = reader.read();\n            string += c;\n\n            //if the delimiter is found with an escapement, we're done.\n            if (c === delim && prev !== \"\\\\\"){\n                break;\n            }\n\n            //if there's a newline without an escapement, it's an invalid string\n            if (isNewLine(reader.peek()) && c !== \"\\\\\"){\n                string = \"\";\n                break;\n            }\n\n            //save previous and get next\n            prev = c;\n            c = reader.peek();\n        }\n\n        //if c is null, that means we're out of input and the string was never closed\n        if (c === null){\n            string = \"\";\n        }\n\n        return string;\n    },\n    readURI: function(first){\n        var reader  = this._reader,\n            uri     = first,\n            inner   = \"\",\n            c       = reader.peek();\n\n        reader.mark();\n\n        //skip whitespace before\n        while(c && isWhitespace(c)){\n            reader.read();\n            c = reader.peek();\n        }\n\n        //it's a string\n        if (c === \"'\" || c === \"\\\"\"){\n            inner = this.readString();\n        } else {\n            inner = this.readURL();\n        }\n\n        c = reader.peek();\n\n        //skip whitespace after\n        while(c && isWhitespace(c)){\n            reader.read();\n            c = reader.peek();\n        }\n\n        //if there was no inner value or the next character isn't closing paren, it's not a URI\n        if (inner === \"\" || c !== \")\"){\n            uri = first;\n            reader.reset();\n        } else {\n            uri += inner + reader.read();\n        }\n\n        return uri;\n    },\n    readURL: function(){\n        var reader  = this._reader,\n            url     = \"\",\n            c       = reader.peek();\n\n        //TODO: Check for escape and nonascii\n        while (/^[!#$%&\\\\*-~]$/.test(c)){\n            url += reader.read();\n            c = reader.peek();\n        }\n\n        return url;\n\n    },\n    readName: function(first){\n        var reader  = this._reader,\n            ident   = first || \"\",\n            c       = reader.peek();\n\n        while(true){\n            if (c === \"\\\\\"){\n                ident += this.readEscape(reader.read());\n                c = reader.peek();\n            } else if(c && isNameChar(c)){\n                ident += reader.read();\n                c = reader.peek();\n            } else {\n                break;\n            }\n        }\n\n        return ident;\n    },\n\n    readEscape: function(first){\n        var reader  = this._reader,\n            cssEscape = first || \"\",\n            i       = 0,\n            c       = reader.peek();\n\n        if (isHexDigit(c)){\n            do {\n                cssEscape += reader.read();\n                c = reader.peek();\n            } while(c && isHexDigit(c) && ++i < 6);\n        }\n\n        if (cssEscape.length === 3 && /\\s/.test(c) ||\n            cssEscape.length === 7 || cssEscape.length === 1){\n                reader.read();\n        } else {\n            c = \"\";\n        }\n\n        return cssEscape + c;\n    },\n\n    readComment: function(first){\n        var reader  = this._reader,\n            comment = first || \"\",\n            c       = reader.read();\n\n        if (c === \"*\"){\n            while(c){\n                comment += c;\n\n                //look for end of comment\n                if (comment.length > 2 && c === \"*\" && reader.peek() === \"/\"){\n                    comment += reader.read();\n                    break;\n                }\n\n                c = reader.read();\n            }\n\n            return comment;\n        } else {\n            return \"\";\n        }\n\n    }\n});\n\nvar Tokens  = [\n\n    /*\n     * The following token names are defined in CSS3 Grammar: http://www.w3.org/TR/css3-syntax/#lexical\n     */\n\n    //HTML-style comments\n    { name: \"CDO\"},\n    { name: \"CDC\"},\n\n    //ignorables\n    { name: \"S\", whitespace: true/*, channel: \"ws\"*/},\n    { name: \"COMMENT\", comment: true, hide: true, channel: \"comment\" },\n\n    //attribute equality\n    { name: \"INCLUDES\", text: \"~=\"},\n    { name: \"DASHMATCH\", text: \"|=\"},\n    { name: \"PREFIXMATCH\", text: \"^=\"},\n    { name: \"SUFFIXMATCH\", text: \"$=\"},\n    { name: \"SUBSTRINGMATCH\", text: \"*=\"},\n\n    //identifier types\n    { name: \"STRING\"},\n    { name: \"IDENT\"},\n    { name: \"HASH\"},\n\n    //at-keywords\n    { name: \"IMPORT_SYM\", text: \"@import\"},\n    { name: \"PAGE_SYM\", text: \"@page\"},\n    { name: \"MEDIA_SYM\", text: \"@media\"},\n    { name: \"FONT_FACE_SYM\", text: \"@font-face\"},\n    { name: \"CHARSET_SYM\", text: \"@charset\"},\n    { name: \"NAMESPACE_SYM\", text: \"@namespace\"},\n    { name: \"VIEWPORT_SYM\", text: [\"@viewport\", \"@-ms-viewport\", \"@-o-viewport\"]},\n    { name: \"DOCUMENT_SYM\", text: [\"@document\", \"@-moz-document\"]},\n    { name: \"UNKNOWN_SYM\" },\n    //{ name: \"ATKEYWORD\"},\n\n    //CSS3 animations\n    { name: \"KEYFRAMES_SYM\", text: [ \"@keyframes\", \"@-webkit-keyframes\", \"@-moz-keyframes\", \"@-o-keyframes\" ] },\n\n    //important symbol\n    { name: \"IMPORTANT_SYM\"},\n\n    //measurements\n    { name: \"LENGTH\"},\n    { name: \"ANGLE\"},\n    { name: \"TIME\"},\n    { name: \"FREQ\"},\n    { name: \"DIMENSION\"},\n    { name: \"PERCENTAGE\"},\n    { name: \"NUMBER\"},\n\n    //functions\n    { name: \"URI\"},\n    { name: \"FUNCTION\"},\n\n    //Unicode ranges\n    { name: \"UNICODE_RANGE\"},\n\n    /*\n     * The following token names are defined in CSS3 Selectors: http://www.w3.org/TR/css3-selectors/#selector-syntax\n     */\n\n    //invalid string\n    { name: \"INVALID\"},\n\n    //combinators\n    { name: \"PLUS\", text: \"+\" },\n    { name: \"GREATER\", text: \">\"},\n    { name: \"COMMA\", text: \",\"},\n    { name: \"TILDE\", text: \"~\"},\n\n    //modifier\n    { name: \"NOT\"},\n\n    /*\n     * Defined in CSS3 Paged Media\n     */\n    { name: \"TOPLEFTCORNER_SYM\", text: \"@top-left-corner\"},\n    { name: \"TOPLEFT_SYM\", text: \"@top-left\"},\n    { name: \"TOPCENTER_SYM\", text: \"@top-center\"},\n    { name: \"TOPRIGHT_SYM\", text: \"@top-right\"},\n    { name: \"TOPRIGHTCORNER_SYM\", text: \"@top-right-corner\"},\n    { name: \"BOTTOMLEFTCORNER_SYM\", text: \"@bottom-left-corner\"},\n    { name: \"BOTTOMLEFT_SYM\", text: \"@bottom-left\"},\n    { name: \"BOTTOMCENTER_SYM\", text: \"@bottom-center\"},\n    { name: \"BOTTOMRIGHT_SYM\", text: \"@bottom-right\"},\n    { name: \"BOTTOMRIGHTCORNER_SYM\", text: \"@bottom-right-corner\"},\n    { name: \"LEFTTOP_SYM\", text: \"@left-top\"},\n    { name: \"LEFTMIDDLE_SYM\", text: \"@left-middle\"},\n    { name: \"LEFTBOTTOM_SYM\", text: \"@left-bottom\"},\n    { name: \"RIGHTTOP_SYM\", text: \"@right-top\"},\n    { name: \"RIGHTMIDDLE_SYM\", text: \"@right-middle\"},\n    { name: \"RIGHTBOTTOM_SYM\", text: \"@right-bottom\"},\n\n    /*\n     * The following token names are defined in CSS3 Media Queries: http://www.w3.org/TR/css3-mediaqueries/#syntax\n     */\n    /*{ name: \"MEDIA_ONLY\", state: \"media\"},\n    { name: \"MEDIA_NOT\", state: \"media\"},\n    { name: \"MEDIA_AND\", state: \"media\"},*/\n    { name: \"RESOLUTION\", state: \"media\"},\n\n    /*\n     * The following token names are not defined in any CSS specification but are used by the lexer.\n     */\n\n    //not a real token, but useful for stupid IE filters\n    { name: \"IE_FUNCTION\" },\n\n    //part of CSS3 grammar but not the Flex code\n    { name: \"CHAR\" },\n\n    //TODO: Needed?\n    //Not defined as tokens, but might as well be\n    {\n        name: \"PIPE\",\n        text: \"|\"\n    },\n    {\n        name: \"SLASH\",\n        text: \"/\"\n    },\n    {\n        name: \"MINUS\",\n        text: \"-\"\n    },\n    {\n        name: \"STAR\",\n        text: \"*\"\n    },\n\n    {\n        name: \"LBRACE\",\n        endChar: \"}\",\n        text: \"{\"\n    },\n    {\n        name: \"RBRACE\",\n        text: \"}\"\n    },\n    {\n        name: \"LBRACKET\",\n        endChar: \"]\",\n        text: \"[\"\n    },\n    {\n        name: \"RBRACKET\",\n        text: \"]\"\n    },\n    {\n        name: \"EQUALS\",\n        text: \"=\"\n    },\n    {\n        name: \"COLON\",\n        text: \":\"\n    },\n    {\n        name: \"SEMICOLON\",\n        text: \";\"\n    },\n\n    {\n        name: \"LPAREN\",\n        endChar: \")\",\n        text: \"(\"\n    },\n    {\n        name: \"RPAREN\",\n        text: \")\"\n    },\n    {\n        name: \"DOT\",\n        text: \".\"\n    }\n];\n\n(function(){\n\n    var nameMap = [],\n        typeMap = Object.create(null);\n\n    Tokens.UNKNOWN = -1;\n    Tokens.unshift({name:\"EOF\"});\n    for (var i=0, len = Tokens.length; i < len; i++){\n        nameMap.push(Tokens[i].name);\n        Tokens[Tokens[i].name] = i;\n        if (Tokens[i].text){\n            if (Tokens[i].text instanceof Array){\n                for (var j=0; j < Tokens[i].text.length; j++){\n                    typeMap[Tokens[i].text[j]] = i;\n                }\n            } else {\n                typeMap[Tokens[i].text] = i;\n            }\n        }\n    }\n\n    Tokens.name = function(tt){\n        return nameMap[tt];\n    };\n\n    Tokens.type = function(c){\n        return typeMap[c] || -1;\n    };\n\n})();\n\n\n\n//This file will likely change a lot! Very experimental!\nvar Validation = {\n\n    validate: function(property, value){\n\n        //normalize name\n        var name        = property.toString().toLowerCase(),\n            expression  = new PropertyValueIterator(value),\n            spec        = Properties[name];\n\n        if (!spec) {\n            if (name.indexOf(\"-\") !== 0){    //vendor prefixed are ok\n                throw new ValidationError(\"Unknown property '\" + property + \"'.\", property.line, property.col);\n            }\n        } else if (typeof spec !== \"number\"){\n\n            //initialization\n            if (typeof spec === \"string\"){\n                if (spec.indexOf(\"||\") > -1) {\n                    this.groupProperty(spec, expression);\n                } else {\n                    this.singleProperty(spec, expression, 1);\n                }\n\n            } else if (spec.multi) {\n                this.multiProperty(spec.multi, expression, spec.comma, spec.max || Infinity);\n            } else if (typeof spec === \"function\") {\n                spec(expression);\n            }\n\n        }\n\n    },\n\n    singleProperty: function(types, expression, max, partial) {\n\n        var result      = false,\n            value       = expression.value,\n            count       = 0,\n            part;\n\n        while (expression.hasNext() && count < max) {\n            result = ValidationTypes.isAny(expression, types);\n            if (!result) {\n                break;\n            }\n            count++;\n        }\n\n        if (!result) {\n            if (expression.hasNext() && !expression.isFirst()) {\n                part = expression.peek();\n                throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\n            } else {\n                 throw new ValidationError(\"Expected (\" + types + \") but found '\" + value + \"'.\", value.line, value.col);\n            }\n        } else if (expression.hasNext()) {\n            part = expression.next();\n            throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\n        }\n\n    },\n\n    multiProperty: function (types, expression, comma, max) {\n\n        var result      = false,\n            value       = expression.value,\n            count       = 0,\n            part;\n\n        while(expression.hasNext() && !result && count < max) {\n            if (ValidationTypes.isAny(expression, types)) {\n                count++;\n                if (!expression.hasNext()) {\n                    result = true;\n\n                } else if (comma) {\n                    if (String(expression.peek()) === \",\") {\n                        part = expression.next();\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                break;\n\n            }\n        }\n\n        if (!result) {\n            if (expression.hasNext() && !expression.isFirst()) {\n                part = expression.peek();\n                throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\n            } else {\n                part = expression.previous();\n                if (comma && String(part) === \",\") {\n                    throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\n                } else {\n                    throw new ValidationError(\"Expected (\" + types + \") but found '\" + value + \"'.\", value.line, value.col);\n                }\n            }\n\n        } else if (expression.hasNext()) {\n            part = expression.next();\n            throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\n        }\n\n    },\n\n    groupProperty: function (types, expression, comma) {\n\n        var result      = false,\n            value       = expression.value,\n            typeCount   = types.split(\"||\").length,\n            groups      = { count: 0 },\n            partial     = false,\n            name,\n            part;\n\n        while(expression.hasNext() && !result) {\n            name = ValidationTypes.isAnyOfGroup(expression, types);\n            if (name) {\n\n                //no dupes\n                if (groups[name]) {\n                    break;\n                } else {\n                    groups[name] = 1;\n                    groups.count++;\n                    partial = true;\n\n                    if (groups.count === typeCount || !expression.hasNext()) {\n                        result = true;\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n\n        if (!result) {\n            if (partial && expression.hasNext()) {\n                    part = expression.peek();\n                    throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\n            } else {\n                throw new ValidationError(\"Expected (\" + types + \") but found '\" + value + \"'.\", value.line, value.col);\n            }\n        } else if (expression.hasNext()) {\n            part = expression.next();\n            throw new ValidationError(\"Expected end of value but found '\" + part + \"'.\", part.line, part.col);\n        }\n    }\n\n\n\n};\n/**\n * Type to use when a validation error occurs.\n * @class ValidationError\n * @namespace parserlib.util\n * @constructor\n * @param {String} message The error message.\n * @param {int} line The line at which the error occurred.\n * @param {int} col The column at which the error occurred.\n */\nfunction ValidationError(message, line, col){\n\n    /**\n     * The column at which the error occurred.\n     * @type int\n     * @property col\n     */\n    this.col = col;\n\n    /**\n     * The line at which the error occurred.\n     * @type int\n     * @property line\n     */\n    this.line = line;\n\n    /**\n     * The text representation of the unit.\n     * @type String\n     * @property text\n     */\n    this.message = message;\n\n}\n\n//inherit from Error\nValidationError.prototype = new Error();\n//This file will likely change a lot! Very experimental!\nvar ValidationTypes = {\n\n    isLiteral: function (part, literals) {\n        var text = part.text.toString().toLowerCase(),\n            args = literals.split(\" | \"),\n            i, len, found = false;\n\n        for (i=0,len=args.length; i < len && !found; i++){\n            if (text === args[i].toLowerCase()){\n                found = true;\n            }\n        }\n\n        return found;\n    },\n\n    isSimple: function(type) {\n        return !!this.simple[type];\n    },\n\n    isComplex: function(type) {\n        return !!this.complex[type];\n    },\n\n    /**\n     * Determines if the next part(s) of the given expression\n     * are any of the given types.\n     */\n    isAny: function (expression, types) {\n        var args = types.split(\" | \"),\n            i, len, found = false;\n\n        for (i=0,len=args.length; i < len && !found && expression.hasNext(); i++){\n            found = this.isType(expression, args[i]);\n        }\n\n        return found;\n    },\n\n    /**\n     * Determines if the next part(s) of the given expression\n     * are one of a group.\n     */\n    isAnyOfGroup: function(expression, types) {\n        var args = types.split(\" || \"),\n            i, len, found = false;\n\n        for (i=0,len=args.length; i < len && !found; i++){\n            found = this.isType(expression, args[i]);\n        }\n\n        return found ? args[i-1] : false;\n    },\n\n    /**\n     * Determines if the next part(s) of the given expression\n     * are of a given type.\n     */\n    isType: function (expression, type) {\n        var part = expression.peek(),\n            result = false;\n\n        if (type.charAt(0) !== \"<\") {\n            result = this.isLiteral(part, type);\n            if (result) {\n                expression.next();\n            }\n        } else if (this.simple[type]) {\n            result = this.simple[type](part);\n            if (result) {\n                expression.next();\n            }\n        } else {\n            result = this.complex[type](expression);\n        }\n\n        return result;\n    },\n\n\n\n    simple: {\n        __proto__: null,\n\n        \"<absolute-size>\": function(part){\n            return ValidationTypes.isLiteral(part, \"xx-small | x-small | small | medium | large | x-large | xx-large\");\n        },\n\n        \"<attachment>\": function(part){\n            return ValidationTypes.isLiteral(part, \"scroll | fixed | local\");\n        },\n\n        \"<attr>\": function(part){\n            return part.type === \"function\" && part.name === \"attr\";\n        },\n\n        \"<bg-image>\": function(part){\n            return this[\"<image>\"](part) || this[\"<gradient>\"](part) ||  String(part) === \"none\";\n        },\n\n        \"<gradient>\": function(part) {\n            return part.type === \"function\" && /^(?:\\-(?:ms|moz|o|webkit)\\-)?(?:repeating\\-)?(?:radial\\-|linear\\-)?gradient/i.test(part);\n        },\n\n        \"<box>\": function(part){\n            return ValidationTypes.isLiteral(part, \"padding-box | border-box | content-box\");\n        },\n\n        \"<content>\": function(part){\n            return part.type === \"function\" && part.name === \"content\";\n        },\n\n        \"<relative-size>\": function(part){\n            return ValidationTypes.isLiteral(part, \"smaller | larger\");\n        },\n\n        //any identifier\n        \"<ident>\": function(part){\n            return part.type === \"identifier\";\n        },\n\n        \"<length>\": function(part){\n            if (part.type === \"function\" && /^(?:\\-(?:ms|moz|o|webkit)\\-)?calc/i.test(part)){\n                return true;\n            }else{\n                return part.type === \"length\" || part.type === \"number\" || part.type === \"integer\" || String(part) === \"0\";\n            }\n        },\n\n        \"<color>\": function(part){\n            return part.type === \"color\" || String(part) === \"transparent\" || String(part) === \"currentColor\";\n        },\n\n        \"<number>\": function(part){\n            return part.type === \"number\" || this[\"<integer>\"](part);\n        },\n\n        \"<integer>\": function(part){\n            return part.type === \"integer\";\n        },\n\n        \"<line>\": function(part){\n            return part.type === \"integer\";\n        },\n\n        \"<angle>\": function(part){\n            return part.type === \"angle\";\n        },\n\n        \"<uri>\": function(part){\n            return part.type === \"uri\";\n        },\n\n        \"<image>\": function(part){\n            return this[\"<uri>\"](part);\n        },\n\n        \"<percentage>\": function(part){\n            return part.type === \"percentage\" || String(part) === \"0\";\n        },\n\n        \"<border-width>\": function(part){\n            return this[\"<length>\"](part) || ValidationTypes.isLiteral(part, \"thin | medium | thick\");\n        },\n\n        \"<border-style>\": function(part){\n            return ValidationTypes.isLiteral(part, \"none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset\");\n        },\n\n        \"<content-sizing>\": function(part){ // http://www.w3.org/TR/css3-sizing/#width-height-keywords\n            return ValidationTypes.isLiteral(part, \"fill-available | -moz-available | -webkit-fill-available | max-content | -moz-max-content | -webkit-max-content | min-content | -moz-min-content | -webkit-min-content | fit-content | -moz-fit-content | -webkit-fit-content\");\n        },\n\n        \"<margin-width>\": function(part){\n            return this[\"<length>\"](part) || this[\"<percentage>\"](part) || ValidationTypes.isLiteral(part, \"auto\");\n        },\n\n        \"<padding-width>\": function(part){\n            return this[\"<length>\"](part) || this[\"<percentage>\"](part);\n        },\n\n        \"<shape>\": function(part){\n            return part.type === \"function\" && (part.name === \"rect\" || part.name === \"inset-rect\");\n        },\n\n        \"<time>\": function(part) {\n            return part.type === \"time\";\n        },\n\n        \"<flex-grow>\": function(part){\n            return this[\"<number>\"](part);\n        },\n\n        \"<flex-shrink>\": function(part){\n            return this[\"<number>\"](part);\n        },\n\n        \"<width>\": function(part){\n            return this[\"<margin-width>\"](part);\n        },\n\n        \"<flex-basis>\": function(part){\n            return this[\"<width>\"](part);\n        },\n\n        \"<flex-direction>\": function(part){\n            return ValidationTypes.isLiteral(part, \"row | row-reverse | column | column-reverse\");\n        },\n\n        \"<flex-wrap>\": function(part){\n            return ValidationTypes.isLiteral(part, \"nowrap | wrap | wrap-reverse\");\n        },\n\n        \"<feature-tag-value>\": function(part){\n            return (part.type === \"function\" && /^[A-Z0-9]{4}$/i.test(part));\n        }\n    },\n\n    complex: {\n        __proto__: null,\n\n        \"<bg-position>\": function(expression){\n            var result  = false,\n                numeric = \"<percentage> | <length>\",\n                xDir    = \"left | right\",\n                yDir    = \"top | bottom\",\n                count = 0;\n\n            while (expression.peek(count) && expression.peek(count).text !== \",\") {\n                count++;\n            }\n\n/*\n<position> = [\n  [ left | center | right | top | bottom | <percentage> | <length> ]\n|\n  [ left | center | right | <percentage> | <length> ]\n  [ top | center | bottom | <percentage> | <length> ]\n|\n  [ center | [ left | right ] [ <percentage> | <length> ]? ] &&\n  [ center | [ top | bottom ] [ <percentage> | <length> ]? ]\n]\n*/\n\n            if (count < 3) {\n                if (ValidationTypes.isAny(expression, xDir + \" | center | \" + numeric)) {\n                        result = true;\n                        ValidationTypes.isAny(expression, yDir + \" | center | \" + numeric);\n                } else if (ValidationTypes.isAny(expression, yDir)) {\n                        result = true;\n                        ValidationTypes.isAny(expression, xDir + \" | center\");\n                }\n            } else {\n                if (ValidationTypes.isAny(expression, xDir)) {\n                    if (ValidationTypes.isAny(expression, yDir)) {\n                        result = true;\n                        ValidationTypes.isAny(expression, numeric);\n                    } else if (ValidationTypes.isAny(expression, numeric)) {\n                        if (ValidationTypes.isAny(expression, yDir)) {\n                            result = true;\n                            ValidationTypes.isAny(expression, numeric);\n                        } else if (ValidationTypes.isAny(expression, \"center\")) {\n                            result = true;\n                        }\n                    }\n                } else if (ValidationTypes.isAny(expression, yDir)) {\n                    if (ValidationTypes.isAny(expression, xDir)) {\n                        result = true;\n                        ValidationTypes.isAny(expression, numeric);\n                    } else if (ValidationTypes.isAny(expression, numeric)) {\n                        if (ValidationTypes.isAny(expression, xDir)) {\n                                result = true;\n                                ValidationTypes.isAny(expression, numeric);\n                        } else if (ValidationTypes.isAny(expression, \"center\")) {\n                            result = true;\n                        }\n                    }\n                } else if (ValidationTypes.isAny(expression, \"center\")) {\n                    if (ValidationTypes.isAny(expression, xDir + \" | \" + yDir)) {\n                        result = true;\n                        ValidationTypes.isAny(expression, numeric);\n                    }\n                }\n            }\n\n            return result;\n        },\n\n        \"<bg-size>\": function(expression){\n            //<bg-size> = [ <length> | <percentage> | auto ]{1,2} | cover | contain\n            var result  = false,\n                numeric = \"<percentage> | <length> | auto\";\n\n            if (ValidationTypes.isAny(expression, \"cover | contain\")) {\n                result = true;\n            } else if (ValidationTypes.isAny(expression, numeric)) {\n                result = true;\n                ValidationTypes.isAny(expression, numeric);\n            }\n\n            return result;\n        },\n\n        \"<repeat-style>\": function(expression){\n            //repeat-x | repeat-y | [repeat | space | round | no-repeat]{1,2}\n            var result  = false,\n                values  = \"repeat | space | round | no-repeat\",\n                part;\n\n            if (expression.hasNext()){\n                part = expression.next();\n\n                if (ValidationTypes.isLiteral(part, \"repeat-x | repeat-y\")) {\n                    result = true;\n                } else if (ValidationTypes.isLiteral(part, values)) {\n                    result = true;\n\n                    if (expression.hasNext() && ValidationTypes.isLiteral(expression.peek(), values)) {\n                        expression.next();\n                    }\n                }\n            }\n\n            return result;\n\n        },\n\n        \"<shadow>\": function(expression) {\n            //inset? && [ <length>{2,4} && <color>? ]\n            var result  = false,\n                count   = 0,\n                inset   = false,\n                color   = false;\n\n            if (expression.hasNext()) {\n\n                if (ValidationTypes.isAny(expression, \"inset\")){\n                    inset = true;\n                }\n\n                if (ValidationTypes.isAny(expression, \"<color>\")) {\n                    color = true;\n                }\n\n                while (ValidationTypes.isAny(expression, \"<length>\") && count < 4) {\n                    count++;\n                }\n\n\n                if (expression.hasNext()) {\n                    if (!color) {\n                        ValidationTypes.isAny(expression, \"<color>\");\n                    }\n\n                    if (!inset) {\n                        ValidationTypes.isAny(expression, \"inset\");\n                    }\n\n                }\n\n                result = (count >= 2 && count <= 4);\n\n            }\n\n            return result;\n        },\n\n        \"<x-one-radius>\": function(expression) {\n            //[ <length> | <percentage> ] [ <length> | <percentage> ]?\n            var result  = false,\n                simple = \"<length> | <percentage> | inherit\";\n\n            if (ValidationTypes.isAny(expression, simple)){\n                result = true;\n                ValidationTypes.isAny(expression, simple);\n            }\n\n            return result;\n        },\n\n        \"<flex>\": function(expression) {\n            // http://www.w3.org/TR/2014/WD-css-flexbox-1-20140325/#flex-property\n            // none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]\n            // Valid syntaxes, according to https://developer.mozilla.org/en-US/docs/Web/CSS/flex#Syntax\n            // * none\n            // * <flex-grow>\n            // * <flex-basis>\n            // * <flex-grow> <flex-basis>\n            // * <flex-grow> <flex-shrink>\n            // * <flex-grow> <flex-shrink> <flex-basis>\n            // * inherit\n            var part,\n                result = false;\n            if (ValidationTypes.isAny(expression, \"none | inherit\")) {\n                result = true;\n            } else {\n                if (ValidationTypes.isType(expression, \"<flex-grow>\")) {\n                    if (expression.peek()) {\n                        if (ValidationTypes.isType(expression, \"<flex-shrink>\")) {\n                            if (expression.peek()) {\n                                result = ValidationTypes.isType(expression, \"<flex-basis>\");\n                            } else {\n                                result = true;\n                            }\n                        } else if (ValidationTypes.isType(expression, \"<flex-basis>\")) {\n                            result = expression.peek() === null;\n                        }\n                    } else {\n                        result = true;\n                    }\n                } else if (ValidationTypes.isType(expression, \"<flex-basis>\")) {\n                    result = true;\n                }\n            }\n\n            if (!result) {\n                // Generate a more verbose error than \"Expected <flex>...\"\n                part = expression.peek();\n                throw new ValidationError(\"Expected (none | [ <flex-grow> <flex-shrink>? || <flex-basis> ]) but found '\" + expression.value.text + \"'.\", part.line, part.col);\n            }\n\n            return result;\n        }\n    }\n};\n\nparserlib.css = {\n__proto__           :null,\nColors              :Colors,\nCombinator          :Combinator,\nParser              :Parser,\nPropertyName        :PropertyName,\nPropertyValue       :PropertyValue,\nPropertyValuePart   :PropertyValuePart,\nMediaFeature        :MediaFeature,\nMediaQuery          :MediaQuery,\nSelector            :Selector,\nSelectorPart        :SelectorPart,\nSelectorSubPart     :SelectorSubPart,\nSpecificity         :Specificity,\nTokenStream         :TokenStream,\nTokens              :Tokens,\nValidationError     :ValidationError\n};\n})();\n\n(function(){\n/* jshint forin:false */\nfor(var prop in parserlib){\nexports[prop] = parserlib[prop];\n}\n})();\n","\"use strict\";\n\nvar attributes = require('./attributes');\nvar sloppy = require('./sloppy');\nvar isApiWritable = require(\"./config\").isApiWritable;\n\nmodule.exports = function(spec, defaultConstructor, tagList, tagNameToImpl) {\n  var c = spec.ctor;\n  if (c) {\n    var props = spec.props || {};\n\n    if (spec.attributes) {\n      for (var n in spec.attributes) {\n        var attr = spec.attributes[n];\n        if (typeof attr !== 'object' || Array.isArray(attr)) attr = {type: attr};\n        if (!attr.name) attr.name = n.toLowerCase();\n        props[n] = attributes.property(attr);\n      }\n    }\n\n    props.constructor = { value : c, writable: isApiWritable };\n    c.prototype = Object.create((spec.superclass || defaultConstructor).prototype, props);\n    if (spec.events) {\n      addEventHandlers(c, spec.events);\n    }\n    tagList[c.name] = c;\n  }\n  else {\n    c = defaultConstructor;\n  }\n\n  (spec.tags || spec.tag && [spec.tag] || []).forEach(function(tag) {\n    tagNameToImpl[tag] = c;\n  });\n\n  return c;\n};\n\nfunction EventHandlerBuilder(body, document, form, element) {\n  this.body = body;\n  this.document = document;\n  this.form = form;\n  this.element = element;\n}\n\nEventHandlerBuilder.prototype.build = sloppy.EventHandlerBuilder_build;\n\nfunction EventHandlerChangeHandler(elt, name, oldval, newval) {\n  var doc = elt.ownerDocument || Object.create(null);\n  var form = elt.form || Object.create(null);\n  elt[name] = new EventHandlerBuilder(newval, doc, form, elt).build();\n}\n\nfunction addEventHandlers(c, eventHandlerTypes) {\n  var p = c.prototype;\n  eventHandlerTypes.forEach(function(type) {\n    // Define the event handler registration IDL attribute for this type\n    Object.defineProperty(p, \"on\" + type, {\n      get: function() {\n        return this._getEventHandler(type);\n      },\n      set: function(v) {\n        this._setEventHandler(type, v);\n      },\n    });\n\n    // Define special behavior for the content attribute as well\n    attributes.registerChangeHandler(c, \"on\" + type, EventHandlerChangeHandler);\n  });\n}\n","\"use strict\";\nmodule.exports = {\n  Event: require('./Event'),\n  UIEvent: require('./UIEvent'),\n  MouseEvent: require('./MouseEvent'),\n  CustomEvent: require('./CustomEvent')\n};\n","\"use strict\";\nvar Node = require('./Node');\nvar Element = require('./Element');\nvar CSSStyleDeclaration = require('./CSSStyleDeclaration');\nvar utils = require('./utils');\nvar URLUtils = require('./URLUtils');\nvar defineElement = require('./defineElement');\n\nvar htmlElements = exports.elements = {};\nvar htmlNameToImpl = Object.create(null);\n\nexports.createElement = function(doc, localName, prefix) {\n  var impl = htmlNameToImpl[localName] || HTMLUnknownElement;\n  return new impl(doc, localName, prefix);\n};\n\nfunction define(spec) {\n  return defineElement(spec, HTMLElement, htmlElements, htmlNameToImpl);\n}\n\nfunction URL(attr) {\n  return {\n    get: function() {\n      var v = this._getattr(attr);\n      if (v === null) { return ''; }\n      var url = this.doc._resolve(v);\n      return (url === null) ? v : url;\n    },\n    set: function(value) {\n      this._setattr(attr, value);\n    }\n  };\n}\n\nfunction CORS(attr) {\n  return {\n    get: function() {\n      var v = this._getattr(attr);\n      if (v === null) { return null; }\n      if (v.toLowerCase() === 'use-credentials') { return 'use-credentials'; }\n      return 'anonymous';\n    },\n    set: function(value) {\n      if (value===null || value===undefined) {\n        this.removeAttribute(attr);\n      } else {\n        this._setattr(attr, value);\n      }\n    }\n  };\n}\n\nvar REFERRER = {\n  type: [\"\", \"no-referrer\", \"no-referrer-when-downgrade\", \"same-origin\", \"origin\", \"strict-origin\", \"origin-when-cross-origin\", \"strict-origin-when-cross-origin\", \"unsafe-url\"],\n  missing: '',\n};\n\n\n// XXX: the default value for tabIndex should be 0 if the element is\n// focusable and -1 if it is not.  But the full definition of focusable\n// is actually hard to compute, so for now, I'll follow Firefox and\n// just base the default value on the type of the element.\nvar focusableElements = {\n  \"A\":true, \"LINK\":true, \"BUTTON\":true, \"INPUT\":true,\n  \"SELECT\":true, \"TEXTAREA\":true, \"COMMAND\":true\n};\n\nvar HTMLFormElement = function(doc, localName, prefix) {\n  HTMLElement.call(this, doc, localName, prefix);\n  this._form = null; // Prevent later deoptimization\n};\n\nvar HTMLElement = exports.HTMLElement = define({\n  superclass: Element,\n  ctor: function HTMLElement(doc, localName, prefix) {\n    Element.call(this, doc, localName, utils.NAMESPACE.HTML, prefix);\n  },\n  props: {\n    innerHTML: {\n      get: function() {\n        return this.serialize();\n      },\n      set: function(v) {\n        var parser = this.ownerDocument.implementation.mozHTMLParser(\n          this.ownerDocument._address,\n          this);\n        parser.parse(v===null ? '' : String(v), true);\n\n        // Remove any existing children of this node\n        var target = (this instanceof htmlNameToImpl.template) ?\n            this.content : this;\n        while(target.hasChildNodes())\n          target.removeChild(target.firstChild);\n\n        // Now copy newly parsed children to this node\n        target.appendChild(parser._asDocumentFragment());\n      }\n    },\n    style: { get: function() {\n      if (!this._style)\n        this._style = new CSSStyleDeclaration(this);\n      return this._style;\n    }, set: function(v) {\n        if (v===null||v===undefined) { v = ''; }\n        this._setattr('style', String(v));\n    }},\n\n    // These can't really be implemented server-side in a reasonable way.\n    blur: { value: function() {}},\n    focus: { value: function() {}},\n    forceSpellCheck: { value: function() {}},\n\n    click: { value: function() {\n      if (this._click_in_progress) return;\n      this._click_in_progress = true;\n      try {\n        if (this._pre_click_activation_steps)\n          this._pre_click_activation_steps();\n\n        var event = this.ownerDocument.createEvent(\"MouseEvent\");\n        event.initMouseEvent(\"click\", true, true,\n          this.ownerDocument.defaultView, 1,\n          0, 0, 0, 0,\n          // These 4 should be initialized with\n          // the actually current keyboard state\n          // somehow...\n          false, false, false, false,\n          0, null\n        );\n\n        // Dispatch this as an untrusted event since it is synthetic\n        var success = this.dispatchEvent(event);\n\n        if (success) {\n          if (this._post_click_activation_steps)\n            this._post_click_activation_steps(event);\n        }\n        else {\n          if (this._cancelled_activation_steps)\n            this._cancelled_activation_steps();\n        }\n      }\n      finally {\n        this._click_in_progress = false;\n      }\n    }},\n    submit: { value: utils.nyi },\n  },\n  attributes: {\n    title: String,\n    lang: String,\n    dir: {type: [\"ltr\", \"rtl\", \"auto\"], missing: ''},\n    accessKey: String,\n    hidden: Boolean,\n    tabIndex: {type: \"long\", default: function() {\n      if (this.tagName in focusableElements ||\n        this.contentEditable)\n        return 0;\n      else\n        return -1;\n    }}\n  },\n  events: [\n    \"abort\", \"canplay\", \"canplaythrough\", \"change\", \"click\", \"contextmenu\",\n    \"cuechange\", \"dblclick\", \"drag\", \"dragend\", \"dragenter\", \"dragleave\",\n    \"dragover\", \"dragstart\", \"drop\", \"durationchange\", \"emptied\", \"ended\",\n    \"input\", \"invalid\", \"keydown\", \"keypress\", \"keyup\", \"loadeddata\",\n    \"loadedmetadata\", \"loadstart\", \"mousedown\", \"mousemove\", \"mouseout\",\n    \"mouseover\", \"mouseup\", \"mousewheel\", \"pause\", \"play\", \"playing\",\n    \"progress\", \"ratechange\", \"readystatechange\", \"reset\", \"seeked\",\n    \"seeking\", \"select\", \"show\", \"stalled\", \"submit\", \"suspend\",\n    \"timeupdate\", \"volumechange\", \"waiting\",\n\n    // These last 5 event types will be overriden by HTMLBodyElement\n    \"blur\", \"error\", \"focus\", \"load\", \"scroll\"\n  ]\n});\n\n\n// XXX: reflect contextmenu as contextMenu, with element type\n\n\n// style: the spec doesn't call this a reflected attribute.\n//   may want to handle it manually.\n\n// contentEditable: enumerated, not clear if it is actually\n// reflected or requires custom getter/setter. Not listed as\n// \"limited to known values\".  Raises syntax_err on bad setting,\n// so I think this is custom.\n\n// contextmenu: content is element id, idl type is an element\n// draggable: boolean, but not a reflected attribute\n// dropzone: reflected SettableTokenList, experimental, so don't\n//   implement it right away.\n\n// data-* attributes: need special handling in setAttribute?\n// Or maybe that isn't necessary. Can I just scan the attribute list\n// when building the dataset?  Liveness and caching issues?\n\n// microdata attributes: many are simple reflected attributes, but\n// I'm not going to implement this now.\n\n\nvar HTMLUnknownElement = define({\n  ctor: function HTMLUnknownElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  }\n});\n\n\nvar formAssociatedProps = {\n  // See http://www.w3.org/TR/html5/association-of-controls-and-forms.html#form-owner\n  form: { get: function() {\n    return this._form;\n  }}\n};\n\ndefine({\n  tag: 'a',\n  ctor: function HTMLAnchorElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    _post_click_activation_steps: { value: function(e) {\n      if (this.href) {\n        // Follow the link\n        // XXX: this is just a quick hack\n        // XXX: the HTML spec probably requires more than this\n        this.ownerDocument.defaultView.location = this.href;\n      }\n    }},\n  },\n  attributes: {\n    href: URL,\n    ping: String,\n    download: String,\n    target: String,\n    rel: String,\n    media: String,\n    hreflang: String,\n    type: String,\n    referrerPolicy: REFERRER,\n    // Obsolete\n    coords: String,\n    charset: String,\n    name: String,\n    rev: String,\n    shape: String,\n  }\n});\n// Latest WhatWG spec says these methods come via HTMLHyperlinkElementUtils\nURLUtils._inherit(htmlNameToImpl.a.prototype);\n\ndefine({\n  tag: 'area',\n  ctor: function HTMLAreaElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    alt: String,\n    target: String,\n    download: String,\n    rel: String,\n    media: String,\n    href: URL,\n    hreflang: String,\n    type: String,\n    shape: String,\n    coords: String,\n    ping: String,\n    // XXX: also reflect relList\n    referrerPolicy: REFERRER,\n    // Obsolete\n    noHref: Boolean,\n  }\n});\n// Latest WhatWG spec says these methods come via HTMLHyperlinkElementUtils\nURLUtils._inherit(htmlNameToImpl.area.prototype);\n\ndefine({\n  tag: 'br',\n  ctor: function HTMLBRElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    clear: String\n  },\n});\n\ndefine({\n  tag: 'base',\n  ctor: function HTMLBaseElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    \"target\": String\n  }\n});\n\n\ndefine({\n  tag: 'body',\n  ctor: function HTMLBodyElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  // Certain event handler attributes on a <body> tag actually set\n  // handlers for the window rather than just that element.  Define\n  // getters and setters for those here.  Note that some of these override\n  // properties on HTMLElement.prototype.\n  // XXX: If I add support for <frameset>, these have to go there, too\n  // XXX\n  // When the Window object is implemented, these attribute will have\n  // to work with the same-named attributes on the Window.\n  events: [\n    \"afterprint\", \"beforeprint\", \"beforeunload\", \"blur\", \"error\",\n    \"focus\",\"hashchange\", \"load\", \"message\", \"offline\", \"online\",\n    \"pagehide\", \"pageshow\",\"popstate\",\"resize\",\"scroll\",\"storage\",\"unload\",\n  ],\n  attributes: {\n    // Obsolete\n    text: { type: String, treatNullAsEmptyString: true },\n    link: { type: String, treatNullAsEmptyString: true },\n    vLink: { type: String, treatNullAsEmptyString: true },\n    aLink: { type: String, treatNullAsEmptyString: true },\n    bgColor: { type: String, treatNullAsEmptyString: true },\n    background: String,\n  }\n});\n\ndefine({\n  tag: 'button',\n  ctor: function HTMLButtonElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: formAssociatedProps,\n  attributes: {\n    name: String,\n    value: String,\n    disabled: Boolean,\n    autofocus: Boolean,\n    type: { type:[\"submit\", \"reset\", \"button\", \"menu\"], missing: 'submit' },\n    formTarget: String,\n    formNoValidate: Boolean,\n    formMethod: { type: [\"get\", \"post\", \"dialog\"], invalid: 'get', missing: '' },\n    formEnctype: { type: [\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"], invalid: \"application/x-www-form-urlencoded\", missing: '' },\n  }\n});\n\ndefine({\n  tag: 'dl',\n  ctor: function HTMLDListElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    compact: Boolean,\n  }\n});\n\ndefine({\n  tag: 'data',\n  ctor: function HTMLDataElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    value: String,\n  }\n});\n\ndefine({\n  tag: 'datalist',\n  ctor: function HTMLDataListElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  }\n});\n\ndefine({\n  tag: 'details',\n  ctor: function HTMLDetailsElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    \"open\": Boolean\n  }\n});\n\ndefine({\n  tag: 'div',\n  ctor: function HTMLDivElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    align: String\n  }\n});\n\ndefine({\n  tag: 'embed',\n  ctor: function HTMLEmbedElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    src: URL,\n    type: String,\n    width: String,\n    height: String,\n    // Obsolete\n    align: String,\n    name: String,\n  }\n});\n\ndefine({\n  tag: 'fieldset',\n  ctor: function HTMLFieldSetElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: formAssociatedProps,\n  attributes: {\n    disabled: Boolean,\n    name: String\n  }\n});\n\ndefine({\n  tag: 'form',\n  ctor: function HTMLFormElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    action: String,\n    autocomplete: {type:['on', 'off'], missing: 'on'},\n    name: String,\n    acceptCharset: {name: \"accept-charset\"},\n    target: String,\n    noValidate: Boolean,\n    method: { type: [\"get\", \"post\", \"dialog\"], invalid: 'get', missing: 'get' },\n    // Both enctype and encoding reflect the enctype content attribute\n    enctype: { type: [\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"], invalid: \"application/x-www-form-urlencoded\", missing: \"application/x-www-form-urlencoded\" },\n    encoding: {name: 'enctype', type: [\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"], invalid: \"application/x-www-form-urlencoded\", missing: \"application/x-www-form-urlencoded\" },\n  }\n});\n\ndefine({\n  tag: 'hr',\n  ctor: function HTMLHRElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    align: String,\n    color: String,\n    noShade: Boolean,\n    size: String,\n    width: String,\n  },\n});\n\ndefine({\n  tag: 'head',\n  ctor: function HTMLHeadElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  }\n});\n\ndefine({\n  tags: ['h1','h2','h3','h4','h5','h6'],\n  ctor: function HTMLHeadingElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    align: String,\n  },\n});\n\ndefine({\n  tag: 'html',\n  ctor: function HTMLHtmlElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    version: String\n  }\n});\n\ndefine({\n  tag: 'iframe',\n  ctor: function HTMLIFrameElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n    var Window = require('./Window'); // Avoid circular dependencies.\n    this._contentWindow = new Window();\n  },\n  props: {\n    contentWindow: { get: function() {\n      return this._contentWindow;\n    } },\n    contentDocument: { get: function() {\n      return this.contentWindow.document;\n    } },\n  },\n  attributes: {\n    src: URL,\n    srcdoc: String,\n    name: String,\n    width: String,\n    height: String,\n    // XXX: sandbox is a reflected settable token list\n    seamless: Boolean,\n    allowFullscreen: Boolean,\n    allowUserMedia: Boolean,\n    allowPaymentRequest: Boolean,\n    referrerPolicy: REFERRER,\n    // Obsolete\n    align: String,\n    scrolling: String,\n    frameBorder: String,\n    longDesc: URL,\n    marginHeight: { type: String, treatNullAsEmptyString: true },\n    marginWidth: { type: String, treatNullAsEmptyString: true },\n  }\n});\n\ndefine({\n  tag: 'img',\n  ctor: function HTMLImageElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    alt: String,\n    src: URL,\n    srcset: String,\n    crossOrigin: CORS,\n    useMap: String,\n    isMap: Boolean,\n    height: { type: \"unsigned long\", default: 0 },\n    width: { type: \"unsigned long\", default: 0 },\n    referrerPolicy: REFERRER,\n    // Obsolete:\n    name: String,\n    lowsrc: URL,\n    align: String,\n    hspace: { type: \"unsigned long\", default: 0 },\n    vspace: { type: \"unsigned long\", default: 0 },\n    longDesc: URL,\n    border: { type: String, treatNullAsEmptyString: true },\n  }\n});\n\ndefine({\n  tag: 'input',\n  ctor: function HTMLInputElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    form: formAssociatedProps.form,\n    _post_click_activation_steps: { value: function(e) {\n      if (this.type === 'checkbox') {\n        this.checked = !this.checked;\n      }\n      else if (this.type === 'radio') {\n        var group = this.form.getElementsByName(this.name);\n        for (var i=group.length-1; i >= 0; i--) {\n          var el = group[i];\n          el.checked = (el === this);\n        }\n      }\n    }},\n  },\n  attributes: {\n    name: String,\n    disabled: Boolean,\n    autofocus: Boolean,\n    accept: String,\n    alt: String,\n    max: String,\n    min: String,\n    pattern: String,\n    placeholder: String,\n    step: String,\n    dirName: String,\n    defaultValue: {name: 'value'},\n    multiple: Boolean,\n    required: Boolean,\n    readOnly: Boolean,\n    checked: Boolean,\n    value: String,\n    src: URL,\n    defaultChecked: {name: 'checked', type: Boolean},\n    size: {type: 'unsigned long', default: 20, min: 1, setmin: 1},\n    width: {type: 'unsigned long', min: 0, setmin: 0, default: 0},\n    height: {type: 'unsigned long', min: 0, setmin: 0, default: 0},\n    minLength: {type: 'unsigned long', min: 0, setmin: 0, default: -1},\n    maxLength: {type: 'unsigned long', min: 0, setmin: 0, default: -1},\n    autocomplete: String, // It's complicated\n    type: { type:\n            [\"text\", \"hidden\", \"search\", \"tel\", \"url\", \"email\", \"password\",\n             \"datetime\", \"date\", \"month\", \"week\", \"time\", \"datetime-local\",\n             \"number\", \"range\", \"color\", \"checkbox\", \"radio\", \"file\", \"submit\",\n             \"image\", \"reset\", \"button\"],\n            missing: 'text' },\n    formTarget: String,\n    formNoValidate: Boolean,\n    formMethod: { type: [\"get\", \"post\"], invalid: 'get', missing: '' },\n    formEnctype: { type: [\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"], invalid: \"application/x-www-form-urlencoded\", missing: '' },\n    inputMode: { type: [ \"verbatim\", \"latin\", \"latin-name\", \"latin-prose\", \"full-width-latin\", \"kana\", \"kana-name\", \"katakana\", \"numeric\", \"tel\", \"email\", \"url\" ], missing: '' },\n    // Obsolete\n    align: String,\n    useMap: String,\n  }\n});\n\ndefine({\n  tag: 'keygen',\n  ctor: function HTMLKeygenElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: formAssociatedProps,\n  attributes: {\n    name: String,\n    disabled: Boolean,\n    autofocus: Boolean,\n    challenge: String,\n    keytype: { type:[\"rsa\"], missing: '' },\n  }\n});\n\ndefine({\n  tag: 'li',\n  ctor: function HTMLLIElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    value: {type: \"long\", default: 0},\n    // Obsolete\n    type: String,\n  }\n});\n\ndefine({\n  tag: 'label',\n  ctor: function HTMLLabelElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: formAssociatedProps,\n  attributes: {\n    htmlFor: {name: 'for', type: String}\n  }\n});\n\ndefine({\n  tag: 'legend',\n  ctor: function HTMLLegendElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    align: String\n  },\n});\n\ndefine({\n  tag: 'link',\n  ctor: function HTMLLinkElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // XXX Reflect DOMSettableTokenList sizes also DOMTokenList relList\n    href: URL,\n    rel: String,\n    media: String,\n    hreflang: String,\n    type: String,\n    crossOrigin: CORS,\n    nonce: String,\n    integrity: String,\n    referrerPolicy: REFERRER,\n    // Obsolete\n    charset: String,\n    rev: String,\n    target: String,\n  }\n});\n\ndefine({\n  tag: 'map',\n  ctor: function HTMLMapElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    name: String\n  }\n});\n\ndefine({\n  tag: 'menu',\n  ctor: function HTMLMenuElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // XXX: not quite right, default should be popup if parent element is\n    // popup.\n    type: { type: [ 'context', 'popup', 'toolbar' ], missing: 'toolbar' },\n    label: String,\n    // Obsolete\n    compact: Boolean,\n  }\n});\n\ndefine({\n  tag: 'meta',\n  ctor: function HTMLMetaElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    name: String,\n    content: String,\n    httpEquiv: {name: 'http-equiv', type: String},\n    // Obsolete\n    scheme: String,\n  }\n});\n\ndefine({\n  tag: 'meter',\n  ctor: function HTMLMeterElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: formAssociatedProps\n});\n\ndefine({\n  tags: ['ins', 'del'],\n  ctor: function HTMLModElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    cite: URL,\n    dateTime: String\n  }\n});\n\ndefine({\n  tag: 'ol',\n  ctor: function HTMLOListElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    // Utility function (see the start attribute default value). Returns\n    // the number of <li> children of this element\n    _numitems: { get: function() {\n      var items = 0;\n      this.childNodes.forEach(function(n) {\n        if (n.nodeType === Node.ELEMENT_NODE && n.tagName === \"LI\")\n          items++;\n      });\n      return items;\n    }}\n  },\n  attributes: {\n    type: String,\n    reversed: Boolean,\n    start: {\n      type: \"long\",\n      default: function() {\n       // The default value of the start attribute is 1 unless the list is\n       // reversed. Then it is the # of li children\n       if (this.reversed)\n         return this._numitems;\n       else\n         return 1;\n      }\n    },\n    // Obsolete\n    compact: Boolean,\n  }\n});\n\ndefine({\n  tag: 'object',\n  ctor: function HTMLObjectElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: formAssociatedProps,\n  attributes: {\n    data: URL,\n    type: String,\n    name: String,\n    useMap: String,\n    typeMustMatch: Boolean,\n    width: String,\n    height: String,\n    // Obsolete\n    align: String,\n    archive: String,\n    code: String,\n    declare: Boolean,\n    hspace: { type: \"unsigned long\", default: 0 },\n    standby: String,\n    vspace: { type: \"unsigned long\", default: 0 },\n    codeBase: URL,\n    codeType: String,\n    border: { type: String, treatNullAsEmptyString: true },\n  }\n});\n\ndefine({\n  tag: 'optgroup',\n  ctor: function HTMLOptGroupElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    disabled: Boolean,\n    label: String\n  }\n});\n\ndefine({\n  tag: 'option',\n  ctor: function HTMLOptionElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    form: { get: function() {\n      var p = this.parentNode;\n      while (p && p.nodeType === Node.ELEMENT_NODE) {\n        if (p.localName === 'select') return p.form;\n        p = p.parentNode;\n      }\n    }},\n    value: {\n      get: function() { return this._getattr('value') || this.text; },\n      set: function(v) { this._setattr('value', v); },\n    },\n    text: {\n      get: function() {\n        // Strip and collapse whitespace\n        return this.textContent.replace(/[ \\t\\n\\f\\r]+/g, ' ').trim();\n      },\n      set: function(v) { this.textContent = v; },\n    },\n    // missing: index\n  },\n  attributes: {\n    disabled: Boolean,\n    defaultSelected: {name: 'selected', type: Boolean},\n    label: String,\n  }\n});\n\ndefine({\n  tag: 'output',\n  ctor: function HTMLOutputElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: formAssociatedProps,\n  attributes: {\n    // XXX Reflect for/htmlFor as a settable token list\n    name: String\n  }\n});\n\ndefine({\n  tag: 'p',\n  ctor: function HTMLParagraphElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    align: String\n  }\n});\n\ndefine({\n  tag: 'param',\n  ctor: function HTMLParamElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    name: String,\n    value: String,\n    // Obsolete\n    type: String,\n    valueType: String,\n  }\n});\n\ndefine({\n  tags: ['pre',/*legacy elements:*/'listing','xmp'],\n  ctor: function HTMLPreElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    width: { type: \"long\", default: 0 },\n  }\n});\n\ndefine({\n  tag: 'progress',\n  ctor: function HTMLProgressElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: formAssociatedProps,\n  attributes: {\n    max: {type: Number, float: true, default: 1.0, min: 0}\n  }\n});\n\ndefine({\n  tags: ['q', 'blockquote'],\n  ctor: function HTMLQuoteElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    cite: URL\n  }\n});\n\ndefine({\n  tag: 'script',\n  ctor: function HTMLScriptElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    text: {\n      get: function() {\n        var s = \"\";\n        for(var i = 0, n = this.childNodes.length; i < n; i++) {\n          var child = this.childNodes[i];\n          if (child.nodeType === Node.TEXT_NODE)\n            s += child._data;\n        }\n        return s;\n      },\n      set: function(value) {\n        this.removeChildren();\n        if (value !== null && value !== \"\") {\n          this.appendChild(this.ownerDocument.createTextNode(value));\n        }\n      }\n    }\n  },\n  attributes: {\n    src: URL,\n    type: String,\n    charset: String,\n    defer: Boolean,\n    async: Boolean,\n    crossOrigin: CORS,\n    nonce: String,\n    integrity: String,\n  }\n});\n\ndefine({\n  tag: 'select',\n  ctor: function HTMLSelectElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    form: formAssociatedProps.form,\n    options: { get: function() {\n      return this.getElementsByTagName('option');\n    }}\n  },\n  attributes: {\n    autocomplete: String, // It's complicated\n    name: String,\n    disabled: Boolean,\n    autofocus: Boolean,\n    multiple: Boolean,\n    required: Boolean,\n    size: {type: \"unsigned long\", default: 0}\n  }\n});\n\ndefine({\n  tag: 'source',\n  ctor: function HTMLSourceElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    src: URL,\n    type: String,\n    media: String\n  }\n});\n\ndefine({\n  tag: 'span',\n  ctor: function HTMLSpanElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  }\n});\n\ndefine({\n  tag: 'style',\n  ctor: function HTMLStyleElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    media: String,\n    type: String,\n    scoped: Boolean\n  }\n});\n\ndefine({\n  tag: 'caption',\n  ctor: function HTMLTableCaptionElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    // Obsolete\n    align: String,\n  }\n});\n\n\ndefine({\n  ctor: function HTMLTableCellElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    colSpan: {type: \"unsigned long\", default: 1},\n    rowSpan: {type: \"unsigned long\", default: 1},\n    //XXX Also reflect settable token list headers\n    scope: { type: ['row','col','rowgroup','colgroup'], missing: '' },\n    abbr: String,\n    // Obsolete\n    align: String,\n    axis: String,\n    height: String,\n    width: String,\n    ch: { name: 'char', type: String },\n    chOff: { name: 'charoff', type: String },\n    noWrap: Boolean,\n    vAlign: String,\n    bgColor: { type: String, treatNullAsEmptyString: true },\n  }\n});\n\ndefine({\n  tags: ['col', 'colgroup'],\n  ctor: function HTMLTableColElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    span: {type: 'limited unsigned long with fallback', default: 1, min: 1},\n    // Obsolete\n    align: String,\n    ch: { name: 'char', type: String },\n    chOff: { name: 'charoff', type: String },\n    vAlign: String,\n    width: String,\n  }\n});\n\ndefine({\n  tag: 'table',\n  ctor: function HTMLTableElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    rows: { get: function() {\n      return this.getElementsByTagName('tr');\n    }}\n  },\n  attributes: {\n    // Obsolete\n    align: String,\n    border: String,\n    frame: String,\n    rules: String,\n    summary: String,\n    width: String,\n    bgColor: { type: String, treatNullAsEmptyString: true },\n    cellPadding: { type: String, treatNullAsEmptyString: true },\n    cellSpacing: { type: String, treatNullAsEmptyString: true },\n  }\n});\n\ndefine({\n  tag: 'template',\n  ctor: function HTMLTemplateElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n    this._contentFragment = doc._templateDoc.createDocumentFragment();\n  },\n  props: {\n    content: { get: function() { return this._contentFragment; } },\n    serialize: { value: function() { return this.content.serialize(); } }\n  }\n});\n\ndefine({\n  tag: 'tr',\n  ctor: function HTMLTableRowElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    cells: { get: function() {\n      return this.querySelectorAll('td,th');\n    }}\n  },\n  attributes: {\n    // Obsolete\n    align: String,\n    ch: { name: 'char', type: String },\n    chOff: { name: 'charoff', type: String },\n    vAlign: String,\n    bgColor: { type: String, treatNullAsEmptyString: true },\n  },\n});\n\ndefine({\n  tags: ['thead', 'tfoot', 'tbody'],\n  ctor: function HTMLTableSectionElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    rows: { get: function() {\n      return this.getElementsByTagName('tr');\n    }}\n  },\n  attributes: {\n    // Obsolete\n    align: String,\n    ch: { name: 'char', type: String },\n    chOff: { name: 'charoff', type: String },\n    vAlign: String,\n  }\n});\n\ndefine({\n  tag: 'textarea',\n  ctor: function HTMLTextAreaElement(doc, localName, prefix) {\n    HTMLFormElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    form: formAssociatedProps.form,\n    type: { get: function() { return 'textarea'; } },\n    defaultValue: {\n      get: function() { return this.textContent; },\n      set: function(v) { this.textContent = v; },\n    },\n    value: {\n      get: function() { return this.defaultValue; /* never dirty */ },\n      set: function(v) {\n        // This isn't completely correct: according to the spec, this\n        // should \"dirty\" the API value, and result in\n        // `this.value !== this.defaultValue`.  But for most of what\n        // folks want to do, this implementation should be fine:\n        this.defaultValue = v;\n      },\n    },\n    textLength: { get: function() { return this.value.length; } },\n  },\n  attributes: {\n    autocomplete: String, // It's complicated\n    name: String,\n    disabled: Boolean,\n    autofocus: Boolean,\n    placeholder: String,\n    wrap: String,\n    dirName: String,\n    required: Boolean,\n    readOnly: Boolean,\n    rows: {type: 'limited unsigned long with fallback', default: 2 },\n    cols: {type: 'limited unsigned long with fallback', default: 20 },\n    maxLength: {type: 'unsigned long', min: 0, setmin: 0, default: -1},\n    minLength: {type: 'unsigned long', min: 0, setmin: 0, default: -1},\n    inputMode: { type: [ \"verbatim\", \"latin\", \"latin-name\", \"latin-prose\", \"full-width-latin\", \"kana\", \"kana-name\", \"katakana\", \"numeric\", \"tel\", \"email\", \"url\" ], missing: '' },\n  }\n});\n\ndefine({\n  tag: 'time',\n  ctor: function HTMLTimeElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    dateTime: String,\n    pubDate: Boolean\n  }\n});\n\ndefine({\n  tag: 'title',\n  ctor: function HTMLTitleElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    text: { get: function() {\n      return this.textContent;\n    }}\n  }\n});\n\ndefine({\n  tag: 'ul',\n  ctor: function HTMLUListElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    type: String,\n    // Obsolete\n    compact: Boolean,\n  }\n});\n\ndefine({\n  ctor: function HTMLMediaElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    src: URL,\n    crossOrigin: CORS,\n    preload: { type:[\"metadata\", \"none\", \"auto\", {value: \"\", alias: \"auto\"}], missing: 'auto' },\n    loop: Boolean,\n    autoplay: Boolean,\n    mediaGroup: String,\n    controls: Boolean,\n    defaultMuted: {name: \"muted\", type: Boolean}\n  }\n});\n\ndefine({\n  tag: 'audio',\n  superclass: htmlElements.HTMLMediaElement,\n  ctor: function HTMLAudioElement(doc, localName, prefix) {\n    htmlElements.HTMLMediaElement.call(this, doc, localName, prefix);\n  }\n});\n\ndefine({\n  tag: 'video',\n  superclass: htmlElements.HTMLMediaElement,\n  ctor: function HTMLVideoElement(doc, localName, prefix) {\n    htmlElements.HTMLMediaElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    poster: URL,\n    width: {type: \"unsigned long\", min: 0, default: 0 },\n    height: {type: \"unsigned long\", min: 0, default: 0 }\n  }\n});\n\ndefine({\n  tag: 'td',\n  superclass: htmlElements.HTMLTableCellElement,\n  ctor: function HTMLTableDataCellElement(doc, localName, prefix) {\n    htmlElements.HTMLTableCellElement.call(this, doc, localName, prefix);\n  }\n});\n\ndefine({\n  tag: 'th',\n  superclass: htmlElements.HTMLTableCellElement,\n  ctor: function HTMLTableHeaderCellElement(doc, localName, prefix) {\n    htmlElements.HTMLTableCellElement.call(this, doc, localName, prefix);\n  },\n});\n\ndefine({\n  tag: 'frameset',\n  ctor: function HTMLFrameSetElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  }\n});\n\ndefine({\n  tag: 'frame',\n  ctor: function HTMLFrameElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  }\n});\n\ndefine({\n  tag: 'canvas',\n  ctor: function HTMLCanvasElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    getContext: { value: utils.nyi },\n    probablySupportsContext: { value: utils.nyi },\n    setContext: { value: utils.nyi },\n    transferControlToProxy: { value: utils.nyi },\n    toDataURL: { value: utils.nyi },\n    toBlob: { value: utils.nyi }\n  },\n  attributes: {\n    width: { type: \"unsigned long\", default: 300},\n    height: { type: \"unsigned long\", default: 150}\n  }\n});\n\ndefine({\n  tag: 'dialog',\n  ctor: function HTMLDialogElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    show: { value: utils.nyi },\n    showModal: { value: utils.nyi },\n    close: { value: utils.nyi }\n  },\n  attributes: {\n    open: Boolean,\n    returnValue: String\n  }\n});\n\ndefine({\n  tag: 'menuitem',\n  ctor: function HTMLMenuItemElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  props: {\n    // The menuitem's label\n    _label: {\n      get: function() {\n        var val = this._getattr('label');\n        if (val !== null && val !== '') { return val; }\n        val = this.textContent;\n        // Strip and collapse whitespace\n        return val.replace(/[ \\t\\n\\f\\r]+/g, ' ').trim();\n      }\n    },\n    // The menuitem label IDL attribute\n    label: {\n      get: function() {\n        var val = this._getattr('label');\n        if (val !== null) { return val; }\n        return this._label;\n      },\n      set: function(v) {\n        this._setattr('label', v);\n      },\n    }\n  },\n  attributes: {\n    type: { type: [\"command\",\"checkbox\",\"radio\"], missing: 'command' },\n    icon: URL,\n    disabled: Boolean,\n    checked: Boolean,\n    radiogroup: String,\n    default: Boolean\n  }\n});\n\ndefine({\n  tag: 'source',\n  ctor: function HTMLSourceElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    srcset: String,\n    sizes: String,\n    media: String,\n    src: URL,\n    type: String\n  }\n});\n\ndefine({\n  tag: 'track',\n  ctor: function HTMLTrackElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    src: URL,\n    srclang: String,\n    label: String,\n    default: Boolean,\n    kind: { type: [\"subtitles\", \"captions\", \"descriptions\", \"chapters\", \"metadata\"], missing: 'subtitles', invalid: 'metadata' },\n  },\n  props: {\n    NONE: { get: function() { return 0; } },\n    LOADING: { get: function() { return 1; } },\n    LOADED: { get: function() { return 2; } },\n    ERROR: { get: function() { return 3; } },\n    readyState: { get: utils.nyi },\n    track: { get: utils.nyi }\n  }\n});\n\ndefine({\n  // obsolete\n  tag: 'font',\n  ctor: function HTMLFontElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    color: { type: String, treatNullAsEmptyString: true },\n    face: { type: String },\n    size: { type: String },\n  },\n});\n\ndefine({\n  // obsolete\n  tag: 'dir',\n  ctor: function HTMLDirectoryElement(doc, localName, prefix) {\n    HTMLElement.call(this, doc, localName, prefix);\n  },\n  attributes: {\n    compact: Boolean,\n  },\n});\n\ndefine({\n  tags: [\n    \"abbr\", \"address\", \"article\", \"aside\", \"b\", \"bdi\", \"bdo\",\n    \"cite\", \"code\", \"dd\", \"dfn\", \"dt\", \"em\", \"figcaption\", \"figure\",\n    \"footer\", \"header\", \"hgroup\", \"i\", \"kbd\", \"main\", \"mark\", \"nav\", \"noscript\",\n    \"rb\", \"rp\", \"rt\", \"rtc\", \"ruby\", \"s\", \"samp\", \"section\", \"small\", \"strong\",\n    \"sub\", \"summary\", \"sup\", \"u\", \"var\", \"wbr\",\n    // Legacy elements\n    \"acronym\", \"basefont\", \"big\", \"center\", \"nobr\", \"noembed\", \"noframes\",\n    \"plaintext\", \"strike\", \"tt\"\n  ]\n});\n","\"use strict\";\nvar utils = require('./utils');\n\nexports = module.exports = {\n  CSSStyleDeclaration: require('./CSSStyleDeclaration'),\n  CharacterData: require('./CharacterData'),\n  Comment: require('./Comment'),\n  DOMException: require('./DOMException'),\n  DOMImplementation: require('./DOMImplementation'),\n  DOMTokenList: require('./DOMTokenList'),\n  Document: require('./Document'),\n  DocumentFragment: require('./DocumentFragment'),\n  DocumentType: require('./DocumentType'),\n  Element: require('./Element'),\n  HTMLParser: require('./HTMLParser'),\n  NamedNodeMap: require('./NamedNodeMap'),\n  Node: require('./Node'),\n  NodeList: require('./NodeList'),\n  NodeFilter: require('./NodeFilter'),\n  ProcessingInstruction: require('./ProcessingInstruction'),\n  Text: require('./Text'),\n  Window: require('./Window')\n};\n\nutils.merge(exports, require('./events'));\nutils.merge(exports, require('./htmlelts').elements);\nutils.merge(exports, require('./svg').elements);\n","\"use strict\";\nvar DOMImplementation = require('./DOMImplementation');\nvar HTMLParser = require('./HTMLParser');\nvar Window = require('./Window');\n\nexports.createDOMImplementation = function() {\n  return new DOMImplementation(null);\n};\n\nexports.createDocument = function(html, force) {\n  // Previous API couldn't let you pass '' as a document, and that\n  // yields a slightly different document than createHTMLDocument('')\n  // does.  The new `force` parameter lets you pass '' if you want to.\n  if (html || force) {\n    var parser = new HTMLParser();\n    parser.parse(html || '', true);\n    return parser.document();\n  }\n  return new DOMImplementation(null).createHTMLDocument(\"\");\n};\n\nexports.createIncrementalHTMLParser = function() {\n    var parser = new HTMLParser();\n    /** API for incremental parser. */\n    return {\n        /** Provide an additional chunk of text to be parsed. */\n        write: function(s) {\n          if (s.length > 0) {\n            parser.parse(s, false, function() { return true; });\n          }\n        },\n        /**\n         * Signal that we are done providing input text, optionally\n         * providing one last chunk as a parameter.\n         */\n        end: function(s) {\n          parser.parse(s || '', true, function() { return true; });\n        },\n        /**\n         * Performs a chunk of parsing work, returning at the end of\n         * the next token as soon as shouldPauseFunc() returns true.\n         * Returns true iff there is more work to do.\n         *\n         * For example:\n         * ```\n         *  var incrParser = domino.createIncrementalHTMLParser();\n         *  incrParser.end('...long html document...');\n         *  while (true) {\n         *    // Pause every 10ms\n         *    var start = Date.now();\n         *    var pauseIn10 = function() { return (Date.now() - start) >= 10; };\n         *    if (!incrParser.process(pauseIn10)) {\n         *      break;\n         *    }\n         *    ...yield to other tasks, do other housekeeping, etc...\n         *  }\n         * ```\n         */\n        process: function(shouldPauseFunc) {\n          return parser.parse('', false, shouldPauseFunc);\n        },\n        /**\n         * Returns the result of the incremental parse.  Valid after\n         * `this.end()` has been called and `this.process()` has returned\n         * false.\n         */\n        document: function() {\n          return parser.document();\n        },\n    };\n};\n\nexports.createWindow = function(html, address) {\n  var document = exports.createDocument(html);\n  if (address !== undefined) { document._address = address; }\n  return new Window(document);\n};\n\nexports.impl = require('./impl');\n","\"use strict\";\n/* jshint eqnull: true */\n/**\n * Zest (https://github.com/chjj/zest)\n * A css selector engine.\n * Copyright (c) 2011-2012, Christopher Jeffrey. (MIT Licensed)\n * Domino version based on Zest v0.1.3 with bugfixes applied.\n */\n\n/**\n * Helpers\n */\n\nvar window = Object.create(null, {\n  location: { get: function() {\n    throw new Error('window.location is not supported.');\n  } }\n});\n\nvar compareDocumentPosition = function(a, b) {\n      return a.compareDocumentPosition(b);\n};\n\nvar order = function(a, b) {\n  /* jshint bitwise: false */\n  return compareDocumentPosition(a, b) & 2 ? 1 : -1;\n};\n\nvar next = function(el) {\n  while ((el = el.nextSibling)\n         && el.nodeType !== 1);\n  return el;\n};\n\nvar prev = function(el) {\n  while ((el = el.previousSibling)\n         && el.nodeType !== 1);\n  return el;\n};\n\nvar child = function(el) {\n  /*jshint -W084 */\n  if (el = el.firstChild) {\n    while (el.nodeType !== 1\n           && (el = el.nextSibling));\n  }\n  return el;\n};\n\nvar lastChild = function(el) {\n  /*jshint -W084 */\n  if (el = el.lastChild) {\n    while (el.nodeType !== 1\n           && (el = el.previousSibling));\n  }\n  return el;\n};\n\nvar parentIsElement = function(n) {\n  if (!n.parentNode) { return false; }\n  var nodeType = n.parentNode.nodeType;\n  // The root `html` element can be a first- or last-child, too.\n  return nodeType === 1 || nodeType === 9;\n};\n\nvar unquote = function(str) {\n  if (!str) return str;\n  var ch = str[0];\n  if (ch === '\"' || ch === '\\'') {\n    if (str[str.length-1] === ch) {\n      str = str.slice(1, -1);\n    } else {\n      // bad string.\n      str = str.slice(1);\n    }\n    return str.replace(rules.str_escape, function(s) {\n      var m = /^\\\\(?:([0-9A-Fa-f]+)|([\\r\\n\\f]+))/.exec(s);\n      if (!m) { return s.slice(1); }\n      if (m[2]) { return ''; /* escaped newlines are ignored in strings. */ }\n      var cp = parseInt(m[1], 16);\n      return String.fromCodePoint ? String.fromCodePoint(cp) :\n        // Not all JavaScript implementations have String.fromCodePoint yet.\n        String.fromCharCode(cp);\n    });\n  } else if (rules.ident.test(str)) {\n    return decodeid(str);\n  } else {\n    // NUMBER, PERCENTAGE, DIMENSION, etc\n    return str;\n  }\n};\n\nvar decodeid = function(str) {\n  return str.replace(rules.escape, function(s) {\n    var m = /^\\\\([0-9A-Fa-f]+)/.exec(s);\n    if (!m) { return s[1]; }\n    var cp = parseInt(m[1], 16);\n    return String.fromCodePoint ? String.fromCodePoint(cp) :\n      // Not all JavaScript implementations have String.fromCodePoint yet.\n      String.fromCharCode(cp);\n  });\n};\n\nvar indexOf = (function() {\n  if (Array.prototype.indexOf) {\n    return Array.prototype.indexOf;\n  }\n  return function(obj, item) {\n    var i = this.length;\n    while (i--) {\n      if (this[i] === item) return i;\n    }\n    return -1;\n  };\n})();\n\nvar makeInside = function(start, end) {\n  var regex = rules.inside.source\n    .replace(/</g, start)\n    .replace(/>/g, end);\n\n  return new RegExp(regex);\n};\n\nvar replace = function(regex, name, val) {\n  regex = regex.source;\n  regex = regex.replace(name, val.source || val);\n  return new RegExp(regex);\n};\n\nvar truncateUrl = function(url, num) {\n  return url\n    .replace(/^(?:\\w+:\\/\\/|\\/+)/, '')\n    .replace(/(?:\\/+|\\/*#.*?)$/, '')\n    .split('/', num)\n    .join('/');\n};\n\n/**\n * Handle `nth` Selectors\n */\n\nvar parseNth = function(param_, test) {\n  var param = param_.replace(/\\s+/g, '')\n    , cap;\n\n  if (param === 'even') {\n    param = '2n+0';\n  } else if (param === 'odd') {\n    param = '2n+1';\n  } else if (param.indexOf('n') === -1) {\n    param = '0n' + param;\n  }\n\n  cap = /^([+-])?(\\d+)?n([+-])?(\\d+)?$/.exec(param);\n\n  return {\n    group: cap[1] === '-'\n      ? -(cap[2] || 1)\n      : +(cap[2] || 1),\n    offset: cap[4]\n      ? (cap[3] === '-' ? -cap[4] : +cap[4])\n      : 0\n  };\n};\n\nvar nth = function(param_, test, last) {\n  var param = parseNth(param_)\n    , group = param.group\n    , offset = param.offset\n    , find = !last ? child : lastChild\n    , advance = !last ? next : prev;\n\n  return function(el) {\n    if (!parentIsElement(el)) return;\n\n    var rel = find(el.parentNode)\n      , pos = 0;\n\n    while (rel) {\n      if (test(rel, el)) pos++;\n      if (rel === el) {\n        pos -= offset;\n        return group && pos\n          ? (pos % group) === 0 && (pos < 0 === group < 0)\n          : !pos;\n      }\n      rel = advance(rel);\n    }\n  };\n};\n\n/**\n * Simple Selectors\n */\n\nvar selectors = {\n  '*': (function() {\n    if (false/*function() {\n      var el = document.createElement('div');\n      el.appendChild(document.createComment(''));\n      return !!el.getElementsByTagName('*')[0];\n    }()*/) {\n      return function(el) {\n        if (el.nodeType === 1) return true;\n      };\n    }\n    return function() {\n      return true;\n    };\n  })(),\n  'type': function(type) {\n    type = type.toLowerCase();\n    return function(el) {\n      return el.nodeName.toLowerCase() === type;\n    };\n  },\n  'attr': function(key, op, val, i) {\n    op = operators[op];\n    return function(el) {\n      var attr;\n      switch (key) {\n        case 'for':\n          attr = el.htmlFor;\n          break;\n        case 'class':\n          // className is '' when non-existent\n          // getAttribute('class') is null\n          attr = el.className;\n          if (attr === '' && el.getAttribute('class') == null) {\n            attr = null;\n          }\n          break;\n        case 'href':\n        case 'src':\n          attr = el.getAttribute(key, 2);\n          break;\n        case 'title':\n          // getAttribute('title') can be '' when non-existent sometimes?\n          attr = el.getAttribute('title') || null;\n          break;\n        // careful with attributes with special getter functions\n        case 'id':\n        case 'lang':\n        case 'dir':\n        case 'accessKey':\n        case 'hidden':\n        case 'tabIndex':\n        case 'style':\n          if (el.getAttribute) {\n            attr = el.getAttribute(key);\n            break;\n          }\n        /* falls through */\n        default:\n          if (el.hasAttribute && !el.hasAttribute(key)) {\n            break;\n          }\n          attr = el[key] != null\n            ? el[key]\n            : el.getAttribute && el.getAttribute(key);\n          break;\n      }\n      if (attr == null) return;\n      attr = attr + '';\n      if (i) {\n        attr = attr.toLowerCase();\n        val = val.toLowerCase();\n      }\n      return op(attr, val);\n    };\n  },\n  ':first-child': function(el) {\n    return !prev(el) && parentIsElement(el);\n  },\n  ':last-child': function(el) {\n    return !next(el) && parentIsElement(el);\n  },\n  ':only-child': function(el) {\n    return !prev(el) && !next(el) && parentIsElement(el);\n  },\n  ':nth-child': function(param, last) {\n    return nth(param, function() {\n      return true;\n    }, last);\n  },\n  ':nth-last-child': function(param) {\n    return selectors[':nth-child'](param, true);\n  },\n  ':root': function(el) {\n    return el.ownerDocument.documentElement === el;\n  },\n  ':empty': function(el) {\n    return !el.firstChild;\n  },\n  ':not': function(sel) {\n    var test = compileGroup(sel);\n    return function(el) {\n      return !test(el);\n    };\n  },\n  ':first-of-type': function(el) {\n    if (!parentIsElement(el)) return;\n    var type = el.nodeName;\n    /*jshint -W084 */\n    while (el = prev(el)) {\n      if (el.nodeName === type) return;\n    }\n    return true;\n  },\n  ':last-of-type': function(el) {\n    if (!parentIsElement(el)) return;\n    var type = el.nodeName;\n    /*jshint -W084 */\n    while (el = next(el)) {\n      if (el.nodeName === type) return;\n    }\n    return true;\n  },\n  ':only-of-type': function(el) {\n    return selectors[':first-of-type'](el)\n        && selectors[':last-of-type'](el);\n  },\n  ':nth-of-type': function(param, last) {\n    return nth(param, function(rel, el) {\n      return rel.nodeName === el.nodeName;\n    }, last);\n  },\n  ':nth-last-of-type': function(param) {\n    return selectors[':nth-of-type'](param, true);\n  },\n  ':checked': function(el) {\n    return !!(el.checked || el.selected);\n  },\n  ':indeterminate': function(el) {\n    return !selectors[':checked'](el);\n  },\n  ':enabled': function(el) {\n    return !el.disabled && el.type !== 'hidden';\n  },\n  ':disabled': function(el) {\n    return !!el.disabled;\n  },\n  ':target': function(el) {\n    return el.id === window.location.hash.substring(1);\n  },\n  ':focus': function(el) {\n    return el === el.ownerDocument.activeElement;\n  },\n  ':is': function(sel) {\n    return compileGroup(sel);\n  },\n  // :matches is an older name for :is; see\n  // https://github.com/w3c/csswg-drafts/issues/3258\n  ':matches': function(sel) {\n    return selectors[':is'](sel);\n  },\n  ':nth-match': function(param, last) {\n    var args = param.split(/\\s*,\\s*/)\n      , arg = args.shift()\n      , test = compileGroup(args.join(','));\n\n    return nth(arg, test, last);\n  },\n  ':nth-last-match': function(param) {\n    return selectors[':nth-match'](param, true);\n  },\n  ':links-here': function(el) {\n    return el + '' === window.location + '';\n  },\n  ':lang': function(param) {\n    return function(el) {\n      while (el) {\n        if (el.lang) return el.lang.indexOf(param) === 0;\n        el = el.parentNode;\n      }\n    };\n  },\n  ':dir': function(param) {\n    return function(el) {\n      while (el) {\n        if (el.dir) return el.dir === param;\n        el = el.parentNode;\n      }\n    };\n  },\n  ':scope': function(el, con) {\n    var context = con || el.ownerDocument;\n    if (context.nodeType === 9) {\n      return el === context.documentElement;\n    }\n    return el === context;\n  },\n  ':any-link': function(el) {\n    return typeof el.href === 'string';\n  },\n  ':local-link': function(el) {\n    if (el.nodeName) {\n      return el.href && el.host === window.location.host;\n    }\n    var param = +el + 1;\n    return function(el) {\n      if (!el.href) return;\n\n      var url = window.location + ''\n        , href = el + '';\n\n      return truncateUrl(url, param) === truncateUrl(href, param);\n    };\n  },\n  ':default': function(el) {\n    return !!el.defaultSelected;\n  },\n  ':valid': function(el) {\n    return el.willValidate || (el.validity && el.validity.valid);\n  },\n  ':invalid': function(el) {\n    return !selectors[':valid'](el);\n  },\n  ':in-range': function(el) {\n    return el.value > el.min && el.value <= el.max;\n  },\n  ':out-of-range': function(el) {\n    return !selectors[':in-range'](el);\n  },\n  ':required': function(el) {\n    return !!el.required;\n  },\n  ':optional': function(el) {\n    return !el.required;\n  },\n  ':read-only': function(el) {\n    if (el.readOnly) return true;\n\n    var attr = el.getAttribute('contenteditable')\n      , prop = el.contentEditable\n      , name = el.nodeName.toLowerCase();\n\n    name = name !== 'input' && name !== 'textarea';\n\n    return (name || el.disabled) && attr == null && prop !== 'true';\n  },\n  ':read-write': function(el) {\n    return !selectors[':read-only'](el);\n  },\n  ':hover': function() {\n    throw new Error(':hover is not supported.');\n  },\n  ':active': function() {\n    throw new Error(':active is not supported.');\n  },\n  ':link': function() {\n    throw new Error(':link is not supported.');\n  },\n  ':visited': function() {\n    throw new Error(':visited is not supported.');\n  },\n  ':column': function() {\n    throw new Error(':column is not supported.');\n  },\n  ':nth-column': function() {\n    throw new Error(':nth-column is not supported.');\n  },\n  ':nth-last-column': function() {\n    throw new Error(':nth-last-column is not supported.');\n  },\n  ':current': function() {\n    throw new Error(':current is not supported.');\n  },\n  ':past': function() {\n    throw new Error(':past is not supported.');\n  },\n  ':future': function() {\n    throw new Error(':future is not supported.');\n  },\n  // Non-standard, for compatibility purposes.\n  ':contains': function(param) {\n    return function(el) {\n      var text = el.innerText || el.textContent || el.value || '';\n      return text.indexOf(param) !== -1;\n    };\n  },\n  ':has': function(param) {\n    return function(el) {\n      return find(param, el).length > 0;\n    };\n  }\n  // Potentially add more pseudo selectors for\n  // compatibility with sizzle and most other\n  // selector engines (?).\n};\n\n/**\n * Attribute Operators\n */\n\nvar operators = {\n  '-': function() {\n    return true;\n  },\n  '=': function(attr, val) {\n    return attr === val;\n  },\n  '*=': function(attr, val) {\n    return attr.indexOf(val) !== -1;\n  },\n  '~=': function(attr, val) {\n    var i\n      , s\n      , f\n      , l;\n\n    for (s = 0; true; s = i + 1) {\n      i = attr.indexOf(val, s);\n      if (i === -1) return false;\n      f = attr[i - 1];\n      l = attr[i + val.length];\n      if ((!f || f === ' ') && (!l || l === ' ')) return true;\n    }\n  },\n  '|=': function(attr, val) {\n    var i = attr.indexOf(val)\n      , l;\n\n    if (i !== 0) return;\n    l = attr[i + val.length];\n\n    return l === '-' || !l;\n  },\n  '^=': function(attr, val) {\n    return attr.indexOf(val) === 0;\n  },\n  '$=': function(attr, val) {\n    var i = attr.lastIndexOf(val);\n    return i !== -1 && i + val.length === attr.length;\n  },\n  // non-standard\n  '!=': function(attr, val) {\n    return attr !== val;\n  }\n};\n\n/**\n * Combinator Logic\n */\n\nvar combinators = {\n  ' ': function(test) {\n    return function(el) {\n      /*jshint -W084 */\n      while (el = el.parentNode) {\n        if (test(el)) return el;\n      }\n    };\n  },\n  '>': function(test) {\n    return function(el) {\n      /*jshint -W084 */\n      if (el = el.parentNode) {\n        return test(el) && el;\n      }\n    };\n  },\n  '+': function(test) {\n    return function(el) {\n      /*jshint -W084 */\n      if (el = prev(el)) {\n        return test(el) && el;\n      }\n    };\n  },\n  '~': function(test) {\n    return function(el) {\n      /*jshint -W084 */\n      while (el = prev(el)) {\n        if (test(el)) return el;\n      }\n    };\n  },\n  'noop': function(test) {\n    return function(el) {\n      return test(el) && el;\n    };\n  },\n  'ref': function(test, name) {\n    var node;\n\n    function ref(el) {\n      var doc = el.ownerDocument\n        , nodes = doc.getElementsByTagName('*')\n        , i = nodes.length;\n\n      while (i--) {\n        node = nodes[i];\n        if (ref.test(el)) {\n          node = null;\n          return true;\n        }\n      }\n\n      node = null;\n    }\n\n    ref.combinator = function(el) {\n      if (!node || !node.getAttribute) return;\n\n      var attr = node.getAttribute(name) || '';\n      if (attr[0] === '#') attr = attr.substring(1);\n\n      if (attr === el.id && test(node)) {\n        return node;\n      }\n    };\n\n    return ref;\n  }\n};\n\n/**\n * Grammar\n */\n\nvar rules = {\n  escape: /\\\\(?:[^0-9A-Fa-f\\r\\n]|[0-9A-Fa-f]{1,6}[\\r\\n\\t ]?)/g,\n  str_escape: /(escape)|\\\\(\\n|\\r\\n?|\\f)/g,\n  nonascii: /[\\u00A0-\\uFFFF]/,\n  cssid: /(?:(?!-?[0-9])(?:escape|nonascii|[-_a-zA-Z0-9])+)/,\n  qname: /^ *(cssid|\\*)/,\n  simple: /^(?:([.#]cssid)|pseudo|attr)/,\n  ref: /^ *\\/(cssid)\\/ */,\n  combinator: /^(?: +([^ \\w*.#\\\\]) +|( )+|([^ \\w*.#\\\\]))(?! *$)/,\n  attr: /^\\[(cssid)(?:([^\\w]?=)(inside))?\\]/,\n  pseudo: /^(:cssid)(?:\\((inside)\\))?/,\n  inside: /(?:\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'|<[^\"'>]*>|\\\\[\"'>]|[^\"'>])*/,\n  ident: /^(cssid)$/\n};\n\nrules.cssid = replace(rules.cssid, 'nonascii', rules.nonascii);\nrules.cssid = replace(rules.cssid, 'escape', rules.escape);\nrules.qname = replace(rules.qname, 'cssid', rules.cssid);\nrules.simple = replace(rules.simple, 'cssid', rules.cssid);\nrules.ref = replace(rules.ref, 'cssid', rules.cssid);\nrules.attr = replace(rules.attr, 'cssid', rules.cssid);\nrules.pseudo = replace(rules.pseudo, 'cssid', rules.cssid);\nrules.inside = replace(rules.inside, '[^\"\\'>]*', rules.inside);\nrules.attr = replace(rules.attr, 'inside', makeInside('\\\\[', '\\\\]'));\nrules.pseudo = replace(rules.pseudo, 'inside', makeInside('\\\\(', '\\\\)'));\nrules.simple = replace(rules.simple, 'pseudo', rules.pseudo);\nrules.simple = replace(rules.simple, 'attr', rules.attr);\nrules.ident = replace(rules.ident, 'cssid', rules.cssid);\nrules.str_escape = replace(rules.str_escape, 'escape', rules.escape);\n\n/**\n * Compiling\n */\n\nvar compile = function(sel_) {\n  var sel = sel_.replace(/^\\s+|\\s+$/g, '')\n    , test\n    , filter = []\n    , buff = []\n    , subject\n    , qname\n    , cap\n    , op\n    , ref;\n\n  /*jshint -W084 */\n  while (sel) {\n    if (cap = rules.qname.exec(sel)) {\n      sel = sel.substring(cap[0].length);\n      qname = decodeid(cap[1]);\n      buff.push(tok(qname, true));\n    } else if (cap = rules.simple.exec(sel)) {\n      sel = sel.substring(cap[0].length);\n      qname = '*';\n      buff.push(tok(qname, true));\n      buff.push(tok(cap));\n    } else {\n      throw new SyntaxError('Invalid selector.');\n    }\n\n    while (cap = rules.simple.exec(sel)) {\n      sel = sel.substring(cap[0].length);\n      buff.push(tok(cap));\n    }\n\n    if (sel[0] === '!') {\n      sel = sel.substring(1);\n      subject = makeSubject();\n      subject.qname = qname;\n      buff.push(subject.simple);\n    }\n\n    if (cap = rules.ref.exec(sel)) {\n      sel = sel.substring(cap[0].length);\n      ref = combinators.ref(makeSimple(buff), decodeid(cap[1]));\n      filter.push(ref.combinator);\n      buff = [];\n      continue;\n    }\n\n    if (cap = rules.combinator.exec(sel)) {\n      sel = sel.substring(cap[0].length);\n      op = cap[1] || cap[2] || cap[3];\n      if (op === ',') {\n        filter.push(combinators.noop(makeSimple(buff)));\n        break;\n      }\n    } else {\n      op = 'noop';\n    }\n\n    if (!combinators[op]) { throw new SyntaxError('Bad combinator.'); }\n    filter.push(combinators[op](makeSimple(buff)));\n    buff = [];\n  }\n\n  test = makeTest(filter);\n  test.qname = qname;\n  test.sel = sel;\n\n  if (subject) {\n    subject.lname = test.qname;\n\n    subject.test = test;\n    subject.qname = subject.qname;\n    subject.sel = test.sel;\n    test = subject;\n  }\n\n  if (ref) {\n    ref.test = test;\n    ref.qname = test.qname;\n    ref.sel = test.sel;\n    test = ref;\n  }\n\n  return test;\n};\n\nvar tok = function(cap, qname) {\n  // qname\n  if (qname) {\n    return cap === '*'\n      ? selectors['*']\n      : selectors.type(cap);\n  }\n\n  // class/id\n  if (cap[1]) {\n    return cap[1][0] === '.'\n\t  // XXX unescape here?  or in attr?\n      ? selectors.attr('class', '~=', decodeid(cap[1].substring(1)), false)\n      : selectors.attr('id', '=', decodeid(cap[1].substring(1)), false);\n  }\n\n  // pseudo-name\n  // inside-pseudo\n  if (cap[2]) {\n    return cap[3]\n      ? selectors[decodeid(cap[2])](unquote(cap[3]))\n      : selectors[decodeid(cap[2])];\n  }\n\n  // attr name\n  // attr op\n  // attr value\n  if (cap[4]) {\n    var value = cap[6];\n    var i = /[\"'\\s]\\s*I$/i.test(value);\n    if (i) {\n      value = value.replace(/\\s*I$/i, '');\n    }\n    return selectors.attr(decodeid(cap[4]), cap[5] || '-', unquote(value), i);\n  }\n\n  throw new SyntaxError('Unknown Selector.');\n};\n\nvar makeSimple = function(func) {\n  var l = func.length\n    , i;\n\n  // Potentially make sure\n  // `el` is truthy.\n  if (l < 2) return func[0];\n\n  return function(el) {\n    if (!el) return;\n    for (i = 0; i < l; i++) {\n      if (!func[i](el)) return;\n    }\n    return true;\n  };\n};\n\nvar makeTest = function(func) {\n  if (func.length < 2) {\n    return function(el) {\n      return !!func[0](el);\n    };\n  }\n  return function(el) {\n    var i = func.length;\n    while (i--) {\n      if (!(el = func[i](el))) return;\n    }\n    return true;\n  };\n};\n\nvar makeSubject = function() {\n  var target;\n\n  function subject(el) {\n    var node = el.ownerDocument\n      , scope = node.getElementsByTagName(subject.lname)\n      , i = scope.length;\n\n    while (i--) {\n      if (subject.test(scope[i]) && target === el) {\n        target = null;\n        return true;\n      }\n    }\n\n    target = null;\n  }\n\n  subject.simple = function(el) {\n    target = el;\n    return true;\n  };\n\n  return subject;\n};\n\nvar compileGroup = function(sel) {\n  var test = compile(sel)\n    , tests = [ test ];\n\n  while (test.sel) {\n    test = compile(test.sel);\n    tests.push(test);\n  }\n\n  if (tests.length < 2) return test;\n\n  return function(el) {\n    var l = tests.length\n      , i = 0;\n\n    for (; i < l; i++) {\n      if (tests[i](el)) return true;\n    }\n  };\n};\n\n/**\n * Selection\n */\n\nvar find = function(sel, node) {\n  var results = []\n    , test = compile(sel)\n    , scope = node.getElementsByTagName(test.qname)\n    , i = 0\n    , el;\n\n  /*jshint -W084 */\n  while (el = scope[i++]) {\n    if (test(el)) results.push(el);\n  }\n\n  if (test.sel) {\n    while (test.sel) {\n      test = compile(test.sel);\n      scope = node.getElementsByTagName(test.qname);\n      i = 0;\n      /*jshint -W084 */\n      while (el = scope[i++]) {\n        if (test(el) && indexOf.call(results, el) === -1) {\n          results.push(el);\n        }\n      }\n    }\n    results.sort(order);\n  }\n\n  return results;\n};\n\n/**\n * Expose\n */\n\nmodule.exports = exports = function(sel, context) {\n  /* when context isn't a DocumentFragment and the selector is simple: */\n  var id, r;\n  if (context.nodeType !== 11 && sel.indexOf(' ') === -1) {\n    if (sel[0] === '#' && context.rooted && /^#[A-Z_][-A-Z0-9_]*$/i.test(sel)) {\n      if (context.doc._hasMultipleElementsWithId) {\n        id = sel.substring(1);\n        if (!context.doc._hasMultipleElementsWithId(id)) {\n          r = context.doc.getElementById(id);\n          return r ? [r] : [];\n        }\n      }\n    }\n    if (sel[0] === '.' && /^\\.\\w+$/.test(sel)) {\n      return context.getElementsByClassName(sel.substring(1));\n    }\n    if (/^\\w+$/.test(sel)) {\n      return context.getElementsByTagName(sel);\n    }\n  }\n  /* do things the hard/slow way */\n  return find(sel, context);\n};\n\nexports.selectors = selectors;\nexports.operators = operators;\nexports.combinators = combinators;\n\nexports.matches = function(el, sel) {\n  var test = { sel: sel };\n  do {\n    test = compile(test.sel);\n    if (test(el)) { return true; }\n  } while (test.sel);\n  return false;\n};\n","/* Domino uses sloppy-mode features (in particular, `with`) for a few\n * minor things.  This file encapsulates all the sloppiness; every\n * other module should be strict. */\n/* jshint strict: false */\n/* jshint evil: true */\n/* jshint -W085 */\nmodule.exports = {\n  Window_run: function _run(code, file) {\n    if (file) code += '\\n//@ sourceURL=' + file;\n    with(this) eval(code);\n  },\n  EventHandlerBuilder_build: function build() {\n    try {\n      with(this.document.defaultView || Object.create(null))\n        with(this.document)\n          with(this.form)\n            with(this.element)\n              return eval(\"(function(event){\" + this.body + \"})\");\n    }\n    catch (err) {\n      return function() { throw err; };\n    }\n  }\n};\n","\"use strict\";\nvar Element = require('./Element');\nvar defineElement = require('./defineElement');\nvar utils = require('./utils');\nvar CSSStyleDeclaration = require('./CSSStyleDeclaration');\n\nvar svgElements = exports.elements = {};\nvar svgNameToImpl = Object.create(null);\n\nexports.createElement = function(doc, localName, prefix) {\n  var impl = svgNameToImpl[localName] || SVGElement;\n  return new impl(doc, localName, prefix);\n};\n\nfunction define(spec) {\n  return defineElement(spec, SVGElement, svgElements, svgNameToImpl);\n}\n\nvar SVGElement = define({\n  superclass: Element,\n  ctor: function SVGElement(doc, localName, prefix) {\n    Element.call(this, doc, localName, utils.NAMESPACE.SVG, prefix);\n  },\n  props: {\n    style: { get: function() {\n      if (!this._style)\n        this._style = new CSSStyleDeclaration(this);\n      return this._style;\n    }}\n  }\n});\n\ndefine({\n  ctor: function SVGSVGElement(doc, localName, prefix) {\n    SVGElement.call(this, doc, localName, prefix);\n  },\n  tag: 'svg',\n  props: {\n    createSVGRect: { value: function () {\n      return exports.createElement(this.ownerDocument, 'rect', null);\n    } }\n  }\n});\n\ndefine({\n  tags: [\n    'a', 'altGlyph', 'altGlyphDef', 'altGlyphItem', 'animate', 'animateColor', 'animateMotion', 'animateTransform',\n    'circle', 'clipPath', 'color-profile', 'cursor', 'defs', 'desc', 'ellipse', 'feBlend', 'feColorMatrix',\n    'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight',\n    'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode',\n    'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence', 'filter',\n    'font', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignObject', 'g',\n    'glyph', 'glyphRef', 'hkern', 'image', 'line', 'linearGradient', 'marker', 'mask', 'metadata', 'missing-glyph',\n    'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'script', 'set', 'stop',  'style',\n    'switch', 'symbol', 'text', 'textPath', 'title', 'tref', 'tspan', 'use', 'view', 'vkern'\n  ]\n});\n","\"use strict\";\nvar DOMException = require('./DOMException');\nvar ERR = DOMException;\nvar isApiWritable = require(\"./config\").isApiWritable;\n\nexports.NAMESPACE = {\n  HTML: 'http://www.w3.org/1999/xhtml',\n  XML: 'http://www.w3.org/XML/1998/namespace',\n  XMLNS: 'http://www.w3.org/2000/xmlns/',\n  MATHML: 'http://www.w3.org/1998/Math/MathML',\n  SVG: 'http://www.w3.org/2000/svg',\n  XLINK: 'http://www.w3.org/1999/xlink'\n};\n\n//\n// Shortcut functions for throwing errors of various types.\n//\nexports.IndexSizeError = function() { throw new DOMException(ERR.INDEX_SIZE_ERR); };\nexports.HierarchyRequestError = function() { throw new DOMException(ERR.HIERARCHY_REQUEST_ERR); };\nexports.WrongDocumentError = function() { throw new DOMException(ERR.WRONG_DOCUMENT_ERR); };\nexports.InvalidCharacterError = function() { throw new DOMException(ERR.INVALID_CHARACTER_ERR); };\nexports.NoModificationAllowedError = function() { throw new DOMException(ERR.NO_MODIFICATION_ALLOWED_ERR); };\nexports.NotFoundError = function() { throw new DOMException(ERR.NOT_FOUND_ERR); };\nexports.NotSupportedError = function() { throw new DOMException(ERR.NOT_SUPPORTED_ERR); };\nexports.InvalidStateError = function() { throw new DOMException(ERR.INVALID_STATE_ERR); };\nexports.SyntaxError = function() { throw new DOMException(ERR.SYNTAX_ERR); };\nexports.InvalidModificationError = function() { throw new DOMException(ERR.INVALID_MODIFICATION_ERR); };\nexports.NamespaceError = function() { throw new DOMException(ERR.NAMESPACE_ERR); };\nexports.InvalidAccessError = function() { throw new DOMException(ERR.INVALID_ACCESS_ERR); };\nexports.TypeMismatchError = function() { throw new DOMException(ERR.TYPE_MISMATCH_ERR); };\nexports.SecurityError = function() { throw new DOMException(ERR.SECURITY_ERR); };\nexports.NetworkError = function() { throw new DOMException(ERR.NETWORK_ERR); };\nexports.AbortError = function() { throw new DOMException(ERR.ABORT_ERR); };\nexports.UrlMismatchError = function() { throw new DOMException(ERR.URL_MISMATCH_ERR); };\nexports.QuotaExceededError = function() { throw new DOMException(ERR.QUOTA_EXCEEDED_ERR); };\nexports.TimeoutError = function() { throw new DOMException(ERR.TIMEOUT_ERR); };\nexports.InvalidNodeTypeError = function() { throw new DOMException(ERR.INVALID_NODE_TYPE_ERR); };\nexports.DataCloneError = function() { throw new DOMException(ERR.DATA_CLONE_ERR); };\n\nexports.nyi = function() {\n  throw new Error(\"NotYetImplemented\");\n};\n\nexports.shouldOverride = function() {\n  throw new Error(\"Abstract function; should be overriding in subclass.\");\n};\n\nexports.assert = function(expr, msg) {\n  if (!expr) {\n    throw new Error(\"Assertion failed: \" + (msg || \"\") + \"\\n\" + new Error().stack);\n  }\n};\n\nexports.expose = function(src, c) {\n  for (var n in src) {\n    Object.defineProperty(c.prototype, n, { value: src[n], writable: isApiWritable });\n  }\n};\n\nexports.merge = function(a, b) {\n  for (var n in b) {\n    a[n] = b[n];\n  }\n};\n\n// Compare two nodes based on their document order. This function is intended\n// to be passed to sort(). Assumes that the array being sorted does not\n// contain duplicates.  And that all nodes are connected and comparable.\n// Clever code by ppk via jeresig.\nexports.documentOrder = function(n,m) {\n  /* jshint bitwise: false */\n  return 3 - (n.compareDocumentPosition(m) & 6);\n};\n\nexports.toASCIILowerCase = function(s) {\n  return s.replace(/[A-Z]+/g, function(c) {\n    return c.toLowerCase();\n  });\n};\n\nexports.toASCIIUpperCase = function(s) {\n  return s.replace(/[a-z]+/g, function(c) {\n    return c.toUpperCase();\n  });\n};\n","\"use strict\";\n// This grammar is from the XML and XML Namespace specs. It specifies whether\n// a string (such as an element or attribute name) is a valid Name or QName.\n//\n// Name           ::= NameStartChar (NameChar)*\n// NameStartChar  ::= \":\" | [A-Z] | \"_\" | [a-z] |\n//                    [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] |\n//                    [#x370-#x37D] | [#x37F-#x1FFF] |\n//                    [#x200C-#x200D] | [#x2070-#x218F] |\n//                    [#x2C00-#x2FEF] | [#x3001-#xD7FF] |\n//                    [#xF900-#xFDCF] | [#xFDF0-#xFFFD] |\n//                    [#x10000-#xEFFFF]\n//\n// NameChar       ::= NameStartChar | \"-\" | \".\" | [0-9] |\n//                    #xB7 | [#x0300-#x036F] | [#x203F-#x2040]\n//\n// QName          ::= PrefixedName| UnprefixedName\n// PrefixedName   ::= Prefix ':' LocalPart\n// UnprefixedName ::= LocalPart\n// Prefix         ::= NCName\n// LocalPart      ::= NCName\n// NCName         ::= Name - (Char* ':' Char*)\n//                    # An XML Name, minus the \":\"\n//\n\nexports.isValidName = isValidName;\nexports.isValidQName = isValidQName;\n\n// Most names will be ASCII only. Try matching against simple regexps first\nvar simplename = /^[_:A-Za-z][-.:\\w]+$/;\nvar simpleqname = /^([_A-Za-z][-.\\w]+|[_A-Za-z][-.\\w]+:[_A-Za-z][-.\\w]+)$/;\n\n// If the regular expressions above fail, try more complex ones that work\n// for any identifiers using codepoints from the Unicode BMP\nvar ncnamestartchars = \"_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02ff\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\";\nvar ncnamechars = \"-._A-Za-z0-9\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02ff\\u0300-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u203f\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\";\n\nvar ncname = \"[\" + ncnamestartchars + \"][\" + ncnamechars + \"]*\";\nvar namestartchars = ncnamestartchars + \":\";\nvar namechars = ncnamechars + \":\";\nvar name = new RegExp(\"^[\" + namestartchars + \"]\" + \"[\" + namechars + \"]*$\");\nvar qname = new RegExp(\"^(\" + ncname + \"|\" + ncname + \":\" + ncname + \")$\");\n\n// XML says that these characters are also legal:\n// [#x10000-#xEFFFF].  So if the patterns above fail, and the\n// target string includes surrogates, then try the following\n// patterns that allow surrogates and then run an extra validation\n// step to make sure that the surrogates are in valid pairs and in\n// the right range.  Note that since the characters \\uf0000 to \\u1f0000\n// are not allowed, it means that the high surrogate can only go up to\n// \\uDB7f instead of \\uDBFF.\nvar hassurrogates = /[\\uD800-\\uDB7F\\uDC00-\\uDFFF]/;\nvar surrogatechars = /[\\uD800-\\uDB7F\\uDC00-\\uDFFF]/g;\nvar surrogatepairs = /[\\uD800-\\uDB7F][\\uDC00-\\uDFFF]/g;\n\n// Modify the variables above to allow surrogates\nncnamestartchars += \"\\uD800-\\uDB7F\\uDC00-\\uDFFF\";\nncnamechars += \"\\uD800-\\uDB7F\\uDC00-\\uDFFF\";\nncname = \"[\" + ncnamestartchars + \"][\" + ncnamechars + \"]*\";\nnamestartchars = ncnamestartchars + \":\";\nnamechars = ncnamechars + \":\";\n\n// Build another set of regexps that include surrogates\nvar surrogatename = new RegExp(\"^[\" + namestartchars + \"]\" + \"[\" + namechars + \"]*$\");\nvar surrogateqname = new RegExp(\"^(\" + ncname + \"|\" + ncname + \":\" + ncname + \")$\");\n\nfunction isValidName(s) {\n  if (simplename.test(s)) return true; // Plain ASCII\n  if (name.test(s)) return true; // Unicode BMP\n\n  // Maybe the tests above failed because s includes surrogate pairs\n  // Most likely, though, they failed for some more basic syntax problem\n  if (!hassurrogates.test(s)) return false;\n\n  // Is the string a valid name if we allow surrogates?\n  if (!surrogatename.test(s)) return false;\n\n  // Finally, are the surrogates all correctly paired up?\n  var chars = s.match(surrogatechars), pairs = s.match(surrogatepairs);\n  return pairs !== null && 2*pairs.length === chars.length;\n}\n\nfunction isValidQName(s) {\n  if (simpleqname.test(s)) return true; // Plain ASCII\n  if (qname.test(s)) return true; // Unicode BMP\n\n  if (!hassurrogates.test(s)) return false;\n  if (!surrogateqname.test(s)) return false;\n  var chars = s.match(surrogatechars), pairs = s.match(surrogatepairs);\n  return pairs !== null && 2*pairs.length === chars.length;\n}\n","/* @flow */\n/*::\n\ntype DotenvParseOptions = {\n  debug?: boolean\n}\n\n// keys and values from src\ntype DotenvParseOutput = { [string]: string }\n\ntype DotenvConfigOptions = {\n  path?: string, // path to .env file\n  encoding?: string, // encoding of .env file\n  debug?: string // turn on logging for debugging purposes\n}\n\ntype DotenvConfigOutput = {\n  parsed?: DotenvParseOutput,\n  error?: Error\n}\n\n*/\n\nconst fs = require('fs')\nconst path = require('path')\nconst os = require('os')\n\nfunction log (message /*: string */) {\n  console.log(`[dotenv][DEBUG] ${message}`)\n}\n\nconst NEWLINE = '\\n'\nconst RE_INI_KEY_VAL = /^\\s*([\\w.-]+)\\s*=\\s*(.*)?\\s*$/\nconst RE_NEWLINES = /\\\\n/g\nconst NEWLINES_MATCH = /\\r\\n|\\n|\\r/\n\n// Parses src into an Object\nfunction parse (src /*: string | Buffer */, options /*: ?DotenvParseOptions */) /*: DotenvParseOutput */ {\n  const debug = Boolean(options && options.debug)\n  const obj = {}\n\n  // convert Buffers before splitting into lines and processing\n  src.toString().split(NEWLINES_MATCH).forEach(function (line, idx) {\n    // matching \"KEY' and 'VAL' in 'KEY=VAL'\n    const keyValueArr = line.match(RE_INI_KEY_VAL)\n    // matched?\n    if (keyValueArr != null) {\n      const key = keyValueArr[1]\n      // default undefined or missing values to empty string\n      let val = (keyValueArr[2] || '')\n      const end = val.length - 1\n      const isDoubleQuoted = val[0] === '\"' && val[end] === '\"'\n      const isSingleQuoted = val[0] === \"'\" && val[end] === \"'\"\n\n      // if single or double quoted, remove quotes\n      if (isSingleQuoted || isDoubleQuoted) {\n        val = val.substring(1, end)\n\n        // if double quoted, expand newlines\n        if (isDoubleQuoted) {\n          val = val.replace(RE_NEWLINES, NEWLINE)\n        }\n      } else {\n        // remove surrounding whitespace\n        val = val.trim()\n      }\n\n      obj[key] = val\n    } else if (debug) {\n      log(`did not match key and value when parsing line ${idx + 1}: ${line}`)\n    }\n  })\n\n  return obj\n}\n\nfunction resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\n// Populates process.env from .env file\nfunction config (options /*: ?DotenvConfigOptions */) /*: DotenvConfigOutput */ {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding /*: string */ = 'utf8'\n  let debug = false\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = resolveHome(options.path)\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n    if (options.debug != null) {\n      debug = true\n    }\n  }\n\n  try {\n    // specifying an encoding returns a string instead of a buffer\n    const parsed = parse(fs.readFileSync(dotenvPath, { encoding }), { debug })\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key]\n      } else if (debug) {\n        log(`\"${key}\" is already defined in \\`process.env\\` and will not be overwritten`)\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    return { error: e }\n  }\n}\n\nmodule.exports.config = config\nmodule.exports.parse = parse\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;\nvar entities_json_1 = __importDefault(require(\"./maps/entities.json\"));\nvar legacy_json_1 = __importDefault(require(\"./maps/legacy.json\"));\nvar xml_json_1 = __importDefault(require(\"./maps/xml.json\"));\nvar decode_codepoint_1 = __importDefault(require(\"./decode_codepoint\"));\nvar strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\\da-fA-F]+|#\\d+);/g;\nexports.decodeXML = getStrictDecoder(xml_json_1.default);\nexports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);\nfunction getStrictDecoder(map) {\n    var replace = getReplacer(map);\n    return function (str) { return String(str).replace(strictEntityRe, replace); };\n}\nvar sorter = function (a, b) { return (a < b ? 1 : -1); };\nexports.decodeHTML = (function () {\n    var legacy = Object.keys(legacy_json_1.default).sort(sorter);\n    var keys = Object.keys(entities_json_1.default).sort(sorter);\n    for (var i = 0, j = 0; i < keys.length; i++) {\n        if (legacy[j] === keys[i]) {\n            keys[i] += \";?\";\n            j++;\n        }\n        else {\n            keys[i] += \";\";\n        }\n    }\n    var re = new RegExp(\"&(?:\" + keys.join(\"|\") + \"|#[xX][\\\\da-fA-F]+;?|#\\\\d+;?)\", \"g\");\n    var replace = getReplacer(entities_json_1.default);\n    function replacer(str) {\n        if (str.substr(-1) !== \";\")\n            str += \";\";\n        return replace(str);\n    }\n    // TODO consider creating a merged map\n    return function (str) { return String(str).replace(re, replacer); };\n})();\nfunction getReplacer(map) {\n    return function replace(str) {\n        if (str.charAt(1) === \"#\") {\n            var secondChar = str.charAt(2);\n            if (secondChar === \"X\" || secondChar === \"x\") {\n                return decode_codepoint_1.default(parseInt(str.substr(3), 16));\n            }\n            return decode_codepoint_1.default(parseInt(str.substr(2), 10));\n        }\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        return map[str.slice(1, -1)] || str;\n    };\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar decode_json_1 = __importDefault(require(\"./maps/decode.json\"));\n// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119\nvar fromCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.fromCodePoint ||\n    function (codePoint) {\n        var output = \"\";\n        if (codePoint > 0xffff) {\n            codePoint -= 0x10000;\n            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);\n            codePoint = 0xdc00 | (codePoint & 0x3ff);\n        }\n        output += String.fromCharCode(codePoint);\n        return output;\n    };\nfunction decodeCodePoint(codePoint) {\n    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {\n        return \"\\uFFFD\";\n    }\n    if (codePoint in decode_json_1.default) {\n        codePoint = decode_json_1.default[codePoint];\n    }\n    return fromCodePoint(codePoint);\n}\nexports.default = decodeCodePoint;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;\nvar xml_json_1 = __importDefault(require(\"./maps/xml.json\"));\nvar inverseXML = getInverseObj(xml_json_1.default);\nvar xmlReplacer = getInverseReplacer(inverseXML);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nexports.encodeXML = getASCIIEncoder(inverseXML);\nvar entities_json_1 = __importDefault(require(\"./maps/entities.json\"));\nvar inverseHTML = getInverseObj(entities_json_1.default);\nvar htmlReplacer = getInverseReplacer(inverseHTML);\n/**\n * Encodes all entities and non-ASCII characters in the input.\n *\n * This includes characters that are valid ASCII characters in HTML documents.\n * For example `#` will be encoded as `&num;`. To get a more compact output,\n * consider using the `encodeNonAsciiHTML` function.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nexports.encodeHTML = getInverse(inverseHTML, htmlReplacer);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nexports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);\nfunction getInverseObj(obj) {\n    return Object.keys(obj)\n        .sort()\n        .reduce(function (inverse, name) {\n        inverse[obj[name]] = \"&\" + name + \";\";\n        return inverse;\n    }, {});\n}\nfunction getInverseReplacer(inverse) {\n    var single = [];\n    var multiple = [];\n    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {\n        var k = _a[_i];\n        if (k.length === 1) {\n            // Add value to single array\n            single.push(\"\\\\\" + k);\n        }\n        else {\n            // Add value to multiple array\n            multiple.push(k);\n        }\n    }\n    // Add ranges to single characters.\n    single.sort();\n    for (var start = 0; start < single.length - 1; start++) {\n        // Find the end of a run of characters\n        var end = start;\n        while (end < single.length - 1 &&\n            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {\n            end += 1;\n        }\n        var count = 1 + end - start;\n        // We want to replace at least three characters\n        if (count < 3)\n            continue;\n        single.splice(start, count, single[start] + \"-\" + single[end]);\n    }\n    multiple.unshift(\"[\" + single.join(\"\") + \"]\");\n    return new RegExp(multiple.join(\"|\"), \"g\");\n}\n// /[^\\0-\\x7F]/gu\nvar reNonASCII = /(?:[\\x80-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g;\nvar getCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null\n    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        function (str) { return str.codePointAt(0); }\n    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        function (c) {\n            return (c.charCodeAt(0) - 0xd800) * 0x400 +\n                c.charCodeAt(1) -\n                0xdc00 +\n                0x10000;\n        };\nfunction singleCharReplacer(c) {\n    return \"&#x\" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))\n        .toString(16)\n        .toUpperCase() + \";\";\n}\nfunction getInverse(inverse, re) {\n    return function (data) {\n        return data\n            .replace(re, function (name) { return inverse[name]; })\n            .replace(reNonASCII, singleCharReplacer);\n    };\n}\nvar reEscapeChars = new RegExp(xmlReplacer.source + \"|\" + reNonASCII.source, \"g\");\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nfunction escape(data) {\n    return data.replace(reEscapeChars, singleCharReplacer);\n}\nexports.escape = escape;\n/**\n * Encodes all characters not valid in XML documents using numeric hexadecimal\n * reference (eg. `&#xfc;`).\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nfunction escapeUTF8(data) {\n    return data.replace(xmlReplacer, singleCharReplacer);\n}\nexports.escapeUTF8 = escapeUTF8;\nfunction getASCIIEncoder(obj) {\n    return function (data) {\n        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });\n    };\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;\nvar decode_1 = require(\"./decode\");\nvar encode_1 = require(\"./encode\");\n/**\n * Decodes a string with entities.\n *\n * @param data String to decode.\n * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `decodeXML` or `decodeHTML` directly.\n */\nfunction decode(data, level) {\n    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);\n}\nexports.decode = decode;\n/**\n * Decodes a string with entities. Does not allow missing trailing semicolons for entities.\n *\n * @param data String to decode.\n * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.\n */\nfunction decodeStrict(data, level) {\n    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);\n}\nexports.decodeStrict = decodeStrict;\n/**\n * Encodes a string with entities.\n *\n * @param data String to encode.\n * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.\n */\nfunction encode(data, level) {\n    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);\n}\nexports.encode = encode;\nvar encode_2 = require(\"./encode\");\nObject.defineProperty(exports, \"encodeXML\", { enumerable: true, get: function () { return encode_2.encodeXML; } });\nObject.defineProperty(exports, \"encodeHTML\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\nObject.defineProperty(exports, \"encodeNonAsciiHTML\", { enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } });\nObject.defineProperty(exports, \"escape\", { enumerable: true, get: function () { return encode_2.escape; } });\nObject.defineProperty(exports, \"escapeUTF8\", { enumerable: true, get: function () { return encode_2.escapeUTF8; } });\n// Legacy aliases (deprecated)\nObject.defineProperty(exports, \"encodeHTML4\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\nObject.defineProperty(exports, \"encodeHTML5\", { enumerable: true, get: function () { return encode_2.encodeHTML; } });\nvar decode_2 = require(\"./decode\");\nObject.defineProperty(exports, \"decodeXML\", { enumerable: true, get: function () { return decode_2.decodeXML; } });\nObject.defineProperty(exports, \"decodeHTML\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\nObject.defineProperty(exports, \"decodeHTMLStrict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\n// Legacy aliases (deprecated)\nObject.defineProperty(exports, \"decodeHTML4\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\nObject.defineProperty(exports, \"decodeHTML5\", { enumerable: true, get: function () { return decode_2.decodeHTML; } });\nObject.defineProperty(exports, \"decodeHTML4Strict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\nObject.defineProperty(exports, \"decodeHTML5Strict\", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });\nObject.defineProperty(exports, \"decodeXMLStrict\", { enumerable: true, get: function () { return decode_2.decodeXML; } });\n","'use strict';\n\nmodule.exports = string => {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when its always valid, and a \\unnnn escape when the simpler form would be disallowed by Unicode patterns stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n};\n","'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\nmodule.exports = function isBuffer (obj) {\n  return obj != null && obj.constructor != null &&\n    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n","'use strict';\n\nmodule.exports = value => {\n\tif (Object.prototype.toString.call(value) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn prototype === null || prototype === Object.prototype;\n};\n","'use strict'\n\nvar repeat = require('repeat-string')\n\nmodule.exports = markdownTable\n\nvar trailingWhitespace = / +$/\n\n// Characters.\nvar space = ' '\nvar lineFeed = '\\n'\nvar dash = '-'\nvar colon = ':'\nvar verticalBar = '|'\n\nvar x = 0\nvar C = 67\nvar L = 76\nvar R = 82\nvar c = 99\nvar l = 108\nvar r = 114\n\n// Create a table from a matrix of strings.\nfunction markdownTable(table, options) {\n  var settings = options || {}\n  var padding = settings.padding !== false\n  var start = settings.delimiterStart !== false\n  var end = settings.delimiterEnd !== false\n  var align = (settings.align || []).concat()\n  var alignDelimiters = settings.alignDelimiters !== false\n  var alignments = []\n  var stringLength = settings.stringLength || defaultStringLength\n  var rowIndex = -1\n  var rowLength = table.length\n  var cellMatrix = []\n  var sizeMatrix = []\n  var row = []\n  var sizes = []\n  var longestCellByColumn = []\n  var mostCellsPerRow = 0\n  var cells\n  var columnIndex\n  var columnLength\n  var largest\n  var size\n  var cell\n  var lines\n  var line\n  var before\n  var after\n  var code\n\n  // This is a superfluous loop if we dont align delimiters, but otherwise wed\n  // do superfluous work when aligning, so optimize for aligning.\n  while (++rowIndex < rowLength) {\n    cells = table[rowIndex]\n    columnIndex = -1\n    columnLength = cells.length\n    row = []\n    sizes = []\n\n    if (columnLength > mostCellsPerRow) {\n      mostCellsPerRow = columnLength\n    }\n\n    while (++columnIndex < columnLength) {\n      cell = serialize(cells[columnIndex])\n\n      if (alignDelimiters === true) {\n        size = stringLength(cell)\n        sizes[columnIndex] = size\n\n        largest = longestCellByColumn[columnIndex]\n\n        if (largest === undefined || size > largest) {\n          longestCellByColumn[columnIndex] = size\n        }\n      }\n\n      row.push(cell)\n    }\n\n    cellMatrix[rowIndex] = row\n    sizeMatrix[rowIndex] = sizes\n  }\n\n  // Figure out which alignments to use.\n  columnIndex = -1\n  columnLength = mostCellsPerRow\n\n  if (typeof align === 'object' && 'length' in align) {\n    while (++columnIndex < columnLength) {\n      alignments[columnIndex] = toAlignment(align[columnIndex])\n    }\n  } else {\n    code = toAlignment(align)\n\n    while (++columnIndex < columnLength) {\n      alignments[columnIndex] = code\n    }\n  }\n\n  // Inject the alignment row.\n  columnIndex = -1\n  columnLength = mostCellsPerRow\n  row = []\n  sizes = []\n\n  while (++columnIndex < columnLength) {\n    code = alignments[columnIndex]\n    before = ''\n    after = ''\n\n    if (code === l) {\n      before = colon\n    } else if (code === r) {\n      after = colon\n    } else if (code === c) {\n      before = colon\n      after = colon\n    }\n\n    // There *must* be at least one hyphen-minus in each alignment cell.\n    size = alignDelimiters\n      ? Math.max(\n          1,\n          longestCellByColumn[columnIndex] - before.length - after.length\n        )\n      : 1\n\n    cell = before + repeat(dash, size) + after\n\n    if (alignDelimiters === true) {\n      size = before.length + size + after.length\n\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size\n      }\n\n      sizes[columnIndex] = size\n    }\n\n    row[columnIndex] = cell\n  }\n\n  // Inject the alignment row.\n  cellMatrix.splice(1, 0, row)\n  sizeMatrix.splice(1, 0, sizes)\n\n  rowIndex = -1\n  rowLength = cellMatrix.length\n  lines = []\n\n  while (++rowIndex < rowLength) {\n    row = cellMatrix[rowIndex]\n    sizes = sizeMatrix[rowIndex]\n    columnIndex = -1\n    columnLength = mostCellsPerRow\n    line = []\n\n    while (++columnIndex < columnLength) {\n      cell = row[columnIndex] || ''\n      before = ''\n      after = ''\n\n      if (alignDelimiters === true) {\n        size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0)\n        code = alignments[columnIndex]\n\n        if (code === r) {\n          before = repeat(space, size)\n        } else if (code === c) {\n          if (size % 2 === 0) {\n            before = repeat(space, size / 2)\n            after = before\n          } else {\n            before = repeat(space, size / 2 + 0.5)\n            after = repeat(space, size / 2 - 0.5)\n          }\n        } else {\n          after = repeat(space, size)\n        }\n      }\n\n      if (start === true && columnIndex === 0) {\n        line.push(verticalBar)\n      }\n\n      if (\n        padding === true &&\n        // Dont add the opening space if were not aligning and the cell is\n        // empty: there will be a closing space.\n        !(alignDelimiters === false && cell === '') &&\n        (start === true || columnIndex !== 0)\n      ) {\n        line.push(space)\n      }\n\n      if (alignDelimiters === true) {\n        line.push(before)\n      }\n\n      line.push(cell)\n\n      if (alignDelimiters === true) {\n        line.push(after)\n      }\n\n      if (padding === true) {\n        line.push(space)\n      }\n\n      if (end === true || columnIndex !== columnLength - 1) {\n        line.push(verticalBar)\n      }\n    }\n\n    line = line.join('')\n\n    if (end === false) {\n      line = line.replace(trailingWhitespace, '')\n    }\n\n    lines.push(line)\n  }\n\n  return lines.join(lineFeed)\n}\n\nfunction serialize(value) {\n  return value === null || value === undefined ? '' : String(value)\n}\n\nfunction defaultStringLength(value) {\n  return value.length\n}\n\nfunction toAlignment(value) {\n  var code = typeof value === 'string' ? value.charCodeAt(0) : x\n\n  return code === L || code === l\n    ? l\n    : code === R || code === r\n    ? r\n    : code === C || code === c\n    ? c\n    : x\n}\n","'use strict'\n\nmodule.exports = findAndReplace\n\nvar visit = require('unist-util-visit-parents')\nvar convert = require('unist-util-is/convert')\nvar escape = require('escape-string-regexp')\n\nvar splice = [].splice\n\nfunction findAndReplace(tree, find, replace, options) {\n  var settings\n  var schema\n\n  if (typeof find === 'string' || (find && typeof find.exec === 'function')) {\n    schema = [[find, replace]]\n  } else {\n    schema = find\n    options = replace\n  }\n\n  settings = options || {}\n\n  search(tree, settings, handlerFactory(toPairs(schema)))\n\n  return tree\n\n  function handlerFactory(pairs) {\n    var pair = pairs[0]\n\n    return handler\n\n    function handler(node, parent) {\n      var find = pair[0]\n      var replace = pair[1]\n      var nodes = []\n      var start = 0\n      var index = parent.children.indexOf(node)\n      var position\n      var match\n      var subhandler\n      var value\n\n      find.lastIndex = 0\n\n      match = find.exec(node.value)\n\n      while (match) {\n        position = match.index\n        value = replace.apply(\n          null,\n          [].concat(match, {index: match.index, input: match.input})\n        )\n\n        if (value !== false) {\n          if (start !== position) {\n            nodes.push({type: 'text', value: node.value.slice(start, position)})\n          }\n\n          if (typeof value === 'string' && value.length > 0) {\n            value = {type: 'text', value: value}\n          }\n\n          if (value) {\n            nodes = [].concat(nodes, value)\n          }\n\n          start = position + match[0].length\n        }\n\n        if (!find.global) {\n          break\n        }\n\n        match = find.exec(node.value)\n      }\n\n      if (position === undefined) {\n        nodes = [node]\n        index--\n      } else {\n        if (start < node.value.length) {\n          nodes.push({type: 'text', value: node.value.slice(start)})\n        }\n\n        nodes.unshift(index, 1)\n        splice.apply(parent.children, nodes)\n      }\n\n      if (pairs.length > 1) {\n        subhandler = handlerFactory(pairs.slice(1))\n        position = -1\n\n        while (++position < nodes.length) {\n          node = nodes[position]\n\n          if (node.type === 'text') {\n            subhandler(node, parent)\n          } else {\n            search(node, settings, subhandler)\n          }\n        }\n      }\n\n      return index + nodes.length + 1\n    }\n  }\n}\n\nfunction search(tree, settings, handler) {\n  var ignored = convert(settings.ignore || [])\n  var result = []\n\n  visit(tree, 'text', visitor)\n\n  return result\n\n  function visitor(node, parents) {\n    var index = -1\n    var parent\n    var grandparent\n\n    while (++index < parents.length) {\n      parent = parents[index]\n\n      if (\n        ignored(\n          parent,\n          grandparent ? grandparent.children.indexOf(parent) : undefined,\n          grandparent\n        )\n      ) {\n        return\n      }\n\n      grandparent = parent\n    }\n\n    return handler(node, grandparent)\n  }\n}\n\nfunction toPairs(schema) {\n  var result = []\n  var key\n  var index\n\n  if (typeof schema !== 'object') {\n    throw new Error('Expected array or object as schema')\n  }\n\n  if ('length' in schema) {\n    index = -1\n\n    while (++index < schema.length) {\n      result.push([\n        toExpression(schema[index][0]),\n        toFunction(schema[index][1])\n      ])\n    }\n  } else {\n    for (key in schema) {\n      result.push([toExpression(key), toFunction(schema[key])])\n    }\n  }\n\n  return result\n}\n\nfunction toExpression(find) {\n  return typeof find === 'string' ? new RegExp(escape(find), 'g') : find\n}\n\nfunction toFunction(replace) {\n  return typeof replace === 'function' ? replace : returner\n\n  function returner() {\n    return replace\n  }\n}\n","'use strict'\n\nmodule.exports = fromMarkdown\n\n// These three are compiled away in the `dist/`\n\nvar toString = require('mdast-util-to-string')\nvar assign = require('micromark/dist/constant/assign')\nvar own = require('micromark/dist/constant/has-own-property')\nvar normalizeIdentifier = require('micromark/dist/util/normalize-identifier')\nvar safeFromInt = require('micromark/dist/util/safe-from-int')\nvar parser = require('micromark/dist/parse')\nvar preprocessor = require('micromark/dist/preprocess')\nvar postprocess = require('micromark/dist/postprocess')\nvar decode = require('parse-entities/decode-entity')\nvar stringifyPosition = require('unist-util-stringify-position')\n\nfunction fromMarkdown(value, encoding, options) {\n  if (typeof encoding !== 'string') {\n    options = encoding\n    encoding = undefined\n  }\n\n  return compiler(options)(\n    postprocess(\n      parser(options).document().write(preprocessor()(value, encoding, true))\n    )\n  )\n}\n\n// Note this compiler only understand complete buffering, not streaming.\nfunction compiler(options) {\n  var settings = options || {}\n  var config = configure(\n    {\n      transforms: [],\n      canContainEols: [\n        'emphasis',\n        'fragment',\n        'heading',\n        'paragraph',\n        'strong'\n      ],\n\n      enter: {\n        autolink: opener(link),\n        autolinkProtocol: onenterdata,\n        autolinkEmail: onenterdata,\n        atxHeading: opener(heading),\n        blockQuote: opener(blockQuote),\n        characterEscape: onenterdata,\n        characterReference: onenterdata,\n        codeFenced: opener(codeFlow),\n        codeFencedFenceInfo: buffer,\n        codeFencedFenceMeta: buffer,\n        codeIndented: opener(codeFlow, buffer),\n        codeText: opener(codeText, buffer),\n        codeTextData: onenterdata,\n        data: onenterdata,\n        codeFlowValue: onenterdata,\n        definition: opener(definition),\n        definitionDestinationString: buffer,\n        definitionLabelString: buffer,\n        definitionTitleString: buffer,\n        emphasis: opener(emphasis),\n        hardBreakEscape: opener(hardBreak),\n        hardBreakTrailing: opener(hardBreak),\n        htmlFlow: opener(html, buffer),\n        htmlFlowData: onenterdata,\n        htmlText: opener(html, buffer),\n        htmlTextData: onenterdata,\n        image: opener(image),\n        label: buffer,\n        link: opener(link),\n        listItem: opener(listItem),\n        listItemValue: onenterlistitemvalue,\n        listOrdered: opener(list, onenterlistordered),\n        listUnordered: opener(list),\n        paragraph: opener(paragraph),\n        reference: onenterreference,\n        referenceString: buffer,\n        resourceDestinationString: buffer,\n        resourceTitleString: buffer,\n        setextHeading: opener(heading),\n        strong: opener(strong),\n        thematicBreak: opener(thematicBreak)\n      },\n\n      exit: {\n        atxHeading: closer(),\n        atxHeadingSequence: onexitatxheadingsequence,\n        autolink: closer(),\n        autolinkEmail: onexitautolinkemail,\n        autolinkProtocol: onexitautolinkprotocol,\n        blockQuote: closer(),\n        characterEscapeValue: onexitdata,\n        characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,\n        characterReferenceMarkerNumeric: onexitcharacterreferencemarker,\n        characterReferenceValue: onexitcharacterreferencevalue,\n        codeFenced: closer(onexitcodefenced),\n        codeFencedFence: onexitcodefencedfence,\n        codeFencedFenceInfo: onexitcodefencedfenceinfo,\n        codeFencedFenceMeta: onexitcodefencedfencemeta,\n        codeFlowValue: onexitdata,\n        codeIndented: closer(onexitcodeindented),\n        codeText: closer(onexitcodetext),\n        codeTextData: onexitdata,\n        data: onexitdata,\n        definition: closer(),\n        definitionDestinationString: onexitdefinitiondestinationstring,\n        definitionLabelString: onexitdefinitionlabelstring,\n        definitionTitleString: onexitdefinitiontitlestring,\n        emphasis: closer(),\n        hardBreakEscape: closer(onexithardbreak),\n        hardBreakTrailing: closer(onexithardbreak),\n        htmlFlow: closer(onexithtmlflow),\n        htmlFlowData: onexitdata,\n        htmlText: closer(onexithtmltext),\n        htmlTextData: onexitdata,\n        image: closer(onexitimage),\n        label: onexitlabel,\n        labelText: onexitlabeltext,\n        lineEnding: onexitlineending,\n        link: closer(onexitlink),\n        listItem: closer(),\n        listOrdered: closer(),\n        listUnordered: closer(),\n        paragraph: closer(),\n        referenceString: onexitreferencestring,\n        resourceDestinationString: onexitresourcedestinationstring,\n        resourceTitleString: onexitresourcetitlestring,\n        resource: onexitresource,\n        setextHeading: closer(onexitsetextheading),\n        setextHeadingLineSequence: onexitsetextheadinglinesequence,\n        setextHeadingText: onexitsetextheadingtext,\n        strong: closer(),\n        thematicBreak: closer()\n      }\n    },\n\n    settings.mdastExtensions || []\n  )\n\n  var data = {}\n\n  return compile\n\n  function compile(events) {\n    var tree = {type: 'root', children: []}\n    var stack = [tree]\n    var tokenStack = []\n    var listStack = []\n    var index = -1\n    var handler\n    var listStart\n\n    var context = {\n      stack: stack,\n      tokenStack: tokenStack,\n      config: config,\n      enter: enter,\n      exit: exit,\n      buffer: buffer,\n      resume: resume,\n      setData: setData,\n      getData: getData\n    }\n\n    while (++index < events.length) {\n      // We preprocess lists to add `listItem` tokens, and to infer whether\n      // items the list itself are spread out.\n      if (\n        events[index][1].type === 'listOrdered' ||\n        events[index][1].type === 'listUnordered'\n      ) {\n        if (events[index][0] === 'enter') {\n          listStack.push(index)\n        } else {\n          listStart = listStack.pop(index)\n          index = prepareList(events, listStart, index)\n        }\n      }\n    }\n\n    index = -1\n\n    while (++index < events.length) {\n      handler = config[events[index][0]]\n\n      if (own.call(handler, events[index][1].type)) {\n        handler[events[index][1].type].call(\n          assign({sliceSerialize: events[index][2].sliceSerialize}, context),\n          events[index][1]\n        )\n      }\n    }\n\n    if (tokenStack.length) {\n      throw new Error(\n        'Cannot close document, a token (`' +\n          tokenStack[tokenStack.length - 1].type +\n          '`, ' +\n          stringifyPosition({\n            start: tokenStack[tokenStack.length - 1].start,\n            end: tokenStack[tokenStack.length - 1].end\n          }) +\n          ') is still open'\n      )\n    }\n\n    // Figure out `root` position.\n    tree.position = {\n      start: point(\n        events.length ? events[0][1].start : {line: 1, column: 1, offset: 0}\n      ),\n\n      end: point(\n        events.length\n          ? events[events.length - 2][1].end\n          : {line: 1, column: 1, offset: 0}\n      )\n    }\n\n    index = -1\n    while (++index < config.transforms.length) {\n      tree = config.transforms[index](tree) || tree\n    }\n\n    return tree\n  }\n\n  function prepareList(events, start, length) {\n    var index = start - 1\n    var containerBalance = -1\n    var listSpread = false\n    var listItem\n    var tailIndex\n    var lineIndex\n    var tailEvent\n    var event\n    var firstBlankLineIndex\n    var atMarker\n\n    while (++index <= length) {\n      event = events[index]\n\n      if (\n        event[1].type === 'listUnordered' ||\n        event[1].type === 'listOrdered' ||\n        event[1].type === 'blockQuote'\n      ) {\n        if (event[0] === 'enter') {\n          containerBalance++\n        } else {\n          containerBalance--\n        }\n\n        atMarker = undefined\n      } else if (event[1].type === 'lineEndingBlank') {\n        if (event[0] === 'enter') {\n          if (\n            listItem &&\n            !atMarker &&\n            !containerBalance &&\n            !firstBlankLineIndex\n          ) {\n            firstBlankLineIndex = index\n          }\n\n          atMarker = undefined\n        }\n      } else if (\n        event[1].type === 'linePrefix' ||\n        event[1].type === 'listItemValue' ||\n        event[1].type === 'listItemMarker' ||\n        event[1].type === 'listItemPrefix' ||\n        event[1].type === 'listItemPrefixWhitespace'\n      ) {\n        // Empty.\n      } else {\n        atMarker = undefined\n      }\n\n      if (\n        (!containerBalance &&\n          event[0] === 'enter' &&\n          event[1].type === 'listItemPrefix') ||\n        (containerBalance === -1 &&\n          event[0] === 'exit' &&\n          (event[1].type === 'listUnordered' ||\n            event[1].type === 'listOrdered'))\n      ) {\n        if (listItem) {\n          tailIndex = index\n          lineIndex = undefined\n\n          while (tailIndex--) {\n            tailEvent = events[tailIndex]\n\n            if (\n              tailEvent[1].type === 'lineEnding' ||\n              tailEvent[1].type === 'lineEndingBlank'\n            ) {\n              if (tailEvent[0] === 'exit') continue\n\n              if (lineIndex) {\n                events[lineIndex][1].type = 'lineEndingBlank'\n                listSpread = true\n              }\n\n              tailEvent[1].type = 'lineEnding'\n              lineIndex = tailIndex\n            } else if (\n              tailEvent[1].type === 'linePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefix' ||\n              tailEvent[1].type === 'blockQuotePrefixWhitespace' ||\n              tailEvent[1].type === 'blockQuoteMarker' ||\n              tailEvent[1].type === 'listItemIndent'\n            ) {\n              // Empty\n            } else {\n              break\n            }\n          }\n\n          if (\n            firstBlankLineIndex &&\n            (!lineIndex || firstBlankLineIndex < lineIndex)\n          ) {\n            listItem._spread = true\n          }\n\n          // Fix position.\n          listItem.end = point(\n            lineIndex ? events[lineIndex][1].start : event[1].end\n          )\n\n          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]])\n          index++\n          length++\n        }\n\n        // Create a new list item.\n        if (event[1].type === 'listItemPrefix') {\n          listItem = {\n            type: 'listItem',\n            _spread: false,\n            start: point(event[1].start)\n          }\n\n          events.splice(index, 0, ['enter', listItem, event[2]])\n          index++\n          length++\n          firstBlankLineIndex = undefined\n          atMarker = true\n        }\n      }\n    }\n\n    events[start][1]._spread = listSpread\n    return length\n  }\n\n  function setData(key, value) {\n    data[key] = value\n  }\n\n  function getData(key) {\n    return data[key]\n  }\n\n  function point(d) {\n    return {line: d.line, column: d.column, offset: d.offset}\n  }\n\n  function opener(create, and) {\n    return open\n\n    function open(token) {\n      enter.call(this, create(token), token)\n      if (and) and.call(this, token)\n    }\n  }\n\n  function buffer() {\n    this.stack.push({type: 'fragment', children: []})\n  }\n\n  function enter(node, token) {\n    this.stack[this.stack.length - 1].children.push(node)\n    this.stack.push(node)\n    this.tokenStack.push(token)\n    node.position = {start: point(token.start)}\n    return node\n  }\n\n  function closer(and) {\n    return close\n\n    function close(token) {\n      if (and) and.call(this, token)\n      exit.call(this, token)\n    }\n  }\n\n  function exit(token) {\n    var node = this.stack.pop()\n    var open = this.tokenStack.pop()\n\n    if (!open) {\n      throw new Error(\n        'Cannot close `' +\n          token.type +\n          '` (' +\n          stringifyPosition({start: token.start, end: token.end}) +\n          '): its not open'\n      )\n    } else if (open.type !== token.type) {\n      throw new Error(\n        'Cannot close `' +\n          token.type +\n          '` (' +\n          stringifyPosition({start: token.start, end: token.end}) +\n          '): a different token (`' +\n          open.type +\n          '`, ' +\n          stringifyPosition({start: open.start, end: open.end}) +\n          ') is open'\n      )\n    }\n\n    node.position.end = point(token.end)\n    return node\n  }\n\n  function resume() {\n    return toString(this.stack.pop())\n  }\n\n  //\n  // Handlers.\n  //\n\n  function onenterlistordered() {\n    setData('expectingFirstListItemValue', true)\n  }\n\n  function onenterlistitemvalue(token) {\n    if (getData('expectingFirstListItemValue')) {\n      this.stack[this.stack.length - 2].start = parseInt(\n        this.sliceSerialize(token),\n        10\n      )\n\n      setData('expectingFirstListItemValue')\n    }\n  }\n\n  function onexitcodefencedfenceinfo() {\n    var data = this.resume()\n    this.stack[this.stack.length - 1].lang = data\n  }\n\n  function onexitcodefencedfencemeta() {\n    var data = this.resume()\n    this.stack[this.stack.length - 1].meta = data\n  }\n\n  function onexitcodefencedfence() {\n    // Exit if this is the closing fence.\n    if (getData('flowCodeInside')) return\n    this.buffer()\n    setData('flowCodeInside', true)\n  }\n\n  function onexitcodefenced() {\n    var data = this.resume()\n    this.stack[this.stack.length - 1].value = data.replace(\n      /^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g,\n      ''\n    )\n\n    setData('flowCodeInside')\n  }\n\n  function onexitcodeindented() {\n    var data = this.resume()\n    this.stack[this.stack.length - 1].value = data\n  }\n\n  function onexitdefinitionlabelstring(token) {\n    // Discard label, use the source content instead.\n    var label = this.resume()\n    this.stack[this.stack.length - 1].label = label\n    this.stack[this.stack.length - 1].identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n\n  function onexitdefinitiontitlestring() {\n    var data = this.resume()\n    this.stack[this.stack.length - 1].title = data\n  }\n\n  function onexitdefinitiondestinationstring() {\n    var data = this.resume()\n    this.stack[this.stack.length - 1].url = data\n  }\n\n  function onexitatxheadingsequence(token) {\n    if (!this.stack[this.stack.length - 1].depth) {\n      this.stack[this.stack.length - 1].depth = this.sliceSerialize(\n        token\n      ).length\n    }\n  }\n\n  function onexitsetextheadingtext() {\n    setData('setextHeadingSlurpLineEnding', true)\n  }\n\n  function onexitsetextheadinglinesequence(token) {\n    this.stack[this.stack.length - 1].depth =\n      this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2\n  }\n\n  function onexitsetextheading() {\n    setData('setextHeadingSlurpLineEnding')\n  }\n\n  function onenterdata(token) {\n    var siblings = this.stack[this.stack.length - 1].children\n    var tail = siblings[siblings.length - 1]\n\n    if (!tail || tail.type !== 'text') {\n      // Add a new text node.\n      tail = text()\n      tail.position = {start: point(token.start)}\n      this.stack[this.stack.length - 1].children.push(tail)\n    }\n\n    this.stack.push(tail)\n  }\n\n  function onexitdata(token) {\n    var tail = this.stack.pop()\n    tail.value += this.sliceSerialize(token)\n    tail.position.end = point(token.end)\n  }\n\n  function onexitlineending(token) {\n    var context = this.stack[this.stack.length - 1]\n\n    // If were at a hard break, include the line ending in there.\n    if (getData('atHardBreak')) {\n      context.children[context.children.length - 1].position.end = point(\n        token.end\n      )\n\n      setData('atHardBreak')\n      return\n    }\n\n    if (\n      !getData('setextHeadingSlurpLineEnding') &&\n      config.canContainEols.indexOf(context.type) > -1\n    ) {\n      onenterdata.call(this, token)\n      onexitdata.call(this, token)\n    }\n  }\n\n  function onexithardbreak() {\n    setData('atHardBreak', true)\n  }\n\n  function onexithtmlflow() {\n    var data = this.resume()\n    this.stack[this.stack.length - 1].value = data\n  }\n\n  function onexithtmltext() {\n    var data = this.resume()\n    this.stack[this.stack.length - 1].value = data\n  }\n\n  function onexitcodetext() {\n    var data = this.resume()\n    this.stack[this.stack.length - 1].value = data\n  }\n\n  function onexitlink() {\n    var context = this.stack[this.stack.length - 1]\n\n    // To do: clean.\n    if (getData('inReference')) {\n      context.type += 'Reference'\n      context.referenceType = getData('referenceType') || 'shortcut'\n      delete context.url\n      delete context.title\n    } else {\n      delete context.identifier\n      delete context.label\n      delete context.referenceType\n    }\n\n    setData('referenceType')\n  }\n\n  function onexitimage() {\n    var context = this.stack[this.stack.length - 1]\n\n    // To do: clean.\n    if (getData('inReference')) {\n      context.type += 'Reference'\n      context.referenceType = getData('referenceType') || 'shortcut'\n      delete context.url\n      delete context.title\n    } else {\n      delete context.identifier\n      delete context.label\n      delete context.referenceType\n    }\n\n    setData('referenceType')\n  }\n\n  function onexitlabeltext(token) {\n    this.stack[this.stack.length - 2].identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n  }\n\n  function onexitlabel() {\n    var fragment = this.stack[this.stack.length - 1]\n    var value = this.resume()\n\n    this.stack[this.stack.length - 1].label = value\n\n    // Assume a reference.\n    setData('inReference', true)\n\n    if (this.stack[this.stack.length - 1].type === 'link') {\n      this.stack[this.stack.length - 1].children = fragment.children\n    } else {\n      this.stack[this.stack.length - 1].alt = value\n    }\n  }\n\n  function onexitresourcedestinationstring() {\n    var data = this.resume()\n    this.stack[this.stack.length - 1].url = data\n  }\n\n  function onexitresourcetitlestring() {\n    var data = this.resume()\n    this.stack[this.stack.length - 1].title = data\n  }\n\n  function onexitresource() {\n    setData('inReference')\n  }\n\n  function onenterreference() {\n    setData('referenceType', 'collapsed')\n  }\n\n  function onexitreferencestring(token) {\n    var label = this.resume()\n    this.stack[this.stack.length - 1].label = label\n    this.stack[this.stack.length - 1].identifier = normalizeIdentifier(\n      this.sliceSerialize(token)\n    ).toLowerCase()\n    setData('referenceType', 'full')\n  }\n\n  function onexitcharacterreferencemarker(token) {\n    setData('characterReferenceType', token.type)\n  }\n\n  function onexitcharacterreferencevalue(token) {\n    var data = this.sliceSerialize(token)\n    var type = getData('characterReferenceType')\n    var value\n    var tail\n\n    if (type) {\n      value = safeFromInt(\n        data,\n        type === 'characterReferenceMarkerNumeric' ? 10 : 16\n      )\n\n      setData('characterReferenceType')\n    } else {\n      value = decode(data)\n    }\n\n    tail = this.stack.pop()\n    tail.value += value\n    tail.position.end = point(token.end)\n  }\n\n  function onexitautolinkprotocol(token) {\n    onexitdata.call(this, token)\n    this.stack[this.stack.length - 1].url = this.sliceSerialize(token)\n  }\n\n  function onexitautolinkemail(token) {\n    onexitdata.call(this, token)\n    this.stack[this.stack.length - 1].url =\n      'mailto:' + this.sliceSerialize(token)\n  }\n\n  //\n  // Creaters.\n  //\n\n  function blockQuote() {\n    return {type: 'blockquote', children: []}\n  }\n\n  function codeFlow() {\n    return {type: 'code', lang: null, meta: null, value: ''}\n  }\n\n  function codeText() {\n    return {type: 'inlineCode', value: ''}\n  }\n\n  function definition() {\n    return {\n      type: 'definition',\n      identifier: '',\n      label: null,\n      title: null,\n      url: ''\n    }\n  }\n\n  function emphasis() {\n    return {type: 'emphasis', children: []}\n  }\n\n  function heading() {\n    return {type: 'heading', depth: undefined, children: []}\n  }\n\n  function hardBreak() {\n    return {type: 'break'}\n  }\n\n  function html() {\n    return {type: 'html', value: ''}\n  }\n\n  function image() {\n    return {type: 'image', title: null, url: '', alt: null}\n  }\n\n  function link() {\n    return {type: 'link', title: null, url: '', children: []}\n  }\n\n  function list(token) {\n    return {\n      type: 'list',\n      ordered: token.type === 'listOrdered',\n      start: null,\n      spread: token._spread,\n      children: []\n    }\n  }\n\n  function listItem(token) {\n    return {\n      type: 'listItem',\n      spread: token._spread,\n      checked: null,\n      children: []\n    }\n  }\n\n  function paragraph() {\n    return {type: 'paragraph', children: []}\n  }\n\n  function strong() {\n    return {type: 'strong', children: []}\n  }\n\n  function text() {\n    return {type: 'text', value: ''}\n  }\n\n  function thematicBreak() {\n    return {type: 'thematicBreak'}\n  }\n}\n\nfunction configure(config, extensions) {\n  var index = -1\n\n  while (++index < extensions.length) {\n    extension(config, extensions[index])\n  }\n\n  return config\n}\n\nfunction extension(config, extension) {\n  var key\n  var left\n\n  for (key in extension) {\n    left = own.call(config, key) ? config[key] : (config[key] = {})\n\n    if (key === 'canContainEols' || key === 'transforms') {\n      config[key] = [].concat(left, extension[key])\n    } else {\n      Object.assign(left, extension[key])\n    }\n  }\n}\n","'use strict'\n\nmodule.exports = require('./dist')\n","var ccount = require('ccount')\nvar findAndReplace = require('mdast-util-find-and-replace')\nvar unicodePunctuation = require('micromark/dist/character/unicode-punctuation')\nvar unicodeWhitespace = require('micromark/dist/character/unicode-whitespace')\n\nexports.transforms = [transformGfmAutolinkLiterals]\nexports.enter = {\n  literalAutolink: enterLiteralAutolink,\n  literalAutolinkEmail: enterLiteralAutolinkValue,\n  literalAutolinkHttp: enterLiteralAutolinkValue,\n  literalAutolinkWww: enterLiteralAutolinkValue\n}\nexports.exit = {\n  literalAutolink: exitLiteralAutolink,\n  literalAutolinkEmail: exitLiteralAutolinkEmail,\n  literalAutolinkHttp: exitLiteralAutolinkHttp,\n  literalAutolinkWww: exitLiteralAutolinkWww\n}\n\nfunction enterLiteralAutolink(token) {\n  this.enter({type: 'link', title: null, url: '', children: []}, token)\n}\n\nfunction enterLiteralAutolinkValue(token) {\n  this.config.enter.autolinkProtocol.call(this, token)\n}\n\nfunction exitLiteralAutolinkHttp(token) {\n  this.config.exit.autolinkProtocol.call(this, token)\n}\n\nfunction exitLiteralAutolinkWww(token) {\n  this.config.exit.data.call(this, token)\n  this.stack[this.stack.length - 1].url = 'http://' + this.sliceSerialize(token)\n}\n\nfunction exitLiteralAutolinkEmail(token) {\n  this.config.exit.autolinkEmail.call(this, token)\n}\n\nfunction exitLiteralAutolink(token) {\n  this.exit(token)\n}\n\nfunction transformGfmAutolinkLiterals(tree) {\n  findAndReplace(\n    tree,\n    [\n      [/(https?:\\/\\/|www(?=\\.))([-.\\w]+)([^ \\t\\r\\n]*)/i, findUrl],\n      [/([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)/, findEmail]\n    ],\n    {ignore: ['link', 'linkReference']}\n  )\n}\n\nfunction findUrl($0, protocol, domain, path, match) {\n  var prefix = ''\n  var parts\n  var result\n\n  // Not an expected previous character.\n  if (!previous(match)) {\n    return false\n  }\n\n  // Treat `www` as part of the domain.\n  if (/^w/i.test(protocol)) {\n    domain = protocol + domain\n    protocol = ''\n    prefix = 'http://'\n  }\n\n  if (!isCorrectDomain(domain)) {\n    return false\n  }\n\n  parts = splitUrl(domain + path)\n\n  if (!parts[0]) return false\n\n  result = {\n    type: 'link',\n    title: null,\n    url: prefix + protocol + parts[0],\n    children: [{type: 'text', value: protocol + parts[0]}]\n  }\n\n  if (parts[1]) {\n    result = [result, {type: 'text', value: parts[1]}]\n  }\n\n  return result\n}\n\nfunction findEmail($0, atext, label, match) {\n  // Not an expected previous character.\n  if (!previous(match, true) || /[_-]$/.test(label)) {\n    return false\n  }\n\n  return {\n    type: 'link',\n    title: null,\n    url: 'mailto:' + atext + '@' + label,\n    children: [{type: 'text', value: atext + '@' + label}]\n  }\n}\n\nfunction isCorrectDomain(domain) {\n  var parts = domain.split('.')\n\n  if (\n    parts.length < 2 ||\n    (parts[parts.length - 1] &&\n      (/_/.test(parts[parts.length - 1]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 1]))) ||\n    (parts[parts.length - 2] &&\n      (/_/.test(parts[parts.length - 2]) ||\n        !/[a-zA-Z\\d]/.test(parts[parts.length - 2])))\n  ) {\n    return false\n  }\n\n  return true\n}\n\nfunction splitUrl(url) {\n  var trail = /[!\"&'),.:;<>?\\]}]+$/.exec(url)\n  var closingParenIndex\n  var openingParens\n  var closingParens\n\n  if (trail) {\n    url = url.slice(0, trail.index)\n    trail = trail[0]\n    closingParenIndex = trail.indexOf(')')\n    openingParens = ccount(url, '(')\n    closingParens = ccount(url, ')')\n\n    while (closingParenIndex !== -1 && openingParens > closingParens) {\n      url += trail.slice(0, closingParenIndex + 1)\n      trail = trail.slice(closingParenIndex + 1)\n      closingParenIndex = trail.indexOf(')')\n      closingParens++\n    }\n  }\n\n  return [url, trail]\n}\n\nfunction previous(match, email) {\n  var code = match.input.charCodeAt(match.index - 1)\n  return (\n    (code !== code || unicodeWhitespace(code) || unicodePunctuation(code)) &&\n    (!email || code !== 47)\n  )\n}\n","var inConstruct = 'phrasing'\nvar notInConstruct = ['autolink', 'link', 'image', 'label']\n\nexports.unsafe = [\n  {\n    character: '@',\n    before: '[+\\\\-.\\\\w]',\n    after: '[\\\\-.\\\\w]',\n    inConstruct: inConstruct,\n    notInConstruct: notInConstruct\n  },\n  {\n    character: '.',\n    before: '[Ww]',\n    after: '[\\\\-.\\\\w]',\n    inConstruct: inConstruct,\n    notInConstruct: notInConstruct\n  },\n  {\n    character: ':',\n    before: '[ps]',\n    after: '\\\\/',\n    inConstruct: inConstruct,\n    notInConstruct: notInConstruct\n  }\n]\n","exports.canContainEols = ['delete']\nexports.enter = {strikethrough: enterStrikethrough}\nexports.exit = {strikethrough: exitStrikethrough}\n\nfunction enterStrikethrough(token) {\n  this.enter({type: 'delete', children: []}, token)\n}\n\nfunction exitStrikethrough(token) {\n  this.exit(token)\n}\n","var phrasing = require('mdast-util-to-markdown/lib/util/container-phrasing')\n\nexports.unsafe = [{character: '~', inConstruct: 'phrasing'}]\nexports.handlers = {delete: handleDelete}\n\nhandleDelete.peek = peekDelete\n\nfunction handleDelete(node, _, context) {\n  var exit = context.enter('emphasis')\n  var value = phrasing(node, context, {before: '~', after: '~'})\n  exit()\n  return '~~' + value + '~~'\n}\n\nfunction peekDelete() {\n  return '~'\n}\n","exports.enter = {\n  table: enterTable,\n  tableData: enterCell,\n  tableHeader: enterCell,\n  tableRow: enterRow\n}\nexports.exit = {\n  codeText: exitCodeText,\n  table: exitTable,\n  tableData: exit,\n  tableHeader: exit,\n  tableRow: exit\n}\n\nfunction enterTable(token) {\n  this.enter({type: 'table', align: token._align, children: []}, token)\n  this.setData('inTable', true)\n}\n\nfunction exitTable(token) {\n  this.exit(token)\n  this.setData('inTable')\n}\n\nfunction enterRow(token) {\n  this.enter({type: 'tableRow', children: []}, token)\n}\n\nfunction exit(token) {\n  this.exit(token)\n}\n\nfunction enterCell(token) {\n  this.enter({type: 'tableCell', children: []}, token)\n}\n\n// Overwrite the default code text data handler to unescape escaped pipes when\n// they are in tables.\nfunction exitCodeText(token) {\n  var value = this.resume()\n\n  if (this.getData('inTable')) {\n    value = value.replace(/\\\\([\\\\|])/g, replace)\n  }\n\n  this.stack[this.stack.length - 1].value = value\n  this.exit(token)\n}\n\nfunction replace($0, $1) {\n  // Pipes work, backslashes dont (but cant escape pipes).\n  return $1 === '|' ? $1 : $0\n}\n","var phrasing = require('mdast-util-to-markdown/lib/util/container-phrasing')\nvar defaultInlineCode = require('mdast-util-to-markdown/lib/handle/inline-code')\nvar markdownTable = require('markdown-table')\n\nmodule.exports = toMarkdown\n\nfunction toMarkdown(options) {\n  var settings = options || {}\n  var padding = settings.tableCellPadding\n  var alignDelimiters = settings.tablePipeAlign\n  var stringLength = settings.stringLength\n  var around = padding ? ' ' : '|'\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: 'tableCell'},\n      {character: '\\n', inConstruct: 'tableCell'},\n      // A pipe, when followed by a tab or space (padding), or a dash or colon\n      // (unpadded delimiter row), could result in a table.\n      {atBreak: true, character: '|', after: '[\\t :-]'},\n      // A pipe in a cell must be encoded.\n      {character: '|', inConstruct: 'tableCell'},\n      // A colon must be followed by a dash, in which case it could start a\n      // delimiter row.\n      {atBreak: true, character: ':', after: '-'},\n      // A delimiter row can also start with a dash, when followed by more\n      // dashes, a colon, or a pipe.\n      // This is a stricter version than the built in check for lists, thematic\n      // breaks, and setex heading underlines though:\n      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n      {atBreak: true, character: '-', after: '[:|-]'}\n    ],\n    handlers: {\n      table: handleTable,\n      tableRow: handleTableRow,\n      tableCell: handleTableCell,\n      inlineCode: inlineCodeWithTable\n    }\n  }\n\n  function handleTable(node, _, context) {\n    return serializeData(handleTableAsData(node, context), node.align)\n  }\n\n  // This function isnt really used normally, because we handle rows at the\n  // table level.\n  // But, if someone passes in a table row, this ensures we make somewhat sense.\n  function handleTableRow(node, _, context) {\n    var row = handleTableRowAsData(node, context)\n    // `markdown-table` will always add an align row\n    var value = serializeData([row])\n    return value.slice(0, value.indexOf('\\n'))\n  }\n\n  function handleTableCell(node, _, context) {\n    var exit = context.enter('tableCell')\n    var value = phrasing(node, context, {before: around, after: around})\n    exit()\n    return value\n  }\n\n  function serializeData(matrix, align) {\n    return markdownTable(matrix, {\n      align: align,\n      alignDelimiters: alignDelimiters,\n      padding: padding,\n      stringLength: stringLength\n    })\n  }\n\n  function handleTableAsData(node, context) {\n    var children = node.children\n    var index = -1\n    var length = children.length\n    var result = []\n    var subexit = context.enter('table')\n\n    while (++index < length) {\n      result[index] = handleTableRowAsData(children[index], context)\n    }\n\n    subexit()\n\n    return result\n  }\n\n  function handleTableRowAsData(node, context) {\n    var children = node.children\n    var index = -1\n    var length = children.length\n    var result = []\n    var subexit = context.enter('tableRow')\n\n    while (++index < length) {\n      result[index] = handleTableCell(children[index], node, context)\n    }\n\n    subexit()\n\n    return result\n  }\n\n  function inlineCodeWithTable(node, parent, context) {\n    var value = defaultInlineCode(node, parent, context)\n\n    if (context.stack.indexOf('tableCell') !== -1) {\n      value = value.replace(/\\|/g, '\\\\$&')\n    }\n\n    return value\n  }\n}\n","exports.exit = {\n  taskListCheckValueChecked: exitCheck,\n  taskListCheckValueUnchecked: exitCheck,\n  paragraph: exitParagraphWithTaskListItem\n}\n\nfunction exitCheck(token) {\n  // Were always in a paragraph, in a list item.\n  this.stack[this.stack.length - 2].checked =\n    token.type === 'taskListCheckValueChecked'\n}\n\nfunction exitParagraphWithTaskListItem(token) {\n  var parent = this.stack[this.stack.length - 2]\n  var node = this.stack[this.stack.length - 1]\n  var siblings = parent.children\n  var head = node.children[0]\n  var index = -1\n  var firstParaghraph\n\n  if (\n    parent &&\n    parent.type === 'listItem' &&\n    typeof parent.checked === 'boolean' &&\n    head &&\n    head.type === 'text'\n  ) {\n    while (++index < siblings.length) {\n      if (siblings[index].type === 'paragraph') {\n        firstParaghraph = siblings[index]\n        break\n      }\n    }\n\n    if (firstParaghraph === node) {\n      // Must start with a space or a tab.\n      head.value = head.value.slice(1)\n\n      if (head.value.length === 0) {\n        node.children.shift()\n      } else {\n        head.position.start.column++\n        head.position.start.offset++\n        node.position.start = Object.assign({}, head.position.start)\n      }\n    }\n  }\n\n  this.exit(token)\n}\n","var defaultListItem = require('mdast-util-to-markdown/lib/handle/list-item')\n\nexports.unsafe = [{atBreak: true, character: '-', after: '[:|-]'}]\n\nexports.handlers = {\n  listItem: listItemWithTaskListItem\n}\n\nfunction listItemWithTaskListItem(node, parent, context) {\n  var value = defaultListItem(node, parent, context)\n  var head = node.children[0]\n\n  if (typeof node.checked === 'boolean' && head && head.type === 'paragraph') {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check)\n  }\n\n  return value\n\n  function check($0) {\n    return $0 + '[' + (node.checked ? 'x' : ' ') + '] '\n  }\n}\n","var autolinkLiteral = require('mdast-util-gfm-autolink-literal/from-markdown')\nvar strikethrough = require('mdast-util-gfm-strikethrough/from-markdown')\nvar table = require('mdast-util-gfm-table/from-markdown')\nvar taskListItem = require('mdast-util-gfm-task-list-item/from-markdown')\n\nvar own = {}.hasOwnProperty\n\nmodule.exports = configure([\n  autolinkLiteral,\n  strikethrough,\n  table,\n  taskListItem\n])\n\nfunction configure(extensions) {\n  var config = {transforms: [], canContainEols: []}\n  var length = extensions.length\n  var index = -1\n\n  while (++index < length) {\n    extension(config, extensions[index])\n  }\n\n  return config\n}\n\nfunction extension(config, extension) {\n  var key\n  var left\n  var right\n\n  for (key in extension) {\n    left = own.call(config, key) ? config[key] : (config[key] = {})\n    right = extension[key]\n\n    if (key === 'canContainEols' || key === 'transforms') {\n      config[key] = [].concat(left, right)\n    } else {\n      Object.assign(left, right)\n    }\n  }\n}\n","var autolinkLiteral = require('mdast-util-gfm-autolink-literal/to-markdown')\nvar strikethrough = require('mdast-util-gfm-strikethrough/to-markdown')\nvar table = require('mdast-util-gfm-table/to-markdown')\nvar taskListItem = require('mdast-util-gfm-task-list-item/to-markdown')\nvar configure = require('mdast-util-to-markdown/lib/configure')\n\nmodule.exports = toMarkdown\n\nfunction toMarkdown(options) {\n  var config = configure(\n    {handlers: {}, join: [], unsafe: [], options: {}},\n    {\n      extensions: [autolinkLiteral, strikethrough, table(options), taskListItem]\n    }\n  )\n\n  return Object.assign(config.options, {\n    handlers: config.handlers,\n    join: config.join,\n    unsafe: config.unsafe\n  })\n}\n","module.exports = configure\n\nfunction configure(base, extension) {\n  var index = -1\n  var key\n\n  // First do subextensions.\n  if (extension.extensions) {\n    while (++index < extension.extensions.length) {\n      configure(base, extension.extensions[index])\n    }\n  }\n\n  for (key in extension) {\n    if (key === 'extensions') {\n      // Empty.\n    } else if (key === 'unsafe' || key === 'join') {\n      base[key] = base[key].concat(extension[key] || [])\n    } else if (key === 'handlers') {\n      base[key] = Object.assign(base[key], extension[key] || {})\n    } else {\n      base.options[key] = extension[key]\n    }\n  }\n\n  return base\n}\n","module.exports = inlineCode\ninlineCode.peek = inlineCodePeek\n\nvar patternCompile = require('../util/pattern-compile')\n\nfunction inlineCode(node, parent, context) {\n  var value = node.value || ''\n  var sequence = '`'\n  var index = -1\n  var pattern\n  var expression\n  var match\n  var position\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs dont count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    (/[ \\r\\n`]/.test(value.charAt(0)) ||\n      /[ \\r\\n`]/.test(value.charAt(value.length - 1)))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We cant escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < context.unsafe.length) {\n    pattern = context.unsafe[index]\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    expression = patternCompile(pattern)\n\n    while ((match = expression.exec(value))) {\n      position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\nfunction inlineCodePeek() {\n  return '`'\n}\n","module.exports = listItem\n\nvar repeat = require('repeat-string')\nvar checkBullet = require('../util/check-bullet')\nvar checkListItemIndent = require('../util/check-list-item-indent')\nvar flow = require('../util/container-flow')\nvar indentLines = require('../util/indent-lines')\n\nfunction listItem(node, parent, context) {\n  var bullet = checkBullet(context)\n  var listItemIndent = checkListItemIndent(context)\n  var size\n  var value\n  var exit\n\n  if (parent && parent.ordered) {\n    bullet =\n      (parent.start > -1 ? parent.start : 1) +\n      (context.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      '.'\n  }\n\n  size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' && ((parent && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  exit = context.enter('listItem')\n  value = indentLines(flow(node, context), map)\n  exit()\n\n  return value\n\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : repeat(' ', size)) + line\n    }\n\n    return (blank ? bullet : bullet + repeat(' ', size - bullet.length)) + line\n  }\n}\n","module.exports = checkBullet\n\nfunction checkBullet(context) {\n  var marker = context.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","module.exports = checkListItemIndent\n\nfunction checkListItemIndent(context) {\n  var style = context.options.listItemIndent || 'tab'\n\n  if (style === 1 || style === '1') {\n    return 'one'\n  }\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","module.exports = flow\n\nvar repeat = require('repeat-string')\n\nfunction flow(parent, context) {\n  var children = parent.children || []\n  var results = []\n  var index = -1\n  var child\n\n  while (++index < children.length) {\n    child = children[index]\n\n    results.push(\n      context.handle(child, parent, context, {before: '\\n', after: '\\n'})\n    )\n\n    if (index + 1 < children.length) {\n      results.push(between(child, children[index + 1]))\n    }\n  }\n\n  return results.join('')\n\n  function between(left, right) {\n    var index = -1\n    var result\n\n    while (++index < context.join.length) {\n      result = context.join[index](left, right, parent, context)\n\n      if (result === true || result === 1) {\n        break\n      }\n\n      if (typeof result === 'number') {\n        return repeat('\\n', 1 + Number(result))\n      }\n\n      if (result === false) {\n        return '\\n\\n<!---->\\n\\n'\n      }\n    }\n\n    return '\\n\\n'\n  }\n}\n","module.exports = phrasing\n\nfunction phrasing(parent, context, safeOptions) {\n  var children = parent.children || []\n  var results = []\n  var index = -1\n  var before = safeOptions.before\n  var after\n  var handle\n  var child\n\n  while (++index < children.length) {\n    child = children[index]\n\n    if (index + 1 < children.length) {\n      handle = context.handle.handlers[children[index + 1].type]\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, context, {\n            before: '',\n            after: ''\n          }).charAt(0)\n        : ''\n    } else {\n      after = safeOptions.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When wed serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we cant escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n    }\n\n    results.push(\n      context.handle(child, parent, context, {\n        before: before,\n        after: after\n      })\n    )\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  return results.join('')\n}\n","module.exports = indentLines\n\nvar eol = /\\r?\\n|\\r/g\n\nfunction indentLines(value, map) {\n  var result = []\n  var start = 0\n  var line = 0\n  var match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n","module.exports = patternCompile\n\nfunction patternCompile(pattern) {\n  var before\n  var after\n\n  if (!pattern._compiled) {\n    before = pattern.before ? '(?:' + pattern.before + ')' : ''\n    after = pattern.after ? '(?:' + pattern.after + ')' : ''\n\n    if (pattern.atBreak) {\n      before = '[\\\\r\\\\n][\\\\t ]*' + before\n    }\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (after || ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","'use strict'\n\nmodule.exports = toString\n\n// Get the text content of a node.\n// Prefer the nodes plain-text fields, otherwise serialize its children,\n// and if the given value is an array, serialize the nodes in it.\nfunction toString(node) {\n  return (\n    (node &&\n      (node.value ||\n        node.alt ||\n        node.title ||\n        ('children' in node && all(node.children)) ||\n        ('length' in node && all(node)))) ||\n    ''\n  )\n}\n\nfunction all(values) {\n  var result = []\n  var index = -1\n\n  while (++index < values.length) {\n    result[index] = toString(values[index])\n  }\n\n  return result.join('')\n}\n","module.exports = require('./syntax')\n","var asciiAlpha = require('micromark/dist/character/ascii-alpha')\nvar asciiAlphanumeric = require('micromark/dist/character/ascii-alphanumeric')\nvar asciiControl = require('micromark/dist/character/ascii-control')\nvar markdownLineEnding = require('micromark/dist/character/markdown-line-ending')\nvar unicodePunctuation = require('micromark/dist/character/unicode-punctuation')\nvar unicodeWhitespace = require('micromark/dist/character/unicode-whitespace')\n\nvar www = {tokenize: tokenizeWww, partial: true}\nvar domain = {tokenize: tokenizeDomain, partial: true}\nvar path = {tokenize: tokenizePath, partial: true}\nvar punctuation = {tokenize: tokenizePunctuation, partial: true}\nvar namedCharacterReference = {\n  tokenize: tokenizeNamedCharacterReference,\n  partial: true\n}\n\nvar wwwAutolink = {tokenize: tokenizeWwwAutolink, previous: previousWww}\nvar httpAutolink = {tokenize: tokenizeHttpAutolink, previous: previousHttp}\nvar emailAutolink = {tokenize: tokenizeEmailAutolink, previous: previousEmail}\n\nvar text = {}\n\n// Export hooked constructs.\nexports.text = text\n\n// `0`\nvar code = 48\n\n// While the code is smaller than `{`.\nwhile (code < 123) {\n  text[code] = emailAutolink\n  code++\n  // Jump from `:` -> `A`\n  if (code === 58) code = 65\n  // Jump from `[` -> `a`\n  else if (code === 91) code = 97\n}\n\n// `+`\ntext[43] = emailAutolink\n// `-`\ntext[45] = emailAutolink\n// `.`\ntext[46] = emailAutolink\n// `_`\ntext[95] = emailAutolink\n// `h`.\ntext[72] = [emailAutolink, httpAutolink]\ntext[104] = [emailAutolink, httpAutolink]\n// `w`.\ntext[87] = [emailAutolink, wwwAutolink]\ntext[119] = [emailAutolink, wwwAutolink]\n\nfunction tokenizeEmailAutolink(effects, ok, nok) {\n  var self = this\n  var hasDot\n\n  return start\n\n  function start(code) {\n    /* istanbul ignore next - hooks. */\n    if (\n      !gfmAtext(code) ||\n      !previousEmail(self.previous) ||\n      previous(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkEmail')\n    return atext(code)\n  }\n\n  function atext(code) {\n    if (gfmAtext(code)) {\n      effects.consume(code)\n      return atext\n    }\n\n    // `@`\n    if (code === 64) {\n      effects.consume(code)\n      return label\n    }\n\n    return nok(code)\n  }\n\n  function label(code) {\n    // `.`\n    if (code === 46) {\n      return effects.check(punctuation, done, dotContinuation)(code)\n    }\n\n    if (\n      // `-`\n      code === 45 ||\n      // `_`\n      code === 95\n    ) {\n      return effects.check(punctuation, nok, dashOrUnderscoreContinuation)(code)\n    }\n\n    if (asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return label\n    }\n\n    return done(code)\n  }\n\n  function dotContinuation(code) {\n    effects.consume(code)\n    hasDot = true\n    return label\n  }\n\n  function dashOrUnderscoreContinuation(code) {\n    effects.consume(code)\n    return afterDashOrUnderscore\n  }\n\n  function afterDashOrUnderscore(code) {\n    // `.`\n    if (code === 46) {\n      return effects.check(punctuation, nok, dotContinuation)(code)\n    }\n\n    return label(code)\n  }\n\n  function done(code) {\n    if (hasDot) {\n      effects.exit('literalAutolinkEmail')\n      effects.exit('literalAutolink')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\nfunction tokenizeWwwAutolink(effects, ok, nok) {\n  var self = this\n\n  return start\n\n  function start(code) {\n    /* istanbul ignore next - hooks. */\n    if (\n      (code !== 87 && code - 32 !== 87) ||\n      !previousWww(self.previous) ||\n      previous(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkWww')\n    // For `www.` we check instead of attempt, because when it matches, GH\n    // treats it as part of a domain (yes, it says a valid domain must come\n    // after `www.`, but thats not how its implemented by them).\n    return effects.check(\n      www,\n      effects.attempt(domain, effects.attempt(path, done), nok),\n      nok\n    )(code)\n  }\n\n  function done(code) {\n    effects.exit('literalAutolinkWww')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n\nfunction tokenizeHttpAutolink(effects, ok, nok) {\n  var self = this\n\n  return start\n\n  function start(code) {\n    /* istanbul ignore next - hooks. */\n    if (\n      (code !== 72 && code - 32 !== 72) ||\n      !previousHttp(self.previous) ||\n      previous(self.events)\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('literalAutolink')\n    effects.enter('literalAutolinkHttp')\n    effects.consume(code)\n    return t1\n  }\n\n  function t1(code) {\n    // `t`\n    if (code === 84 || code - 32 === 84) {\n      effects.consume(code)\n      return t2\n    }\n\n    return nok(code)\n  }\n\n  function t2(code) {\n    // `t`\n    if (code === 84 || code - 32 === 84) {\n      effects.consume(code)\n      return p\n    }\n\n    return nok(code)\n  }\n\n  function p(code) {\n    // `p`\n    if (code === 80 || code - 32 === 80) {\n      effects.consume(code)\n      return s\n    }\n\n    return nok(code)\n  }\n\n  function s(code) {\n    // `s`\n    if (code === 83 || code - 32 === 83) {\n      effects.consume(code)\n      return colon\n    }\n\n    return colon(code)\n  }\n\n  function colon(code) {\n    // `:`\n    if (code === 58) {\n      effects.consume(code)\n      return slash1\n    }\n\n    return nok(code)\n  }\n\n  function slash1(code) {\n    // `/`\n    if (code === 47) {\n      effects.consume(code)\n      return slash2\n    }\n\n    return nok(code)\n  }\n\n  function slash2(code) {\n    // `/`\n    if (code === 47) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n\n  function after(code) {\n    return asciiControl(code) ||\n      unicodeWhitespace(code) ||\n      unicodePunctuation(code)\n      ? nok(code)\n      : effects.attempt(domain, effects.attempt(path, done), nok)(code)\n  }\n\n  function done(code) {\n    effects.exit('literalAutolinkHttp')\n    effects.exit('literalAutolink')\n    return ok(code)\n  }\n}\n\nfunction tokenizeWww(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    // Assume a `w`.\n    effects.consume(code)\n    return w2\n  }\n\n  function w2(code) {\n    // `w`\n    if (code === 87 || code - 32 === 87) {\n      effects.consume(code)\n      return w3\n    }\n\n    return nok(code)\n  }\n\n  function w3(code) {\n    // `w`\n    if (code === 87 || code - 32 === 87) {\n      effects.consume(code)\n      return dot\n    }\n\n    return nok(code)\n  }\n\n  function dot(code) {\n    // `.`\n    if (code === 46) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? nok(code) : ok(code)\n  }\n}\n\nfunction tokenizeDomain(effects, ok, nok) {\n  var hasUnderscoreInLastSegment\n  var hasUnderscoreInLastLastSegment\n\n  return domain\n\n  function domain(code) {\n    // `&`\n    if (code === 38) {\n      return effects.check(\n        namedCharacterReference,\n        done,\n        punctuationContinuation\n      )(code)\n    }\n\n    if (code === 46 /* `.` */ || code === 95 /* `_` */) {\n      return effects.check(punctuation, done, punctuationContinuation)(code)\n    }\n\n    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can\n    // occur, which sounds like ASCII only, but they also support `www..com`,\n    // so thats Unicode.\n    // Instead of some new production for Unicode alphanumerics, markdown\n    // already has that for Unicode punctuation and whitespace, so use those.\n    if (\n      asciiControl(code) ||\n      unicodeWhitespace(code) ||\n      (code !== 45 /* `-` */ && unicodePunctuation(code))\n    ) {\n      return done(code)\n    }\n\n    effects.consume(code)\n    return domain\n  }\n\n  function punctuationContinuation(code) {\n    // `.`\n    if (code === 46) {\n      hasUnderscoreInLastLastSegment = hasUnderscoreInLastSegment\n      hasUnderscoreInLastSegment = undefined\n      effects.consume(code)\n      return domain\n    }\n\n    // `_`\n    if (code === 95) hasUnderscoreInLastSegment = true\n\n    effects.consume(code)\n    return domain\n  }\n\n  function done(code) {\n    if (!hasUnderscoreInLastLastSegment && !hasUnderscoreInLastSegment) {\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\nfunction tokenizePath(effects, ok) {\n  var balance = 0\n\n  return inPath\n\n  function inPath(code) {\n    // `&`\n    if (code === 38) {\n      return effects.check(\n        namedCharacterReference,\n        ok,\n        continuedPunctuation\n      )(code)\n    }\n\n    // `(`\n    if (code === 40) {\n      balance++\n    }\n\n    // `)`\n    if (code === 41) {\n      return effects.check(\n        punctuation,\n        parenAtPathEnd,\n        continuedPunctuation\n      )(code)\n    }\n\n    if (pathEnd(code)) {\n      return ok(code)\n    }\n\n    if (trailingPunctuation(code)) {\n      return effects.check(punctuation, ok, continuedPunctuation)(code)\n    }\n\n    effects.consume(code)\n    return inPath\n  }\n\n  function continuedPunctuation(code) {\n    effects.consume(code)\n    return inPath\n  }\n\n  function parenAtPathEnd(code) {\n    balance--\n    return balance < 0 ? ok(code) : continuedPunctuation(code)\n  }\n}\n\nfunction tokenizeNamedCharacterReference(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    // Assume an ampersand.\n    effects.consume(code)\n    return inside\n  }\n\n  function inside(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return inside\n    }\n\n    // `;`\n    if (code === 59) {\n      effects.consume(code)\n      return after\n    }\n\n    return nok(code)\n  }\n\n  function after(code) {\n    // If the named character reference is followed by the end of the path, its\n    // not continued punctuation.\n    return pathEnd(code) ? ok(code) : nok(code)\n  }\n}\n\nfunction tokenizePunctuation(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    // Always a valid trailing punctuation marker.\n    effects.consume(code)\n    return after\n  }\n\n  function after(code) {\n    // Check the next.\n    if (trailingPunctuation(code)) {\n      effects.consume(code)\n      return after\n    }\n\n    // If the punctuation marker is followed by the end of the path, its not\n    // continued punctuation.\n    return pathEnd(code) ? ok(code) : nok(code)\n  }\n}\n\nfunction trailingPunctuation(code) {\n  return (\n    // `!`\n    code === 33 ||\n    // `\"`\n    code === 34 ||\n    // `'`\n    code === 39 ||\n    // `)`\n    code === 41 ||\n    // `*`\n    code === 42 ||\n    // `,`\n    code === 44 ||\n    // `.`\n    code === 46 ||\n    // `:`\n    code === 58 ||\n    // `;`\n    code === 59 ||\n    // `<`\n    code === 60 ||\n    // `?`\n    code === 63 ||\n    // `_`.\n    code === 95 ||\n    // `~`\n    code === 126\n  )\n}\n\nfunction pathEnd(code) {\n  return (\n    // EOF.\n    code === null ||\n    // CR, LF, CRLF, HT, VS.\n    code < 0 ||\n    // Space.\n    code === 32 ||\n    // `<`\n    code === 60\n  )\n}\n\nfunction gfmAtext(code) {\n  return (\n    code === 43 /* `+` */ ||\n    code === 45 /* `-` */ ||\n    code === 46 /* `.` */ ||\n    code === 95 /* `_` */ ||\n    asciiAlphanumeric(code)\n  )\n}\n\nfunction previousWww(code) {\n  return (\n    code === null ||\n    code < 0 ||\n    code === 32 /* ` ` */ ||\n    code === 40 /* `(` */ ||\n    code === 42 /* `*` */ ||\n    code === 95 /* `_` */ ||\n    code === 126 /* `~` */\n  )\n}\n\nfunction previousHttp(code) {\n  return code === null || !asciiAlpha(code)\n}\n\nfunction previousEmail(code) {\n  return code !== 47 /* `/` */ && previousHttp(code)\n}\n\nfunction previous(events) {\n  var index = events.length\n\n  while (index--) {\n    if (\n      (events[index][1].type === 'labelLink' ||\n        events[index][1].type === 'labelImage') &&\n      !events[index][1]._balanced\n    ) {\n      return true\n    }\n  }\n}\n","module.exports = create\n\nvar classifyCharacter = require('micromark/dist/util/classify-character')\nvar chunkedSplice = require('micromark/dist/util/chunked-splice')\nvar resolveAll = require('micromark/dist/util/resolve-all')\nvar shallow = require('micromark/dist/util/shallow')\n\nfunction create(options) {\n  var settings = options || {}\n  var single = settings.singleTilde\n  var tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  }\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  return {text: {126: tokenizer}, insideSpan: {null: tokenizer}}\n\n  // Take events and resolve strikethrough.\n  function resolveAllStrikethrough(events, context) {\n    var index = -1\n    var strikethrough\n    var text\n    var open\n    var nextEvents\n\n    // Walk through all events.\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (\n        events[index][0] === 'enter' &&\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\n        events[index][1]._close\n      ) {\n        open = index\n\n        // Now walk back to find an opener.\n        while (open--) {\n          // Find a token that can open the closer.\n          if (\n            events[open][0] === 'exit' &&\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\n            events[open][1]._open &&\n            // If the sizes are the same:\n            events[index][1].end.offset - events[index][1].start.offset ===\n              events[open][1].end.offset - events[open][1].start.offset\n          ) {\n            events[index][1].type = 'strikethroughSequence'\n            events[open][1].type = 'strikethroughSequence'\n\n            strikethrough = {\n              type: 'strikethrough',\n              start: shallow(events[open][1].start),\n              end: shallow(events[index][1].end)\n            }\n\n            text = {\n              type: 'strikethroughText',\n              start: shallow(events[open][1].end),\n              end: shallow(events[index][1].start)\n            }\n\n            // Opening.\n            nextEvents = [\n              ['enter', strikethrough, context],\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context],\n              ['enter', text, context]\n            ]\n\n            // Between.\n            chunkedSplice(\n              nextEvents,\n              nextEvents.length,\n              0,\n              resolveAll(\n                context.parser.constructs.insideSpan.null,\n                events.slice(open + 1, index),\n                context\n              )\n            )\n\n            // Closing.\n            chunkedSplice(nextEvents, nextEvents.length, 0, [\n              ['exit', text, context],\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context],\n              ['exit', strikethrough, context]\n            ])\n\n            chunkedSplice(events, open - 1, index - open + 3, nextEvents)\n\n            index = open + nextEvents.length - 2\n            break\n          }\n        }\n      }\n    }\n\n    return removeRemainingSequences(events)\n  }\n\n  function removeRemainingSequences(events) {\n    var index = -1\n    var length = events.length\n\n    while (++index < length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data'\n      }\n    }\n\n    return events\n  }\n\n  function tokenizeStrikethrough(effects, ok, nok) {\n    var previous = this.previous\n    var events = this.events\n    var size = 0\n\n    return start\n\n    function start(code) {\n      if (\n        code !== 126 ||\n        (previous === 126 &&\n          events[events.length - 1][1].type !== 'characterEscape')\n      ) {\n        return nok(code)\n      }\n\n      effects.enter('strikethroughSequenceTemporary')\n      return more(code)\n    }\n\n    function more(code) {\n      var before = classifyCharacter(previous)\n      var token\n      var after\n\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code)\n        effects.consume(code)\n        size++\n        return more\n      }\n\n      if (size < 2 && !single) return nok(code)\n      token = effects.exit('strikethroughSequenceTemporary')\n      after = classifyCharacter(code)\n      token._open = !after || (after === 2 && before)\n      token._close = !before || (before === 2 && after)\n      return ok(code)\n    }\n  }\n}\n","module.exports = require('./syntax')\n","exports.flow = {\n  null: {tokenize: tokenizeTable, resolve: resolveTable, interruptible: true}\n}\n\nvar createSpace = require('micromark/dist/tokenize/factory-space')\n\nvar setextUnderlineMini = {tokenize: tokenizeSetextUnderlineMini, partial: true}\nvar nextPrefixedOrBlank = {tokenize: tokenizeNextPrefixedOrBlank, partial: true}\n\nfunction resolveTable(events, context) {\n  var length = events.length\n  var index = -1\n  var token\n  var inHead\n  var inDelimiterRow\n  var inRow\n  var cell\n  var content\n  var text\n  var contentStart\n  var contentEnd\n  var cellStart\n\n  while (++index < length) {\n    token = events[index][1]\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index\n        contentEnd = index\n      }\n\n      if (\n        // Combine separate content parts into one.\n        (token.type === 'tableCellDivider' || token.type === 'tableRow') &&\n        contentEnd\n      ) {\n        content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        }\n        text = {\n          type: 'chunkText',\n          start: content.start,\n          end: content.end,\n          contentType: 'text'\n        }\n\n        events.splice(\n          contentStart,\n          contentEnd - contentStart + 1,\n          ['enter', content, context],\n          ['enter', text, context],\n          ['exit', text, context],\n          ['exit', content, context]\n        )\n        index -= contentEnd - contentStart - 3\n        length = events.length\n        contentStart = undefined\n        contentEnd = undefined\n      }\n    }\n\n    if (\n      events[index][0] === 'exit' &&\n      cellStart &&\n      cellStart + 1 < index &&\n      (token.type === 'tableCellDivider' ||\n        (token.type === 'tableRow' &&\n          (cellStart + 3 < index ||\n            events[cellStart][1].type !== 'whitespace')))\n    ) {\n      cell = {\n        type: inDelimiterRow\n          ? 'tableDelimiter'\n          : inHead\n          ? 'tableHeader'\n          : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      }\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [\n        'exit',\n        cell,\n        context\n      ])\n      events.splice(cellStart, 0, ['enter', cell, context])\n      index += 2\n      length = events.length\n      cellStart = index + 1\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter'\n\n      if (inRow) {\n        cellStart = index + 1\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter'\n\n      if (inDelimiterRow) {\n        cellStart = index + 1\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter'\n    }\n  }\n\n  return events\n}\n\nfunction tokenizeTable(effects, ok, nok) {\n  var align = []\n  var tableHeaderCount = 0\n  var seenDelimiter\n  var hasDash\n\n  return start\n\n  function start(code) {\n    /* istanbul ignore if - used to be passed in beta micromark versions. */\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return nok(code)\n    }\n\n    effects.enter('table')._align = align\n    effects.enter('tableHead')\n    effects.enter('tableRow')\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === 124) {\n      return cellDividerHead(code)\n    }\n\n    tableHeaderCount++\n    effects.enter('temporaryTableCellContent')\n    // Cant be space or eols at the start of a construct, so were in a cell.\n    return inCellContentHead(code)\n  }\n\n  function cellDividerHead(code) {\n    // Always a pipe.\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    seenDelimiter = true\n    return cellBreakHead\n  }\n\n  function cellBreakHead(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return atRowEndHead(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined\n      tableHeaderCount++\n    }\n\n    // `|`\n    if (code === 124) {\n      return cellDividerHead(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent')\n    return inCellContentHead(code)\n  }\n\n  function inWhitespaceHead(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    effects.exit('whitespace')\n    return cellBreakHead(code)\n  }\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code < 0 || code === 32 || code === 124) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakHead(code)\n    }\n\n    effects.consume(code)\n    // `\\`\n    return code === 92 ? inCellContentEscapeHead : inCellContentHead\n  }\n\n  function inCellContentEscapeHead(code) {\n    // `\\` or `|`\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentHead\n    }\n\n    // Anything else.\n    return inCellContentHead(code)\n  }\n\n  function atRowEndHead(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    effects.exit('tableRow')\n    effects.exit('tableHead')\n\n    // Always a line ending.\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n\n    // If a setext heading, exit.\n    return effects.check(\n      setextUnderlineMini,\n      nok,\n      // Support an indent before the delimiter row.\n      createSpace(effects, rowStartDelimiter, 'linePrefix', 4)\n    )\n  }\n\n  function rowStartDelimiter(code) {\n    // If theres another space, or were at the EOL/EOF, exit.\n    if (code === null || code < 0 || code === 32) {\n      return nok(code)\n    }\n\n    effects.enter('tableDelimiterRow')\n    return atDelimiterRowBreak(code)\n  }\n\n  function atDelimiterRowBreak(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return rowEndDelimiter(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    // `-`\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      align.push(null)\n      return inFillerDelimiter\n    }\n\n    // `:`\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align.push('left')\n      return afterLeftAlignment\n    }\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n\n  function inWhitespaceDelimiter(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    effects.exit('whitespace')\n    return atDelimiterRowBreak(code)\n  }\n\n  function inFillerDelimiter(code) {\n    // `-`\n    if (code === 45) {\n      effects.consume(code)\n      return inFillerDelimiter\n    }\n\n    effects.exit('tableDelimiterFiller')\n\n    // `:`\n    if (code === 58) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n\n      align[align.length - 1] =\n        align[align.length - 1] === 'left' ? 'center' : 'right'\n\n      return afterRightAlignment\n    }\n\n    return atDelimiterRowBreak(code)\n  }\n\n  function afterLeftAlignment(code) {\n    // `-`\n    if (code === 45) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      return inFillerDelimiter\n    }\n\n    // Anything else is not ok.\n    return nok(code)\n  }\n\n  function afterRightAlignment(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return rowEndDelimiter(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    // `|`\n    if (code === 124) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow')\n\n    // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code)\n    }\n\n    if (code === null) {\n      return tableClose(code)\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableClose, tableContinue)(code)\n  }\n\n  function tableClose(code) {\n    effects.exit('table')\n    return ok(code)\n  }\n\n  function tableContinue(code) {\n    // Always a line ending.\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    // We checked that its not a prefixed or blank line, so were certain a\n    // body is coming, though it may be indented.\n    return createSpace(effects, bodyStart, 'linePrefix', 4)\n  }\n\n  function bodyStart(code) {\n    effects.enter('tableBody')\n    return rowStartBody(code)\n  }\n\n  function rowStartBody(code) {\n    effects.enter('tableRow')\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === 124) {\n      return cellDividerBody(code)\n    }\n\n    effects.enter('temporaryTableCellContent')\n    // Cant be space or eols at the start of a construct, so were in a cell.\n    return inCellContentBody(code)\n  }\n\n  function cellDividerBody(code) {\n    // Always a pipe.\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    return cellBreakBody\n  }\n\n  function cellBreakBody(code) {\n    // EOF, CR, LF, CRLF.\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return atRowEndBody(code)\n    }\n\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.enter('whitespace')\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    // `|`\n    if (code === 124) {\n      return cellDividerBody(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent')\n    return inCellContentBody(code)\n  }\n\n  function inWhitespaceBody(code) {\n    // HT, VS, SP.\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    effects.exit('whitespace')\n    return cellBreakBody(code)\n  }\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === null || code < 0 || code === 32 || code === 124) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakBody(code)\n    }\n\n    effects.consume(code)\n    // `\\`\n    return code === 92 ? inCellContentEscapeBody : inCellContentBody\n  }\n\n  function inCellContentEscapeBody(code) {\n    // `\\` or `|`\n    if (code === 92 || code === 124) {\n      effects.consume(code)\n      return inCellContentBody\n    }\n\n    // Anything else.\n    return inCellContentBody(code)\n  }\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow')\n\n    if (code === null) {\n      return tableBodyClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableBodyClose,\n      tableBodyContinue\n    )(code)\n  }\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody')\n    return tableClose(code)\n  }\n\n  function tableBodyContinue(code) {\n    // Always a line ending.\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    // Support an optional prefix, then start a body row.\n    return createSpace(effects, rowStartBody, 'linePrefix', 4)\n  }\n}\n\n// Based on micromark, but that wont work as were in a table, and that expects\n// content.\n// <https://github.com/micromark/micromark/blob/main/lib/tokenize/setext-underline.js>\nfunction tokenizeSetextUnderlineMini(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    // `-`\n    if (code !== 45) {\n      return nok(code)\n    }\n\n    effects.enter('setextUnderline')\n    return sequence(code)\n  }\n\n  function sequence(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return sequence\n    }\n\n    return whitespace(code)\n  }\n\n  function whitespace(code) {\n    if (code === -2 || code === -1 || code === 32) {\n      effects.consume(code)\n      return whitespace\n    }\n\n    if (code === null || code === -5 || code === -4 || code === -3) {\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  var size = 0\n\n  return start\n\n  function start(code) {\n    // This is a check, so we dont care about tokens, but we open a bogus one\n    // so were valid.\n    effects.enter('check')\n    // EOL.\n    effects.consume(code)\n    return whitespace\n  }\n\n  function whitespace(code) {\n    // VS or SP.\n    if (code === -1 || code === 32) {\n      effects.consume(code)\n      size++\n      return size === 4 ? ok : whitespace\n    }\n\n    // EOF or whitespace\n    if (code === null || code < 0) {\n      return ok(code)\n    }\n\n    // Anything else.\n    return nok(code)\n  }\n}\n","module.exports = require('./syntax')\n","var markdownLineEndingOrSpace = require('micromark/dist/character/markdown-line-ending-or-space')\nvar spaceFactory = require('micromark/dist/tokenize/factory-space')\nvar prefixSize = require('micromark/dist/util/prefix-size')\n\nvar tasklistCheck = {tokenize: tokenizeTasklistCheck}\n\nexports.text = {91: tasklistCheck}\n\nfunction tokenizeTasklistCheck(effects, ok, nok) {\n  var self = this\n\n  return open\n\n  function open(code) {\n    if (\n      // Exit if not `[`.\n      code !== 91 ||\n      // Exit if theres stuff before.\n      self.previous !== null ||\n      // Exit if not in the first content that is the first child of a list\n      // item.\n      !self._gfmTasklistFirstContentOfListItem\n    ) {\n      return nok(code)\n    }\n\n    effects.enter('taskListCheck')\n    effects.enter('taskListCheckMarker')\n    effects.consume(code)\n    effects.exit('taskListCheckMarker')\n    return inside\n  }\n\n  function inside(code) {\n    // Tab or space.\n    if (code === -2 || code === 32) {\n      effects.enter('taskListCheckValueUnchecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueUnchecked')\n      return close\n    }\n\n    // Upper- and lower `x`.\n    if (code === 88 || code === 120) {\n      effects.enter('taskListCheckValueChecked')\n      effects.consume(code)\n      effects.exit('taskListCheckValueChecked')\n      return close\n    }\n\n    return nok(code)\n  }\n\n  function close(code) {\n    // `]`\n    if (code === 93) {\n      effects.enter('taskListCheckMarker')\n      effects.consume(code)\n      effects.exit('taskListCheckMarker')\n      effects.exit('taskListCheck')\n      return effects.check({tokenize: spaceThenNonSpace}, ok, nok)\n    }\n\n    return nok(code)\n  }\n}\n\nfunction spaceThenNonSpace(effects, ok, nok) {\n  var self = this\n\n  return spaceFactory(effects, after, 'whitespace')\n\n  function after(code) {\n    return prefixSize(self.events, 'whitespace') &&\n      code !== null &&\n      !markdownLineEndingOrSpace(code)\n      ? ok(code)\n      : nok(code)\n  }\n}\n","module.exports = require('./syntax')\n","var combine = require('micromark/dist/util/combine-extensions')\nvar autolink = require('micromark-extension-gfm-autolink-literal')\nvar strikethrough = require('micromark-extension-gfm-strikethrough')\nvar table = require('micromark-extension-gfm-table')\nvar tasklist = require('micromark-extension-gfm-task-list-item')\n\nmodule.exports = create\n\nfunction create(options) {\n  return combine([autolink, strikethrough(options), table, tasklist])\n}\n","'use strict'\n\nvar regexCheck = require('../util/regex-check.js')\n\nvar asciiAlpha = regexCheck(/[A-Za-z]/)\n\nmodule.exports = asciiAlpha\n","'use strict'\n\nvar regexCheck = require('../util/regex-check.js')\n\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/)\n\nmodule.exports = asciiAlphanumeric\n","'use strict'\n\nvar regexCheck = require('../util/regex-check.js')\n\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/)\n\nmodule.exports = asciiAtext\n","'use strict'\n\n// Note: EOF is seen as ASCII control here, because `null < 32 == true`.\nfunction asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code < 32 || code === 127\n  )\n}\n\nmodule.exports = asciiControl\n","'use strict'\n\nvar regexCheck = require('../util/regex-check.js')\n\nvar asciiDigit = regexCheck(/\\d/)\n\nmodule.exports = asciiDigit\n","'use strict'\n\nvar regexCheck = require('../util/regex-check.js')\n\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/)\n\nmodule.exports = asciiHexDigit\n","'use strict'\n\nvar regexCheck = require('../util/regex-check.js')\n\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/)\n\nmodule.exports = asciiPunctuation\n","'use strict'\n\nfunction markdownLineEndingOrSpace(code) {\n  return code < 0 || code === 32\n}\n\nmodule.exports = markdownLineEndingOrSpace\n","'use strict'\n\nfunction markdownLineEnding(code) {\n  return code < -2\n}\n\nmodule.exports = markdownLineEnding\n","'use strict'\n\nfunction markdownSpace(code) {\n  return code === -2 || code === -1 || code === 32\n}\n\nmodule.exports = markdownSpace\n","'use strict'\n\nvar unicodePunctuationRegex = require('../constant/unicode-punctuation-regex.js')\nvar regexCheck = require('../util/regex-check.js')\n\n// In fact adds to the bundle size.\n\nvar unicodePunctuation = regexCheck(unicodePunctuationRegex)\n\nmodule.exports = unicodePunctuation\n","'use strict'\n\nvar regexCheck = require('../util/regex-check.js')\n\nvar unicodeWhitespace = regexCheck(/\\s/)\n\nmodule.exports = unicodeWhitespace\n","'use strict'\n\nvar assign = Object.assign\n\nmodule.exports = assign\n","'use strict'\n\nvar fromCharCode = String.fromCharCode\n\nmodule.exports = fromCharCode\n","'use strict'\n\nvar own = {}.hasOwnProperty\n\nmodule.exports = own\n","'use strict'\n\n// This module is copied from <https://spec.commonmark.org/0.29/#html-blocks>.\nvar basics = [\n  'address',\n  'article',\n  'aside',\n  'base',\n  'basefont',\n  'blockquote',\n  'body',\n  'caption',\n  'center',\n  'col',\n  'colgroup',\n  'dd',\n  'details',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'footer',\n  'form',\n  'frame',\n  'frameset',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hr',\n  'html',\n  'iframe',\n  'legend',\n  'li',\n  'link',\n  'main',\n  'menu',\n  'menuitem',\n  'nav',\n  'noframes',\n  'ol',\n  'optgroup',\n  'option',\n  'p',\n  'param',\n  'section',\n  'source',\n  'summary',\n  'table',\n  'tbody',\n  'td',\n  'tfoot',\n  'th',\n  'thead',\n  'title',\n  'tr',\n  'track',\n  'ul'\n]\n\nmodule.exports = basics\n","'use strict'\n\n// This module is copied from <https://spec.commonmark.org/0.29/#html-blocks>.\nvar raws = ['pre', 'script', 'style', 'textarea']\n\nmodule.exports = raws\n","'use strict'\n\nvar splice = [].splice\n\nmodule.exports = splice\n","'use strict'\n\n// This module is generated by `script/`.\n//\n// CommonMark handles attention (emphasis, strong) markers based on what comes\n// before or after them.\n// One such difference is if those characters are Unicode punctuation.\n// This script is generated from the Unicode data.\nvar unicodePunctuation = /[!-\\/:-@\\[-`\\{-~\\xA1\\xA7\\xAB\\xB6\\xB7\\xBB\\xBF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n\nmodule.exports = unicodePunctuation\n","'use strict'\n\nObject.defineProperty(exports, '__esModule', {value: true})\n\nvar text$1 = require('./initialize/text.js')\nvar attention = require('./tokenize/attention.js')\nvar autolink = require('./tokenize/autolink.js')\nvar blockQuote = require('./tokenize/block-quote.js')\nvar characterEscape = require('./tokenize/character-escape.js')\nvar characterReference = require('./tokenize/character-reference.js')\nvar codeFenced = require('./tokenize/code-fenced.js')\nvar codeIndented = require('./tokenize/code-indented.js')\nvar codeText = require('./tokenize/code-text.js')\nvar definition = require('./tokenize/definition.js')\nvar hardBreakEscape = require('./tokenize/hard-break-escape.js')\nvar headingAtx = require('./tokenize/heading-atx.js')\nvar htmlFlow = require('./tokenize/html-flow.js')\nvar htmlText = require('./tokenize/html-text.js')\nvar labelEnd = require('./tokenize/label-end.js')\nvar labelStartImage = require('./tokenize/label-start-image.js')\nvar labelStartLink = require('./tokenize/label-start-link.js')\nvar lineEnding = require('./tokenize/line-ending.js')\nvar list = require('./tokenize/list.js')\nvar setextUnderline = require('./tokenize/setext-underline.js')\nvar thematicBreak = require('./tokenize/thematic-break.js')\n\nvar document = {\n  42: list,\n  // Asterisk\n  43: list,\n  // Plus sign\n  45: list,\n  // Dash\n  48: list,\n  // 0\n  49: list,\n  // 1\n  50: list,\n  // 2\n  51: list,\n  // 3\n  52: list,\n  // 4\n  53: list,\n  // 5\n  54: list,\n  // 6\n  55: list,\n  // 7\n  56: list,\n  // 8\n  57: list,\n  // 9\n  62: blockQuote // Greater than\n}\nvar contentInitial = {\n  91: definition // Left square bracket\n}\nvar flowInitial = {\n  '-2': codeIndented,\n  // Horizontal tab\n  '-1': codeIndented,\n  // Virtual space\n  32: codeIndented // Space\n}\nvar flow = {\n  35: headingAtx,\n  // Number sign\n  42: thematicBreak,\n  // Asterisk\n  45: [setextUnderline, thematicBreak],\n  // Dash\n  60: htmlFlow,\n  // Less than\n  61: setextUnderline,\n  // Equals to\n  95: thematicBreak,\n  // Underscore\n  96: codeFenced,\n  // Grave accent\n  126: codeFenced // Tilde\n}\nvar string = {\n  38: characterReference,\n  // Ampersand\n  92: characterEscape // Backslash\n}\nvar text = {\n  '-5': lineEnding,\n  // Carriage return\n  '-4': lineEnding,\n  // Line feed\n  '-3': lineEnding,\n  // Carriage return + line feed\n  33: labelStartImage,\n  // Exclamation mark\n  38: characterReference,\n  // Ampersand\n  42: attention,\n  // Asterisk\n  60: [autolink, htmlText],\n  // Less than\n  91: labelStartLink,\n  // Left square bracket\n  92: [hardBreakEscape, characterEscape],\n  // Backslash\n  93: labelEnd,\n  // Right square bracket\n  95: attention,\n  // Underscore\n  96: codeText // Grave accent\n}\nvar insideSpan = {\n  null: [attention, text$1.resolver]\n}\nvar disable = {\n  null: []\n}\n\nexports.contentInitial = contentInitial\nexports.disable = disable\nexports.document = document\nexports.flow = flow\nexports.flowInitial = flowInitial\nexports.insideSpan = insideSpan\nexports.string = string\nexports.text = text\n","'use strict'\n\nObject.defineProperty(exports, '__esModule', {value: true})\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar factorySpace = require('../tokenize/factory-space.js')\n\nvar tokenize = initializeContent\n\nfunction initializeContent(effects) {\n  var contentStart = effects.attempt(\n    this.parser.constructs.contentInitial,\n    afterContentStartConstruct,\n    paragraphInitial\n  )\n  var previous\n  return contentStart\n\n  function afterContentStartConstruct(code) {\n    if (code === null) {\n      effects.consume(code)\n      return\n    }\n\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, contentStart, 'linePrefix')\n  }\n\n  function paragraphInitial(code) {\n    effects.enter('paragraph')\n    return lineStart(code)\n  }\n\n  function lineStart(code) {\n    var token = effects.enter('chunkText', {\n      contentType: 'text',\n      previous: previous\n    })\n\n    if (previous) {\n      previous.next = token\n    }\n\n    previous = token\n    return data(code)\n  }\n\n  function data(code) {\n    if (code === null) {\n      effects.exit('chunkText')\n      effects.exit('paragraph')\n      effects.consume(code)\n      return\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code)\n      effects.exit('chunkText')\n      return lineStart\n    } // Data.\n\n    effects.consume(code)\n    return data\n  }\n}\n\nexports.tokenize = tokenize\n","'use strict'\n\nObject.defineProperty(exports, '__esModule', {value: true})\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar factorySpace = require('../tokenize/factory-space.js')\nvar partialBlankLine = require('../tokenize/partial-blank-line.js')\n\nvar tokenize = initializeDocument\nvar containerConstruct = {\n  tokenize: tokenizeContainer\n}\nvar lazyFlowConstruct = {\n  tokenize: tokenizeLazyFlow\n}\n\nfunction initializeDocument(effects) {\n  var self = this\n  var stack = []\n  var continued = 0\n  var inspectConstruct = {\n    tokenize: tokenizeInspect,\n    partial: true\n  }\n  var inspectResult\n  var childFlow\n  var childToken\n  return start\n\n  function start(code) {\n    if (continued < stack.length) {\n      self.containerState = stack[continued][1]\n      return effects.attempt(\n        stack[continued][0].continuation,\n        documentContinue,\n        documentContinued\n      )(code)\n    }\n\n    return documentContinued(code)\n  }\n\n  function documentContinue(code) {\n    continued++\n    return start(code)\n  }\n\n  function documentContinued(code) {\n    // If were in a concrete construct (such as when expecting another line of\n    // HTML, or we resulted in lazy content), we can immediately start flow.\n    if (inspectResult && inspectResult.flowContinue) {\n      return flowStart(code)\n    }\n\n    self.interrupt =\n      childFlow &&\n      childFlow.currentConstruct &&\n      childFlow.currentConstruct.interruptible\n    self.containerState = {}\n    return effects.attempt(\n      containerConstruct,\n      containerContinue,\n      flowStart\n    )(code)\n  }\n\n  function containerContinue(code) {\n    stack.push([self.currentConstruct, self.containerState])\n    self.containerState = undefined\n    return documentContinued(code)\n  }\n\n  function flowStart(code) {\n    if (code === null) {\n      exitContainers(0, true)\n      effects.consume(code)\n      return\n    }\n\n    childFlow = childFlow || self.parser.flow(self.now())\n    effects.enter('chunkFlow', {\n      contentType: 'flow',\n      previous: childToken,\n      _tokenizer: childFlow\n    })\n    return flowContinue(code)\n  }\n\n  function flowContinue(code) {\n    if (code === null) {\n      continueFlow(effects.exit('chunkFlow'))\n      return flowStart(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.consume(code)\n      continueFlow(effects.exit('chunkFlow'))\n      return effects.check(inspectConstruct, documentAfterPeek)\n    }\n\n    effects.consume(code)\n    return flowContinue\n  }\n\n  function documentAfterPeek(code) {\n    exitContainers(\n      inspectResult.continued,\n      inspectResult && inspectResult.flowEnd\n    )\n    continued = 0\n    return start(code)\n  }\n\n  function continueFlow(token) {\n    if (childToken) childToken.next = token\n    childToken = token\n    childFlow.lazy = inspectResult && inspectResult.lazy\n    childFlow.defineSkip(token.start)\n    childFlow.write(self.sliceStream(token))\n  }\n\n  function exitContainers(size, end) {\n    var index = stack.length // Close the flow.\n\n    if (childFlow && end) {\n      childFlow.write([null])\n      childToken = childFlow = undefined\n    } // Exit open containers.\n\n    while (index-- > size) {\n      self.containerState = stack[index][1]\n      stack[index][0].exit.call(self, effects)\n    }\n\n    stack.length = size\n  }\n\n  function tokenizeInspect(effects, ok) {\n    var subcontinued = 0\n    inspectResult = {}\n    return inspectStart\n\n    function inspectStart(code) {\n      if (subcontinued < stack.length) {\n        self.containerState = stack[subcontinued][1]\n        return effects.attempt(\n          stack[subcontinued][0].continuation,\n          inspectContinue,\n          inspectLess\n        )(code)\n      } // If were continued but in a concrete flow, we cant have more\n      // containers.\n\n      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {\n        inspectResult.flowContinue = true\n        return inspectDone(code)\n      }\n\n      self.interrupt =\n        childFlow.currentConstruct && childFlow.currentConstruct.interruptible\n      self.containerState = {}\n      return effects.attempt(\n        containerConstruct,\n        inspectFlowEnd,\n        inspectDone\n      )(code)\n    }\n\n    function inspectContinue(code) {\n      subcontinued++\n      return self.containerState._closeFlow\n        ? inspectFlowEnd(code)\n        : inspectStart(code)\n    }\n\n    function inspectLess(code) {\n      if (childFlow.currentConstruct && childFlow.currentConstruct.lazy) {\n        // Maybe another container?\n        self.containerState = {}\n        return effects.attempt(\n          containerConstruct,\n          inspectFlowEnd, // Maybe flow, or a blank line?\n          effects.attempt(\n            lazyFlowConstruct,\n            inspectFlowEnd,\n            effects.check(partialBlankLine, inspectFlowEnd, inspectLazy)\n          )\n        )(code)\n      } // Otherwise were interrupting.\n\n      return inspectFlowEnd(code)\n    }\n\n    function inspectLazy(code) {\n      // Act as if all containers are continued.\n      subcontinued = stack.length\n      inspectResult.lazy = true\n      inspectResult.flowContinue = true\n      return inspectDone(code)\n    } // Were done with flow if we have more containers, or an interruption.\n\n    function inspectFlowEnd(code) {\n      inspectResult.flowEnd = true\n      return inspectDone(code)\n    }\n\n    function inspectDone(code) {\n      inspectResult.continued = subcontinued\n      self.interrupt = self.containerState = undefined\n      return ok(code)\n    }\n  }\n}\n\nfunction tokenizeContainer(effects, ok, nok) {\n  return factorySpace(\n    effects,\n    effects.attempt(this.parser.constructs.document, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.indexOf('codeIndented') > -1\n      ? undefined\n      : 4\n  )\n}\n\nfunction tokenizeLazyFlow(effects, ok, nok) {\n  return factorySpace(\n    effects,\n    effects.lazy(this.parser.constructs.flow, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.indexOf('codeIndented') > -1\n      ? undefined\n      : 4\n  )\n}\n\nexports.tokenize = tokenize\n","'use strict'\n\nObject.defineProperty(exports, '__esModule', {value: true})\n\nvar content = require('../tokenize/content.js')\nvar factorySpace = require('../tokenize/factory-space.js')\nvar partialBlankLine = require('../tokenize/partial-blank-line.js')\n\nvar tokenize = initializeFlow\n\nfunction initializeFlow(effects) {\n  var self = this\n  var initial = effects.attempt(\n    // Try to parse a blank line.\n    partialBlankLine,\n    atBlankEnding, // Try to parse initial flow (essentially, only code).\n    effects.attempt(\n      this.parser.constructs.flowInitial,\n      afterConstruct,\n      factorySpace(\n        effects,\n        effects.attempt(\n          this.parser.constructs.flow,\n          afterConstruct,\n          effects.attempt(content, afterConstruct)\n        ),\n        'linePrefix'\n      )\n    )\n  )\n  return initial\n\n  function atBlankEnding(code) {\n    if (code === null) {\n      effects.consume(code)\n      return\n    }\n\n    effects.enter('lineEndingBlank')\n    effects.consume(code)\n    effects.exit('lineEndingBlank')\n    self.currentConstruct = undefined\n    return initial\n  }\n\n  function afterConstruct(code) {\n    if (code === null) {\n      effects.consume(code)\n      return\n    }\n\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    self.currentConstruct = undefined\n    return initial\n  }\n}\n\nexports.tokenize = tokenize\n","'use strict'\n\nObject.defineProperty(exports, '__esModule', {value: true})\n\nvar assign = require('../constant/assign.js')\nvar shallow = require('../util/shallow.js')\n\nvar text = initializeFactory('text')\nvar string = initializeFactory('string')\nvar resolver = {\n  resolveAll: createResolver()\n}\n\nfunction initializeFactory(field) {\n  return {\n    tokenize: initializeText,\n    resolveAll: createResolver(\n      field === 'text' ? resolveAllLineSuffixes : undefined\n    )\n  }\n\n  function initializeText(effects) {\n    var self = this\n    var constructs = this.parser.constructs[field]\n    var text = effects.attempt(constructs, start, notText)\n    return start\n\n    function start(code) {\n      return atBreak(code) ? text(code) : notText(code)\n    }\n\n    function notText(code) {\n      if (code === null) {\n        effects.consume(code)\n        return\n      }\n\n      effects.enter('data')\n      effects.consume(code)\n      return data\n    }\n\n    function data(code) {\n      if (atBreak(code)) {\n        effects.exit('data')\n        return text(code)\n      } // Data.\n\n      effects.consume(code)\n      return data\n    }\n\n    function atBreak(code) {\n      var list = constructs[code]\n      var index = -1\n\n      if (code === null) {\n        return true\n      }\n\n      if (list) {\n        while (++index < list.length) {\n          if (\n            !list[index].previous ||\n            list[index].previous.call(self, self.previous)\n          ) {\n            return true\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction createResolver(extraResolver) {\n  return resolveAllText\n\n  function resolveAllText(events, context) {\n    var index = -1\n    var enter // A rather boring computation (to merge adjacent `data` events) which\n    // improves mm performance by 29%.\n\n    while (++index <= events.length) {\n      if (enter === undefined) {\n        if (events[index] && events[index][1].type === 'data') {\n          enter = index\n          index++\n        }\n      } else if (!events[index] || events[index][1].type !== 'data') {\n        // Dont do anything if there is one data token.\n        if (index !== enter + 2) {\n          events[enter][1].end = events[index - 1][1].end\n          events.splice(enter + 2, index - enter - 2)\n          index = enter + 2\n        }\n\n        enter = undefined\n      }\n    }\n\n    return extraResolver ? extraResolver(events, context) : events\n  }\n} // A rather ugly set of instructions which again looks at chunks in the input\n// stream.\n// The reason to do this here is that it is *much* faster to parse in reverse.\n// And that we cant hook into `null` to split the line suffix before an EOF.\n// To do: figure out if we can make this into a clean utility, or even in core.\n// As it will be useful for GFMs literal autolink extension (and maybe even\n// tables?)\n\nfunction resolveAllLineSuffixes(events, context) {\n  var eventIndex = -1\n  var chunks\n  var data\n  var chunk\n  var index\n  var bufferIndex\n  var size\n  var tabs\n  var token\n\n  while (++eventIndex <= events.length) {\n    if (\n      (eventIndex === events.length ||\n        events[eventIndex][1].type === 'lineEnding') &&\n      events[eventIndex - 1][1].type === 'data'\n    ) {\n      data = events[eventIndex - 1][1]\n      chunks = context.sliceStream(data)\n      index = chunks.length\n      bufferIndex = -1\n      size = 0\n      tabs = undefined\n\n      while (index--) {\n        chunk = chunks[index]\n\n        if (typeof chunk === 'string') {\n          bufferIndex = chunk.length\n\n          while (chunk.charCodeAt(bufferIndex - 1) === 32) {\n            size++\n            bufferIndex--\n          }\n\n          if (bufferIndex) break\n          bufferIndex = -1\n        } // Number\n        else if (chunk === -2) {\n          tabs = true\n          size++\n        } else if (chunk === -1);\n        else {\n          // Replacement character, exit.\n          index++\n          break\n        }\n      }\n\n      if (size) {\n        token = {\n          type:\n            eventIndex === events.length || tabs || size < 2\n              ? 'lineSuffix'\n              : 'hardBreakTrailing',\n          start: {\n            line: data.end.line,\n            column: data.end.column - size,\n            offset: data.end.offset - size,\n            _index: data.start._index + index,\n            _bufferIndex: index\n              ? bufferIndex\n              : data.start._bufferIndex + bufferIndex\n          },\n          end: shallow(data.end)\n        }\n        data.end = shallow(token.start)\n\n        if (data.start.offset === data.end.offset) {\n          assign(data, token)\n        } else {\n          events.splice(\n            eventIndex,\n            0,\n            ['enter', token, context],\n            ['exit', token, context]\n          )\n          eventIndex += 2\n        }\n      }\n\n      eventIndex++\n    }\n  }\n\n  return events\n}\n\nexports.resolver = resolver\nexports.string = string\nexports.text = text\n","'use strict'\n\nvar content = require('./initialize/content.js')\nvar document = require('./initialize/document.js')\nvar flow = require('./initialize/flow.js')\nvar text = require('./initialize/text.js')\nvar combineExtensions = require('./util/combine-extensions.js')\nvar createTokenizer = require('./util/create-tokenizer.js')\nvar miniflat = require('./util/miniflat.js')\nvar constructs = require('./constructs.js')\n\nfunction parse(options) {\n  var settings = options || {}\n  var parser = {\n    defined: [],\n    constructs: combineExtensions(\n      [constructs].concat(miniflat(settings.extensions))\n    ),\n    content: create(content),\n    document: create(document),\n    flow: create(flow),\n    string: create(text.string),\n    text: create(text.text)\n  }\n  return parser\n\n  function create(initializer) {\n    return creator\n\n    function creator(from) {\n      return createTokenizer(parser, initializer, from)\n    }\n  }\n}\n\nmodule.exports = parse\n","'use strict'\n\nvar subtokenize = require('./util/subtokenize.js')\n\nfunction postprocess(events) {\n  while (!subtokenize(events)) {\n    // Empty\n  }\n\n  return events\n}\n\nmodule.exports = postprocess\n","'use strict'\n\nvar search = /[\\0\\t\\n\\r]/g\n\nfunction preprocess() {\n  var start = true\n  var column = 1\n  var buffer = ''\n  var atCarriageReturn\n  return preprocessor\n\n  function preprocessor(value, encoding, end) {\n    var chunks = []\n    var match\n    var next\n    var startPosition\n    var endPosition\n    var code\n    value = buffer + value.toString(encoding)\n    startPosition = 0\n    buffer = ''\n\n    if (start) {\n      if (value.charCodeAt(0) === 65279) {\n        startPosition++\n      }\n\n      start = undefined\n    }\n\n    while (startPosition < value.length) {\n      search.lastIndex = startPosition\n      match = search.exec(value)\n      endPosition = match ? match.index : value.length\n      code = value.charCodeAt(endPosition)\n\n      if (!match) {\n        buffer = value.slice(startPosition)\n        break\n      }\n\n      if (code === 10 && startPosition === endPosition && atCarriageReturn) {\n        chunks.push(-3)\n        atCarriageReturn = undefined\n      } else {\n        if (atCarriageReturn) {\n          chunks.push(-5)\n          atCarriageReturn = undefined\n        }\n\n        if (startPosition < endPosition) {\n          chunks.push(value.slice(startPosition, endPosition))\n          column += endPosition - startPosition\n        }\n\n        if (code === 0) {\n          chunks.push(65533)\n          column++\n        } else if (code === 9) {\n          next = Math.ceil(column / 4) * 4\n          chunks.push(-2)\n\n          while (column++ < next) chunks.push(-1)\n        } else if (code === 10) {\n          chunks.push(-4)\n          column = 1\n        } // Must be carriage return.\n        else {\n          atCarriageReturn = true\n          column = 1\n        }\n      }\n\n      startPosition = endPosition + 1\n    }\n\n    if (end) {\n      if (atCarriageReturn) chunks.push(-5)\n      if (buffer) chunks.push(buffer)\n      chunks.push(null)\n    }\n\n    return chunks\n  }\n}\n\nmodule.exports = preprocess\n","'use strict'\n\nvar chunkedPush = require('../util/chunked-push.js')\nvar chunkedSplice = require('../util/chunked-splice.js')\nvar classifyCharacter = require('../util/classify-character.js')\nvar movePoint = require('../util/move-point.js')\nvar resolveAll = require('../util/resolve-all.js')\nvar shallow = require('../util/shallow.js')\n\nvar attention = {\n  name: 'attention',\n  tokenize: tokenizeAttention,\n  resolveAll: resolveAllAttention\n}\n\nfunction resolveAllAttention(events, context) {\n  var index = -1\n  var open\n  var group\n  var text\n  var openingSequence\n  var closingSequence\n  var use\n  var nextEvents\n  var offset // Walk through all events.\n  //\n  // Note: performance of this is fine on an mb of normal markdown, but its\n  // a bottleneck for malicious stuff.\n\n  while (++index < events.length) {\n    // Find a token that can close.\n    if (\n      events[index][0] === 'enter' &&\n      events[index][1].type === 'attentionSequence' &&\n      events[index][1]._close\n    ) {\n      open = index // Now walk back to find an opener.\n\n      while (open--) {\n        // Find a token that can open the closer.\n        if (\n          events[open][0] === 'exit' &&\n          events[open][1].type === 'attentionSequence' &&\n          events[open][1]._open && // If the markers are the same:\n          context.sliceSerialize(events[open][1]).charCodeAt(0) ===\n            context.sliceSerialize(events[index][1]).charCodeAt(0)\n        ) {\n          // If the opening can close or the closing can open,\n          // and the close size *is not* a multiple of three,\n          // but the sum of the opening and closing size *is* multiple of three,\n          // then dont match.\n          if (\n            (events[open][1]._close || events[index][1]._open) &&\n            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&\n            !(\n              (events[open][1].end.offset -\n                events[open][1].start.offset +\n                events[index][1].end.offset -\n                events[index][1].start.offset) %\n              3\n            )\n          ) {\n            continue\n          } // Number of markers to use from the sequence.\n\n          use =\n            events[open][1].end.offset - events[open][1].start.offset > 1 &&\n            events[index][1].end.offset - events[index][1].start.offset > 1\n              ? 2\n              : 1\n          openingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: movePoint(shallow(events[open][1].end), -use),\n            end: shallow(events[open][1].end)\n          }\n          closingSequence = {\n            type: use > 1 ? 'strongSequence' : 'emphasisSequence',\n            start: shallow(events[index][1].start),\n            end: movePoint(shallow(events[index][1].start), use)\n          }\n          text = {\n            type: use > 1 ? 'strongText' : 'emphasisText',\n            start: shallow(events[open][1].end),\n            end: shallow(events[index][1].start)\n          }\n          group = {\n            type: use > 1 ? 'strong' : 'emphasis',\n            start: shallow(openingSequence.start),\n            end: shallow(closingSequence.end)\n          }\n          events[open][1].end = shallow(openingSequence.start)\n          events[index][1].start = shallow(closingSequence.end)\n          nextEvents = [] // If there are more markers in the opening, add them before.\n\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            nextEvents = chunkedPush(nextEvents, [\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context]\n            ])\n          } // Opening.\n\n          nextEvents = chunkedPush(nextEvents, [\n            ['enter', group, context],\n            ['enter', openingSequence, context],\n            ['exit', openingSequence, context],\n            ['enter', text, context]\n          ]) // Between.\n\n          nextEvents = chunkedPush(\n            nextEvents,\n            resolveAll(\n              context.parser.constructs.insideSpan.null,\n              events.slice(open + 1, index),\n              context\n            )\n          ) // Closing.\n\n          nextEvents = chunkedPush(nextEvents, [\n            ['exit', text, context],\n            ['enter', closingSequence, context],\n            ['exit', closingSequence, context],\n            ['exit', group, context]\n          ]) // If there are more markers in the closing, add them after.\n\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2\n            nextEvents = chunkedPush(nextEvents, [\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context]\n            ])\n          } else {\n            offset = 0\n          }\n\n          chunkedSplice(events, open - 1, index - open + 3, nextEvents)\n          index = open + nextEvents.length - offset - 2\n          break\n        }\n      }\n    }\n  } // Remove remaining sequences.\n\n  index = -1\n\n  while (++index < events.length) {\n    if (events[index][1].type === 'attentionSequence') {\n      events[index][1].type = 'data'\n    }\n  }\n\n  return events\n}\n\nfunction tokenizeAttention(effects, ok) {\n  var before = classifyCharacter(this.previous)\n  var marker\n  return start\n\n  function start(code) {\n    effects.enter('attentionSequence')\n    marker = code\n    return sequence(code)\n  }\n\n  function sequence(code) {\n    var token\n    var after\n    var open\n    var close\n\n    if (code === marker) {\n      effects.consume(code)\n      return sequence\n    }\n\n    token = effects.exit('attentionSequence')\n    after = classifyCharacter(code)\n    open = !after || (after === 2 && before)\n    close = !before || (before === 2 && after)\n    token._open = marker === 42 ? open : open && (before || !close)\n    token._close = marker === 42 ? close : close && (after || !open)\n    return ok(code)\n  }\n}\n\nmodule.exports = attention\n","'use strict'\n\nvar asciiAlpha = require('../character/ascii-alpha.js')\nvar asciiAlphanumeric = require('../character/ascii-alphanumeric.js')\nvar asciiAtext = require('../character/ascii-atext.js')\nvar asciiControl = require('../character/ascii-control.js')\n\nvar autolink = {\n  name: 'autolink',\n  tokenize: tokenizeAutolink\n}\n\nfunction tokenizeAutolink(effects, ok, nok) {\n  var size = 1\n  return start\n\n  function start(code) {\n    effects.enter('autolink')\n    effects.enter('autolinkMarker')\n    effects.consume(code)\n    effects.exit('autolinkMarker')\n    effects.enter('autolinkProtocol')\n    return open\n  }\n\n  function open(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return schemeOrEmailAtext\n    }\n\n    return asciiAtext(code) ? emailAtext(code) : nok(code)\n  }\n\n  function schemeOrEmailAtext(code) {\n    return code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)\n      ? schemeInsideOrEmailAtext(code)\n      : emailAtext(code)\n  }\n\n  function schemeInsideOrEmailAtext(code) {\n    if (code === 58) {\n      effects.consume(code)\n      return urlInside\n    }\n\n    if (\n      (code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) &&\n      size++ < 32\n    ) {\n      effects.consume(code)\n      return schemeInsideOrEmailAtext\n    }\n\n    return emailAtext(code)\n  }\n\n  function urlInside(code) {\n    if (code === 62) {\n      effects.exit('autolinkProtocol')\n      return end(code)\n    }\n\n    if (code === 32 || code === 60 || asciiControl(code)) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return urlInside\n  }\n\n  function emailAtext(code) {\n    if (code === 64) {\n      effects.consume(code)\n      size = 0\n      return emailAtSignOrDot\n    }\n\n    if (asciiAtext(code)) {\n      effects.consume(code)\n      return emailAtext\n    }\n\n    return nok(code)\n  }\n\n  function emailAtSignOrDot(code) {\n    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code)\n  }\n\n  function emailLabel(code) {\n    if (code === 46) {\n      effects.consume(code)\n      size = 0\n      return emailAtSignOrDot\n    }\n\n    if (code === 62) {\n      // Exit, then change the type.\n      effects.exit('autolinkProtocol').type = 'autolinkEmail'\n      return end(code)\n    }\n\n    return emailValue(code)\n  }\n\n  function emailValue(code) {\n    if ((code === 45 || asciiAlphanumeric(code)) && size++ < 63) {\n      effects.consume(code)\n      return code === 45 ? emailValue : emailLabel\n    }\n\n    return nok(code)\n  }\n\n  function end(code) {\n    effects.enter('autolinkMarker')\n    effects.consume(code)\n    effects.exit('autolinkMarker')\n    effects.exit('autolink')\n    return ok\n  }\n}\n\nmodule.exports = autolink\n","'use strict'\n\nvar markdownSpace = require('../character/markdown-space.js')\nvar factorySpace = require('./factory-space.js')\n\nvar blockQuote = {\n  name: 'blockQuote',\n  tokenize: tokenizeBlockQuoteStart,\n  continuation: {\n    tokenize: tokenizeBlockQuoteContinuation\n  },\n  exit: exit\n}\n\nfunction tokenizeBlockQuoteStart(effects, ok, nok) {\n  var self = this\n  return start\n\n  function start(code) {\n    if (code === 62) {\n      if (!self.containerState.open) {\n        effects.enter('blockQuote', {\n          _container: true\n        })\n        self.containerState.open = true\n      }\n\n      effects.enter('blockQuotePrefix')\n      effects.enter('blockQuoteMarker')\n      effects.consume(code)\n      effects.exit('blockQuoteMarker')\n      return after\n    }\n\n    return nok(code)\n  }\n\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter('blockQuotePrefixWhitespace')\n      effects.consume(code)\n      effects.exit('blockQuotePrefixWhitespace')\n      effects.exit('blockQuotePrefix')\n      return ok\n    }\n\n    effects.exit('blockQuotePrefix')\n    return ok(code)\n  }\n}\n\nfunction tokenizeBlockQuoteContinuation(effects, ok, nok) {\n  return factorySpace(\n    effects,\n    effects.attempt(blockQuote, ok, nok),\n    'linePrefix',\n    this.parser.constructs.disable.null.indexOf('codeIndented') > -1\n      ? undefined\n      : 4\n  )\n}\n\nfunction exit(effects) {\n  effects.exit('blockQuote')\n}\n\nmodule.exports = blockQuote\n","'use strict'\n\nvar asciiPunctuation = require('../character/ascii-punctuation.js')\n\nvar characterEscape = {\n  name: 'characterEscape',\n  tokenize: tokenizeCharacterEscape\n}\n\nfunction tokenizeCharacterEscape(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    effects.enter('characterEscape')\n    effects.enter('escapeMarker')\n    effects.consume(code)\n    effects.exit('escapeMarker')\n    return open\n  }\n\n  function open(code) {\n    if (asciiPunctuation(code)) {\n      effects.enter('characterEscapeValue')\n      effects.consume(code)\n      effects.exit('characterEscapeValue')\n      effects.exit('characterEscape')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n\nmodule.exports = characterEscape\n","'use strict'\n\nvar decodeEntity = require('parse-entities/decode-entity.js')\nvar asciiAlphanumeric = require('../character/ascii-alphanumeric.js')\nvar asciiDigit = require('../character/ascii-digit.js')\nvar asciiHexDigit = require('../character/ascii-hex-digit.js')\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {default: e}\n}\n\nvar decodeEntity__default = /*#__PURE__*/ _interopDefaultLegacy(decodeEntity)\n\nvar characterReference = {\n  name: 'characterReference',\n  tokenize: tokenizeCharacterReference\n}\n\nfunction tokenizeCharacterReference(effects, ok, nok) {\n  var self = this\n  var size = 0\n  var max\n  var test\n  return start\n\n  function start(code) {\n    effects.enter('characterReference')\n    effects.enter('characterReferenceMarker')\n    effects.consume(code)\n    effects.exit('characterReferenceMarker')\n    return open\n  }\n\n  function open(code) {\n    if (code === 35) {\n      effects.enter('characterReferenceMarkerNumeric')\n      effects.consume(code)\n      effects.exit('characterReferenceMarkerNumeric')\n      return numeric\n    }\n\n    effects.enter('characterReferenceValue')\n    max = 31\n    test = asciiAlphanumeric\n    return value(code)\n  }\n\n  function numeric(code) {\n    if (code === 88 || code === 120) {\n      effects.enter('characterReferenceMarkerHexadecimal')\n      effects.consume(code)\n      effects.exit('characterReferenceMarkerHexadecimal')\n      effects.enter('characterReferenceValue')\n      max = 6\n      test = asciiHexDigit\n      return value\n    }\n\n    effects.enter('characterReferenceValue')\n    max = 7\n    test = asciiDigit\n    return value(code)\n  }\n\n  function value(code) {\n    var token\n\n    if (code === 59 && size) {\n      token = effects.exit('characterReferenceValue')\n\n      if (\n        test === asciiAlphanumeric &&\n        !decodeEntity__default['default'](self.sliceSerialize(token))\n      ) {\n        return nok(code)\n      }\n\n      effects.enter('characterReferenceMarker')\n      effects.consume(code)\n      effects.exit('characterReferenceMarker')\n      effects.exit('characterReference')\n      return ok\n    }\n\n    if (test(code) && size++ < max) {\n      effects.consume(code)\n      return value\n    }\n\n    return nok(code)\n  }\n}\n\nmodule.exports = characterReference\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space.js')\nvar prefixSize = require('../util/prefix-size.js')\nvar factorySpace = require('./factory-space.js')\n\nvar codeFenced = {\n  name: 'codeFenced',\n  tokenize: tokenizeCodeFenced,\n  concrete: true\n}\n\nfunction tokenizeCodeFenced(effects, ok, nok) {\n  var self = this\n  var closingFenceConstruct = {\n    tokenize: tokenizeClosingFence,\n    partial: true\n  }\n  var initialPrefix = prefixSize(this.events, 'linePrefix')\n  var sizeOpen = 0\n  var marker\n  return start\n\n  function start(code) {\n    effects.enter('codeFenced')\n    effects.enter('codeFencedFence')\n    effects.enter('codeFencedFenceSequence')\n    marker = code\n    return sequenceOpen(code)\n  }\n\n  function sequenceOpen(code) {\n    if (code === marker) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    effects.exit('codeFencedFenceSequence')\n    return sizeOpen < 3\n      ? nok(code)\n      : factorySpace(effects, infoOpen, 'whitespace')(code)\n  }\n\n  function infoOpen(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('codeFencedFenceInfo')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return info(code)\n  }\n\n  function info(code) {\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceInfo')\n      return factorySpace(effects, infoAfter, 'whitespace')(code)\n    }\n\n    if (code === 96 && code === marker) return nok(code)\n    effects.consume(code)\n    return info\n  }\n\n  function infoAfter(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('codeFencedFenceMeta')\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return meta(code)\n  }\n\n  function meta(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      effects.exit('codeFencedFenceMeta')\n      return openAfter(code)\n    }\n\n    if (code === 96 && code === marker) return nok(code)\n    effects.consume(code)\n    return meta\n  }\n\n  function openAfter(code) {\n    effects.exit('codeFencedFence')\n    return self.interrupt ? ok(code) : content(code)\n  }\n\n  function content(code) {\n    if (code === null) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return effects.attempt(\n        closingFenceConstruct,\n        after,\n        initialPrefix\n          ? factorySpace(effects, content, 'linePrefix', initialPrefix + 1)\n          : content\n      )\n    }\n\n    effects.enter('codeFlowValue')\n    return contentContinue(code)\n  }\n\n  function contentContinue(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return content(code)\n    }\n\n    effects.consume(code)\n    return contentContinue\n  }\n\n  function after(code) {\n    effects.exit('codeFenced')\n    return ok(code)\n  }\n\n  function tokenizeClosingFence(effects, ok, nok) {\n    var size = 0\n    return factorySpace(\n      effects,\n      closingSequenceStart,\n      'linePrefix',\n      this.parser.constructs.disable.null.indexOf('codeIndented') > -1\n        ? undefined\n        : 4\n    )\n\n    function closingSequenceStart(code) {\n      effects.enter('codeFencedFence')\n      effects.enter('codeFencedFenceSequence')\n      return closingSequence(code)\n    }\n\n    function closingSequence(code) {\n      if (code === marker) {\n        effects.consume(code)\n        size++\n        return closingSequence\n      }\n\n      if (size < sizeOpen) return nok(code)\n      effects.exit('codeFencedFenceSequence')\n      return factorySpace(effects, closingSequenceEnd, 'whitespace')(code)\n    }\n\n    function closingSequenceEnd(code) {\n      if (code === null || markdownLineEnding(code)) {\n        effects.exit('codeFencedFence')\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n\nmodule.exports = codeFenced\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar chunkedSplice = require('../util/chunked-splice.js')\nvar prefixSize = require('../util/prefix-size.js')\nvar factorySpace = require('./factory-space.js')\n\nvar codeIndented = {\n  name: 'codeIndented',\n  tokenize: tokenizeCodeIndented,\n  resolve: resolveCodeIndented\n}\nvar indentedContentConstruct = {\n  tokenize: tokenizeIndentedContent,\n  partial: true\n}\n\nfunction resolveCodeIndented(events, context) {\n  var code = {\n    type: 'codeIndented',\n    start: events[0][1].start,\n    end: events[events.length - 1][1].end\n  }\n  chunkedSplice(events, 0, 0, [['enter', code, context]])\n  chunkedSplice(events, events.length, 0, [['exit', code, context]])\n  return events\n}\n\nfunction tokenizeCodeIndented(effects, ok, nok) {\n  return effects.attempt(indentedContentConstruct, afterPrefix, nok)\n\n  function afterPrefix(code) {\n    if (code === null) {\n      return ok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(indentedContentConstruct, afterPrefix, ok)(code)\n    }\n\n    effects.enter('codeFlowValue')\n    return content(code)\n  }\n\n  function content(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('codeFlowValue')\n      return afterPrefix(code)\n    }\n\n    effects.consume(code)\n    return content\n  }\n}\n\nfunction tokenizeIndentedContent(effects, ok, nok) {\n  var self = this\n  return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)\n\n  function afterPrefix(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)\n    }\n\n    return prefixSize(self.events, 'linePrefix') < 4 ? nok(code) : ok(code)\n  }\n}\n\nmodule.exports = codeIndented\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\n\nvar codeText = {\n  name: 'codeText',\n  tokenize: tokenizeCodeText,\n  resolve: resolveCodeText,\n  previous: previous\n}\n\nfunction resolveCodeText(events) {\n  var tailExitIndex = events.length - 4\n  var headEnterIndex = 3\n  var index\n  var enter // If we start and end with an EOL or a space.\n\n  if (\n    (events[headEnterIndex][1].type === 'lineEnding' ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === 'lineEnding' ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex // And we have data.\n\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'codeTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = events[headEnterIndex][1].type =\n          'codeTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  } // Merge adjacent spaces and data.\n\n  index = headEnterIndex - 1\n  tailExitIndex++\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === 'lineEnding'\n    ) {\n      events[enter][1].type = 'codeTextData'\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n\n      enter = undefined\n    }\n  }\n\n  return events\n}\n\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== 96 ||\n    this.events[this.events.length - 1][1].type === 'characterEscape'\n  )\n}\n\nfunction tokenizeCodeText(effects, ok, nok) {\n  var sizeOpen = 0\n  var size\n  var token\n  return start\n\n  function start(code) {\n    effects.enter('codeText')\n    effects.enter('codeTextSequence')\n    return openingSequence(code)\n  }\n\n  function openingSequence(code) {\n    if (code === 96) {\n      effects.consume(code)\n      sizeOpen++\n      return openingSequence\n    }\n\n    effects.exit('codeTextSequence')\n    return gap(code)\n  }\n\n  function gap(code) {\n    // EOF.\n    if (code === null) {\n      return nok(code)\n    } // Closing fence?\n    // Could also be data.\n\n    if (code === 96) {\n      token = effects.enter('codeTextSequence')\n      size = 0\n      return closingSequence(code)\n    } // Tabs dont work, and virtual spaces dont make sense.\n\n    if (code === 32) {\n      effects.enter('space')\n      effects.consume(code)\n      effects.exit('space')\n      return gap\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return gap\n    } // Data.\n\n    effects.enter('codeTextData')\n    return data(code)\n  } // In code.\n\n  function data(code) {\n    if (\n      code === null ||\n      code === 32 ||\n      code === 96 ||\n      markdownLineEnding(code)\n    ) {\n      effects.exit('codeTextData')\n      return gap(code)\n    }\n\n    effects.consume(code)\n    return data\n  } // Closing fence.\n\n  function closingSequence(code) {\n    // More.\n    if (code === 96) {\n      effects.consume(code)\n      size++\n      return closingSequence\n    } // Done!\n\n    if (size === sizeOpen) {\n      effects.exit('codeTextSequence')\n      effects.exit('codeText')\n      return ok(code)\n    } // More or less accents: mark as data.\n\n    token.type = 'codeTextData'\n    return data(code)\n  }\n}\n\nmodule.exports = codeText\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar prefixSize = require('../util/prefix-size.js')\nvar subtokenize = require('../util/subtokenize.js')\nvar factorySpace = require('./factory-space.js')\n\n// No name because it must not be turned off.\nvar content = {\n  tokenize: tokenizeContent,\n  resolve: resolveContent,\n  interruptible: true,\n  lazy: true\n}\nvar continuationConstruct = {\n  tokenize: tokenizeContinuation,\n  partial: true\n} // Content is transparent: its parsed right now. That way, definitions are also\n// parsed right now: before text in paragraphs (specifically, media) are parsed.\n\nfunction resolveContent(events) {\n  subtokenize(events)\n  return events\n}\n\nfunction tokenizeContent(effects, ok) {\n  var previous\n  return start\n\n  function start(code) {\n    effects.enter('content')\n    previous = effects.enter('chunkContent', {\n      contentType: 'content'\n    })\n    return data(code)\n  }\n\n  function data(code) {\n    if (code === null) {\n      return contentEnd(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.check(\n        continuationConstruct,\n        contentContinue,\n        contentEnd\n      )(code)\n    } // Data.\n\n    effects.consume(code)\n    return data\n  }\n\n  function contentEnd(code) {\n    effects.exit('chunkContent')\n    effects.exit('content')\n    return ok(code)\n  }\n\n  function contentContinue(code) {\n    effects.consume(code)\n    effects.exit('chunkContent')\n    previous = previous.next = effects.enter('chunkContent', {\n      contentType: 'content',\n      previous: previous\n    })\n    return data\n  }\n}\n\nfunction tokenizeContinuation(effects, ok, nok) {\n  var self = this\n  return startLookahead\n\n  function startLookahead(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, prefixed, 'linePrefix')\n  }\n\n  function prefixed(code) {\n    if (code === null || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    if (\n      self.parser.constructs.disable.null.indexOf('codeIndented') > -1 ||\n      prefixSize(self.events, 'linePrefix') < 4\n    ) {\n      return effects.interrupt(self.parser.constructs.flow, nok, ok)(code)\n    }\n\n    return ok(code)\n  }\n}\n\nmodule.exports = content\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space.js')\nvar normalizeIdentifier = require('../util/normalize-identifier.js')\nvar factoryDestination = require('./factory-destination.js')\nvar factoryLabel = require('./factory-label.js')\nvar factorySpace = require('./factory-space.js')\nvar factoryWhitespace = require('./factory-whitespace.js')\nvar factoryTitle = require('./factory-title.js')\n\nvar definition = {\n  name: 'definition',\n  tokenize: tokenizeDefinition\n}\nvar titleConstruct = {\n  tokenize: tokenizeTitle,\n  partial: true\n}\n\nfunction tokenizeDefinition(effects, ok, nok) {\n  var self = this\n  var identifier\n  return start\n\n  function start(code) {\n    effects.enter('definition')\n    return factoryLabel.call(\n      self,\n      effects,\n      labelAfter,\n      nok,\n      'definitionLabel',\n      'definitionLabelMarker',\n      'definitionLabelString'\n    )(code)\n  }\n\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(\n      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n    )\n\n    if (code === 58) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker') // Note: blank lines cant exist in content.\n\n      return factoryWhitespace(\n        effects,\n        factoryDestination(\n          effects,\n          effects.attempt(\n            titleConstruct,\n            factorySpace(effects, after, 'whitespace'),\n            factorySpace(effects, after, 'whitespace')\n          ),\n          nok,\n          'definitionDestination',\n          'definitionDestinationLiteral',\n          'definitionDestinationLiteralMarker',\n          'definitionDestinationRaw',\n          'definitionDestinationString'\n        )\n      )\n    }\n\n    return nok(code)\n  }\n\n  function after(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('definition')\n\n      if (self.parser.defined.indexOf(identifier) < 0) {\n        self.parser.defined.push(identifier)\n      }\n\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\nfunction tokenizeTitle(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, before)(code)\n      : nok(code)\n  }\n\n  function before(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        factorySpace(effects, after, 'whitespace'),\n        nok,\n        'definitionTitle',\n        'definitionTitleMarker',\n        'definitionTitleString'\n      )(code)\n    }\n\n    return nok(code)\n  }\n\n  function after(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n\nmodule.exports = definition\n","'use strict'\n\nvar asciiControl = require('../character/ascii-control.js')\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space.js')\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\n\n// eslint-disable-next-line max-params\nfunction destinationFactory(\n  effects,\n  ok,\n  nok,\n  type,\n  literalType,\n  literalMarkerType,\n  rawType,\n  stringType,\n  max\n) {\n  var limit = max || Infinity\n  var balance = 0\n  return start\n\n  function start(code) {\n    if (code === 60) {\n      effects.enter(type)\n      effects.enter(literalType)\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      return destinationEnclosedBefore\n    }\n\n    if (asciiControl(code) || code === 41) {\n      return nok(code)\n    }\n\n    effects.enter(type)\n    effects.enter(rawType)\n    effects.enter(stringType)\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return destinationRaw(code)\n  }\n\n  function destinationEnclosedBefore(code) {\n    if (code === 62) {\n      effects.enter(literalMarkerType)\n      effects.consume(code)\n      effects.exit(literalMarkerType)\n      effects.exit(literalType)\n      effects.exit(type)\n      return ok\n    }\n\n    effects.enter(stringType)\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return destinationEnclosed(code)\n  }\n\n  function destinationEnclosed(code) {\n    if (code === 62) {\n      effects.exit('chunkString')\n      effects.exit(stringType)\n      return destinationEnclosedBefore(code)\n    }\n\n    if (code === null || code === 60 || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? destinationEnclosedEscape : destinationEnclosed\n  }\n\n  function destinationEnclosedEscape(code) {\n    if (code === 60 || code === 62 || code === 92) {\n      effects.consume(code)\n      return destinationEnclosed\n    }\n\n    return destinationEnclosed(code)\n  }\n\n  function destinationRaw(code) {\n    if (code === 40) {\n      if (++balance > limit) return nok(code)\n      effects.consume(code)\n      return destinationRaw\n    }\n\n    if (code === 41) {\n      if (!balance--) {\n        effects.exit('chunkString')\n        effects.exit(stringType)\n        effects.exit(rawType)\n        effects.exit(type)\n        return ok(code)\n      }\n\n      effects.consume(code)\n      return destinationRaw\n    }\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      if (balance) return nok(code)\n      effects.exit('chunkString')\n      effects.exit(stringType)\n      effects.exit(rawType)\n      effects.exit(type)\n      return ok(code)\n    }\n\n    if (asciiControl(code)) return nok(code)\n    effects.consume(code)\n    return code === 92 ? destinationRawEscape : destinationRaw\n  }\n\n  function destinationRawEscape(code) {\n    if (code === 40 || code === 41 || code === 92) {\n      effects.consume(code)\n      return destinationRaw\n    }\n\n    return destinationRaw(code)\n  }\n}\n\nmodule.exports = destinationFactory\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar markdownSpace = require('../character/markdown-space.js')\n\n// eslint-disable-next-line max-params\nfunction labelFactory(effects, ok, nok, type, markerType, stringType) {\n  var self = this\n  var size = 0\n  var data\n  return start\n\n  function start(code) {\n    effects.enter(type)\n    effects.enter(markerType)\n    effects.consume(code)\n    effects.exit(markerType)\n    effects.enter(stringType)\n    return atBreak\n  }\n\n  function atBreak(code) {\n    if (\n      code === null ||\n      code === 91 ||\n      (code === 93 && !data) ||\n      /* c8 ignore next */\n      (code === 94 &&\n        /* c8 ignore next */\n        !size &&\n        /* c8 ignore next */\n        '_hiddenFootnoteSupport' in self.parser.constructs) ||\n      size > 999\n    ) {\n      return nok(code)\n    }\n\n    if (code === 93) {\n      effects.exit(stringType)\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return atBreak\n    }\n\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return label(code)\n  }\n\n  function label(code) {\n    if (\n      code === null ||\n      code === 91 ||\n      code === 93 ||\n      markdownLineEnding(code) ||\n      size++ > 999\n    ) {\n      effects.exit('chunkString')\n      return atBreak(code)\n    }\n\n    effects.consume(code)\n    data = data || !markdownSpace(code)\n    return code === 92 ? labelEscape : label\n  }\n\n  function labelEscape(code) {\n    if (code === 91 || code === 92 || code === 93) {\n      effects.consume(code)\n      size++\n      return label\n    }\n\n    return label(code)\n  }\n}\n\nmodule.exports = labelFactory\n","'use strict'\n\nvar markdownSpace = require('../character/markdown-space.js')\n\nfunction spaceFactory(effects, ok, type, max) {\n  var limit = max ? max - 1 : Infinity\n  var size = 0\n  return start\n\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type)\n      return prefix(code)\n    }\n\n    return ok(code)\n  }\n\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code)\n      return prefix\n    }\n\n    effects.exit(type)\n    return ok(code)\n  }\n}\n\nmodule.exports = spaceFactory\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar factorySpace = require('./factory-space.js')\n\nfunction titleFactory(effects, ok, nok, type, markerType, stringType) {\n  var marker\n  return start\n\n  function start(code) {\n    effects.enter(type)\n    effects.enter(markerType)\n    effects.consume(code)\n    effects.exit(markerType)\n    marker = code === 40 ? 41 : code\n    return atFirstTitleBreak\n  }\n\n  function atFirstTitleBreak(code) {\n    if (code === marker) {\n      effects.enter(markerType)\n      effects.consume(code)\n      effects.exit(markerType)\n      effects.exit(type)\n      return ok\n    }\n\n    effects.enter(stringType)\n    return atTitleBreak(code)\n  }\n\n  function atTitleBreak(code) {\n    if (code === marker) {\n      effects.exit(stringType)\n      return atFirstTitleBreak(marker)\n    }\n\n    if (code === null) {\n      return nok(code)\n    } // Note: blank lines cant exist in content.\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return factorySpace(effects, atTitleBreak, 'linePrefix')\n    }\n\n    effects.enter('chunkString', {\n      contentType: 'string'\n    })\n    return title(code)\n  }\n\n  function title(code) {\n    if (code === marker || code === null || markdownLineEnding(code)) {\n      effects.exit('chunkString')\n      return atTitleBreak(code)\n    }\n\n    effects.consume(code)\n    return code === 92 ? titleEscape : title\n  }\n\n  function titleEscape(code) {\n    if (code === marker || code === 92) {\n      effects.consume(code)\n      return title\n    }\n\n    return title(code)\n  }\n}\n\nmodule.exports = titleFactory\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar markdownSpace = require('../character/markdown-space.js')\nvar factorySpace = require('./factory-space.js')\n\nfunction whitespaceFactory(effects, ok) {\n  var seen\n  return start\n\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      seen = true\n      return start\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(\n        effects,\n        start,\n        seen ? 'linePrefix' : 'lineSuffix'\n      )(code)\n    }\n\n    return ok(code)\n  }\n}\n\nmodule.exports = whitespaceFactory\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\n\nvar hardBreakEscape = {\n  name: 'hardBreakEscape',\n  tokenize: tokenizeHardBreakEscape\n}\n\nfunction tokenizeHardBreakEscape(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    effects.enter('hardBreakEscape')\n    effects.enter('escapeMarker')\n    effects.consume(code)\n    return open\n  }\n\n  function open(code) {\n    if (markdownLineEnding(code)) {\n      effects.exit('escapeMarker')\n      effects.exit('hardBreakEscape')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\nmodule.exports = hardBreakEscape\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space.js')\nvar markdownSpace = require('../character/markdown-space.js')\nvar chunkedSplice = require('../util/chunked-splice.js')\nvar factorySpace = require('./factory-space.js')\n\nvar headingAtx = {\n  name: 'headingAtx',\n  tokenize: tokenizeHeadingAtx,\n  resolve: resolveHeadingAtx\n}\n\nfunction resolveHeadingAtx(events, context) {\n  var contentEnd = events.length - 2\n  var contentStart = 3\n  var content\n  var text // Prefix whitespace, part of the opening.\n\n  if (events[contentStart][1].type === 'whitespace') {\n    contentStart += 2\n  } // Suffix whitespace, part of the closing.\n\n  if (\n    contentEnd - 2 > contentStart &&\n    events[contentEnd][1].type === 'whitespace'\n  ) {\n    contentEnd -= 2\n  }\n\n  if (\n    events[contentEnd][1].type === 'atxHeadingSequence' &&\n    (contentStart === contentEnd - 1 ||\n      (contentEnd - 4 > contentStart &&\n        events[contentEnd - 2][1].type === 'whitespace'))\n  ) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4\n  }\n\n  if (contentEnd > contentStart) {\n    content = {\n      type: 'atxHeadingText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    }\n    text = {\n      type: 'chunkText',\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      contentType: 'text'\n    }\n    chunkedSplice(events, contentStart, contentEnd - contentStart + 1, [\n      ['enter', content, context],\n      ['enter', text, context],\n      ['exit', text, context],\n      ['exit', content, context]\n    ])\n  }\n\n  return events\n}\n\nfunction tokenizeHeadingAtx(effects, ok, nok) {\n  var self = this\n  var size = 0\n  return start\n\n  function start(code) {\n    effects.enter('atxHeading')\n    effects.enter('atxHeadingSequence')\n    return fenceOpenInside(code)\n  }\n\n  function fenceOpenInside(code) {\n    if (code === 35 && size++ < 6) {\n      effects.consume(code)\n      return fenceOpenInside\n    }\n\n    if (code === null || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingSequence')\n      return self.interrupt ? ok(code) : headingBreak(code)\n    }\n\n    return nok(code)\n  }\n\n  function headingBreak(code) {\n    if (code === 35) {\n      effects.enter('atxHeadingSequence')\n      return sequence(code)\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('atxHeading')\n      return ok(code)\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, headingBreak, 'whitespace')(code)\n    }\n\n    effects.enter('atxHeadingText')\n    return data(code)\n  }\n\n  function sequence(code) {\n    if (code === 35) {\n      effects.consume(code)\n      return sequence\n    }\n\n    effects.exit('atxHeadingSequence')\n    return headingBreak(code)\n  }\n\n  function data(code) {\n    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {\n      effects.exit('atxHeadingText')\n      return headingBreak(code)\n    }\n\n    effects.consume(code)\n    return data\n  }\n}\n\nmodule.exports = headingAtx\n","'use strict'\n\nvar asciiAlpha = require('../character/ascii-alpha.js')\nvar asciiAlphanumeric = require('../character/ascii-alphanumeric.js')\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space.js')\nvar markdownSpace = require('../character/markdown-space.js')\nvar fromCharCode = require('../constant/from-char-code.js')\nvar htmlBlockNames = require('../constant/html-block-names.js')\nvar htmlRawNames = require('../constant/html-raw-names.js')\nvar partialBlankLine = require('./partial-blank-line.js')\n\nvar htmlFlow = {\n  name: 'htmlFlow',\n  tokenize: tokenizeHtmlFlow,\n  resolveTo: resolveToHtmlFlow,\n  concrete: true\n}\nvar nextBlankConstruct = {\n  tokenize: tokenizeNextBlank,\n  partial: true\n}\n\nfunction resolveToHtmlFlow(events) {\n  var index = events.length\n\n  while (index--) {\n    if (events[index][0] === 'enter' && events[index][1].type === 'htmlFlow') {\n      break\n    }\n  }\n\n  if (index > 1 && events[index - 2][1].type === 'linePrefix') {\n    // Add the prefix start to the HTML token.\n    events[index][1].start = events[index - 2][1].start // Add the prefix start to the HTML line token.\n\n    events[index + 1][1].start = events[index - 2][1].start // Remove the line prefix.\n\n    events.splice(index - 2, 2)\n  }\n\n  return events\n}\n\nfunction tokenizeHtmlFlow(effects, ok, nok) {\n  var self = this\n  var kind\n  var startTag\n  var buffer\n  var index\n  var marker\n  return start\n\n  function start(code) {\n    effects.enter('htmlFlow')\n    effects.enter('htmlFlowData')\n    effects.consume(code)\n    return open\n  }\n\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code)\n      return declarationStart\n    }\n\n    if (code === 47) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n\n    if (code === 63) {\n      effects.consume(code)\n      kind = 3 // While were in an instruction instead of a declaration, were on a `?`\n      // right now, so we do need to search for `>`, similar to declarations.\n\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      buffer = fromCharCode(code)\n      startTag = true\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  function declarationStart(code) {\n    if (code === 45) {\n      effects.consume(code)\n      kind = 2\n      return commentOpenInside\n    }\n\n    if (code === 91) {\n      effects.consume(code)\n      kind = 5\n      buffer = 'CDATA['\n      index = 0\n      return cdataOpenInside\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      kind = 4\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n\n  function commentOpenInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return self.interrupt ? ok : continuationDeclarationInside\n    }\n\n    return nok(code)\n  }\n\n  function cdataOpenInside(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === buffer.length\n        ? self.interrupt\n          ? ok\n          : continuation\n        : cdataOpenInside\n    }\n\n    return nok(code)\n  }\n\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      buffer = fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  function tagName(code) {\n    if (\n      code === null ||\n      code === 47 ||\n      code === 62 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      if (\n        code !== 47 &&\n        startTag &&\n        htmlRawNames.indexOf(buffer.toLowerCase()) > -1\n      ) {\n        kind = 1\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      if (htmlBlockNames.indexOf(buffer.toLowerCase()) > -1) {\n        kind = 6\n\n        if (code === 47) {\n          effects.consume(code)\n          return basicSelfClosing\n        }\n\n        return self.interrupt ? ok(code) : continuation(code)\n      }\n\n      kind = 7 // Do not support complete HTML when interrupting.\n\n      return self.interrupt\n        ? nok(code)\n        : startTag\n        ? completeAttributeNameBefore(code)\n        : completeClosingTagAfter(code)\n    }\n\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      buffer += fromCharCode(code)\n      return tagName\n    }\n\n    return nok(code)\n  }\n\n  function basicSelfClosing(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return self.interrupt ? ok : continuation\n    }\n\n    return nok(code)\n  }\n\n  function completeClosingTagAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeClosingTagAfter\n    }\n\n    return completeEnd(code)\n  }\n\n  function completeAttributeNameBefore(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return completeEnd\n    }\n\n    if (code === 58 || code === 95 || asciiAlpha(code)) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameBefore\n    }\n\n    return completeEnd(code)\n  }\n\n  function completeAttributeName(code) {\n    if (\n      code === 45 ||\n      code === 46 ||\n      code === 58 ||\n      code === 95 ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return completeAttributeName\n    }\n\n    return completeAttributeNameAfter(code)\n  }\n\n  function completeAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeNameAfter\n    }\n\n    return completeAttributeNameBefore(code)\n  }\n\n  function completeAttributeValueBefore(code) {\n    if (\n      code === null ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n\n    if (code === 34 || code === 39) {\n      effects.consume(code)\n      marker = code\n      return completeAttributeValueQuoted\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAttributeValueBefore\n    }\n\n    marker = undefined\n    return completeAttributeValueUnquoted(code)\n  }\n\n  function completeAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return completeAttributeValueQuotedAfter\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      return nok(code)\n    }\n\n    effects.consume(code)\n    return completeAttributeValueQuoted\n  }\n\n  function completeAttributeValueUnquoted(code) {\n    if (\n      code === null ||\n      code === 34 ||\n      code === 39 ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96 ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      return completeAttributeNameAfter(code)\n    }\n\n    effects.consume(code)\n    return completeAttributeValueUnquoted\n  }\n\n  function completeAttributeValueQuotedAfter(code) {\n    if (code === 47 || code === 62 || markdownSpace(code)) {\n      return completeAttributeNameBefore(code)\n    }\n\n    return nok(code)\n  }\n\n  function completeEnd(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return nok(code)\n  }\n\n  function completeAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return completeAfter\n    }\n\n    return code === null || markdownLineEnding(code)\n      ? continuation(code)\n      : nok(code)\n  }\n\n  function continuation(code) {\n    if (code === 45 && kind === 2) {\n      effects.consume(code)\n      return continuationCommentInside\n    }\n\n    if (code === 60 && kind === 1) {\n      effects.consume(code)\n      return continuationRawTagOpen\n    }\n\n    if (code === 62 && kind === 4) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    if (code === 63 && kind === 3) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    if (code === 93 && kind === 5) {\n      effects.consume(code)\n      return continuationCharacterDataInside\n    }\n\n    if (markdownLineEnding(code) && (kind === 6 || kind === 7)) {\n      return effects.check(\n        nextBlankConstruct,\n        continuationClose,\n        continuationAtLineEnding\n      )(code)\n    }\n\n    if (code === null || markdownLineEnding(code)) {\n      return continuationAtLineEnding(code)\n    }\n\n    effects.consume(code)\n    return continuation\n  }\n\n  function continuationAtLineEnding(code) {\n    effects.exit('htmlFlowData')\n    return htmlContinueStart(code)\n  }\n\n  function htmlContinueStart(code) {\n    if (code === null) {\n      return done(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      return htmlContinueStart\n    }\n\n    effects.enter('htmlFlowData')\n    return continuation(code)\n  }\n\n  function continuationCommentInside(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  function continuationRawTagOpen(code) {\n    if (code === 47) {\n      effects.consume(code)\n      buffer = ''\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n\n  function continuationRawEndTag(code) {\n    if (code === 62 && htmlRawNames.indexOf(buffer.toLowerCase()) > -1) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    if (asciiAlpha(code) && buffer.length < 8) {\n      effects.consume(code)\n      buffer += fromCharCode(code)\n      return continuationRawEndTag\n    }\n\n    return continuation(code)\n  }\n\n  function continuationCharacterDataInside(code) {\n    if (code === 93) {\n      effects.consume(code)\n      return continuationDeclarationInside\n    }\n\n    return continuation(code)\n  }\n\n  function continuationDeclarationInside(code) {\n    if (code === 62) {\n      effects.consume(code)\n      return continuationClose\n    }\n\n    return continuation(code)\n  }\n\n  function continuationClose(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('htmlFlowData')\n      return done(code)\n    }\n\n    effects.consume(code)\n    return continuationClose\n  }\n\n  function done(code) {\n    effects.exit('htmlFlow')\n    return ok(code)\n  }\n}\n\nfunction tokenizeNextBlank(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    effects.exit('htmlFlowData')\n    effects.enter('lineEndingBlank')\n    effects.consume(code)\n    effects.exit('lineEndingBlank')\n    return effects.attempt(partialBlankLine, ok, nok)\n  }\n}\n\nmodule.exports = htmlFlow\n","'use strict'\n\nvar asciiAlpha = require('../character/ascii-alpha.js')\nvar asciiAlphanumeric = require('../character/ascii-alphanumeric.js')\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space.js')\nvar markdownSpace = require('../character/markdown-space.js')\nvar factorySpace = require('./factory-space.js')\n\nvar htmlText = {\n  name: 'htmlText',\n  tokenize: tokenizeHtmlText\n}\n\nfunction tokenizeHtmlText(effects, ok, nok) {\n  var self = this\n  var marker\n  var buffer\n  var index\n  var returnState\n  return start\n\n  function start(code) {\n    effects.enter('htmlText')\n    effects.enter('htmlTextData')\n    effects.consume(code)\n    return open\n  }\n\n  function open(code) {\n    if (code === 33) {\n      effects.consume(code)\n      return declarationOpen\n    }\n\n    if (code === 47) {\n      effects.consume(code)\n      return tagCloseStart\n    }\n\n    if (code === 63) {\n      effects.consume(code)\n      return instruction\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n\n    return nok(code)\n  }\n\n  function declarationOpen(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentOpen\n    }\n\n    if (code === 91) {\n      effects.consume(code)\n      buffer = 'CDATA['\n      index = 0\n      return cdataOpen\n    }\n\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return declaration\n    }\n\n    return nok(code)\n  }\n\n  function commentOpen(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return commentStart\n    }\n\n    return nok(code)\n  }\n\n  function commentStart(code) {\n    if (code === null || code === 62) {\n      return nok(code)\n    }\n\n    if (code === 45) {\n      effects.consume(code)\n      return commentStartDash\n    }\n\n    return comment(code)\n  }\n\n  function commentStartDash(code) {\n    if (code === null || code === 62) {\n      return nok(code)\n    }\n\n    return comment(code)\n  }\n\n  function comment(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (code === 45) {\n      effects.consume(code)\n      return commentClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = comment\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return comment\n  }\n\n  function commentClose(code) {\n    if (code === 45) {\n      effects.consume(code)\n      return end\n    }\n\n    return comment(code)\n  }\n\n  function cdataOpen(code) {\n    if (code === buffer.charCodeAt(index++)) {\n      effects.consume(code)\n      return index === buffer.length ? cdata : cdataOpen\n    }\n\n    return nok(code)\n  }\n\n  function cdata(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (code === 93) {\n      effects.consume(code)\n      return cdataClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = cdata\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return cdata\n  }\n\n  function cdataClose(code) {\n    if (code === 93) {\n      effects.consume(code)\n      return cdataEnd\n    }\n\n    return cdata(code)\n  }\n\n  function cdataEnd(code) {\n    if (code === 62) {\n      return end(code)\n    }\n\n    if (code === 93) {\n      effects.consume(code)\n      return cdataEnd\n    }\n\n    return cdata(code)\n  }\n\n  function declaration(code) {\n    if (code === null || code === 62) {\n      return end(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = declaration\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return declaration\n  }\n\n  function instruction(code) {\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (code === 63) {\n      effects.consume(code)\n      return instructionClose\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = instruction\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return instruction\n  }\n\n  function instructionClose(code) {\n    return code === 62 ? end(code) : instruction(code)\n  }\n\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n\n    return nok(code)\n  }\n\n  function tagClose(code) {\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagClose\n    }\n\n    return tagCloseBetween(code)\n  }\n\n  function tagCloseBetween(code) {\n    if (markdownLineEnding(code)) {\n      returnState = tagCloseBetween\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagCloseBetween\n    }\n\n    return end(code)\n  }\n\n  function tagOpen(code) {\n    if (code === 45 || asciiAlphanumeric(code)) {\n      effects.consume(code)\n      return tagOpen\n    }\n\n    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n\n    return nok(code)\n  }\n\n  function tagOpenBetween(code) {\n    if (code === 47) {\n      effects.consume(code)\n      return end\n    }\n\n    if (code === 58 || code === 95 || asciiAlpha(code)) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenBetween\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenBetween\n    }\n\n    return end(code)\n  }\n\n  function tagOpenAttributeName(code) {\n    if (\n      code === 45 ||\n      code === 46 ||\n      code === 58 ||\n      code === 95 ||\n      asciiAlphanumeric(code)\n    ) {\n      effects.consume(code)\n      return tagOpenAttributeName\n    }\n\n    return tagOpenAttributeNameAfter(code)\n  }\n\n  function tagOpenAttributeNameAfter(code) {\n    if (code === 61) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeNameAfter\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeNameAfter\n    }\n\n    return tagOpenBetween(code)\n  }\n\n  function tagOpenAttributeValueBefore(code) {\n    if (\n      code === null ||\n      code === 60 ||\n      code === 61 ||\n      code === 62 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n\n    if (code === 34 || code === 39) {\n      effects.consume(code)\n      marker = code\n      return tagOpenAttributeValueQuoted\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueBefore\n      return atLineEnding(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return tagOpenAttributeValueBefore\n    }\n\n    effects.consume(code)\n    marker = undefined\n    return tagOpenAttributeValueUnquoted\n  }\n\n  function tagOpenAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return tagOpenAttributeValueQuotedAfter\n    }\n\n    if (code === null) {\n      return nok(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueQuoted\n      return atLineEnding(code)\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueQuoted\n  }\n\n  function tagOpenAttributeValueQuotedAfter(code) {\n    if (code === 62 || code === 47 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n\n    return nok(code)\n  }\n\n  function tagOpenAttributeValueUnquoted(code) {\n    if (\n      code === null ||\n      code === 34 ||\n      code === 39 ||\n      code === 60 ||\n      code === 61 ||\n      code === 96\n    ) {\n      return nok(code)\n    }\n\n    if (code === 62 || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code)\n    }\n\n    effects.consume(code)\n    return tagOpenAttributeValueUnquoted\n  } // We cant have blank lines in content, so no need to worry about empty\n  // tokens.\n\n  function atLineEnding(code) {\n    effects.exit('htmlTextData')\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(\n      effects,\n      afterPrefix,\n      'linePrefix',\n      self.parser.constructs.disable.null.indexOf('codeIndented') > -1\n        ? undefined\n        : 4\n    )\n  }\n\n  function afterPrefix(code) {\n    effects.enter('htmlTextData')\n    return returnState(code)\n  }\n\n  function end(code) {\n    if (code === 62) {\n      effects.consume(code)\n      effects.exit('htmlTextData')\n      effects.exit('htmlText')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n\nmodule.exports = htmlText\n","'use strict'\n\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space.js')\nvar chunkedPush = require('../util/chunked-push.js')\nvar chunkedSplice = require('../util/chunked-splice.js')\nvar normalizeIdentifier = require('../util/normalize-identifier.js')\nvar resolveAll = require('../util/resolve-all.js')\nvar shallow = require('../util/shallow.js')\nvar factoryDestination = require('./factory-destination.js')\nvar factoryLabel = require('./factory-label.js')\nvar factoryTitle = require('./factory-title.js')\nvar factoryWhitespace = require('./factory-whitespace.js')\n\nvar labelEnd = {\n  name: 'labelEnd',\n  tokenize: tokenizeLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  resolveAll: resolveAllLabelEnd\n}\nvar resourceConstruct = {\n  tokenize: tokenizeResource\n}\nvar fullReferenceConstruct = {\n  tokenize: tokenizeFullReference\n}\nvar collapsedReferenceConstruct = {\n  tokenize: tokenizeCollapsedReference\n}\n\nfunction resolveAllLabelEnd(events) {\n  var index = -1\n  var token\n\n  while (++index < events.length) {\n    token = events[index][1]\n\n    if (\n      !token._used &&\n      (token.type === 'labelImage' ||\n        token.type === 'labelLink' ||\n        token.type === 'labelEnd')\n    ) {\n      // Remove the marker.\n      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2)\n      token.type = 'data'\n      index++\n    }\n  }\n\n  return events\n}\n\nfunction resolveToLabelEnd(events, context) {\n  var index = events.length\n  var offset = 0\n  var group\n  var label\n  var text\n  var token\n  var open\n  var close\n  var media // Find an opening.\n\n  while (index--) {\n    token = events[index][1]\n\n    if (open) {\n      // If we see another link, or inactive link label, weve been here before.\n      if (\n        token.type === 'link' ||\n        (token.type === 'labelLink' && token._inactive)\n      ) {\n        break\n      } // Mark other link openings as inactive, as we cant have links in\n      // links.\n\n      if (events[index][0] === 'enter' && token.type === 'labelLink') {\n        token._inactive = true\n      }\n    } else if (close) {\n      if (\n        events[index][0] === 'enter' &&\n        (token.type === 'labelImage' || token.type === 'labelLink') &&\n        !token._balanced\n      ) {\n        open = index\n\n        if (token.type !== 'labelLink') {\n          offset = 2\n          break\n        }\n      }\n    } else if (token.type === 'labelEnd') {\n      close = index\n    }\n  }\n\n  group = {\n    type: events[open][1].type === 'labelLink' ? 'link' : 'image',\n    start: shallow(events[open][1].start),\n    end: shallow(events[events.length - 1][1].end)\n  }\n  label = {\n    type: 'label',\n    start: shallow(events[open][1].start),\n    end: shallow(events[close][1].end)\n  }\n  text = {\n    type: 'labelText',\n    start: shallow(events[open + offset + 2][1].end),\n    end: shallow(events[close - 2][1].start)\n  }\n  media = [\n    ['enter', group, context],\n    ['enter', label, context]\n  ] // Opening marker.\n\n  media = chunkedPush(media, events.slice(open + 1, open + offset + 3)) // Text open.\n\n  media = chunkedPush(media, [['enter', text, context]]) // Between.\n\n  media = chunkedPush(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  ) // Text close, marker close, label close.\n\n  media = chunkedPush(media, [\n    ['exit', text, context],\n    events[close - 2],\n    events[close - 1],\n    ['exit', label, context]\n  ]) // Reference, resource, or so.\n\n  media = chunkedPush(media, events.slice(close + 1)) // Media close.\n\n  media = chunkedPush(media, [['exit', group, context]])\n  chunkedSplice(events, open, events.length, media)\n  return events\n}\n\nfunction tokenizeLabelEnd(effects, ok, nok) {\n  var self = this\n  var index = self.events.length\n  var labelStart\n  var defined // Find an opening.\n\n  while (index--) {\n    if (\n      (self.events[index][1].type === 'labelImage' ||\n        self.events[index][1].type === 'labelLink') &&\n      !self.events[index][1]._balanced\n    ) {\n      labelStart = self.events[index][1]\n      break\n    }\n  }\n\n  return start\n\n  function start(code) {\n    if (!labelStart) {\n      return nok(code)\n    } // Its a balanced bracket, but contains a link.\n\n    if (labelStart._inactive) return balanced(code)\n    defined =\n      self.parser.defined.indexOf(\n        normalizeIdentifier(\n          self.sliceSerialize({\n            start: labelStart.end,\n            end: self.now()\n          })\n        )\n      ) > -1\n    effects.enter('labelEnd')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelEnd')\n    return afterLabelEnd\n  }\n\n  function afterLabelEnd(code) {\n    // Resource: `[asd](fgh)`.\n    if (code === 40) {\n      return effects.attempt(\n        resourceConstruct,\n        ok,\n        defined ? ok : balanced\n      )(code)\n    } // Collapsed (`[asd][]`) or full (`[asd][fgh]`) reference?\n\n    if (code === 91) {\n      return effects.attempt(\n        fullReferenceConstruct,\n        ok,\n        defined\n          ? effects.attempt(collapsedReferenceConstruct, ok, balanced)\n          : balanced\n      )(code)\n    } // Shortcut reference: `[asd]`?\n\n    return defined ? ok(code) : balanced(code)\n  }\n\n  function balanced(code) {\n    labelStart._balanced = true\n    return nok(code)\n  }\n}\n\nfunction tokenizeResource(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    effects.enter('resource')\n    effects.enter('resourceMarker')\n    effects.consume(code)\n    effects.exit('resourceMarker')\n    return factoryWhitespace(effects, open)\n  }\n\n  function open(code) {\n    if (code === 41) {\n      return end(code)\n    }\n\n    return factoryDestination(\n      effects,\n      destinationAfter,\n      nok,\n      'resourceDestination',\n      'resourceDestinationLiteral',\n      'resourceDestinationLiteralMarker',\n      'resourceDestinationRaw',\n      'resourceDestinationString',\n      3\n    )(code)\n  }\n\n  function destinationAfter(code) {\n    return markdownLineEndingOrSpace(code)\n      ? factoryWhitespace(effects, between)(code)\n      : end(code)\n  }\n\n  function between(code) {\n    if (code === 34 || code === 39 || code === 40) {\n      return factoryTitle(\n        effects,\n        factoryWhitespace(effects, end),\n        nok,\n        'resourceTitle',\n        'resourceTitleMarker',\n        'resourceTitleString'\n      )(code)\n    }\n\n    return end(code)\n  }\n\n  function end(code) {\n    if (code === 41) {\n      effects.enter('resourceMarker')\n      effects.consume(code)\n      effects.exit('resourceMarker')\n      effects.exit('resource')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n\nfunction tokenizeFullReference(effects, ok, nok) {\n  var self = this\n  return start\n\n  function start(code) {\n    return factoryLabel.call(\n      self,\n      effects,\n      afterLabel,\n      nok,\n      'reference',\n      'referenceMarker',\n      'referenceString'\n    )(code)\n  }\n\n  function afterLabel(code) {\n    return self.parser.defined.indexOf(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    ) < 0\n      ? nok(code)\n      : ok(code)\n  }\n}\n\nfunction tokenizeCollapsedReference(effects, ok, nok) {\n  return start\n\n  function start(code) {\n    effects.enter('reference')\n    effects.enter('referenceMarker')\n    effects.consume(code)\n    effects.exit('referenceMarker')\n    return open\n  }\n\n  function open(code) {\n    if (code === 93) {\n      effects.enter('referenceMarker')\n      effects.consume(code)\n      effects.exit('referenceMarker')\n      effects.exit('reference')\n      return ok\n    }\n\n    return nok(code)\n  }\n}\n\nmodule.exports = labelEnd\n","'use strict'\n\nvar labelEnd = require('./label-end.js')\n\nvar labelStartImage = {\n  name: 'labelStartImage',\n  tokenize: tokenizeLabelStartImage,\n  resolveAll: labelEnd.resolveAll\n}\n\nfunction tokenizeLabelStartImage(effects, ok, nok) {\n  var self = this\n  return start\n\n  function start(code) {\n    effects.enter('labelImage')\n    effects.enter('labelImageMarker')\n    effects.consume(code)\n    effects.exit('labelImageMarker')\n    return open\n  }\n\n  function open(code) {\n    if (code === 91) {\n      effects.enter('labelMarker')\n      effects.consume(code)\n      effects.exit('labelMarker')\n      effects.exit('labelImage')\n      return after\n    }\n\n    return nok(code)\n  }\n\n  function after(code) {\n    /* c8 ignore next */\n    return code === 94 &&\n      /* c8 ignore next */\n      '_hiddenFootnoteSupport' in self.parser.constructs\n      ? /* c8 ignore next */\n        nok(code)\n      : ok(code)\n  }\n}\n\nmodule.exports = labelStartImage\n","'use strict'\n\nvar labelEnd = require('./label-end.js')\n\nvar labelStartLink = {\n  name: 'labelStartLink',\n  tokenize: tokenizeLabelStartLink,\n  resolveAll: labelEnd.resolveAll\n}\n\nfunction tokenizeLabelStartLink(effects, ok, nok) {\n  var self = this\n  return start\n\n  function start(code) {\n    effects.enter('labelLink')\n    effects.enter('labelMarker')\n    effects.consume(code)\n    effects.exit('labelMarker')\n    effects.exit('labelLink')\n    return after\n  }\n\n  function after(code) {\n    /* c8 ignore next */\n    return code === 94 &&\n      /* c8 ignore next */\n      '_hiddenFootnoteSupport' in self.parser.constructs\n      ? /* c8 ignore next */\n        nok(code)\n      : ok(code)\n  }\n}\n\nmodule.exports = labelStartLink\n","'use strict'\n\nvar factorySpace = require('./factory-space.js')\n\nvar lineEnding = {\n  name: 'lineEnding',\n  tokenize: tokenizeLineEnding\n}\n\nfunction tokenizeLineEnding(effects, ok) {\n  return start\n\n  function start(code) {\n    effects.enter('lineEnding')\n    effects.consume(code)\n    effects.exit('lineEnding')\n    return factorySpace(effects, ok, 'linePrefix')\n  }\n}\n\nmodule.exports = lineEnding\n","'use strict'\n\nvar asciiDigit = require('../character/ascii-digit.js')\nvar markdownSpace = require('../character/markdown-space.js')\nvar prefixSize = require('../util/prefix-size.js')\nvar sizeChunks = require('../util/size-chunks.js')\nvar factorySpace = require('./factory-space.js')\nvar partialBlankLine = require('./partial-blank-line.js')\nvar thematicBreak = require('./thematic-break.js')\n\nvar list = {\n  name: 'list',\n  tokenize: tokenizeListStart,\n  continuation: {\n    tokenize: tokenizeListContinuation\n  },\n  exit: tokenizeListEnd\n}\nvar listItemPrefixWhitespaceConstruct = {\n  tokenize: tokenizeListItemPrefixWhitespace,\n  partial: true\n}\nvar indentConstruct = {\n  tokenize: tokenizeIndent,\n  partial: true\n}\n\nfunction tokenizeListStart(effects, ok, nok) {\n  var self = this\n  var initialSize = prefixSize(self.events, 'linePrefix')\n  var size = 0\n  return start\n\n  function start(code) {\n    var kind =\n      self.containerState.type ||\n      (code === 42 || code === 43 || code === 45\n        ? 'listUnordered'\n        : 'listOrdered')\n\n    if (\n      kind === 'listUnordered'\n        ? !self.containerState.marker || code === self.containerState.marker\n        : asciiDigit(code)\n    ) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind\n        effects.enter(kind, {\n          _container: true\n        })\n      }\n\n      if (kind === 'listUnordered') {\n        effects.enter('listItemPrefix')\n        return code === 42 || code === 45\n          ? effects.check(thematicBreak, nok, atMarker)(code)\n          : atMarker(code)\n      }\n\n      if (!self.interrupt || code === 49) {\n        effects.enter('listItemPrefix')\n        effects.enter('listItemValue')\n        return inside(code)\n      }\n    }\n\n    return nok(code)\n  }\n\n  function inside(code) {\n    if (asciiDigit(code) && ++size < 10) {\n      effects.consume(code)\n      return inside\n    }\n\n    if (\n      (!self.interrupt || size < 2) &&\n      (self.containerState.marker\n        ? code === self.containerState.marker\n        : code === 41 || code === 46)\n    ) {\n      effects.exit('listItemValue')\n      return atMarker(code)\n    }\n\n    return nok(code)\n  }\n\n  function atMarker(code) {\n    effects.enter('listItemMarker')\n    effects.consume(code)\n    effects.exit('listItemMarker')\n    self.containerState.marker = self.containerState.marker || code\n    return effects.check(\n      partialBlankLine, // Cant be empty when interrupting.\n      self.interrupt ? nok : onBlank,\n      effects.attempt(\n        listItemPrefixWhitespaceConstruct,\n        endOfPrefix,\n        otherPrefix\n      )\n    )\n  }\n\n  function onBlank(code) {\n    self.containerState.initialBlankLine = true\n    initialSize++\n    return endOfPrefix(code)\n  }\n\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter('listItemPrefixWhitespace')\n      effects.consume(code)\n      effects.exit('listItemPrefixWhitespace')\n      return endOfPrefix\n    }\n\n    return nok(code)\n  }\n\n  function endOfPrefix(code) {\n    self.containerState.size =\n      initialSize + sizeChunks(self.sliceStream(effects.exit('listItemPrefix')))\n    return ok(code)\n  }\n}\n\nfunction tokenizeListContinuation(effects, ok, nok) {\n  var self = this\n  self.containerState._closeFlow = undefined\n  return effects.check(partialBlankLine, onBlank, notBlank)\n\n  function onBlank(code) {\n    self.containerState.furtherBlankLines =\n      self.containerState.furtherBlankLines ||\n      self.containerState.initialBlankLine // We have a blank line.\n    // Still, try to consume at most the items size.\n\n    return factorySpace(\n      effects,\n      ok,\n      'listItemIndent',\n      self.containerState.size + 1\n    )(code)\n  }\n\n  function notBlank(code) {\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = self.containerState.initialBlankLine = undefined\n      return notInCurrentItem(code)\n    }\n\n    self.containerState.furtherBlankLines = self.containerState.initialBlankLine = undefined\n    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)\n  }\n\n  function notInCurrentItem(code) {\n    // While we do continue, we signal that the flow should be closed.\n    self.containerState._closeFlow = true // As were closing flow, were no longer interrupting.\n\n    self.interrupt = undefined\n    return factorySpace(\n      effects,\n      effects.attempt(list, ok, nok),\n      'linePrefix',\n      self.parser.constructs.disable.null.indexOf('codeIndented') > -1\n        ? undefined\n        : 4\n    )(code)\n  }\n}\n\nfunction tokenizeIndent(effects, ok, nok) {\n  var self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemIndent',\n    self.containerState.size + 1\n  )\n\n  function afterPrefix(code) {\n    return prefixSize(self.events, 'listItemIndent') ===\n      self.containerState.size\n      ? ok(code)\n      : nok(code)\n  }\n}\n\nfunction tokenizeListEnd(effects) {\n  effects.exit(this.containerState.type)\n}\n\nfunction tokenizeListItemPrefixWhitespace(effects, ok, nok) {\n  var self = this\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'listItemPrefixWhitespace',\n    self.parser.constructs.disable.null.indexOf('codeIndented') > -1\n      ? undefined\n      : 4 + 1\n  )\n\n  function afterPrefix(code) {\n    return markdownSpace(code) ||\n      !prefixSize(self.events, 'listItemPrefixWhitespace')\n      ? nok(code)\n      : ok(code)\n  }\n}\n\nmodule.exports = list\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar factorySpace = require('./factory-space.js')\n\nvar partialBlankLine = {\n  tokenize: tokenizePartialBlankLine,\n  partial: true\n}\n\nfunction tokenizePartialBlankLine(effects, ok, nok) {\n  return factorySpace(effects, afterWhitespace, 'linePrefix')\n\n  function afterWhitespace(code) {\n    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)\n  }\n}\n\nmodule.exports = partialBlankLine\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar shallow = require('../util/shallow.js')\nvar factorySpace = require('./factory-space.js')\n\nvar setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n}\n\nfunction resolveToSetextUnderline(events, context) {\n  var index = events.length\n  var content\n  var text\n  var definition\n  var heading // Find the opening of the content.\n  // Itll always exist: we dont tokenize if it isnt there.\n\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === 'content') {\n        content = index\n        break\n      }\n\n      if (events[index][1].type === 'paragraph') {\n        text = index\n      }\n    } // Exit\n    else {\n      if (events[index][1].type === 'content') {\n        // Remove the content end (if needed well add it later)\n        events.splice(index, 1)\n      }\n\n      if (!definition && events[index][1].type === 'definition') {\n        definition = index\n      }\n    }\n  }\n\n  heading = {\n    type: 'setextHeading',\n    start: shallow(events[text][1].start),\n    end: shallow(events[events.length - 1][1].end)\n  } // Change the paragraph to setext heading text.\n\n  events[text][1].type = 'setextHeadingText' // If we have definitions in the content, well keep on having content,\n  // but we need move it.\n\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context])\n    events.splice(definition + 1, 0, ['exit', events[content][1], context])\n    events[content][1].end = shallow(events[definition][1].end)\n  } else {\n    events[content][1] = heading\n  } // Add the heading exit at the end.\n\n  events.push(['exit', heading, context])\n  return events\n}\n\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  var self = this\n  var index = self.events.length\n  var marker\n  var paragraph // Find an opening.\n\n  while (index--) {\n    // Skip enter/exit of line ending, line prefix, and content.\n    // We can now either have a definition or a paragraph.\n    if (\n      self.events[index][1].type !== 'lineEnding' &&\n      self.events[index][1].type !== 'linePrefix' &&\n      self.events[index][1].type !== 'content'\n    ) {\n      paragraph = self.events[index][1].type === 'paragraph'\n      break\n    }\n  }\n\n  return start\n\n  function start(code) {\n    if (!self.lazy && (self.interrupt || paragraph)) {\n      effects.enter('setextHeadingLine')\n      effects.enter('setextHeadingLineSequence')\n      marker = code\n      return closingSequence(code)\n    }\n\n    return nok(code)\n  }\n\n  function closingSequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return closingSequence\n    }\n\n    effects.exit('setextHeadingLineSequence')\n    return factorySpace(effects, closingSequenceEnd, 'lineSuffix')(code)\n  }\n\n  function closingSequenceEnd(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('setextHeadingLine')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\nmodule.exports = setextUnderline\n","'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar markdownSpace = require('../character/markdown-space.js')\nvar factorySpace = require('./factory-space.js')\n\nvar thematicBreak = {\n  name: 'thematicBreak',\n  tokenize: tokenizeThematicBreak\n}\n\nfunction tokenizeThematicBreak(effects, ok, nok) {\n  var size = 0\n  var marker\n  return start\n\n  function start(code) {\n    effects.enter('thematicBreak')\n    marker = code\n    return atBreak(code)\n  }\n\n  function atBreak(code) {\n    if (code === marker) {\n      effects.enter('thematicBreakSequence')\n      return sequence(code)\n    }\n\n    if (markdownSpace(code)) {\n      return factorySpace(effects, atBreak, 'whitespace')(code)\n    }\n\n    if (size < 3 || (code !== null && !markdownLineEnding(code))) {\n      return nok(code)\n    }\n\n    effects.exit('thematicBreak')\n    return ok(code)\n  }\n\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      size++\n      return sequence\n    }\n\n    effects.exit('thematicBreakSequence')\n    return atBreak(code)\n  }\n}\n\nmodule.exports = thematicBreak\n","'use strict'\n\nvar chunkedSplice = require('./chunked-splice.js')\n\nfunction chunkedPush(list, items) {\n  if (list.length) {\n    chunkedSplice(list, list.length, 0, items)\n    return list\n  }\n\n  return items\n}\n\nmodule.exports = chunkedPush\n","'use strict'\n\nvar splice = require('../constant/splice.js')\n\n// causes a stack overflow in V8 when trying to insert 100k items for instance.\n\nfunction chunkedSplice(list, start, remove, items) {\n  var end = list.length\n  var chunkStart = 0\n  var parameters // Make start between zero and `end` (included).\n\n  if (start < 0) {\n    start = -start > end ? 0 : end + start\n  } else {\n    start = start > end ? end : start\n  }\n\n  remove = remove > 0 ? remove : 0 // No need to chunk the items if theres only a couple (10k) items.\n\n  if (items.length < 10000) {\n    parameters = Array.from(items)\n    parameters.unshift(start, remove)\n    splice.apply(list, parameters)\n  } else {\n    // Delete `remove` items starting from `start`\n    if (remove) splice.apply(list, [start, remove]) // Insert the items in chunks to not cause stack overflows.\n\n    while (chunkStart < items.length) {\n      parameters = items.slice(chunkStart, chunkStart + 10000)\n      parameters.unshift(start, 0)\n      splice.apply(list, parameters)\n      chunkStart += 10000\n      start += 10000\n    }\n  }\n}\n\nmodule.exports = chunkedSplice\n","'use strict'\n\nvar markdownLineEndingOrSpace = require('../character/markdown-line-ending-or-space.js')\nvar unicodePunctuation = require('../character/unicode-punctuation.js')\nvar unicodeWhitespace = require('../character/unicode-whitespace.js')\n\n// Classify whether a character is unicode whitespace, unicode punctuation, or\n// anything else.\n// Used for attention (emphasis, strong), whose sequences can open or close\n// based on the class of surrounding characters.\nfunction classifyCharacter(code) {\n  if (\n    code === null ||\n    markdownLineEndingOrSpace(code) ||\n    unicodeWhitespace(code)\n  ) {\n    return 1\n  }\n\n  if (unicodePunctuation(code)) {\n    return 2\n  }\n}\n\nmodule.exports = classifyCharacter\n","'use strict'\n\nvar hasOwnProperty = require('../constant/has-own-property.js')\nvar chunkedSplice = require('./chunked-splice.js')\nvar miniflat = require('./miniflat.js')\n\nfunction combineExtensions(extensions) {\n  var all = {}\n  var index = -1\n\n  while (++index < extensions.length) {\n    extension(all, extensions[index])\n  }\n\n  return all\n}\n\nfunction extension(all, extension) {\n  var hook\n  var left\n  var right\n  var code\n\n  for (hook in extension) {\n    left = hasOwnProperty.call(all, hook) ? all[hook] : (all[hook] = {})\n    right = extension[hook]\n\n    for (code in right) {\n      left[code] = constructs(\n        miniflat(right[code]),\n        hasOwnProperty.call(left, code) ? left[code] : []\n      )\n    }\n  }\n}\n\nfunction constructs(list, existing) {\n  var index = -1\n  var before = []\n\n  while (++index < list.length) {\n    ;(list[index].add === 'after' ? existing : before).push(list[index])\n  }\n\n  chunkedSplice(existing, 0, 0, before)\n  return existing\n}\n\nmodule.exports = combineExtensions\n","'use strict'\n\nvar assign = require('../constant/assign.js')\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar chunkedPush = require('./chunked-push.js')\nvar chunkedSplice = require('./chunked-splice.js')\nvar miniflat = require('./miniflat.js')\nvar resolveAll = require('./resolve-all.js')\nvar serializeChunks = require('./serialize-chunks.js')\nvar shallow = require('./shallow.js')\nvar sliceChunks = require('./slice-chunks.js')\n\n// Create a tokenizer.\n// Tokenizers deal with one type of data (e.g., containers, flow, text).\n// The parser is the object dealing with it all.\n// `initialize` works like other constructs, except that only its `tokenize`\n// function is used, in which case it doesnt receive an `ok` or `nok`.\n// `from` can be given to set the point before the first character, although\n// when further lines are indented, they must be set with `defineSkip`.\nfunction createTokenizer(parser, initialize, from) {\n  var point = from\n    ? shallow(from)\n    : {\n        line: 1,\n        column: 1,\n        offset: 0\n      }\n  var columnStart = {}\n  var resolveAllConstructs = []\n  var chunks = []\n  var stack = []\n\n  var effects = {\n    consume: consume,\n    enter: enter,\n    exit: exit,\n    attempt: constructFactory(onsuccessfulconstruct),\n    check: constructFactory(onsuccessfulcheck),\n    interrupt: constructFactory(onsuccessfulcheck, {\n      interrupt: true\n    }),\n    lazy: constructFactory(onsuccessfulcheck, {\n      lazy: true\n    })\n  } // State and tools for resolving and serializing.\n\n  var context = {\n    previous: null,\n    events: [],\n    parser: parser,\n    sliceStream: sliceStream,\n    sliceSerialize: sliceSerialize,\n    now: now,\n    defineSkip: skip,\n    write: write\n  } // The state function.\n\n  var state = initialize.tokenize.call(context, effects) // Track which character we expect to be consumed, to catch bugs.\n\n  if (initialize.resolveAll) {\n    resolveAllConstructs.push(initialize)\n  } // Store where we are in the input stream.\n\n  point._index = 0\n  point._bufferIndex = -1\n  return context\n\n  function write(slice) {\n    chunks = chunkedPush(chunks, slice)\n    main() // Exit if were not done, resolve might change stuff.\n\n    if (chunks[chunks.length - 1] !== null) {\n      return []\n    }\n\n    addResult(initialize, 0) // Otherwise, resolve, and exit.\n\n    context.events = resolveAll(resolveAllConstructs, context.events, context)\n    return context.events\n  } //\n  // Tools.\n  //\n\n  function sliceSerialize(token) {\n    return serializeChunks(sliceStream(token))\n  }\n\n  function sliceStream(token) {\n    return sliceChunks(chunks, token)\n  }\n\n  function now() {\n    return shallow(point)\n  }\n\n  function skip(value) {\n    columnStart[value.line] = value.column\n    accountForPotentialSkip()\n  } //\n  // State management.\n  //\n  // Main loop (note that `_index` and `_bufferIndex` in `point` are modified by\n  // `consume`).\n  // Here is where we walk through the chunks, which either include strings of\n  // several characters, or numerical character codes.\n  // The reason to do this in a loop instead of a call is so the stack can\n  // drain.\n\n  function main() {\n    var chunkIndex\n    var chunk\n\n    while (point._index < chunks.length) {\n      chunk = chunks[point._index] // If were in a buffer chunk, loop through it.\n\n      if (typeof chunk === 'string') {\n        chunkIndex = point._index\n\n        if (point._bufferIndex < 0) {\n          point._bufferIndex = 0\n        }\n\n        while (\n          point._index === chunkIndex &&\n          point._bufferIndex < chunk.length\n        ) {\n          go(chunk.charCodeAt(point._bufferIndex))\n        }\n      } else {\n        go(chunk)\n      }\n    }\n  } // Deal with one code.\n\n  function go(code) {\n    state = state(code)\n  } // Move a character forward.\n\n  function consume(code) {\n    if (markdownLineEnding(code)) {\n      point.line++\n      point.column = 1\n      point.offset += code === -3 ? 2 : 1\n      accountForPotentialSkip()\n    } else if (code !== -1) {\n      point.column++\n      point.offset++\n    } // Not in a string chunk.\n\n    if (point._bufferIndex < 0) {\n      point._index++\n    } else {\n      point._bufferIndex++ // At end of string chunk.\n\n      if (point._bufferIndex === chunks[point._index].length) {\n        point._bufferIndex = -1\n        point._index++\n      }\n    } // Expose the previous character.\n\n    context.previous = code // Mark as consumed.\n  } // Start a token.\n\n  function enter(type, fields) {\n    var token = fields || {}\n    token.type = type\n    token.start = now()\n    context.events.push(['enter', token, context])\n    stack.push(token)\n    return token\n  } // Stop a token.\n\n  function exit(type) {\n    var token = stack.pop()\n    token.end = now()\n    context.events.push(['exit', token, context])\n    return token\n  } // Use results.\n\n  function onsuccessfulconstruct(construct, info) {\n    addResult(construct, info.from)\n  } // Discard results.\n\n  function onsuccessfulcheck(construct, info) {\n    info.restore()\n  } // Factory to attempt/check/interrupt.\n\n  function constructFactory(onreturn, fields) {\n    return hook // Handle either an object mapping codes to constructs, a list of\n    // constructs, or a single construct.\n\n    function hook(constructs, returnState, bogusState) {\n      var listOfConstructs\n      var constructIndex\n      var currentConstruct\n      var info\n      return constructs.tokenize || 'length' in constructs\n        ? handleListOfConstructs(miniflat(constructs))\n        : handleMapOfConstructs\n\n      function handleMapOfConstructs(code) {\n        if (code in constructs || null in constructs) {\n          return handleListOfConstructs(\n            constructs.null\n              ? /* c8 ignore next */\n                miniflat(constructs[code]).concat(miniflat(constructs.null))\n              : constructs[code]\n          )(code)\n        }\n\n        return bogusState(code)\n      }\n\n      function handleListOfConstructs(list) {\n        listOfConstructs = list\n        constructIndex = 0\n        return handleConstruct(list[constructIndex])\n      }\n\n      function handleConstruct(construct) {\n        return start\n\n        function start(code) {\n          // To do: not nede to store if there is no bogus state, probably?\n          // Currently doesnt work because `inspect` in document does a check\n          // w/o a bogus, which doesnt make sense. But it does seem to help perf\n          // by not storing.\n          info = store()\n          currentConstruct = construct\n\n          if (!construct.partial) {\n            context.currentConstruct = construct\n          }\n\n          if (\n            construct.name &&\n            context.parser.constructs.disable.null.indexOf(construct.name) > -1\n          ) {\n            return nok()\n          }\n\n          return construct.tokenize.call(\n            fields ? assign({}, context, fields) : context,\n            effects,\n            ok,\n            nok\n          )(code)\n        }\n      }\n\n      function ok(code) {\n        onreturn(currentConstruct, info)\n        return returnState\n      }\n\n      function nok(code) {\n        info.restore()\n\n        if (++constructIndex < listOfConstructs.length) {\n          return handleConstruct(listOfConstructs[constructIndex])\n        }\n\n        return bogusState\n      }\n    }\n  }\n\n  function addResult(construct, from) {\n    if (construct.resolveAll && resolveAllConstructs.indexOf(construct) < 0) {\n      resolveAllConstructs.push(construct)\n    }\n\n    if (construct.resolve) {\n      chunkedSplice(\n        context.events,\n        from,\n        context.events.length - from,\n        construct.resolve(context.events.slice(from), context)\n      )\n    }\n\n    if (construct.resolveTo) {\n      context.events = construct.resolveTo(context.events, context)\n    }\n  }\n\n  function store() {\n    var startPoint = now()\n    var startPrevious = context.previous\n    var startCurrentConstruct = context.currentConstruct\n    var startEventsIndex = context.events.length\n    var startStack = Array.from(stack)\n    return {\n      restore: restore,\n      from: startEventsIndex\n    }\n\n    function restore() {\n      point = startPoint\n      context.previous = startPrevious\n      context.currentConstruct = startCurrentConstruct\n      context.events.length = startEventsIndex\n      stack = startStack\n      accountForPotentialSkip()\n    }\n  }\n\n  function accountForPotentialSkip() {\n    if (point.line in columnStart && point.column < 2) {\n      point.column = columnStart[point.line]\n      point.offset += columnStart[point.line] - 1\n    }\n  }\n}\n\nmodule.exports = createTokenizer\n","'use strict'\n\nfunction miniflat(value) {\n  return value === null || value === undefined\n    ? []\n    : 'length' in value\n    ? value\n    : [value]\n}\n\nmodule.exports = miniflat\n","'use strict'\n\n// chunks (replacement characters, tabs, or line endings).\n\nfunction movePoint(point, offset) {\n  point.column += offset\n  point.offset += offset\n  point._bufferIndex += offset\n  return point\n}\n\nmodule.exports = movePoint\n","'use strict'\n\nfunction normalizeIdentifier(value) {\n  return (\n    value // Collapse Markdown whitespace.\n      .replace(/[\\t\\n\\r ]+/g, ' ') // Trim.\n      .replace(/^ | $/g, '') // Some characters are considered uppercase, but if their lowercase\n      // counterpart is uppercased will result in a different uppercase\n      // character.\n      // Hence, to get that form, we perform both lower- and uppercase.\n      // Upper case makes sure keys will not interact with default prototypal\n      // methods: no object method is uppercase.\n      .toLowerCase()\n      .toUpperCase()\n  )\n}\n\nmodule.exports = normalizeIdentifier\n","'use strict'\n\nvar sizeChunks = require('./size-chunks.js')\n\nfunction prefixSize(events, type) {\n  var tail = events[events.length - 1]\n  if (!tail || tail[1].type !== type) return 0\n  return sizeChunks(tail[2].sliceStream(tail[1]))\n}\n\nmodule.exports = prefixSize\n","'use strict'\n\nvar fromCharCode = require('../constant/from-char-code.js')\n\nfunction regexCheck(regex) {\n  return check\n\n  function check(code) {\n    return regex.test(fromCharCode(code))\n  }\n}\n\nmodule.exports = regexCheck\n","'use strict'\n\nfunction resolveAll(constructs, events, context) {\n  var called = []\n  var index = -1\n  var resolve\n\n  while (++index < constructs.length) {\n    resolve = constructs[index].resolveAll\n\n    if (resolve && called.indexOf(resolve) < 0) {\n      events = resolve(events, context)\n      called.push(resolve)\n    }\n  }\n\n  return events\n}\n\nmodule.exports = resolveAll\n","'use strict'\n\nvar fromCharCode = require('../constant/from-char-code.js')\n\nfunction safeFromInt(value, base) {\n  var code = parseInt(value, base)\n\n  if (\n    // C0 except for HT, LF, FF, CR, space\n    code < 9 ||\n    code === 11 ||\n    (code > 13 && code < 32) || // Control character (DEL) of the basic block and C1 controls.\n    (code > 126 && code < 160) || // Lone high surrogates and low surrogates.\n    (code > 55295 && code < 57344) || // Noncharacters.\n    (code > 64975 && code < 65008) ||\n    (code & 65535) === 65535 ||\n    (code & 65535) === 65534 || // Out of range\n    code > 1114111\n  ) {\n    return '\\uFFFD'\n  }\n\n  return fromCharCode(code)\n}\n\nmodule.exports = safeFromInt\n","'use strict'\n\nvar fromCharCode = require('../constant/from-char-code.js')\n\nfunction serializeChunks(chunks) {\n  var index = -1\n  var result = []\n  var chunk\n  var value\n  var atTab\n\n  while (++index < chunks.length) {\n    chunk = chunks[index]\n\n    if (typeof chunk === 'string') {\n      value = chunk\n    } else if (chunk === -5) {\n      value = '\\r'\n    } else if (chunk === -4) {\n      value = '\\n'\n    } else if (chunk === -3) {\n      value = '\\r' + '\\n'\n    } else if (chunk === -2) {\n      value = '\\t'\n    } else if (chunk === -1) {\n      if (atTab) continue\n      value = ' '\n    } else {\n      // Currently only replacement character.\n      value = fromCharCode(chunk)\n    }\n\n    atTab = chunk === -2\n    result.push(value)\n  }\n\n  return result.join('')\n}\n\nmodule.exports = serializeChunks\n","'use strict'\n\nvar assign = require('../constant/assign.js')\n\nfunction shallow(object) {\n  return assign({}, object)\n}\n\nmodule.exports = shallow\n","'use strict'\n\n// Counts tabs based on their expanded size, and CR+LF as one character.\n\nfunction sizeChunks(chunks) {\n  var index = -1\n  var size = 0\n\n  while (++index < chunks.length) {\n    size += typeof chunks[index] === 'string' ? chunks[index].length : 1\n  }\n\n  return size\n}\n\nmodule.exports = sizeChunks\n","'use strict'\n\nfunction sliceChunks(chunks, token) {\n  var startIndex = token.start._index\n  var startBufferIndex = token.start._bufferIndex\n  var endIndex = token.end._index\n  var endBufferIndex = token.end._bufferIndex\n  var view\n\n  if (startIndex === endIndex) {\n    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)]\n  } else {\n    view = chunks.slice(startIndex, endIndex)\n\n    if (startBufferIndex > -1) {\n      view[0] = view[0].slice(startBufferIndex)\n    }\n\n    if (endBufferIndex > 0) {\n      view.push(chunks[endIndex].slice(0, endBufferIndex))\n    }\n  }\n\n  return view\n}\n\nmodule.exports = sliceChunks\n","'use strict'\n\nvar assign = require('../constant/assign.js')\nvar chunkedSplice = require('./chunked-splice.js')\nvar shallow = require('./shallow.js')\n\nfunction subtokenize(events) {\n  var jumps = {}\n  var index = -1\n  var event\n  var lineIndex\n  var otherIndex\n  var otherEvent\n  var parameters\n  var subevents\n  var more\n\n  while (++index < events.length) {\n    while (index in jumps) {\n      index = jumps[index]\n    }\n\n    event = events[index] // Add a hook for the GFM tasklist extension, which needs to know if text\n    // is in the first content of a list item.\n\n    if (\n      index &&\n      event[1].type === 'chunkFlow' &&\n      events[index - 1][1].type === 'listItemPrefix'\n    ) {\n      subevents = event[1]._tokenizer.events\n      otherIndex = 0\n\n      if (\n        otherIndex < subevents.length &&\n        subevents[otherIndex][1].type === 'lineEndingBlank'\n      ) {\n        otherIndex += 2\n      }\n\n      if (\n        otherIndex < subevents.length &&\n        subevents[otherIndex][1].type === 'content'\n      ) {\n        while (++otherIndex < subevents.length) {\n          if (subevents[otherIndex][1].type === 'content') {\n            break\n          }\n\n          if (subevents[otherIndex][1].type === 'chunkText') {\n            subevents[otherIndex][1].isInFirstContentOfListItem = true\n            otherIndex++\n          }\n        }\n      }\n    } // Enter.\n\n    if (event[0] === 'enter') {\n      if (event[1].contentType) {\n        assign(jumps, subcontent(events, index))\n        index = jumps[index]\n        more = true\n      }\n    } // Exit.\n    else if (event[1]._container || event[1]._movePreviousLineEndings) {\n      otherIndex = index\n      lineIndex = undefined\n\n      while (otherIndex--) {\n        otherEvent = events[otherIndex]\n\n        if (\n          otherEvent[1].type === 'lineEnding' ||\n          otherEvent[1].type === 'lineEndingBlank'\n        ) {\n          if (otherEvent[0] === 'enter') {\n            if (lineIndex) {\n              events[lineIndex][1].type = 'lineEndingBlank'\n            }\n\n            otherEvent[1].type = 'lineEnding'\n            lineIndex = otherIndex\n          }\n        } else {\n          break\n        }\n      }\n\n      if (lineIndex) {\n        // Fix position.\n        event[1].end = shallow(events[lineIndex][1].start) // Switch container exit w/ line endings.\n\n        parameters = events.slice(lineIndex, index)\n        parameters.unshift(event)\n        chunkedSplice(events, lineIndex, index - lineIndex + 1, parameters)\n      }\n    }\n  }\n\n  return !more\n}\n\nfunction subcontent(events, eventIndex) {\n  var token = events[eventIndex][1]\n  var context = events[eventIndex][2]\n  var startPosition = eventIndex - 1\n  var startPositions = []\n  var tokenizer =\n    token._tokenizer || context.parser[token.contentType](token.start)\n  var childEvents = tokenizer.events\n  var jumps = []\n  var gaps = {}\n  var stream\n  var previous\n  var index\n  var entered\n  var end\n  var adjust // Loop forward through the linked tokens to pass them in order to the\n  // subtokenizer.\n\n  while (token) {\n    // Find the position of the event for this token.\n    while (events[++startPosition][1] !== token) {\n      // Empty.\n    }\n\n    startPositions.push(startPosition)\n\n    if (!token._tokenizer) {\n      stream = context.sliceStream(token)\n\n      if (!token.next) {\n        stream.push(null)\n      }\n\n      if (previous) {\n        tokenizer.defineSkip(token.start)\n      }\n\n      if (token.isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = true\n      }\n\n      tokenizer.write(stream)\n\n      if (token.isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = undefined\n      }\n    } // Unravel the next token.\n\n    previous = token\n    token = token.next\n  } // Now, loop back through all events (and linked tokens), to figure out which\n  // parts belong where.\n\n  token = previous\n  index = childEvents.length\n\n  while (index--) {\n    // Make sure weve at least seen something (final eol is part of the last\n    // token).\n    if (childEvents[index][0] === 'enter') {\n      entered = true\n    } else if (\n      // Find a void token that includes a break.\n      entered &&\n      childEvents[index][1].type === childEvents[index - 1][1].type &&\n      childEvents[index][1].start.line !== childEvents[index][1].end.line\n    ) {\n      add(childEvents.slice(index + 1, end))\n      // Help GC.\n      token._tokenizer = token.next = undefined\n      token = token.previous\n      end = index + 1\n    }\n  }\n\n  // Help GC.\n  tokenizer.events = token._tokenizer = token.next = undefined // Do head:\n\n  add(childEvents.slice(0, end))\n  index = -1\n  adjust = 0\n\n  while (++index < jumps.length) {\n    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1]\n    adjust += jumps[index][1] - jumps[index][0] - 1\n  }\n\n  return gaps\n\n  function add(slice) {\n    var start = startPositions.pop()\n    jumps.unshift([start, start + slice.length - 1])\n    chunkedSplice(events, start, 2, slice)\n  }\n}\n\nmodule.exports = subtokenize\n","'use strict'\n\nvar characterEntities = require('character-entities')\n\nmodule.exports = decodeEntity\n\nvar own = {}.hasOwnProperty\n\nfunction decodeEntity(characters) {\n  return own.call(characterEntities, characters)\n    ? characterEntities[characters]\n    : false\n}\n","'use strict'\n\nvar syntax = require('micromark-extension-gfm')\nvar fromMarkdown = require('mdast-util-gfm/from-markdown')\nvar toMarkdown = require('mdast-util-gfm/to-markdown')\n\nvar warningIssued\n\nmodule.exports = gfm\n\nfunction gfm(options) {\n  var data = this.data()\n\n  /* istanbul ignore next - old remark. */\n  if (\n    !warningIssued &&\n    ((this.Parser &&\n      this.Parser.prototype &&\n      this.Parser.prototype.blockTokenizers) ||\n      (this.Compiler &&\n        this.Compiler.prototype &&\n        this.Compiler.prototype.visitors))\n  ) {\n    warningIssued = true\n    console.warn(\n      '[remark-gfm] Warning: please upgrade to remark 13 to use this plugin'\n    )\n  }\n\n  add('micromarkExtensions', syntax(options))\n  add('fromMarkdownExtensions', fromMarkdown)\n  add('toMarkdownExtensions', toMarkdown(options))\n\n  function add(field, value) {\n    /* istanbul ignore if - other extensions. */\n    if (data[field]) data[field].push(value)\n    else data[field] = [value]\n  }\n}\n","'use strict'\n\nmodule.exports = parse\n\nvar fromMarkdown = require('mdast-util-from-markdown')\n\nfunction parse(options) {\n  var self = this\n\n  this.Parser = parse\n\n  function parse(doc) {\n    return fromMarkdown(\n      doc,\n      Object.assign({}, self.data('settings'), options, {\n        // Note: these options are not in the readme.\n        // The goal is for them to be set by plugins on `data` instead of being\n        // passed by users.\n        extensions: self.data('micromarkExtensions') || [],\n        mdastExtensions: self.data('fromMarkdownExtensions') || []\n      })\n    )\n  }\n}\n","/*!\n * repeat-string <https://github.com/jonschlinkert/repeat-string>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\n/**\n * Results cache\n */\n\nvar res = '';\nvar cache;\n\n/**\n * Expose `repeat`\n */\n\nmodule.exports = repeat;\n\n/**\n * Repeat the given `string` the specified `number`\n * of times.\n *\n * **Example:**\n *\n * ```js\n * var repeat = require('repeat-string');\n * repeat('A', 5);\n * //=> AAAAA\n * ```\n *\n * @param {String} `string` The string to repeat\n * @param {Number} `number` The number of times to repeat the string\n * @return {String} Repeated string\n * @api public\n */\n\nfunction repeat(str, num) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  // cover common, quick use cases\n  if (num === 1) return str;\n  if (num === 2) return str + str;\n\n  var max = str.length * num;\n  if (cache !== str || typeof cache === 'undefined') {\n    cache = str;\n    res = '';\n  } else if (res.length >= max) {\n    return res.substr(0, max);\n  }\n\n  while (max > res.length && num > 1) {\n    if (num & 1) {\n      res += str;\n    }\n\n    num >>= 1;\n    str += str;\n  }\n\n  res += str;\n  res = res.substr(0, max);\n  return res;\n}\n","'use strict';\n\nmodule.exports = require('./lib/parser');\n\n","const fields = module.exports = {};\n\nfields.feed = [\n  ['author', 'creator'],\n  ['dc:publisher', 'publisher'],\n  ['dc:creator', 'creator'],\n  ['dc:source', 'source'],\n  ['dc:title', 'title'],\n  ['dc:type', 'type'],\n  'title',\n  'description',\n  'author',\n  'pubDate',\n  'webMaster',\n  'managingEditor',\n  'generator',\n  'link',\n  'language',\n  'copyright',\n  'lastBuildDate',\n  'docs',\n  'generator',\n  'ttl',\n  'rating',\n  'skipHours',\n  'skipDays',\n];\n\nfields.item = [\n  ['author', 'creator'],\n  ['dc:creator', 'creator'],\n  ['dc:date', 'date'],\n  ['dc:language', 'language'],\n  ['dc:rights', 'rights'],\n  ['dc:source', 'source'],\n  ['dc:title', 'title'],\n  'title',\n  'link',\n  'pubDate',\n  'author',\n  'summary',\n  ['content:encoded', 'content:encoded', {includeSnippet: true}],\n  'enclosure',\n  'dc:creator',\n  'dc:date',\n  'comments',\n];\n\nvar mapItunesField = function(f) {\n  return ['itunes:' + f, f];\n}\n\nfields.podcastFeed = ([\n  'author',\n  'subtitle',\n  'summary',\n  'explicit'\n]).map(mapItunesField);\n\nfields.podcastItem = ([\n  'author',\n  'subtitle',\n  'summary',\n  'explicit',\n  'duration',\n  'image',\n  'episode',\n  'image',\n  'season',\n  'keywords',\n]).map(mapItunesField);\n\n","\"use strict\";\nconst http = require('http');\nconst https = require('https');\nconst xml2js = require('xml2js');\nconst url = require('url');\n\nconst fields = require('./fields');\nconst utils = require('./utils');\n\nconst DEFAULT_HEADERS = {\n  'User-Agent': 'rss-parser',\n  'Accept': 'application/rss+xml',\n}\nconst DEFAULT_MAX_REDIRECTS = 5;\nconst DEFAULT_TIMEOUT = 60000;\n\nclass Parser {\n  constructor(options={}) {\n    options.headers = options.headers || {};\n    options.xml2js = options.xml2js || {};\n    options.customFields = options.customFields || {};\n    options.customFields.item = options.customFields.item || [];\n    options.customFields.feed = options.customFields.feed || [];\n    options.requestOptions = options.requestOptions || {};\n    if (!options.maxRedirects) options.maxRedirects = DEFAULT_MAX_REDIRECTS;\n    if (!options.timeout) options.timeout = DEFAULT_TIMEOUT;\n    this.options = options;\n    this.xmlParser = new xml2js.Parser(this.options.xml2js);\n  }\n\n  parseString(xml, callback) {\n    let prom = new Promise((resolve, reject) => {\n      this.xmlParser.parseString(xml, (err, result) => {\n        if (err) return reject(err);\n        if (!result) {\n          return reject(new Error('Unable to parse XML.'));\n        }\n        let feed = null;\n        if (result.feed) {\n          feed = this.buildAtomFeed(result);\n        } else if (result.rss && result.rss.$ && result.rss.$.version && result.rss.$.version.match(/^2/)) {\n          feed = this.buildRSS2(result);\n        } else if (result['rdf:RDF']) {\n          feed = this.buildRSS1(result);\n        } else if (result.rss && result.rss.$ && result.rss.$.version && result.rss.$.version.match(/0\\.9/)) {\n          feed = this.buildRSS0_9(result);\n        } else if (result.rss && this.options.defaultRSS) {\n          switch(this.options.defaultRSS) {\n            case 0.9:\n              feed = this.buildRSS0_9(result);\n              break;\n            case 1:\n              feed = this.buildRSS1(result);\n              break;\n            case 2:\n              feed = this.buildRSS2(result);\n              break;\n            default:\n              return reject(new Error(\"default RSS version not recognized.\"))\n          }\n        } else {\n          return reject(new Error(\"Feed not recognized as RSS 1 or 2.\"))\n        }\n        resolve(feed);\n      });\n    });\n    prom = utils.maybePromisify(callback, prom);\n    return prom;\n  }\n\n  parseURL(feedUrl, callback, redirectCount=0) {\n    let xml = '';\n    let get = feedUrl.indexOf('https') === 0 ? https.get : http.get;\n    let urlParts = url.parse(feedUrl);\n    let headers = Object.assign({}, DEFAULT_HEADERS, this.options.headers);\n    let timeout = null;\n    let prom = new Promise((resolve, reject) => {\n      const requestOpts = Object.assign({headers}, urlParts, this.options.requestOptions);\n      let req = get(requestOpts, (res) => {\n        if (this.options.maxRedirects && res.statusCode >= 300 && res.statusCode < 400 && res.headers['location']) {\n          if (redirectCount === this.options.maxRedirects) {\n            return reject(new Error(\"Too many redirects\"));\n          } else {\n            const newLocation = url.resolve(feedUrl, res.headers['location']);\n            return this.parseURL(newLocation, null, redirectCount + 1).then(resolve, reject);\n          }\n        } else if (res.statusCode >= 300) {\n          return reject(new Error(\"Status code \" + res.statusCode))\n        }\n        let encoding = utils.getEncodingFromContentType(res.headers['content-type']);\n        res.setEncoding(encoding);\n        res.on('data', (chunk) => {\n          xml += chunk;\n        });\n        res.on('end', () => {\n          return this.parseString(xml).then(resolve, reject);\n        });\n      })\n      req.on('error', reject);\n      timeout = setTimeout(() => {\n        return reject(new Error(\"Request timed out after \" + this.options.timeout + \"ms\"));\n      }, this.options.timeout);\n    }).then(data => {\n      clearTimeout(timeout);\n      return Promise.resolve(data);\n    }, e => {\n      clearTimeout(timeout);\n      return Promise.reject(e);\n    });\n    prom = utils.maybePromisify(callback, prom);\n    return prom;\n  }\n\n  buildAtomFeed(xmlObj) {\n    let feed = {items: []};\n    utils.copyFromXML(xmlObj.feed, feed, this.options.customFields.feed);\n    if (xmlObj.feed.link) {\n      feed.link = utils.getLink(xmlObj.feed.link, 'alternate', 0);\n      feed.feedUrl = utils.getLink(xmlObj.feed.link, 'self', 1);\n    }\n    if (xmlObj.feed.title) {\n      let title = xmlObj.feed.title[0] || '';\n      if (title._) title = title._\n      if (title) feed.title = title;\n    }\n    if (xmlObj.feed.updated) {\n      feed.lastBuildDate = xmlObj.feed.updated[0];\n    }\n    feed.items = (xmlObj.feed.entry || []).map(entry => this.parseItemAtom(entry));\n    return feed;\n  }\n\n  parseItemAtom(entry) {\n    let item = {};\n    utils.copyFromXML(entry, item, this.options.customFields.item);\n    if (entry.title) {\n      let title = entry.title[0] || '';\n      if (title._) title = title._;\n      if (title) item.title = title;\n    }\n    if (entry.link && entry.link.length) {\n      item.link = utils.getLink(entry.link, 'alternate', 0);\n    }\n    if (entry.published && entry.published.length && entry.published[0].length) item.pubDate = new Date(entry.published[0]).toISOString();\n    if (!item.pubDate && entry.updated && entry.updated.length && entry.updated[0].length) item.pubDate = new Date(entry.updated[0]).toISOString();\n    if (entry.author && entry.author.length && entry.author[0].name && entry.author[0].name.length) item.author = entry.author[0].name[0];\n    if (entry.content && entry.content.length) {\n      item.content = utils.getContent(entry.content[0]);\n      item.contentSnippet = utils.getSnippet(item.content)\n    }\n    if (entry.summary && entry.summary.length) {\n      item.summary = utils.getContent(entry.summary[0]);\n    }\n    if (entry.id) {\n      item.id = entry.id[0];\n    }\n    this.setISODate(item);\n    return item;\n  }\n\n  buildRSS0_9(xmlObj) {\n    var channel = xmlObj.rss.channel[0];\n    var items = channel.item;\n    return this.buildRSS(channel, items);\n  }\n\n  buildRSS1(xmlObj) {\n    xmlObj = xmlObj['rdf:RDF'];\n    let channel = xmlObj.channel[0];\n    let items = xmlObj.item;\n    return this.buildRSS(channel, items);\n  }\n\n  buildRSS2(xmlObj) {\n    let channel = xmlObj.rss.channel[0];\n    let items = channel.item;\n    let feed = this.buildRSS(channel, items);\n    if (xmlObj.rss.$ && xmlObj.rss.$['xmlns:itunes']) {\n      this.decorateItunes(feed, channel);\n    }\n    return feed;\n  }\n\n  buildRSS(channel, items) {\n    items = items || [];\n    let feed = {items: []};\n    let feedFields = fields.feed.concat(this.options.customFields.feed);\n    let itemFields = fields.item.concat(this.options.customFields.item);\n    if (channel['atom:link'] && channel['atom:link'][0] && channel['atom:link'][0].$) {\n      feed.feedUrl = channel['atom:link'][0].$.href;\n    }\n    if (channel.image && channel.image[0] && channel.image[0].url) {\n      feed.image = {};\n      let image = channel.image[0];\n      if (image.link) feed.image.link = image.link[0];\n      if (image.url) feed.image.url = image.url[0];\n      if (image.title) feed.image.title = image.title[0];\n      if (image.width) feed.image.width = image.width[0];\n      if (image.height) feed.image.height = image.height[0];\n    }\n    const paginationLinks = this.generatePaginationLinks(channel);\n    if (Object.keys(paginationLinks).length) {\n      feed.paginationLinks = paginationLinks;\n    }\n    utils.copyFromXML(channel, feed, feedFields);\n    feed.items = items.map(xmlItem => this.parseItemRss(xmlItem, itemFields));\n    return feed;\n  }\n\n  parseItemRss(xmlItem, itemFields) {\n    let item = {};\n    utils.copyFromXML(xmlItem, item, itemFields);\n    if (xmlItem.enclosure) {\n      item.enclosure = xmlItem.enclosure[0].$;\n    }\n    if (xmlItem.description) {\n      item.content = utils.getContent(xmlItem.description[0]);\n      item.contentSnippet = utils.getSnippet(item.content);\n    }\n    if (xmlItem.guid) {\n      item.guid = xmlItem.guid[0];\n      if (item.guid._) item.guid = item.guid._;\n    }\n    if (xmlItem.category) item.categories = xmlItem.category;\n    this.setISODate(item);\n    return item;\n  }\n\n  /**\n   * Add iTunes specific fields from XML to extracted JSON\n   *\n   * @access public\n   * @param {object} feed extracted\n   * @param {object} channel parsed XML\n   */\n  decorateItunes(feed, channel) {\n    let items = channel.item || [];\n    let categories = [];\n    feed.itunes = {}\n\n    if (channel['itunes:owner']) {\n      let owner = {};\n\n      if(channel['itunes:owner'][0]['itunes:name']) {\n        owner.name = channel['itunes:owner'][0]['itunes:name'][0];\n      }\n      if(channel['itunes:owner'][0]['itunes:email']) {\n        owner.email = channel['itunes:owner'][0]['itunes:email'][0];\n      }\n      feed.itunes.owner = owner;\n    }\n\n    if (channel['itunes:image']) {\n      let image;\n      let hasImageHref = (channel['itunes:image'][0] &&\n        channel['itunes:image'][0].$ &&\n        channel['itunes:image'][0].$.href);\n      image = hasImageHref ? channel['itunes:image'][0].$.href : null;\n      if (image) {\n        feed.itunes.image = image;\n      }\n    }\n\n    if (channel['itunes:category']) {\n      const categoriesWithSubs = channel['itunes:category'].map((category) => {\n        return {\n          name: category.$.text,\n          subs: category['itunes:category'] ?\n            category['itunes:category']\n              .map((subcategory) => ({ name: subcategory.$.text })) : null,\n        };\n      });\n\n      feed.itunes.categories = categoriesWithSubs.map((category) => category.name);\n      feed.itunes.categoriesWithSubs = categoriesWithSubs;\n    }\n\n    if (channel['itunes:keywords']) {\n      if (channel['itunes:keywords'].length > 1) {\n        feed.itunes.keywords = channel['itunes:keywords'].map(\n          keyword => keyword.$.text\n        );\n      } else {\n        let keywords = channel['itunes:keywords'][0];\n        if (keywords && typeof keywords._ === 'string') {\n          keywords = keywords._;\n        }\n\n        if (keywords && keywords.$ && keywords.$.text) {\n          feed.itunes.keywords = keywords.$.text.split(',')\n        } else if (typeof keywords === \"string\") {\n          feed.itunes.keywords = keywords.split(',');\n        }\n      }\n    }\n\n    utils.copyFromXML(channel, feed.itunes, fields.podcastFeed);\n    items.forEach((item, index) => {\n      let entry = feed.items[index];\n      entry.itunes = {};\n      utils.copyFromXML(item, entry.itunes, fields.podcastItem);\n      let image = item['itunes:image'];\n      if (image && image[0] && image[0].$ && image[0].$.href) {\n        entry.itunes.image = image[0].$.href;\n      }\n    });\n  }\n\n  setISODate(item) {\n    let date = item.pubDate || item.date;\n    if (date) {\n      try {\n        item.isoDate = new Date(date.trim()).toISOString();\n      } catch (e) {\n        // Ignore bad date format\n      }\n    }\n  }\n\n  /**\n   * Generates a pagination object where the rel attribute is the key and href attribute is the value\n   *  { self: 'self-url', first: 'first-url', ...  }\n   *\n   * @access private\n   * @param {Object} channel parsed XML\n   * @returns {Object}\n   */\n  generatePaginationLinks(channel) {\n    if (!channel['atom:link']) {\n      return {};\n    }\n    const paginationRelAttributes = ['self', 'first', 'next', 'prev', 'last'];\n\n    return channel['atom:link'].reduce((paginationLinks, link) => {\n      if (!link.$ || !paginationRelAttributes.includes(link.$.rel)) {\n        return paginationLinks;\n      }\n      paginationLinks[link.$.rel] = link.$.href;\n      return paginationLinks;\n    }, {});\n  }\n}\n\nmodule.exports = Parser;\n","const utils = module.exports = {};\nconst entities = require('entities');\nconst xml2js = require('xml2js');\n\nutils.stripHtml = function(str) {\n  str = str.replace(/([^\\n])<\\/?(h|br|p|ul|ol|li|blockquote|section|table|tr|div)(?:.|\\n)*?>([^\\n])/gm, '$1\\n$3')\n  str = str.replace(/<(?:.|\\n)*?>/gm, '');\n  return str;\n}\n\nutils.getSnippet = function(str) {\n  return entities.decodeHTML(utils.stripHtml(str)).trim();\n}\n\nutils.getLink = function(links, rel, fallbackIdx) {\n  if (!links) return;\n  for (let i = 0; i < links.length; ++i) {\n    if (links[i].$.rel === rel) return links[i].$.href;\n  }\n  if (links[fallbackIdx]) return links[fallbackIdx].$.href;\n}\n\nutils.getContent = function(content) {\n  if (typeof content._ === 'string') {\n    return content._;\n  } else if (typeof content === 'object') {\n    let builder = new xml2js.Builder({headless: true, explicitRoot: true, rootName: 'div', renderOpts: {pretty: false}});\n    return builder.buildObject(content);\n  } else {\n    return content;\n  }\n}\n\nutils.copyFromXML = function(xml, dest, fields) {\n  fields.forEach(function(f) {\n    let from = f;\n    let to = f;\n    let options = {};\n    if (Array.isArray(f)) {\n      from = f[0];\n      to = f[1];\n      if (f.length > 2) {\n        options = f[2];\n      }\n    }\n    const { keepArray, includeSnippet } = options;\n    if (xml[from] !== undefined){\n      dest[to] = keepArray ? xml[from] : xml[from][0];\n    }\n    if (dest[to] && typeof dest[to]._ === 'string') {\n      dest[to]=dest[to]._;\n    }\n    if (includeSnippet && dest[to] && typeof dest[to] === 'string') {\n      dest[to + 'Snippet'] = utils.getSnippet(dest[to]);\n    }\n  })\n}\n\nutils.maybePromisify = function(callback, promise) {\n  if (!callback) return promise;\n  return promise.then(\n    data => setTimeout(() => callback(null, data)),\n    err => setTimeout(() => callback(err))\n  );\n}\n\nconst DEFAULT_ENCODING = 'utf8';\nconst ENCODING_REGEX = /(encoding|charset)\\s*=\\s*(\\S+)/;\nconst SUPPORTED_ENCODINGS = ['ascii', 'utf8', 'utf16le', 'ucs2', 'base64', 'latin1', 'binary', 'hex'];\nconst ENCODING_ALIASES = {\n  'utf-8': 'utf8',\n  'iso-8859-1': 'latin1',\n}\n\nutils.getEncodingFromContentType = function(contentType) {\n  contentType = contentType || '';\n  let match = contentType.match(ENCODING_REGEX);\n  let encoding = (match || [])[2] || '';\n  encoding = encoding.toLowerCase();\n  encoding = ENCODING_ALIASES[encoding] || encoding;\n  if (!encoding || SUPPORTED_ENCODINGS.indexOf(encoding) === -1) {\n    encoding = DEFAULT_ENCODING;\n  }\n  return encoding;\n}\n",";(function (sax) { // wrapper for non-node envs\n  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }\n  sax.SAXParser = SAXParser\n  sax.SAXStream = SAXStream\n  sax.createStream = createStream\n\n  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.\n  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),\n  // since that's the earliest that a buffer overrun could occur.  This way, checks are\n  // as rare as required, but as often as necessary to ensure never crossing this bound.\n  // Furthermore, buffers are only tested at most once per write(), so passing a very\n  // large string into write() might have undesirable effects, but this is manageable by\n  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme\n  // edge case, result in creating at most one complete copy of the string passed in.\n  // Set to Infinity to have unlimited buffers.\n  sax.MAX_BUFFER_LENGTH = 64 * 1024\n\n  var buffers = [\n    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',\n    'procInstName', 'procInstBody', 'entity', 'attribName',\n    'attribValue', 'cdata', 'script'\n  ]\n\n  sax.EVENTS = [\n    'text',\n    'processinginstruction',\n    'sgmldeclaration',\n    'doctype',\n    'comment',\n    'opentagstart',\n    'attribute',\n    'opentag',\n    'closetag',\n    'opencdata',\n    'cdata',\n    'closecdata',\n    'error',\n    'end',\n    'ready',\n    'script',\n    'opennamespace',\n    'closenamespace'\n  ]\n\n  function SAXParser (strict, opt) {\n    if (!(this instanceof SAXParser)) {\n      return new SAXParser(strict, opt)\n    }\n\n    var parser = this\n    clearBuffers(parser)\n    parser.q = parser.c = ''\n    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH\n    parser.opt = opt || {}\n    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags\n    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'\n    parser.tags = []\n    parser.closed = parser.closedRoot = parser.sawRoot = false\n    parser.tag = parser.error = null\n    parser.strict = !!strict\n    parser.noscript = !!(strict || parser.opt.noscript)\n    parser.state = S.BEGIN\n    parser.strictEntities = parser.opt.strictEntities\n    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)\n    parser.attribList = []\n\n    // namespaces form a prototype chain.\n    // it always points at the current tag,\n    // which protos to its parent tag.\n    if (parser.opt.xmlns) {\n      parser.ns = Object.create(rootNS)\n    }\n\n    // mostly just for error reporting\n    parser.trackPosition = parser.opt.position !== false\n    if (parser.trackPosition) {\n      parser.position = parser.line = parser.column = 0\n    }\n    emit(parser, 'onready')\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function F () {}\n      F.prototype = o\n      var newf = new F()\n      return newf\n    }\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = []\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)\n      return a\n    }\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)\n    var maxActual = 0\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      var len = parser[buffers[i]].length\n      if (len > maxAllowed) {\n        // Text/cdata nodes can get big, and since they're buffered,\n        // we can get here under normal conditions.\n        // Avoid issues by emitting the text node now,\n        // so at least it won't get any bigger.\n        switch (buffers[i]) {\n          case 'textNode':\n            closeText(parser)\n            break\n\n          case 'cdata':\n            emitNode(parser, 'oncdata', parser.cdata)\n            parser.cdata = ''\n            break\n\n          case 'script':\n            emitNode(parser, 'onscript', parser.script)\n            parser.script = ''\n            break\n\n          default:\n            error(parser, 'Max buffer length exceeded: ' + buffers[i])\n        }\n      }\n      maxActual = Math.max(maxActual, len)\n    }\n    // schedule the next check for the earliest possible buffer overrun.\n    var m = sax.MAX_BUFFER_LENGTH - maxActual\n    parser.bufferCheckPosition = m + parser.position\n  }\n\n  function clearBuffers (parser) {\n    for (var i = 0, l = buffers.length; i < l; i++) {\n      parser[buffers[i]] = ''\n    }\n  }\n\n  function flushBuffers (parser) {\n    closeText(parser)\n    if (parser.cdata !== '') {\n      emitNode(parser, 'oncdata', parser.cdata)\n      parser.cdata = ''\n    }\n    if (parser.script !== '') {\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n  }\n\n  SAXParser.prototype = {\n    end: function () { end(this) },\n    write: write,\n    resume: function () { this.error = null; return this },\n    close: function () { return this.write(null) },\n    flush: function () { flushBuffers(this) }\n  }\n\n  var Stream\n  try {\n    Stream = require('stream').Stream\n  } catch (ex) {\n    Stream = function () {}\n  }\n\n  var streamWraps = sax.EVENTS.filter(function (ev) {\n    return ev !== 'error' && ev !== 'end'\n  })\n\n  function createStream (strict, opt) {\n    return new SAXStream(strict, opt)\n  }\n\n  function SAXStream (strict, opt) {\n    if (!(this instanceof SAXStream)) {\n      return new SAXStream(strict, opt)\n    }\n\n    Stream.apply(this)\n\n    this._parser = new SAXParser(strict, opt)\n    this.writable = true\n    this.readable = true\n\n    var me = this\n\n    this._parser.onend = function () {\n      me.emit('end')\n    }\n\n    this._parser.onerror = function (er) {\n      me.emit('error', er)\n\n      // if didn't throw, then means error was handled.\n      // go ahead and clear error, so we can write again.\n      me._parser.error = null\n    }\n\n    this._decoder = null\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, 'on' + ev, {\n        get: function () {\n          return me._parser['on' + ev]\n        },\n        set: function (h) {\n          if (!h) {\n            me.removeAllListeners(ev)\n            me._parser['on' + ev] = h\n            return h\n          }\n          me.on(ev, h)\n        },\n        enumerable: true,\n        configurable: false\n      })\n    })\n  }\n\n  SAXStream.prototype = Object.create(Stream.prototype, {\n    constructor: {\n      value: SAXStream\n    }\n  })\n\n  SAXStream.prototype.write = function (data) {\n    if (typeof Buffer === 'function' &&\n      typeof Buffer.isBuffer === 'function' &&\n      Buffer.isBuffer(data)) {\n      if (!this._decoder) {\n        var SD = require('string_decoder').StringDecoder\n        this._decoder = new SD('utf8')\n      }\n      data = this._decoder.write(data)\n    }\n\n    this._parser.write(data.toString())\n    this.emit('data', data)\n    return true\n  }\n\n  SAXStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) {\n      this.write(chunk)\n    }\n    this._parser.end()\n    return true\n  }\n\n  SAXStream.prototype.on = function (ev, handler) {\n    var me = this\n    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser['on' + ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)\n        args.splice(0, 0, ev)\n        me.emit.apply(me, args)\n      }\n    }\n\n    return Stream.prototype.on.call(me, ev, handler)\n  }\n\n  // this really needs to be replaced with character classes.\n  // XML allows all manner of ridiculous numbers and digits.\n  var CDATA = '[CDATA['\n  var DOCTYPE = 'DOCTYPE'\n  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'\n  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'\n  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }\n\n  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar\n  // This implementation works on strings, a single character at a time\n  // as such, it cannot ever support astral-plane characters (10000-EFFFF)\n  // without a significant breaking change to either this  parser, or the\n  // JavaScript language.  Implementation of an emoji-capable xml parser\n  // is left as an exercise for the reader.\n  var nameStart = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n\n  var nameBody = /[:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  var entityStart = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/\n  var entityBody = /[#:_A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\u00B7\\u0300-\\u036F\\u203F-\\u2040.\\d-]/\n\n  function isWhitespace (c) {\n    return c === ' ' || c === '\\n' || c === '\\r' || c === '\\t'\n  }\n\n  function isQuote (c) {\n    return c === '\"' || c === '\\''\n  }\n\n  function isAttribEnd (c) {\n    return c === '>' || isWhitespace(c)\n  }\n\n  function isMatch (regex, c) {\n    return regex.test(c)\n  }\n\n  function notMatch (regex, c) {\n    return !isMatch(regex, c)\n  }\n\n  var S = 0\n  sax.STATE = {\n    BEGIN: S++, // leading byte order mark or whitespace\n    BEGIN_WHITESPACE: S++, // leading whitespace\n    TEXT: S++, // general stuff\n    TEXT_ENTITY: S++, // &amp and such.\n    OPEN_WAKA: S++, // <\n    SGML_DECL: S++, // <!BLARG\n    SGML_DECL_QUOTED: S++, // <!BLARG foo \"bar\n    DOCTYPE: S++, // <!DOCTYPE\n    DOCTYPE_QUOTED: S++, // <!DOCTYPE \"//blah\n    DOCTYPE_DTD: S++, // <!DOCTYPE \"//blah\" [ ...\n    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE \"//blah\" [ \"foo\n    COMMENT_STARTING: S++, // <!-\n    COMMENT: S++, // <!--\n    COMMENT_ENDING: S++, // <!-- blah -\n    COMMENT_ENDED: S++, // <!-- blah --\n    CDATA: S++, // <![CDATA[ something\n    CDATA_ENDING: S++, // ]\n    CDATA_ENDING_2: S++, // ]]\n    PROC_INST: S++, // <?hi\n    PROC_INST_BODY: S++, // <?hi there\n    PROC_INST_ENDING: S++, // <?hi \"there\" ?\n    OPEN_TAG: S++, // <strong\n    OPEN_TAG_SLASH: S++, // <strong /\n    ATTRIB: S++, // <a\n    ATTRIB_NAME: S++, // <a foo\n    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _\n    ATTRIB_VALUE: S++, // <a foo=\n    ATTRIB_VALUE_QUOTED: S++, // <a foo=\"bar\n    ATTRIB_VALUE_CLOSED: S++, // <a foo=\"bar\"\n    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar\n    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar=\"&quot;\"\n    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot\n    CLOSE_TAG: S++, // </a\n    CLOSE_TAG_SAW_WHITE: S++, // </a   >\n    SCRIPT: S++, // <script> ...\n    SCRIPT_ENDING: S++ // <script> ... <\n  }\n\n  sax.XML_ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\"\n  }\n\n  sax.ENTITIES = {\n    'amp': '&',\n    'gt': '>',\n    'lt': '<',\n    'quot': '\"',\n    'apos': \"'\",\n    'AElig': 198,\n    'Aacute': 193,\n    'Acirc': 194,\n    'Agrave': 192,\n    'Aring': 197,\n    'Atilde': 195,\n    'Auml': 196,\n    'Ccedil': 199,\n    'ETH': 208,\n    'Eacute': 201,\n    'Ecirc': 202,\n    'Egrave': 200,\n    'Euml': 203,\n    'Iacute': 205,\n    'Icirc': 206,\n    'Igrave': 204,\n    'Iuml': 207,\n    'Ntilde': 209,\n    'Oacute': 211,\n    'Ocirc': 212,\n    'Ograve': 210,\n    'Oslash': 216,\n    'Otilde': 213,\n    'Ouml': 214,\n    'THORN': 222,\n    'Uacute': 218,\n    'Ucirc': 219,\n    'Ugrave': 217,\n    'Uuml': 220,\n    'Yacute': 221,\n    'aacute': 225,\n    'acirc': 226,\n    'aelig': 230,\n    'agrave': 224,\n    'aring': 229,\n    'atilde': 227,\n    'auml': 228,\n    'ccedil': 231,\n    'eacute': 233,\n    'ecirc': 234,\n    'egrave': 232,\n    'eth': 240,\n    'euml': 235,\n    'iacute': 237,\n    'icirc': 238,\n    'igrave': 236,\n    'iuml': 239,\n    'ntilde': 241,\n    'oacute': 243,\n    'ocirc': 244,\n    'ograve': 242,\n    'oslash': 248,\n    'otilde': 245,\n    'ouml': 246,\n    'szlig': 223,\n    'thorn': 254,\n    'uacute': 250,\n    'ucirc': 251,\n    'ugrave': 249,\n    'uuml': 252,\n    'yacute': 253,\n    'yuml': 255,\n    'copy': 169,\n    'reg': 174,\n    'nbsp': 160,\n    'iexcl': 161,\n    'cent': 162,\n    'pound': 163,\n    'curren': 164,\n    'yen': 165,\n    'brvbar': 166,\n    'sect': 167,\n    'uml': 168,\n    'ordf': 170,\n    'laquo': 171,\n    'not': 172,\n    'shy': 173,\n    'macr': 175,\n    'deg': 176,\n    'plusmn': 177,\n    'sup1': 185,\n    'sup2': 178,\n    'sup3': 179,\n    'acute': 180,\n    'micro': 181,\n    'para': 182,\n    'middot': 183,\n    'cedil': 184,\n    'ordm': 186,\n    'raquo': 187,\n    'frac14': 188,\n    'frac12': 189,\n    'frac34': 190,\n    'iquest': 191,\n    'times': 215,\n    'divide': 247,\n    'OElig': 338,\n    'oelig': 339,\n    'Scaron': 352,\n    'scaron': 353,\n    'Yuml': 376,\n    'fnof': 402,\n    'circ': 710,\n    'tilde': 732,\n    'Alpha': 913,\n    'Beta': 914,\n    'Gamma': 915,\n    'Delta': 916,\n    'Epsilon': 917,\n    'Zeta': 918,\n    'Eta': 919,\n    'Theta': 920,\n    'Iota': 921,\n    'Kappa': 922,\n    'Lambda': 923,\n    'Mu': 924,\n    'Nu': 925,\n    'Xi': 926,\n    'Omicron': 927,\n    'Pi': 928,\n    'Rho': 929,\n    'Sigma': 931,\n    'Tau': 932,\n    'Upsilon': 933,\n    'Phi': 934,\n    'Chi': 935,\n    'Psi': 936,\n    'Omega': 937,\n    'alpha': 945,\n    'beta': 946,\n    'gamma': 947,\n    'delta': 948,\n    'epsilon': 949,\n    'zeta': 950,\n    'eta': 951,\n    'theta': 952,\n    'iota': 953,\n    'kappa': 954,\n    'lambda': 955,\n    'mu': 956,\n    'nu': 957,\n    'xi': 958,\n    'omicron': 959,\n    'pi': 960,\n    'rho': 961,\n    'sigmaf': 962,\n    'sigma': 963,\n    'tau': 964,\n    'upsilon': 965,\n    'phi': 966,\n    'chi': 967,\n    'psi': 968,\n    'omega': 969,\n    'thetasym': 977,\n    'upsih': 978,\n    'piv': 982,\n    'ensp': 8194,\n    'emsp': 8195,\n    'thinsp': 8201,\n    'zwnj': 8204,\n    'zwj': 8205,\n    'lrm': 8206,\n    'rlm': 8207,\n    'ndash': 8211,\n    'mdash': 8212,\n    'lsquo': 8216,\n    'rsquo': 8217,\n    'sbquo': 8218,\n    'ldquo': 8220,\n    'rdquo': 8221,\n    'bdquo': 8222,\n    'dagger': 8224,\n    'Dagger': 8225,\n    'bull': 8226,\n    'hellip': 8230,\n    'permil': 8240,\n    'prime': 8242,\n    'Prime': 8243,\n    'lsaquo': 8249,\n    'rsaquo': 8250,\n    'oline': 8254,\n    'frasl': 8260,\n    'euro': 8364,\n    'image': 8465,\n    'weierp': 8472,\n    'real': 8476,\n    'trade': 8482,\n    'alefsym': 8501,\n    'larr': 8592,\n    'uarr': 8593,\n    'rarr': 8594,\n    'darr': 8595,\n    'harr': 8596,\n    'crarr': 8629,\n    'lArr': 8656,\n    'uArr': 8657,\n    'rArr': 8658,\n    'dArr': 8659,\n    'hArr': 8660,\n    'forall': 8704,\n    'part': 8706,\n    'exist': 8707,\n    'empty': 8709,\n    'nabla': 8711,\n    'isin': 8712,\n    'notin': 8713,\n    'ni': 8715,\n    'prod': 8719,\n    'sum': 8721,\n    'minus': 8722,\n    'lowast': 8727,\n    'radic': 8730,\n    'prop': 8733,\n    'infin': 8734,\n    'ang': 8736,\n    'and': 8743,\n    'or': 8744,\n    'cap': 8745,\n    'cup': 8746,\n    'int': 8747,\n    'there4': 8756,\n    'sim': 8764,\n    'cong': 8773,\n    'asymp': 8776,\n    'ne': 8800,\n    'equiv': 8801,\n    'le': 8804,\n    'ge': 8805,\n    'sub': 8834,\n    'sup': 8835,\n    'nsub': 8836,\n    'sube': 8838,\n    'supe': 8839,\n    'oplus': 8853,\n    'otimes': 8855,\n    'perp': 8869,\n    'sdot': 8901,\n    'lceil': 8968,\n    'rceil': 8969,\n    'lfloor': 8970,\n    'rfloor': 8971,\n    'lang': 9001,\n    'rang': 9002,\n    'loz': 9674,\n    'spades': 9824,\n    'clubs': 9827,\n    'hearts': 9829,\n    'diams': 9830\n  }\n\n  Object.keys(sax.ENTITIES).forEach(function (key) {\n    var e = sax.ENTITIES[key]\n    var s = typeof e === 'number' ? String.fromCharCode(e) : e\n    sax.ENTITIES[key] = s\n  })\n\n  for (var s in sax.STATE) {\n    sax.STATE[sax.STATE[s]] = s\n  }\n\n  // shorthand\n  S = sax.STATE\n\n  function emit (parser, event, data) {\n    parser[event] && parser[event](data)\n  }\n\n  function emitNode (parser, nodeType, data) {\n    if (parser.textNode) closeText(parser)\n    emit(parser, nodeType, data)\n  }\n\n  function closeText (parser) {\n    parser.textNode = textopts(parser.opt, parser.textNode)\n    if (parser.textNode) emit(parser, 'ontext', parser.textNode)\n    parser.textNode = ''\n  }\n\n  function textopts (opt, text) {\n    if (opt.trim) text = text.trim()\n    if (opt.normalize) text = text.replace(/\\s+/g, ' ')\n    return text\n  }\n\n  function error (parser, er) {\n    closeText(parser)\n    if (parser.trackPosition) {\n      er += '\\nLine: ' + parser.line +\n        '\\nColumn: ' + parser.column +\n        '\\nChar: ' + parser.c\n    }\n    er = new Error(er)\n    parser.error = er\n    emit(parser, 'onerror', er)\n    return parser\n  }\n\n  function end (parser) {\n    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')\n    if ((parser.state !== S.BEGIN) &&\n      (parser.state !== S.BEGIN_WHITESPACE) &&\n      (parser.state !== S.TEXT)) {\n      error(parser, 'Unexpected end')\n    }\n    closeText(parser)\n    parser.c = ''\n    parser.closed = true\n    emit(parser, 'onend')\n    SAXParser.call(parser, parser.strict, parser.opt)\n    return parser\n  }\n\n  function strictFail (parser, message) {\n    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {\n      throw new Error('bad call to strictFail')\n    }\n    if (parser.strict) {\n      error(parser, message)\n    }\n  }\n\n  function newTag (parser) {\n    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()\n    var parent = parser.tags[parser.tags.length - 1] || parser\n    var tag = parser.tag = { name: parser.tagName, attributes: {} }\n\n    // will be overridden if tag contails an xmlns=\"foo\" or xmlns:foo=\"bar\"\n    if (parser.opt.xmlns) {\n      tag.ns = parent.ns\n    }\n    parser.attribList.length = 0\n    emitNode(parser, 'onopentagstart', tag)\n  }\n\n  function qname (name, attribute) {\n    var i = name.indexOf(':')\n    var qualName = i < 0 ? [ '', name ] : name.split(':')\n    var prefix = qualName[0]\n    var local = qualName[1]\n\n    // <x \"xmlns\"=\"http://foo\">\n    if (attribute && name === 'xmlns') {\n      prefix = 'xmlns'\n      local = ''\n    }\n\n    return { prefix: prefix, local: local }\n  }\n\n  function attrib (parser) {\n    if (!parser.strict) {\n      parser.attribName = parser.attribName[parser.looseCase]()\n    }\n\n    if (parser.attribList.indexOf(parser.attribName) !== -1 ||\n      parser.tag.attributes.hasOwnProperty(parser.attribName)) {\n      parser.attribName = parser.attribValue = ''\n      return\n    }\n\n    if (parser.opt.xmlns) {\n      var qn = qname(parser.attribName, true)\n      var prefix = qn.prefix\n      var local = qn.local\n\n      if (prefix === 'xmlns') {\n        // namespace binding attribute. push the binding into scope\n        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {\n          strictFail(parser,\n            'xml: prefix must be bound to ' + XML_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {\n          strictFail(parser,\n            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\\n' +\n            'Actual: ' + parser.attribValue)\n        } else {\n          var tag = parser.tag\n          var parent = parser.tags[parser.tags.length - 1] || parser\n          if (tag.ns === parent.ns) {\n            tag.ns = Object.create(parent.ns)\n          }\n          tag.ns[local] = parser.attribValue\n        }\n      }\n\n      // defer onattribute events until all attributes have been seen\n      // so any new bindings can take effect. preserve attribute order\n      // so deferred events can be emitted in document order\n      parser.attribList.push([parser.attribName, parser.attribValue])\n    } else {\n      // in non-xmlns mode, we can emit the event right away\n      parser.tag.attributes[parser.attribName] = parser.attribValue\n      emitNode(parser, 'onattribute', {\n        name: parser.attribName,\n        value: parser.attribValue\n      })\n    }\n\n    parser.attribName = parser.attribValue = ''\n  }\n\n  function openTag (parser, selfClosing) {\n    if (parser.opt.xmlns) {\n      // emit namespace binding events\n      var tag = parser.tag\n\n      // add namespace info to tag\n      var qn = qname(parser.tagName)\n      tag.prefix = qn.prefix\n      tag.local = qn.local\n      tag.uri = tag.ns[qn.prefix] || ''\n\n      if (tag.prefix && !tag.uri) {\n        strictFail(parser, 'Unbound namespace prefix: ' +\n          JSON.stringify(parser.tagName))\n        tag.uri = qn.prefix\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (tag.ns && parent.ns !== tag.ns) {\n        Object.keys(tag.ns).forEach(function (p) {\n          emitNode(parser, 'onopennamespace', {\n            prefix: p,\n            uri: tag.ns[p]\n          })\n        })\n      }\n\n      // handle deferred onattribute events\n      // Note: do not apply default ns to attributes:\n      //   http://www.w3.org/TR/REC-xml-names/#defaulting\n      for (var i = 0, l = parser.attribList.length; i < l; i++) {\n        var nv = parser.attribList[i]\n        var name = nv[0]\n        var value = nv[1]\n        var qualName = qname(name, true)\n        var prefix = qualName.prefix\n        var local = qualName.local\n        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')\n        var a = {\n          name: name,\n          value: value,\n          prefix: prefix,\n          local: local,\n          uri: uri\n        }\n\n        // if there's any attributes with an undefined namespace,\n        // then fail on them now.\n        if (prefix && prefix !== 'xmlns' && !uri) {\n          strictFail(parser, 'Unbound namespace prefix: ' +\n            JSON.stringify(prefix))\n          a.uri = prefix\n        }\n        parser.tag.attributes[name] = a\n        emitNode(parser, 'onattribute', a)\n      }\n      parser.attribList.length = 0\n    }\n\n    parser.tag.isSelfClosing = !!selfClosing\n\n    // process the tag\n    parser.sawRoot = true\n    parser.tags.push(parser.tag)\n    emitNode(parser, 'onopentag', parser.tag)\n    if (!selfClosing) {\n      // special case for <script> in non-strict mode.\n      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {\n        parser.state = S.SCRIPT\n      } else {\n        parser.state = S.TEXT\n      }\n      parser.tag = null\n      parser.tagName = ''\n    }\n    parser.attribName = parser.attribValue = ''\n    parser.attribList.length = 0\n  }\n\n  function closeTag (parser) {\n    if (!parser.tagName) {\n      strictFail(parser, 'Weird empty close tag.')\n      parser.textNode += '</>'\n      parser.state = S.TEXT\n      return\n    }\n\n    if (parser.script) {\n      if (parser.tagName !== 'script') {\n        parser.script += '</' + parser.tagName + '>'\n        parser.tagName = ''\n        parser.state = S.SCRIPT\n        return\n      }\n      emitNode(parser, 'onscript', parser.script)\n      parser.script = ''\n    }\n\n    // first make sure that the closing tag actually exists.\n    // <a><b></c></b></a> will close everything, otherwise.\n    var t = parser.tags.length\n    var tagName = parser.tagName\n    if (!parser.strict) {\n      tagName = tagName[parser.looseCase]()\n    }\n    var closeTo = tagName\n    while (t--) {\n      var close = parser.tags[t]\n      if (close.name !== closeTo) {\n        // fail the first time in strict mode\n        strictFail(parser, 'Unexpected close tag')\n      } else {\n        break\n      }\n    }\n\n    // didn't find it.  we already failed for strict, so just abort.\n    if (t < 0) {\n      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)\n      parser.textNode += '</' + parser.tagName + '>'\n      parser.state = S.TEXT\n      return\n    }\n    parser.tagName = tagName\n    var s = parser.tags.length\n    while (s-- > t) {\n      var tag = parser.tag = parser.tags.pop()\n      parser.tagName = parser.tag.name\n      emitNode(parser, 'onclosetag', parser.tagName)\n\n      var x = {}\n      for (var i in tag.ns) {\n        x[i] = tag.ns[i]\n      }\n\n      var parent = parser.tags[parser.tags.length - 1] || parser\n      if (parser.opt.xmlns && tag.ns !== parent.ns) {\n        // remove namespace bindings introduced by tag\n        Object.keys(tag.ns).forEach(function (p) {\n          var n = tag.ns[p]\n          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })\n        })\n      }\n    }\n    if (t === 0) parser.closedRoot = true\n    parser.tagName = parser.attribValue = parser.attribName = ''\n    parser.attribList.length = 0\n    parser.state = S.TEXT\n  }\n\n  function parseEntity (parser) {\n    var entity = parser.entity\n    var entityLC = entity.toLowerCase()\n    var num\n    var numStr = ''\n\n    if (parser.ENTITIES[entity]) {\n      return parser.ENTITIES[entity]\n    }\n    if (parser.ENTITIES[entityLC]) {\n      return parser.ENTITIES[entityLC]\n    }\n    entity = entityLC\n    if (entity.charAt(0) === '#') {\n      if (entity.charAt(1) === 'x') {\n        entity = entity.slice(2)\n        num = parseInt(entity, 16)\n        numStr = num.toString(16)\n      } else {\n        entity = entity.slice(1)\n        num = parseInt(entity, 10)\n        numStr = num.toString(10)\n      }\n    }\n    entity = entity.replace(/^0+/, '')\n    if (isNaN(num) || numStr.toLowerCase() !== entity) {\n      strictFail(parser, 'Invalid character entity')\n      return '&' + parser.entity + ';'\n    }\n\n    return String.fromCodePoint(num)\n  }\n\n  function beginWhiteSpace (parser, c) {\n    if (c === '<') {\n      parser.state = S.OPEN_WAKA\n      parser.startTagPosition = parser.position\n    } else if (!isWhitespace(c)) {\n      // have to process this as a text node.\n      // weird, but happens.\n      strictFail(parser, 'Non-whitespace before first tag.')\n      parser.textNode = c\n      parser.state = S.TEXT\n    }\n  }\n\n  function charAt (chunk, i) {\n    var result = ''\n    if (i < chunk.length) {\n      result = chunk.charAt(i)\n    }\n    return result\n  }\n\n  function write (chunk) {\n    var parser = this\n    if (this.error) {\n      throw this.error\n    }\n    if (parser.closed) {\n      return error(parser,\n        'Cannot write after close. Assign an onready handler.')\n    }\n    if (chunk === null) {\n      return end(parser)\n    }\n    if (typeof chunk === 'object') {\n      chunk = chunk.toString()\n    }\n    var i = 0\n    var c = ''\n    while (true) {\n      c = charAt(chunk, i++)\n      parser.c = c\n\n      if (!c) {\n        break\n      }\n\n      if (parser.trackPosition) {\n        parser.position++\n        if (c === '\\n') {\n          parser.line++\n          parser.column = 0\n        } else {\n          parser.column++\n        }\n      }\n\n      switch (parser.state) {\n        case S.BEGIN:\n          parser.state = S.BEGIN_WHITESPACE\n          if (c === '\\uFEFF') {\n            continue\n          }\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.BEGIN_WHITESPACE:\n          beginWhiteSpace(parser, c)\n          continue\n\n        case S.TEXT:\n          if (parser.sawRoot && !parser.closedRoot) {\n            var starti = i - 1\n            while (c && c !== '<' && c !== '&') {\n              c = charAt(chunk, i++)\n              if (c && parser.trackPosition) {\n                parser.position++\n                if (c === '\\n') {\n                  parser.line++\n                  parser.column = 0\n                } else {\n                  parser.column++\n                }\n              }\n            }\n            parser.textNode += chunk.substring(starti, i - 1)\n          }\n          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {\n            parser.state = S.OPEN_WAKA\n            parser.startTagPosition = parser.position\n          } else {\n            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {\n              strictFail(parser, 'Text data outside of root node.')\n            }\n            if (c === '&') {\n              parser.state = S.TEXT_ENTITY\n            } else {\n              parser.textNode += c\n            }\n          }\n          continue\n\n        case S.SCRIPT:\n          // only non-strict\n          if (c === '<') {\n            parser.state = S.SCRIPT_ENDING\n          } else {\n            parser.script += c\n          }\n          continue\n\n        case S.SCRIPT_ENDING:\n          if (c === '/') {\n            parser.state = S.CLOSE_TAG\n          } else {\n            parser.script += '<' + c\n            parser.state = S.SCRIPT\n          }\n          continue\n\n        case S.OPEN_WAKA:\n          // either a /, ?, !, or text is coming next.\n          if (c === '!') {\n            parser.state = S.SGML_DECL\n            parser.sgmlDecl = ''\n          } else if (isWhitespace(c)) {\n            // wait for it...\n          } else if (isMatch(nameStart, c)) {\n            parser.state = S.OPEN_TAG\n            parser.tagName = c\n          } else if (c === '/') {\n            parser.state = S.CLOSE_TAG\n            parser.tagName = ''\n          } else if (c === '?') {\n            parser.state = S.PROC_INST\n            parser.procInstName = parser.procInstBody = ''\n          } else {\n            strictFail(parser, 'Unencoded <')\n            // if there was some whitespace, then add that in.\n            if (parser.startTagPosition + 1 < parser.position) {\n              var pad = parser.position - parser.startTagPosition\n              c = new Array(pad).join(' ') + c\n            }\n            parser.textNode += '<' + c\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.SGML_DECL:\n          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {\n            emitNode(parser, 'onopencdata')\n            parser.state = S.CDATA\n            parser.sgmlDecl = ''\n            parser.cdata = ''\n          } else if (parser.sgmlDecl + c === '--') {\n            parser.state = S.COMMENT\n            parser.comment = ''\n            parser.sgmlDecl = ''\n          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {\n            parser.state = S.DOCTYPE\n            if (parser.doctype || parser.sawRoot) {\n              strictFail(parser,\n                'Inappropriately located doctype declaration')\n            }\n            parser.doctype = ''\n            parser.sgmlDecl = ''\n          } else if (c === '>') {\n            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)\n            parser.sgmlDecl = ''\n            parser.state = S.TEXT\n          } else if (isQuote(c)) {\n            parser.state = S.SGML_DECL_QUOTED\n            parser.sgmlDecl += c\n          } else {\n            parser.sgmlDecl += c\n          }\n          continue\n\n        case S.SGML_DECL_QUOTED:\n          if (c === parser.q) {\n            parser.state = S.SGML_DECL\n            parser.q = ''\n          }\n          parser.sgmlDecl += c\n          continue\n\n        case S.DOCTYPE:\n          if (c === '>') {\n            parser.state = S.TEXT\n            emitNode(parser, 'ondoctype', parser.doctype)\n            parser.doctype = true // just remember that we saw it.\n          } else {\n            parser.doctype += c\n            if (c === '[') {\n              parser.state = S.DOCTYPE_DTD\n            } else if (isQuote(c)) {\n              parser.state = S.DOCTYPE_QUOTED\n              parser.q = c\n            }\n          }\n          continue\n\n        case S.DOCTYPE_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.q = ''\n            parser.state = S.DOCTYPE\n          }\n          continue\n\n        case S.DOCTYPE_DTD:\n          parser.doctype += c\n          if (c === ']') {\n            parser.state = S.DOCTYPE\n          } else if (isQuote(c)) {\n            parser.state = S.DOCTYPE_DTD_QUOTED\n            parser.q = c\n          }\n          continue\n\n        case S.DOCTYPE_DTD_QUOTED:\n          parser.doctype += c\n          if (c === parser.q) {\n            parser.state = S.DOCTYPE_DTD\n            parser.q = ''\n          }\n          continue\n\n        case S.COMMENT:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDING\n          } else {\n            parser.comment += c\n          }\n          continue\n\n        case S.COMMENT_ENDING:\n          if (c === '-') {\n            parser.state = S.COMMENT_ENDED\n            parser.comment = textopts(parser.opt, parser.comment)\n            if (parser.comment) {\n              emitNode(parser, 'oncomment', parser.comment)\n            }\n            parser.comment = ''\n          } else {\n            parser.comment += '-' + c\n            parser.state = S.COMMENT\n          }\n          continue\n\n        case S.COMMENT_ENDED:\n          if (c !== '>') {\n            strictFail(parser, 'Malformed comment')\n            // allow <!-- blah -- bloo --> in non-strict mode,\n            // which is a comment of \" blah -- bloo \"\n            parser.comment += '--' + c\n            parser.state = S.COMMENT\n          } else {\n            parser.state = S.TEXT\n          }\n          continue\n\n        case S.CDATA:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING\n          } else {\n            parser.cdata += c\n          }\n          continue\n\n        case S.CDATA_ENDING:\n          if (c === ']') {\n            parser.state = S.CDATA_ENDING_2\n          } else {\n            parser.cdata += ']' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.CDATA_ENDING_2:\n          if (c === '>') {\n            if (parser.cdata) {\n              emitNode(parser, 'oncdata', parser.cdata)\n            }\n            emitNode(parser, 'onclosecdata')\n            parser.cdata = ''\n            parser.state = S.TEXT\n          } else if (c === ']') {\n            parser.cdata += ']'\n          } else {\n            parser.cdata += ']]' + c\n            parser.state = S.CDATA\n          }\n          continue\n\n        case S.PROC_INST:\n          if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else if (isWhitespace(c)) {\n            parser.state = S.PROC_INST_BODY\n          } else {\n            parser.procInstName += c\n          }\n          continue\n\n        case S.PROC_INST_BODY:\n          if (!parser.procInstBody && isWhitespace(c)) {\n            continue\n          } else if (c === '?') {\n            parser.state = S.PROC_INST_ENDING\n          } else {\n            parser.procInstBody += c\n          }\n          continue\n\n        case S.PROC_INST_ENDING:\n          if (c === '>') {\n            emitNode(parser, 'onprocessinginstruction', {\n              name: parser.procInstName,\n              body: parser.procInstBody\n            })\n            parser.procInstName = parser.procInstBody = ''\n            parser.state = S.TEXT\n          } else {\n            parser.procInstBody += '?' + c\n            parser.state = S.PROC_INST_BODY\n          }\n          continue\n\n        case S.OPEN_TAG:\n          if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else {\n            newTag(parser)\n            if (c === '>') {\n              openTag(parser)\n            } else if (c === '/') {\n              parser.state = S.OPEN_TAG_SLASH\n            } else {\n              if (!isWhitespace(c)) {\n                strictFail(parser, 'Invalid character in tag name')\n              }\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.OPEN_TAG_SLASH:\n          if (c === '>') {\n            openTag(parser, true)\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Forward-slash in opening tag not followed by >')\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.ATTRIB:\n          // haven't read the attribute name yet.\n          if (isWhitespace(c)) {\n            continue\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (c === '>') {\n            strictFail(parser, 'Attribute without value')\n            parser.attribValue = parser.attribName\n            attrib(parser)\n            openTag(parser)\n          } else if (isWhitespace(c)) {\n            parser.state = S.ATTRIB_NAME_SAW_WHITE\n          } else if (isMatch(nameBody, c)) {\n            parser.attribName += c\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_NAME_SAW_WHITE:\n          if (c === '=') {\n            parser.state = S.ATTRIB_VALUE\n          } else if (isWhitespace(c)) {\n            continue\n          } else {\n            strictFail(parser, 'Attribute without value')\n            parser.tag.attributes[parser.attribName] = ''\n            parser.attribValue = ''\n            emitNode(parser, 'onattribute', {\n              name: parser.attribName,\n              value: ''\n            })\n            parser.attribName = ''\n            if (c === '>') {\n              openTag(parser)\n            } else if (isMatch(nameStart, c)) {\n              parser.attribName = c\n              parser.state = S.ATTRIB_NAME\n            } else {\n              strictFail(parser, 'Invalid attribute name')\n              parser.state = S.ATTRIB\n            }\n          }\n          continue\n\n        case S.ATTRIB_VALUE:\n          if (isWhitespace(c)) {\n            continue\n          } else if (isQuote(c)) {\n            parser.q = c\n            parser.state = S.ATTRIB_VALUE_QUOTED\n          } else {\n            strictFail(parser, 'Unquoted attribute value')\n            parser.state = S.ATTRIB_VALUE_UNQUOTED\n            parser.attribValue = c\n          }\n          continue\n\n        case S.ATTRIB_VALUE_QUOTED:\n          if (c !== parser.q) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_Q\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          parser.q = ''\n          parser.state = S.ATTRIB_VALUE_CLOSED\n          continue\n\n        case S.ATTRIB_VALUE_CLOSED:\n          if (isWhitespace(c)) {\n            parser.state = S.ATTRIB\n          } else if (c === '>') {\n            openTag(parser)\n          } else if (c === '/') {\n            parser.state = S.OPEN_TAG_SLASH\n          } else if (isMatch(nameStart, c)) {\n            strictFail(parser, 'No whitespace between attributes')\n            parser.attribName = c\n            parser.attribValue = ''\n            parser.state = S.ATTRIB_NAME\n          } else {\n            strictFail(parser, 'Invalid attribute name')\n          }\n          continue\n\n        case S.ATTRIB_VALUE_UNQUOTED:\n          if (!isAttribEnd(c)) {\n            if (c === '&') {\n              parser.state = S.ATTRIB_VALUE_ENTITY_U\n            } else {\n              parser.attribValue += c\n            }\n            continue\n          }\n          attrib(parser)\n          if (c === '>') {\n            openTag(parser)\n          } else {\n            parser.state = S.ATTRIB\n          }\n          continue\n\n        case S.CLOSE_TAG:\n          if (!parser.tagName) {\n            if (isWhitespace(c)) {\n              continue\n            } else if (notMatch(nameStart, c)) {\n              if (parser.script) {\n                parser.script += '</' + c\n                parser.state = S.SCRIPT\n              } else {\n                strictFail(parser, 'Invalid tagname in closing tag.')\n              }\n            } else {\n              parser.tagName = c\n            }\n          } else if (c === '>') {\n            closeTag(parser)\n          } else if (isMatch(nameBody, c)) {\n            parser.tagName += c\n          } else if (parser.script) {\n            parser.script += '</' + parser.tagName\n            parser.tagName = ''\n            parser.state = S.SCRIPT\n          } else {\n            if (!isWhitespace(c)) {\n              strictFail(parser, 'Invalid tagname in closing tag')\n            }\n            parser.state = S.CLOSE_TAG_SAW_WHITE\n          }\n          continue\n\n        case S.CLOSE_TAG_SAW_WHITE:\n          if (isWhitespace(c)) {\n            continue\n          }\n          if (c === '>') {\n            closeTag(parser)\n          } else {\n            strictFail(parser, 'Invalid characters in closing tag')\n          }\n          continue\n\n        case S.TEXT_ENTITY:\n        case S.ATTRIB_VALUE_ENTITY_Q:\n        case S.ATTRIB_VALUE_ENTITY_U:\n          var returnState\n          var buffer\n          switch (parser.state) {\n            case S.TEXT_ENTITY:\n              returnState = S.TEXT\n              buffer = 'textNode'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_Q:\n              returnState = S.ATTRIB_VALUE_QUOTED\n              buffer = 'attribValue'\n              break\n\n            case S.ATTRIB_VALUE_ENTITY_U:\n              returnState = S.ATTRIB_VALUE_UNQUOTED\n              buffer = 'attribValue'\n              break\n          }\n\n          if (c === ';') {\n            parser[buffer] += parseEntity(parser)\n            parser.entity = ''\n            parser.state = returnState\n          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {\n            parser.entity += c\n          } else {\n            strictFail(parser, 'Invalid character in entity name')\n            parser[buffer] += '&' + parser.entity + c\n            parser.entity = ''\n            parser.state = returnState\n          }\n\n          continue\n\n        default:\n          throw new Error(parser, 'Unknown state: ' + parser.state)\n      }\n    } // while\n\n    if (parser.position >= parser.bufferCheckPosition) {\n      checkBufferLength(parser)\n    }\n    return parser\n  }\n\n  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */\n  /* istanbul ignore next */\n  if (!String.fromCodePoint) {\n    (function () {\n      var stringFromCharCode = String.fromCharCode\n      var floor = Math.floor\n      var fromCodePoint = function () {\n        var MAX_SIZE = 0x4000\n        var codeUnits = []\n        var highSurrogate\n        var lowSurrogate\n        var index = -1\n        var length = arguments.length\n        if (!length) {\n          return ''\n        }\n        var result = ''\n        while (++index < length) {\n          var codePoint = Number(arguments[index])\n          if (\n            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n            codePoint < 0 || // not a valid Unicode code point\n            codePoint > 0x10FFFF || // not a valid Unicode code point\n            floor(codePoint) !== codePoint // not an integer\n          ) {\n            throw RangeError('Invalid code point: ' + codePoint)\n          }\n          if (codePoint <= 0xFFFF) { // BMP code point\n            codeUnits.push(codePoint)\n          } else { // Astral code point; split in surrogate halves\n            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n            codePoint -= 0x10000\n            highSurrogate = (codePoint >> 10) + 0xD800\n            lowSurrogate = (codePoint % 0x400) + 0xDC00\n            codeUnits.push(highSurrogate, lowSurrogate)\n          }\n          if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n            result += stringFromCharCode.apply(null, codeUnits)\n            codeUnits.length = 0\n          }\n        }\n        return result\n      }\n      /* istanbul ignore next */\n      if (Object.defineProperty) {\n        Object.defineProperty(String, 'fromCodePoint', {\n          value: fromCodePoint,\n          configurable: true,\n          writable: true\n        })\n      } else {\n        String.fromCodePoint = fromCodePoint\n      }\n    }())\n  }\n})(typeof exports === 'undefined' ? this.sax = {} : exports)\n","\"use strict\";\n\nvar punycode = require(\"punycode\");\nvar mappingTable = require(\"./lib/mappingTable.json\");\n\nvar PROCESSING_OPTIONS = {\n  TRANSITIONAL: 0,\n  NONTRANSITIONAL: 1\n};\n\nfunction normalize(str) { // fix bug in v8\n  return str.split('\\u0000').map(function (s) { return s.normalize('NFC'); }).join('\\u0000');\n}\n\nfunction findStatus(val) {\n  var start = 0;\n  var end = mappingTable.length - 1;\n\n  while (start <= end) {\n    var mid = Math.floor((start + end) / 2);\n\n    var target = mappingTable[mid];\n    if (target[0][0] <= val && target[0][1] >= val) {\n      return target;\n    } else if (target[0][0] > val) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n\n  return null;\n}\n\nvar regexAstralSymbols = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\nfunction countSymbols(string) {\n  return string\n    // replace every surrogate pair with a BMP symbol\n    .replace(regexAstralSymbols, '_')\n    // then get the length\n    .length;\n}\n\nfunction mapChars(domain_name, useSTD3, processing_option) {\n  var hasError = false;\n  var processed = \"\";\n\n  var len = countSymbols(domain_name);\n  for (var i = 0; i < len; ++i) {\n    var codePoint = domain_name.codePointAt(i);\n    var status = findStatus(codePoint);\n\n    switch (status[1]) {\n      case \"disallowed\":\n        hasError = true;\n        processed += String.fromCodePoint(codePoint);\n        break;\n      case \"ignored\":\n        break;\n      case \"mapped\":\n        processed += String.fromCodePoint.apply(String, status[2]);\n        break;\n      case \"deviation\":\n        if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {\n          processed += String.fromCodePoint.apply(String, status[2]);\n        } else {\n          processed += String.fromCodePoint(codePoint);\n        }\n        break;\n      case \"valid\":\n        processed += String.fromCodePoint(codePoint);\n        break;\n      case \"disallowed_STD3_mapped\":\n        if (useSTD3) {\n          hasError = true;\n          processed += String.fromCodePoint(codePoint);\n        } else {\n          processed += String.fromCodePoint.apply(String, status[2]);\n        }\n        break;\n      case \"disallowed_STD3_valid\":\n        if (useSTD3) {\n          hasError = true;\n        }\n\n        processed += String.fromCodePoint(codePoint);\n        break;\n    }\n  }\n\n  return {\n    string: processed,\n    error: hasError\n  };\n}\n\nvar combiningMarksRegex = /[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08E4-\\u0903\\u093A-\\u093C\\u093E-\\u094F\\u0951-\\u0957\\u0962\\u0963\\u0981-\\u0983\\u09BC\\u09BE-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CD\\u09D7\\u09E2\\u09E3\\u0A01-\\u0A03\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81-\\u0A83\\u0ABC\\u0ABE-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AE2\\u0AE3\\u0B01-\\u0B03\\u0B3C\\u0B3E-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD7\\u0C00-\\u0C03\\u0C3E-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81-\\u0C83\\u0CBC\\u0CBE-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D01-\\u0D03\\u0D3E-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D82\\u0D83\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F3E\\u0F3F\\u0F71-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102B-\\u103E\\u1056-\\u1059\\u105E-\\u1060\\u1062-\\u1064\\u1067-\\u106D\\u1071-\\u1074\\u1082-\\u108D\\u108F\\u109A-\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u192B\\u1930-\\u193B\\u19B0-\\u19C0\\u19C8\\u19C9\\u1A17-\\u1A1B\\u1A55-\\u1A5E\\u1A60-\\u1A7C\\u1A7F\\u1AB0-\\u1ABE\\u1B00-\\u1B04\\u1B34-\\u1B44\\u1B6B-\\u1B73\\u1B80-\\u1B82\\u1BA1-\\u1BAD\\u1BE6-\\u1BF3\\u1C24-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE8\\u1CED\\u1CF2-\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF5\\u1DFC-\\u1DFF\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA823-\\uA827\\uA880\\uA881\\uA8B4-\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA953\\uA980-\\uA983\\uA9B3-\\uA9C0\\uA9E5\\uAA29-\\uAA36\\uAA43\\uAA4C\\uAA4D\\uAA7B-\\uAA7D\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEB-\\uAAEF\\uAAF5\\uAAF6\\uABE3-\\uABEA\\uABEC\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2D]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD804[\\uDC00-\\uDC02\\uDC38-\\uDC46\\uDC7F-\\uDC82\\uDCB0-\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD34\\uDD73\\uDD80-\\uDD82\\uDDB3-\\uDDC0\\uDE2C-\\uDE37\\uDEDF-\\uDEEA\\uDF01-\\uDF03\\uDF3C\\uDF3E-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF57\\uDF62\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDCB0-\\uDCC3\\uDDAF-\\uDDB5\\uDDB8-\\uDDC0\\uDE30-\\uDE40\\uDEAB-\\uDEB7]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF51-\\uDF7E\\uDF8F-\\uDF92]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD83A[\\uDCD0-\\uDCD6]|\\uDB40[\\uDD00-\\uDDEF]/;\n\nfunction validateLabel(label, processing_option) {\n  if (label.substr(0, 4) === \"xn--\") {\n    label = punycode.toUnicode(label);\n    processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;\n  }\n\n  var error = false;\n\n  if (normalize(label) !== label ||\n      (label[3] === \"-\" && label[4] === \"-\") ||\n      label[0] === \"-\" || label[label.length - 1] === \"-\" ||\n      label.indexOf(\".\") !== -1 ||\n      label.search(combiningMarksRegex) === 0) {\n    error = true;\n  }\n\n  var len = countSymbols(label);\n  for (var i = 0; i < len; ++i) {\n    var status = findStatus(label.codePointAt(i));\n    if ((processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== \"valid\") ||\n        (processing === PROCESSING_OPTIONS.NONTRANSITIONAL &&\n         status[1] !== \"valid\" && status[1] !== \"deviation\")) {\n      error = true;\n      break;\n    }\n  }\n\n  return {\n    label: label,\n    error: error\n  };\n}\n\nfunction processing(domain_name, useSTD3, processing_option) {\n  var result = mapChars(domain_name, useSTD3, processing_option);\n  result.string = normalize(result.string);\n\n  var labels = result.string.split(\".\");\n  for (var i = 0; i < labels.length; ++i) {\n    try {\n      var validation = validateLabel(labels[i]);\n      labels[i] = validation.label;\n      result.error = result.error || validation.error;\n    } catch(e) {\n      result.error = true;\n    }\n  }\n\n  return {\n    string: labels.join(\".\"),\n    error: result.error\n  };\n}\n\nmodule.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {\n  var result = processing(domain_name, useSTD3, processing_option);\n  var labels = result.string.split(\".\");\n  labels = labels.map(function(l) {\n    try {\n      return punycode.toASCII(l);\n    } catch(e) {\n      result.error = true;\n      return l;\n    }\n  });\n\n  if (verifyDnsLength) {\n    var total = labels.slice(0, labels.length - 1).join(\".\").length;\n    if (total.length > 253 || total.length === 0) {\n      result.error = true;\n    }\n\n    for (var i=0; i < labels.length; ++i) {\n      if (labels.length > 63 || labels.length === 0) {\n        result.error = true;\n        break;\n      }\n    }\n  }\n\n  if (result.error) return null;\n  return labels.join(\".\");\n};\n\nmodule.exports.toUnicode = function(domain_name, useSTD3) {\n  var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);\n\n  return {\n    domain: result.string,\n    error: result.error\n  };\n};\n\nmodule.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;\n","'use strict'\n\nvar wrap = require('./wrap.js')\n\nmodule.exports = trough\n\ntrough.wrap = wrap\n\nvar slice = [].slice\n\n// Create new middleware.\nfunction trough() {\n  var fns = []\n  var middleware = {}\n\n  middleware.run = run\n  middleware.use = use\n\n  return middleware\n\n  // Run `fns`.  Last argument must be a completion handler.\n  function run() {\n    var index = -1\n    var input = slice.call(arguments, 0, -1)\n    var done = arguments[arguments.length - 1]\n\n    if (typeof done !== 'function') {\n      throw new Error('Expected function as last argument, not ' + done)\n    }\n\n    next.apply(null, [null].concat(input))\n\n    // Run the next `fn`, if any.\n    function next(err) {\n      var fn = fns[++index]\n      var params = slice.call(arguments, 0)\n      var values = params.slice(1)\n      var length = input.length\n      var pos = -1\n\n      if (err) {\n        done(err)\n        return\n      }\n\n      // Copy non-nully input into values.\n      while (++pos < length) {\n        if (values[pos] === null || values[pos] === undefined) {\n          values[pos] = input[pos]\n        }\n      }\n\n      input = values\n\n      // Next or done.\n      if (fn) {\n        wrap(fn, next).apply(null, input)\n      } else {\n        done.apply(null, [null].concat(input))\n      }\n    }\n  }\n\n  // Add `fn` to the list.\n  function use(fn) {\n    if (typeof fn !== 'function') {\n      throw new Error('Expected `fn` to be a function, not ' + fn)\n    }\n\n    fns.push(fn)\n\n    return middleware\n  }\n}\n","'use strict'\n\nvar slice = [].slice\n\nmodule.exports = wrap\n\n// Wrap `fn`.\n// Can be sync or async; return a promise, receive a completion handler, return\n// new values and errors.\nfunction wrap(fn, callback) {\n  var invoked\n\n  return wrapped\n\n  function wrapped() {\n    var params = slice.call(arguments, 0)\n    var callback = fn.length > params.length\n    var result\n\n    if (callback) {\n      params.push(done)\n    }\n\n    try {\n      result = fn.apply(null, params)\n    } catch (error) {\n      // Well, this is quite the pickle.\n      // `fn` received a callback and invoked it (thus continuing the pipeline),\n      // but later also threw an error.\n      // Were not about to restart the pipeline again, so the only thing left\n      // to do is to throw the thing instead.\n      if (callback && invoked) {\n        throw error\n      }\n\n      return done(error)\n    }\n\n    if (!callback) {\n      if (result && typeof result.then === 'function') {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  // Invoke `next`, only once.\n  function done() {\n    if (!invoked) {\n      invoked = true\n\n      callback.apply(null, arguments)\n    }\n  }\n\n  // Invoke `done` with one value.\n  // Tracks if an error is passed, too.\n  function then(value) {\n    done(null, value)\n  }\n}\n","'use strict'\n\nvar bail = require('bail')\nvar buffer = require('is-buffer')\nvar extend = require('extend')\nvar plain = require('is-plain-obj')\nvar trough = require('trough')\nvar vfile = require('vfile')\n\n// Expose a frozen processor.\nmodule.exports = unified().freeze()\n\nvar slice = [].slice\nvar own = {}.hasOwnProperty\n\n// Process pipeline.\nvar pipeline = trough()\n  .use(pipelineParse)\n  .use(pipelineRun)\n  .use(pipelineStringify)\n\nfunction pipelineParse(p, ctx) {\n  ctx.tree = p.parse(ctx.file)\n}\n\nfunction pipelineRun(p, ctx, next) {\n  p.run(ctx.tree, ctx.file, done)\n\n  function done(error, tree, file) {\n    if (error) {\n      next(error)\n    } else {\n      ctx.tree = tree\n      ctx.file = file\n      next()\n    }\n  }\n}\n\nfunction pipelineStringify(p, ctx) {\n  var result = p.stringify(ctx.tree, ctx.file)\n\n  if (result === undefined || result === null) {\n    // Empty.\n  } else if (typeof result === 'string' || buffer(result)) {\n    if ('value' in ctx.file) {\n      ctx.file.value = result\n    }\n\n    ctx.file.contents = result\n  } else {\n    ctx.file.result = result\n  }\n}\n\n// Function to create the first processor.\nfunction unified() {\n  var attachers = []\n  var transformers = trough()\n  var namespace = {}\n  var freezeIndex = -1\n  var frozen\n\n  // Data management.\n  processor.data = data\n\n  // Lock.\n  processor.freeze = freeze\n\n  // Plugins.\n  processor.attachers = attachers\n  processor.use = use\n\n  // API.\n  processor.parse = parse\n  processor.stringify = stringify\n  processor.run = run\n  processor.runSync = runSync\n  processor.process = process\n  processor.processSync = processSync\n\n  // Expose.\n  return processor\n\n  // Create a new processor based on the processor in the current scope.\n  function processor() {\n    var destination = unified()\n    var index = -1\n\n    while (++index < attachers.length) {\n      destination.use.apply(null, attachers[index])\n    }\n\n    destination.data(extend(true, {}, namespace))\n\n    return destination\n  }\n\n  // Freeze: used to signal a processor that has finished configuration.\n  //\n  // For example, take unified itself: its frozen.\n  // Plugins should not be added to it.\n  // Rather, it should be extended, by invoking it, before modifying it.\n  //\n  // In essence, always invoke this when exporting a processor.\n  function freeze() {\n    var values\n    var transformer\n\n    if (frozen) {\n      return processor\n    }\n\n    while (++freezeIndex < attachers.length) {\n      values = attachers[freezeIndex]\n\n      if (values[1] === false) {\n        continue\n      }\n\n      if (values[1] === true) {\n        values[1] = undefined\n      }\n\n      transformer = values[0].apply(processor, values.slice(1))\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer)\n      }\n    }\n\n    frozen = true\n    freezeIndex = Infinity\n\n    return processor\n  }\n\n  // Data management.\n  // Getter / setter for processor-specific informtion.\n  function data(key, value) {\n    if (typeof key === 'string') {\n      // Set `key`.\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen)\n        namespace[key] = value\n        return processor\n      }\n\n      // Get `key`.\n      return (own.call(namespace, key) && namespace[key]) || null\n    }\n\n    // Set space.\n    if (key) {\n      assertUnfrozen('data', frozen)\n      namespace = key\n      return processor\n    }\n\n    // Get space.\n    return namespace\n  }\n\n  // Plugin management.\n  //\n  // Pass it:\n  // *   an attacher and options,\n  // *   a preset,\n  // *   a list of presets, attachers, and arguments (list of attachers and\n  //     options).\n  function use(value) {\n    var settings\n\n    assertUnfrozen('use', frozen)\n\n    if (value === null || value === undefined) {\n      // Empty.\n    } else if (typeof value === 'function') {\n      addPlugin.apply(null, arguments)\n    } else if (typeof value === 'object') {\n      if ('length' in value) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new Error('Expected usable value, not `' + value + '`')\n    }\n\n    if (settings) {\n      namespace.settings = extend(namespace.settings || {}, settings)\n    }\n\n    return processor\n\n    function addPreset(result) {\n      addList(result.plugins)\n\n      if (result.settings) {\n        settings = extend(settings || {}, result.settings)\n      }\n    }\n\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value)\n      } else if (typeof value === 'object') {\n        if ('length' in value) {\n          addPlugin.apply(null, value)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new Error('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    function addList(plugins) {\n      var index = -1\n\n      if (plugins === null || plugins === undefined) {\n        // Empty.\n      } else if (typeof plugins === 'object' && 'length' in plugins) {\n        while (++index < plugins.length) {\n          add(plugins[index])\n        }\n      } else {\n        throw new Error('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    function addPlugin(plugin, value) {\n      var entry = find(plugin)\n\n      if (entry) {\n        if (plain(entry[1]) && plain(value)) {\n          value = extend(true, entry[1], value)\n        }\n\n        entry[1] = value\n      } else {\n        attachers.push(slice.call(arguments))\n      }\n    }\n  }\n\n  function find(plugin) {\n    var index = -1\n\n    while (++index < attachers.length) {\n      if (attachers[index][0] === plugin) {\n        return attachers[index]\n      }\n    }\n  }\n\n  // Parse a file (in string or vfile representation) into a unist node using\n  // the `Parser` on the processor.\n  function parse(doc) {\n    var file = vfile(doc)\n    var Parser\n\n    freeze()\n    Parser = processor.Parser\n    assertParser('parse', Parser)\n\n    if (newable(Parser, 'parse')) {\n      return new Parser(String(file), file).parse()\n    }\n\n    return Parser(String(file), file) // eslint-disable-line new-cap\n  }\n\n  // Run transforms on a unist node representation of a file (in string or\n  // vfile representation), async.\n  function run(node, file, cb) {\n    assertNode(node)\n    freeze()\n\n    if (!cb && typeof file === 'function') {\n      cb = file\n      file = null\n    }\n\n    if (!cb) {\n      return new Promise(executor)\n    }\n\n    executor(null, cb)\n\n    function executor(resolve, reject) {\n      transformers.run(node, vfile(file), done)\n\n      function done(error, tree, file) {\n        tree = tree || node\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(tree)\n        } else {\n          cb(null, tree, file)\n        }\n      }\n    }\n  }\n\n  // Run transforms on a unist node representation of a file (in string or\n  // vfile representation), sync.\n  function runSync(node, file) {\n    var result\n    var complete\n\n    run(node, file, done)\n\n    assertDone('runSync', 'run', complete)\n\n    return result\n\n    function done(error, tree) {\n      complete = true\n      result = tree\n      bail(error)\n    }\n  }\n\n  // Stringify a unist node representation of a file (in string or vfile\n  // representation) into a string using the `Compiler` on the processor.\n  function stringify(node, doc) {\n    var file = vfile(doc)\n    var Compiler\n\n    freeze()\n    Compiler = processor.Compiler\n    assertCompiler('stringify', Compiler)\n    assertNode(node)\n\n    if (newable(Compiler, 'compile')) {\n      return new Compiler(node, file).compile()\n    }\n\n    return Compiler(node, file) // eslint-disable-line new-cap\n  }\n\n  // Parse a file (in string or vfile representation) into a unist node using\n  // the `Parser` on the processor, then run transforms on that node, and\n  // compile the resulting node using the `Compiler` on the processor, and\n  // store that result on the vfile.\n  function process(doc, cb) {\n    freeze()\n    assertParser('process', processor.Parser)\n    assertCompiler('process', processor.Compiler)\n\n    if (!cb) {\n      return new Promise(executor)\n    }\n\n    executor(null, cb)\n\n    function executor(resolve, reject) {\n      var file = vfile(doc)\n\n      pipeline.run(processor, {file: file}, done)\n\n      function done(error) {\n        if (error) {\n          reject(error)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          cb(null, file)\n        }\n      }\n    }\n  }\n\n  // Process the given document (in string or vfile representation), sync.\n  function processSync(doc) {\n    var file\n    var complete\n\n    freeze()\n    assertParser('processSync', processor.Parser)\n    assertCompiler('processSync', processor.Compiler)\n    file = vfile(doc)\n\n    process(file, done)\n\n    assertDone('processSync', 'process', complete)\n\n    return file\n\n    function done(error) {\n      complete = true\n      bail(error)\n    }\n  }\n}\n\n// Check if `value` is a constructor.\nfunction newable(value, name) {\n  return (\n    typeof value === 'function' &&\n    value.prototype &&\n    // A function with keys in its prototype is probably a constructor.\n    // Classes prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    (keys(value.prototype) || name in value.prototype)\n  )\n}\n\n// Check if `value` is an object with keys.\nfunction keys(value) {\n  var key\n  for (key in value) {\n    return true\n  }\n\n  return false\n}\n\n// Assert a parser is available.\nfunction assertParser(name, Parser) {\n  if (typeof Parser !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Parser`')\n  }\n}\n\n// Assert a compiler is available.\nfunction assertCompiler(name, Compiler) {\n  if (typeof Compiler !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Compiler`')\n  }\n}\n\n// Assert the processor is not frozen.\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      'Cannot invoke `' +\n        name +\n        '` on a frozen processor.\\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.'\n    )\n  }\n}\n\n// Assert `node` is a unist node.\nfunction assertNode(node) {\n  if (!node || typeof node.type !== 'string') {\n    throw new Error('Expected node, got `' + node + '`')\n  }\n}\n\n// Assert that `complete` is `true`.\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n","'use strict'\n\nmodule.exports = convert\n\nfunction convert(test) {\n  if (test == null) {\n    return ok\n  }\n\n  if (typeof test === 'string') {\n    return typeFactory(test)\n  }\n\n  if (typeof test === 'object') {\n    return 'length' in test ? anyFactory(test) : allFactory(test)\n  }\n\n  if (typeof test === 'function') {\n    return test\n  }\n\n  throw new Error('Expected function, string, or object as test')\n}\n\n// Utility assert each property in `test` is represented in `node`, and each\n// values are strictly equal.\nfunction allFactory(test) {\n  return all\n\n  function all(node) {\n    var key\n\n    for (key in test) {\n      if (node[key] !== test[key]) return false\n    }\n\n    return true\n  }\n}\n\nfunction anyFactory(tests) {\n  var checks = []\n  var index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return any\n\n  function any() {\n    var index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].apply(this, arguments)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n// Utility to convert a string into a function which checks a given nodes type\n// for said string.\nfunction typeFactory(test) {\n  return type\n\n  function type(node) {\n    return Boolean(node && node.type === test)\n  }\n}\n\n// Utility to return true.\nfunction ok() {\n  return true\n}\n","'use strict'\n\nvar own = {}.hasOwnProperty\n\nmodule.exports = stringify\n\nfunction stringify(value) {\n  // Nothing.\n  if (!value || typeof value !== 'object') {\n    return ''\n  }\n\n  // Node.\n  if (own.call(value, 'position') || own.call(value, 'type')) {\n    return position(value.position)\n  }\n\n  // Position.\n  if (own.call(value, 'start') || own.call(value, 'end')) {\n    return position(value)\n  }\n\n  // Point.\n  if (own.call(value, 'line') || own.call(value, 'column')) {\n    return point(value)\n  }\n\n  // ?\n  return ''\n}\n\nfunction point(point) {\n  if (!point || typeof point !== 'object') {\n    point = {}\n  }\n\n  return index(point.line) + ':' + index(point.column)\n}\n\nfunction position(pos) {\n  if (!pos || typeof pos !== 'object') {\n    pos = {}\n  }\n\n  return point(pos.start) + '-' + point(pos.end)\n}\n\nfunction index(value) {\n  return value && typeof value === 'number' ? value : 1\n}\n","module.exports = color\nfunction color(d) {\n  return '\\u001B[33m' + d + '\\u001B[39m'\n}\n","'use strict'\n\nmodule.exports = visitParents\n\nvar convert = require('unist-util-is/convert')\nvar color = require('./color')\n\nvar CONTINUE = true\nvar SKIP = 'skip'\nvar EXIT = false\n\nvisitParents.CONTINUE = CONTINUE\nvisitParents.SKIP = SKIP\nvisitParents.EXIT = EXIT\n\nfunction visitParents(tree, test, visitor, reverse) {\n  var step\n  var is\n\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor\n    visitor = test\n    test = null\n  }\n\n  is = convert(test)\n  step = reverse ? -1 : 1\n\n  factory(tree, null, [])()\n\n  function factory(node, index, parents) {\n    var value = typeof node === 'object' && node !== null ? node : {}\n    var name\n\n    if (typeof value.type === 'string') {\n      name =\n        typeof value.tagName === 'string'\n          ? value.tagName\n          : typeof value.name === 'string'\n          ? value.name\n          : undefined\n\n      visit.displayName =\n        'node (' + color(value.type + (name ? '<' + name + '>' : '')) + ')'\n    }\n\n    return visit\n\n    function visit() {\n      var grandparents = parents.concat(node)\n      var result = []\n      var subresult\n      var offset\n\n      if (!test || is(node, index, parents[parents.length - 1] || null)) {\n        result = toResult(visitor(node, parents))\n\n        if (result[0] === EXIT) {\n          return result\n        }\n      }\n\n      if (node.children && result[0] !== SKIP) {\n        offset = (reverse ? node.children.length : -1) + step\n\n        while (offset > -1 && offset < node.children.length) {\n          subresult = factory(node.children[offset], offset, grandparents)()\n\n          if (subresult[0] === EXIT) {\n            return subresult\n          }\n\n          offset =\n            typeof subresult[1] === 'number' ? subresult[1] : offset + step\n        }\n      }\n\n      return result\n    }\n  }\n}\n\nfunction toResult(value) {\n  if (value !== null && typeof value === 'object' && 'length' in value) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","'use strict'\n\nvar stringify = require('unist-util-stringify-position')\n\nmodule.exports = VMessage\n\n// Inherit from `Error#`.\nfunction VMessagePrototype() {}\nVMessagePrototype.prototype = Error.prototype\nVMessage.prototype = new VMessagePrototype()\n\n// Message properties.\nvar proto = VMessage.prototype\n\nproto.file = ''\nproto.name = ''\nproto.reason = ''\nproto.message = ''\nproto.stack = ''\nproto.fatal = null\nproto.column = null\nproto.line = null\n\n// Construct a new VMessage.\n//\n// Note: We cannot invoke `Error` on the created context, as that adds readonly\n// `line` and `column` attributes on Safari 9, thus throwing and failing the\n// data.\nfunction VMessage(reason, position, origin) {\n  var parts\n  var range\n  var location\n\n  if (typeof position === 'string') {\n    origin = position\n    position = null\n  }\n\n  parts = parseOrigin(origin)\n  range = stringify(position) || '1:1'\n\n  location = {\n    start: {line: null, column: null},\n    end: {line: null, column: null}\n  }\n\n  // Node.\n  if (position && position.position) {\n    position = position.position\n  }\n\n  if (position) {\n    // Position.\n    if (position.start) {\n      location = position\n      position = position.start\n    } else {\n      // Point.\n      location.start = position\n    }\n  }\n\n  if (reason.stack) {\n    this.stack = reason.stack\n    reason = reason.message\n  }\n\n  this.message = reason\n  this.name = range\n  this.reason = reason\n  this.line = position ? position.line : null\n  this.column = position ? position.column : null\n  this.location = location\n  this.source = parts[0]\n  this.ruleId = parts[1]\n}\n\nfunction parseOrigin(origin) {\n  var result = [null, null]\n  var index\n\n  if (typeof origin === 'string') {\n    index = origin.indexOf(':')\n\n    if (index === -1) {\n      result[1] = origin\n    } else {\n      result[0] = origin.slice(0, index)\n      result[1] = origin.slice(index + 1)\n    }\n  }\n\n  return result\n}\n","'use strict'\n\nmodule.exports = require('./lib')\n","'use strict'\n\nvar p = require('./minpath')\nvar proc = require('./minproc')\nvar buffer = require('is-buffer')\n\nmodule.exports = VFile\n\nvar own = {}.hasOwnProperty\n\n// Order of setting (least specific to most), we need this because otherwise\n// `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a\n// stem can be set.\nvar order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']\n\nVFile.prototype.toString = toString\n\n// Access full path (`~/index.min.js`).\nObject.defineProperty(VFile.prototype, 'path', {get: getPath, set: setPath})\n\n// Access parent path (`~`).\nObject.defineProperty(VFile.prototype, 'dirname', {\n  get: getDirname,\n  set: setDirname\n})\n\n// Access basename (`index.min.js`).\nObject.defineProperty(VFile.prototype, 'basename', {\n  get: getBasename,\n  set: setBasename\n})\n\n// Access extname (`.js`).\nObject.defineProperty(VFile.prototype, 'extname', {\n  get: getExtname,\n  set: setExtname\n})\n\n// Access stem (`index.min`).\nObject.defineProperty(VFile.prototype, 'stem', {get: getStem, set: setStem})\n\n// Construct a new file.\nfunction VFile(options) {\n  var prop\n  var index\n\n  if (!options) {\n    options = {}\n  } else if (typeof options === 'string' || buffer(options)) {\n    options = {contents: options}\n  } else if ('message' in options && 'messages' in options) {\n    return options\n  }\n\n  if (!(this instanceof VFile)) {\n    return new VFile(options)\n  }\n\n  this.data = {}\n  this.messages = []\n  this.history = []\n  this.cwd = proc.cwd()\n\n  // Set path related properties in the correct order.\n  index = -1\n\n  while (++index < order.length) {\n    prop = order[index]\n\n    if (own.call(options, prop)) {\n      this[prop] = options[prop]\n    }\n  }\n\n  // Set non-path related properties.\n  for (prop in options) {\n    if (order.indexOf(prop) < 0) {\n      this[prop] = options[prop]\n    }\n  }\n}\n\nfunction getPath() {\n  return this.history[this.history.length - 1]\n}\n\nfunction setPath(path) {\n  assertNonEmpty(path, 'path')\n\n  if (this.path !== path) {\n    this.history.push(path)\n  }\n}\n\nfunction getDirname() {\n  return typeof this.path === 'string' ? p.dirname(this.path) : undefined\n}\n\nfunction setDirname(dirname) {\n  assertPath(this.path, 'dirname')\n  this.path = p.join(dirname || '', this.basename)\n}\n\nfunction getBasename() {\n  return typeof this.path === 'string' ? p.basename(this.path) : undefined\n}\n\nfunction setBasename(basename) {\n  assertNonEmpty(basename, 'basename')\n  assertPart(basename, 'basename')\n  this.path = p.join(this.dirname || '', basename)\n}\n\nfunction getExtname() {\n  return typeof this.path === 'string' ? p.extname(this.path) : undefined\n}\n\nfunction setExtname(extname) {\n  assertPart(extname, 'extname')\n  assertPath(this.path, 'extname')\n\n  if (extname) {\n    if (extname.charCodeAt(0) !== 46 /* `.` */) {\n      throw new Error('`extname` must start with `.`')\n    }\n\n    if (extname.indexOf('.', 1) > -1) {\n      throw new Error('`extname` cannot contain multiple dots')\n    }\n  }\n\n  this.path = p.join(this.dirname, this.stem + (extname || ''))\n}\n\nfunction getStem() {\n  return typeof this.path === 'string'\n    ? p.basename(this.path, this.extname)\n    : undefined\n}\n\nfunction setStem(stem) {\n  assertNonEmpty(stem, 'stem')\n  assertPart(stem, 'stem')\n  this.path = p.join(this.dirname || '', stem + (this.extname || ''))\n}\n\n// Get the value of the file.\nfunction toString(encoding) {\n  return (this.contents || '').toString(encoding)\n}\n\n// Assert that `part` is not a path (i.e., does not contain `p.sep`).\nfunction assertPart(part, name) {\n  if (part && part.indexOf(p.sep) > -1) {\n    throw new Error(\n      '`' + name + '` cannot be a path: did not expect `' + p.sep + '`'\n    )\n  }\n}\n\n// Assert that `part` is not empty.\nfunction assertNonEmpty(part, name) {\n  if (!part) {\n    throw new Error('`' + name + '` cannot be empty')\n  }\n}\n\n// Assert `path` exists.\nfunction assertPath(path, name) {\n  if (!path) {\n    throw new Error('Setting `' + name + '` requires `path` to be set too')\n  }\n}\n","'use strict'\n\nvar VMessage = require('vfile-message')\nvar VFile = require('./core.js')\n\nmodule.exports = VFile\n\nVFile.prototype.message = message\nVFile.prototype.info = info\nVFile.prototype.fail = fail\n\n// Create a message with `reason` at `position`.\n// When an error is passed in as `reason`, copies the stack.\nfunction message(reason, position, origin) {\n  var message = new VMessage(reason, position, origin)\n\n  if (this.path) {\n    message.name = this.path + ':' + message.name\n    message.file = this.path\n  }\n\n  message.fatal = false\n\n  this.messages.push(message)\n\n  return message\n}\n\n// Fail: creates a vmessage, associates it with the file, and throws it.\nfunction fail() {\n  var message = this.message.apply(this, arguments)\n\n  message.fatal = true\n\n  throw message\n}\n\n// Info: creates a vmessage, associates it with the file, and marks the fatality\n// as null.\nfunction info() {\n  var message = this.message.apply(this, arguments)\n\n  message.fatal = null\n\n  return message\n}\n","'use strict'\n\nmodule.exports = require('path')\n","'use strict'\n\nmodule.exports = process\n","\"use strict\";\n\nvar conversions = {};\nmodule.exports = conversions;\n\nfunction sign(x) {\n    return x < 0 ? -1 : 1;\n}\n\nfunction evenRound(x) {\n    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.\n    if ((x % 1) === 0.5 && (x & 1) === 0) { // [even number].5; round down (i.e. floor)\n        return Math.floor(x);\n    } else {\n        return Math.round(x);\n    }\n}\n\nfunction createNumberConversion(bitLength, typeOpts) {\n    if (!typeOpts.unsigned) {\n        --bitLength;\n    }\n    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);\n    const upperBound = Math.pow(2, bitLength) - 1;\n\n    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);\n    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);\n\n    return function(V, opts) {\n        if (!opts) opts = {};\n\n        let x = +V;\n\n        if (opts.enforceRange) {\n            if (!Number.isFinite(x)) {\n                throw new TypeError(\"Argument is not a finite number\");\n            }\n\n            x = sign(x) * Math.floor(Math.abs(x));\n            if (x < lowerBound || x > upperBound) {\n                throw new TypeError(\"Argument is not in byte range\");\n            }\n\n            return x;\n        }\n\n        if (!isNaN(x) && opts.clamp) {\n            x = evenRound(x);\n\n            if (x < lowerBound) x = lowerBound;\n            if (x > upperBound) x = upperBound;\n            return x;\n        }\n\n        if (!Number.isFinite(x) || x === 0) {\n            return 0;\n        }\n\n        x = sign(x) * Math.floor(Math.abs(x));\n        x = x % moduloVal;\n\n        if (!typeOpts.unsigned && x >= moduloBound) {\n            return x - moduloVal;\n        } else if (typeOpts.unsigned) {\n            if (x < 0) {\n              x += moduloVal;\n            } else if (x === -0) { // don't return negative zero\n              return 0;\n            }\n        }\n\n        return x;\n    }\n}\n\nconversions[\"void\"] = function () {\n    return undefined;\n};\n\nconversions[\"boolean\"] = function (val) {\n    return !!val;\n};\n\nconversions[\"byte\"] = createNumberConversion(8, { unsigned: false });\nconversions[\"octet\"] = createNumberConversion(8, { unsigned: true });\n\nconversions[\"short\"] = createNumberConversion(16, { unsigned: false });\nconversions[\"unsigned short\"] = createNumberConversion(16, { unsigned: true });\n\nconversions[\"long\"] = createNumberConversion(32, { unsigned: false });\nconversions[\"unsigned long\"] = createNumberConversion(32, { unsigned: true });\n\nconversions[\"long long\"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });\nconversions[\"unsigned long long\"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });\n\nconversions[\"double\"] = function (V) {\n    const x = +V;\n\n    if (!Number.isFinite(x)) {\n        throw new TypeError(\"Argument is not a finite floating-point value\");\n    }\n\n    return x;\n};\n\nconversions[\"unrestricted double\"] = function (V) {\n    const x = +V;\n\n    if (isNaN(x)) {\n        throw new TypeError(\"Argument is NaN\");\n    }\n\n    return x;\n};\n\n// not quite valid, but good enough for JS\nconversions[\"float\"] = conversions[\"double\"];\nconversions[\"unrestricted float\"] = conversions[\"unrestricted double\"];\n\nconversions[\"DOMString\"] = function (V, opts) {\n    if (!opts) opts = {};\n\n    if (opts.treatNullAsEmptyString && V === null) {\n        return \"\";\n    }\n\n    return String(V);\n};\n\nconversions[\"ByteString\"] = function (V, opts) {\n    const x = String(V);\n    let c = undefined;\n    for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {\n        if (c > 255) {\n            throw new TypeError(\"Argument is not a valid bytestring\");\n        }\n    }\n\n    return x;\n};\n\nconversions[\"USVString\"] = function (V) {\n    const S = String(V);\n    const n = S.length;\n    const U = [];\n    for (let i = 0; i < n; ++i) {\n        const c = S.charCodeAt(i);\n        if (c < 0xD800 || c > 0xDFFF) {\n            U.push(String.fromCodePoint(c));\n        } else if (0xDC00 <= c && c <= 0xDFFF) {\n            U.push(String.fromCodePoint(0xFFFD));\n        } else {\n            if (i === n - 1) {\n                U.push(String.fromCodePoint(0xFFFD));\n            } else {\n                const d = S.charCodeAt(i + 1);\n                if (0xDC00 <= d && d <= 0xDFFF) {\n                    const a = c & 0x3FF;\n                    const b = d & 0x3FF;\n                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));\n                    ++i;\n                } else {\n                    U.push(String.fromCodePoint(0xFFFD));\n                }\n            }\n        }\n    }\n\n    return U.join('');\n};\n\nconversions[\"Date\"] = function (V, opts) {\n    if (!(V instanceof Date)) {\n        throw new TypeError(\"Argument is not a Date object\");\n    }\n    if (isNaN(V)) {\n        return undefined;\n    }\n\n    return V;\n};\n\nconversions[\"RegExp\"] = function (V, opts) {\n    if (!(V instanceof RegExp)) {\n        V = new RegExp(V);\n    }\n\n    return V;\n};\n","\"use strict\";\nconst usm = require(\"./url-state-machine\");\n\nexports.implementation = class URLImpl {\n  constructor(constructorArgs) {\n    const url = constructorArgs[0];\n    const base = constructorArgs[1];\n\n    let parsedBase = null;\n    if (base !== undefined) {\n      parsedBase = usm.basicURLParse(base);\n      if (parsedBase === \"failure\") {\n        throw new TypeError(\"Invalid base URL\");\n      }\n    }\n\n    const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });\n    if (parsedURL === \"failure\") {\n      throw new TypeError(\"Invalid URL\");\n    }\n\n    this._url = parsedURL;\n\n    // TODO: query stuff\n  }\n\n  get href() {\n    return usm.serializeURL(this._url);\n  }\n\n  set href(v) {\n    const parsedURL = usm.basicURLParse(v);\n    if (parsedURL === \"failure\") {\n      throw new TypeError(\"Invalid URL\");\n    }\n\n    this._url = parsedURL;\n  }\n\n  get origin() {\n    return usm.serializeURLOrigin(this._url);\n  }\n\n  get protocol() {\n    return this._url.scheme + \":\";\n  }\n\n  set protocol(v) {\n    usm.basicURLParse(v + \":\", { url: this._url, stateOverride: \"scheme start\" });\n  }\n\n  get username() {\n    return this._url.username;\n  }\n\n  set username(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    usm.setTheUsername(this._url, v);\n  }\n\n  get password() {\n    return this._url.password;\n  }\n\n  set password(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    usm.setThePassword(this._url, v);\n  }\n\n  get host() {\n    const url = this._url;\n\n    if (url.host === null) {\n      return \"\";\n    }\n\n    if (url.port === null) {\n      return usm.serializeHost(url.host);\n    }\n\n    return usm.serializeHost(url.host) + \":\" + usm.serializeInteger(url.port);\n  }\n\n  set host(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"host\" });\n  }\n\n  get hostname() {\n    if (this._url.host === null) {\n      return \"\";\n    }\n\n    return usm.serializeHost(this._url.host);\n  }\n\n  set hostname(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"hostname\" });\n  }\n\n  get port() {\n    if (this._url.port === null) {\n      return \"\";\n    }\n\n    return usm.serializeInteger(this._url.port);\n  }\n\n  set port(v) {\n    if (usm.cannotHaveAUsernamePasswordPort(this._url)) {\n      return;\n    }\n\n    if (v === \"\") {\n      this._url.port = null;\n    } else {\n      usm.basicURLParse(v, { url: this._url, stateOverride: \"port\" });\n    }\n  }\n\n  get pathname() {\n    if (this._url.cannotBeABaseURL) {\n      return this._url.path[0];\n    }\n\n    if (this._url.path.length === 0) {\n      return \"\";\n    }\n\n    return \"/\" + this._url.path.join(\"/\");\n  }\n\n  set pathname(v) {\n    if (this._url.cannotBeABaseURL) {\n      return;\n    }\n\n    this._url.path = [];\n    usm.basicURLParse(v, { url: this._url, stateOverride: \"path start\" });\n  }\n\n  get search() {\n    if (this._url.query === null || this._url.query === \"\") {\n      return \"\";\n    }\n\n    return \"?\" + this._url.query;\n  }\n\n  set search(v) {\n    // TODO: query stuff\n\n    const url = this._url;\n\n    if (v === \"\") {\n      url.query = null;\n      return;\n    }\n\n    const input = v[0] === \"?\" ? v.substring(1) : v;\n    url.query = \"\";\n    usm.basicURLParse(input, { url, stateOverride: \"query\" });\n  }\n\n  get hash() {\n    if (this._url.fragment === null || this._url.fragment === \"\") {\n      return \"\";\n    }\n\n    return \"#\" + this._url.fragment;\n  }\n\n  set hash(v) {\n    if (v === \"\") {\n      this._url.fragment = null;\n      return;\n    }\n\n    const input = v[0] === \"#\" ? v.substring(1) : v;\n    this._url.fragment = \"\";\n    usm.basicURLParse(input, { url: this._url, stateOverride: \"fragment\" });\n  }\n\n  toJSON() {\n    return this.href;\n  }\n};\n","\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst Impl = require(\".//URL-impl.js\");\n\nconst impl = utils.implSymbol;\n\nfunction URL(url) {\n  if (!this || this[impl] || !(this instanceof URL)) {\n    throw new TypeError(\"Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to construct 'URL': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = arguments[i];\n  }\n  args[0] = conversions[\"USVString\"](args[0]);\n  if (args[1] !== undefined) {\n  args[1] = conversions[\"USVString\"](args[1]);\n  }\n\n  module.exports.setup(this, args);\n}\n\nURL.prototype.toJSON = function toJSON() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 0; ++i) {\n    args[i] = arguments[i];\n  }\n  return this[impl].toJSON.apply(this[impl], args);\n};\nObject.defineProperty(URL.prototype, \"href\", {\n  get() {\n    return this[impl].href;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].href = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nURL.prototype.toString = function () {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  return this.href;\n};\n\nObject.defineProperty(URL.prototype, \"origin\", {\n  get() {\n    return this[impl].origin;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"protocol\", {\n  get() {\n    return this[impl].protocol;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].protocol = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"username\", {\n  get() {\n    return this[impl].username;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].username = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"password\", {\n  get() {\n    return this[impl].password;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].password = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"host\", {\n  get() {\n    return this[impl].host;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].host = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"hostname\", {\n  get() {\n    return this[impl].hostname;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].hostname = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"port\", {\n  get() {\n    return this[impl].port;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].port = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"pathname\", {\n  get() {\n    return this[impl].pathname;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].pathname = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"search\", {\n  get() {\n    return this[impl].search;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].search = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(URL.prototype, \"hash\", {\n  get() {\n    return this[impl].hash;\n  },\n  set(V) {\n    V = conversions[\"USVString\"](V);\n    this[impl].hash = V;\n  },\n  enumerable: true,\n  configurable: true\n});\n\n\nmodule.exports = {\n  is(obj) {\n    return !!obj && obj[impl] instanceof Impl.implementation;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(URL.prototype);\n    this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n\n    obj[impl] = new Impl.implementation(constructorArgs, privateData);\n    obj[impl][utils.wrapperSymbol] = obj;\n  },\n  interface: URL,\n  expose: {\n    Window: { URL: URL },\n    Worker: { URL: URL }\n  }\n};\n\n","\"use strict\";\n\nexports.URL = require(\"./URL\").interface;\nexports.serializeURL = require(\"./url-state-machine\").serializeURL;\nexports.serializeURLOrigin = require(\"./url-state-machine\").serializeURLOrigin;\nexports.basicURLParse = require(\"./url-state-machine\").basicURLParse;\nexports.setTheUsername = require(\"./url-state-machine\").setTheUsername;\nexports.setThePassword = require(\"./url-state-machine\").setThePassword;\nexports.serializeHost = require(\"./url-state-machine\").serializeHost;\nexports.serializeInteger = require(\"./url-state-machine\").serializeInteger;\nexports.parseURL = require(\"./url-state-machine\").parseURL;\n","\"use strict\";\r\nconst punycode = require(\"punycode\");\r\nconst tr46 = require(\"tr46\");\r\n\r\nconst specialSchemes = {\r\n  ftp: 21,\r\n  file: null,\r\n  gopher: 70,\r\n  http: 80,\r\n  https: 443,\r\n  ws: 80,\r\n  wss: 443\r\n};\r\n\r\nconst failure = Symbol(\"failure\");\r\n\r\nfunction countSymbols(str) {\r\n  return punycode.ucs2.decode(str).length;\r\n}\r\n\r\nfunction at(input, idx) {\r\n  const c = input[idx];\r\n  return isNaN(c) ? undefined : String.fromCodePoint(c);\r\n}\r\n\r\nfunction isASCIIDigit(c) {\r\n  return c >= 0x30 && c <= 0x39;\r\n}\r\n\r\nfunction isASCIIAlpha(c) {\r\n  return (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A);\r\n}\r\n\r\nfunction isASCIIAlphanumeric(c) {\r\n  return isASCIIAlpha(c) || isASCIIDigit(c);\r\n}\r\n\r\nfunction isASCIIHex(c) {\r\n  return isASCIIDigit(c) || (c >= 0x41 && c <= 0x46) || (c >= 0x61 && c <= 0x66);\r\n}\r\n\r\nfunction isSingleDot(buffer) {\r\n  return buffer === \".\" || buffer.toLowerCase() === \"%2e\";\r\n}\r\n\r\nfunction isDoubleDot(buffer) {\r\n  buffer = buffer.toLowerCase();\r\n  return buffer === \"..\" || buffer === \"%2e.\" || buffer === \".%2e\" || buffer === \"%2e%2e\";\r\n}\r\n\r\nfunction isWindowsDriveLetterCodePoints(cp1, cp2) {\r\n  return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);\r\n}\r\n\r\nfunction isWindowsDriveLetterString(string) {\r\n  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === \":\" || string[1] === \"|\");\r\n}\r\n\r\nfunction isNormalizedWindowsDriveLetterString(string) {\r\n  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === \":\";\r\n}\r\n\r\nfunction containsForbiddenHostCodePoint(string) {\r\n  return string.search(/\\u0000|\\u0009|\\u000A|\\u000D|\\u0020|#|%|\\/|:|\\?|@|\\[|\\\\|\\]/) !== -1;\r\n}\r\n\r\nfunction containsForbiddenHostCodePointExcludingPercent(string) {\r\n  return string.search(/\\u0000|\\u0009|\\u000A|\\u000D|\\u0020|#|\\/|:|\\?|@|\\[|\\\\|\\]/) !== -1;\r\n}\r\n\r\nfunction isSpecialScheme(scheme) {\r\n  return specialSchemes[scheme] !== undefined;\r\n}\r\n\r\nfunction isSpecial(url) {\r\n  return isSpecialScheme(url.scheme);\r\n}\r\n\r\nfunction defaultPort(scheme) {\r\n  return specialSchemes[scheme];\r\n}\r\n\r\nfunction percentEncode(c) {\r\n  let hex = c.toString(16).toUpperCase();\r\n  if (hex.length === 1) {\r\n    hex = \"0\" + hex;\r\n  }\r\n\r\n  return \"%\" + hex;\r\n}\r\n\r\nfunction utf8PercentEncode(c) {\r\n  const buf = new Buffer(c);\r\n\r\n  let str = \"\";\r\n\r\n  for (let i = 0; i < buf.length; ++i) {\r\n    str += percentEncode(buf[i]);\r\n  }\r\n\r\n  return str;\r\n}\r\n\r\nfunction utf8PercentDecode(str) {\r\n  const input = new Buffer(str);\r\n  const output = [];\r\n  for (let i = 0; i < input.length; ++i) {\r\n    if (input[i] !== 37) {\r\n      output.push(input[i]);\r\n    } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {\r\n      output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));\r\n      i += 2;\r\n    } else {\r\n      output.push(input[i]);\r\n    }\r\n  }\r\n  return new Buffer(output).toString();\r\n}\r\n\r\nfunction isC0ControlPercentEncode(c) {\r\n  return c <= 0x1F || c > 0x7E;\r\n}\r\n\r\nconst extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);\r\nfunction isPathPercentEncode(c) {\r\n  return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);\r\n}\r\n\r\nconst extraUserinfoPercentEncodeSet =\r\n  new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);\r\nfunction isUserinfoPercentEncode(c) {\r\n  return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);\r\n}\r\n\r\nfunction percentEncodeChar(c, encodeSetPredicate) {\r\n  const cStr = String.fromCodePoint(c);\r\n\r\n  if (encodeSetPredicate(c)) {\r\n    return utf8PercentEncode(cStr);\r\n  }\r\n\r\n  return cStr;\r\n}\r\n\r\nfunction parseIPv4Number(input) {\r\n  let R = 10;\r\n\r\n  if (input.length >= 2 && input.charAt(0) === \"0\" && input.charAt(1).toLowerCase() === \"x\") {\r\n    input = input.substring(2);\r\n    R = 16;\r\n  } else if (input.length >= 2 && input.charAt(0) === \"0\") {\r\n    input = input.substring(1);\r\n    R = 8;\r\n  }\r\n\r\n  if (input === \"\") {\r\n    return 0;\r\n  }\r\n\r\n  const regex = R === 10 ? /[^0-9]/ : (R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/);\r\n  if (regex.test(input)) {\r\n    return failure;\r\n  }\r\n\r\n  return parseInt(input, R);\r\n}\r\n\r\nfunction parseIPv4(input) {\r\n  const parts = input.split(\".\");\r\n  if (parts[parts.length - 1] === \"\") {\r\n    if (parts.length > 1) {\r\n      parts.pop();\r\n    }\r\n  }\r\n\r\n  if (parts.length > 4) {\r\n    return input;\r\n  }\r\n\r\n  const numbers = [];\r\n  for (const part of parts) {\r\n    if (part === \"\") {\r\n      return input;\r\n    }\r\n    const n = parseIPv4Number(part);\r\n    if (n === failure) {\r\n      return input;\r\n    }\r\n\r\n    numbers.push(n);\r\n  }\r\n\r\n  for (let i = 0; i < numbers.length - 1; ++i) {\r\n    if (numbers[i] > 255) {\r\n      return failure;\r\n    }\r\n  }\r\n  if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {\r\n    return failure;\r\n  }\r\n\r\n  let ipv4 = numbers.pop();\r\n  let counter = 0;\r\n\r\n  for (const n of numbers) {\r\n    ipv4 += n * Math.pow(256, 3 - counter);\r\n    ++counter;\r\n  }\r\n\r\n  return ipv4;\r\n}\r\n\r\nfunction serializeIPv4(address) {\r\n  let output = \"\";\r\n  let n = address;\r\n\r\n  for (let i = 1; i <= 4; ++i) {\r\n    output = String(n % 256) + output;\r\n    if (i !== 4) {\r\n      output = \".\" + output;\r\n    }\r\n    n = Math.floor(n / 256);\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction parseIPv6(input) {\r\n  const address = [0, 0, 0, 0, 0, 0, 0, 0];\r\n  let pieceIndex = 0;\r\n  let compress = null;\r\n  let pointer = 0;\r\n\r\n  input = punycode.ucs2.decode(input);\r\n\r\n  if (input[pointer] === 58) {\r\n    if (input[pointer + 1] !== 58) {\r\n      return failure;\r\n    }\r\n\r\n    pointer += 2;\r\n    ++pieceIndex;\r\n    compress = pieceIndex;\r\n  }\r\n\r\n  while (pointer < input.length) {\r\n    if (pieceIndex === 8) {\r\n      return failure;\r\n    }\r\n\r\n    if (input[pointer] === 58) {\r\n      if (compress !== null) {\r\n        return failure;\r\n      }\r\n      ++pointer;\r\n      ++pieceIndex;\r\n      compress = pieceIndex;\r\n      continue;\r\n    }\r\n\r\n    let value = 0;\r\n    let length = 0;\r\n\r\n    while (length < 4 && isASCIIHex(input[pointer])) {\r\n      value = value * 0x10 + parseInt(at(input, pointer), 16);\r\n      ++pointer;\r\n      ++length;\r\n    }\r\n\r\n    if (input[pointer] === 46) {\r\n      if (length === 0) {\r\n        return failure;\r\n      }\r\n\r\n      pointer -= length;\r\n\r\n      if (pieceIndex > 6) {\r\n        return failure;\r\n      }\r\n\r\n      let numbersSeen = 0;\r\n\r\n      while (input[pointer] !== undefined) {\r\n        let ipv4Piece = null;\r\n\r\n        if (numbersSeen > 0) {\r\n          if (input[pointer] === 46 && numbersSeen < 4) {\r\n            ++pointer;\r\n          } else {\r\n            return failure;\r\n          }\r\n        }\r\n\r\n        if (!isASCIIDigit(input[pointer])) {\r\n          return failure;\r\n        }\r\n\r\n        while (isASCIIDigit(input[pointer])) {\r\n          const number = parseInt(at(input, pointer));\r\n          if (ipv4Piece === null) {\r\n            ipv4Piece = number;\r\n          } else if (ipv4Piece === 0) {\r\n            return failure;\r\n          } else {\r\n            ipv4Piece = ipv4Piece * 10 + number;\r\n          }\r\n          if (ipv4Piece > 255) {\r\n            return failure;\r\n          }\r\n          ++pointer;\r\n        }\r\n\r\n        address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;\r\n\r\n        ++numbersSeen;\r\n\r\n        if (numbersSeen === 2 || numbersSeen === 4) {\r\n          ++pieceIndex;\r\n        }\r\n      }\r\n\r\n      if (numbersSeen !== 4) {\r\n        return failure;\r\n      }\r\n\r\n      break;\r\n    } else if (input[pointer] === 58) {\r\n      ++pointer;\r\n      if (input[pointer] === undefined) {\r\n        return failure;\r\n      }\r\n    } else if (input[pointer] !== undefined) {\r\n      return failure;\r\n    }\r\n\r\n    address[pieceIndex] = value;\r\n    ++pieceIndex;\r\n  }\r\n\r\n  if (compress !== null) {\r\n    let swaps = pieceIndex - compress;\r\n    pieceIndex = 7;\r\n    while (pieceIndex !== 0 && swaps > 0) {\r\n      const temp = address[compress + swaps - 1];\r\n      address[compress + swaps - 1] = address[pieceIndex];\r\n      address[pieceIndex] = temp;\r\n      --pieceIndex;\r\n      --swaps;\r\n    }\r\n  } else if (compress === null && pieceIndex !== 8) {\r\n    return failure;\r\n  }\r\n\r\n  return address;\r\n}\r\n\r\nfunction serializeIPv6(address) {\r\n  let output = \"\";\r\n  const seqResult = findLongestZeroSequence(address);\r\n  const compress = seqResult.idx;\r\n  let ignore0 = false;\r\n\r\n  for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {\r\n    if (ignore0 && address[pieceIndex] === 0) {\r\n      continue;\r\n    } else if (ignore0) {\r\n      ignore0 = false;\r\n    }\r\n\r\n    if (compress === pieceIndex) {\r\n      const separator = pieceIndex === 0 ? \"::\" : \":\";\r\n      output += separator;\r\n      ignore0 = true;\r\n      continue;\r\n    }\r\n\r\n    output += address[pieceIndex].toString(16);\r\n\r\n    if (pieceIndex !== 7) {\r\n      output += \":\";\r\n    }\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction parseHost(input, isSpecialArg) {\r\n  if (input[0] === \"[\") {\r\n    if (input[input.length - 1] !== \"]\") {\r\n      return failure;\r\n    }\r\n\r\n    return parseIPv6(input.substring(1, input.length - 1));\r\n  }\r\n\r\n  if (!isSpecialArg) {\r\n    return parseOpaqueHost(input);\r\n  }\r\n\r\n  const domain = utf8PercentDecode(input);\r\n  const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);\r\n  if (asciiDomain === null) {\r\n    return failure;\r\n  }\r\n\r\n  if (containsForbiddenHostCodePoint(asciiDomain)) {\r\n    return failure;\r\n  }\r\n\r\n  const ipv4Host = parseIPv4(asciiDomain);\r\n  if (typeof ipv4Host === \"number\" || ipv4Host === failure) {\r\n    return ipv4Host;\r\n  }\r\n\r\n  return asciiDomain;\r\n}\r\n\r\nfunction parseOpaqueHost(input) {\r\n  if (containsForbiddenHostCodePointExcludingPercent(input)) {\r\n    return failure;\r\n  }\r\n\r\n  let output = \"\";\r\n  const decoded = punycode.ucs2.decode(input);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);\r\n  }\r\n  return output;\r\n}\r\n\r\nfunction findLongestZeroSequence(arr) {\r\n  let maxIdx = null;\r\n  let maxLen = 1; // only find elements > 1\r\n  let currStart = null;\r\n  let currLen = 0;\r\n\r\n  for (let i = 0; i < arr.length; ++i) {\r\n    if (arr[i] !== 0) {\r\n      if (currLen > maxLen) {\r\n        maxIdx = currStart;\r\n        maxLen = currLen;\r\n      }\r\n\r\n      currStart = null;\r\n      currLen = 0;\r\n    } else {\r\n      if (currStart === null) {\r\n        currStart = i;\r\n      }\r\n      ++currLen;\r\n    }\r\n  }\r\n\r\n  // if trailing zeros\r\n  if (currLen > maxLen) {\r\n    maxIdx = currStart;\r\n    maxLen = currLen;\r\n  }\r\n\r\n  return {\r\n    idx: maxIdx,\r\n    len: maxLen\r\n  };\r\n}\r\n\r\nfunction serializeHost(host) {\r\n  if (typeof host === \"number\") {\r\n    return serializeIPv4(host);\r\n  }\r\n\r\n  // IPv6 serializer\r\n  if (host instanceof Array) {\r\n    return \"[\" + serializeIPv6(host) + \"]\";\r\n  }\r\n\r\n  return host;\r\n}\r\n\r\nfunction trimControlChars(url) {\r\n  return url.replace(/^[\\u0000-\\u001F\\u0020]+|[\\u0000-\\u001F\\u0020]+$/g, \"\");\r\n}\r\n\r\nfunction trimTabAndNewline(url) {\r\n  return url.replace(/\\u0009|\\u000A|\\u000D/g, \"\");\r\n}\r\n\r\nfunction shortenPath(url) {\r\n  const path = url.path;\r\n  if (path.length === 0) {\r\n    return;\r\n  }\r\n  if (url.scheme === \"file\" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {\r\n    return;\r\n  }\r\n\r\n  path.pop();\r\n}\r\n\r\nfunction includesCredentials(url) {\r\n  return url.username !== \"\" || url.password !== \"\";\r\n}\r\n\r\nfunction cannotHaveAUsernamePasswordPort(url) {\r\n  return url.host === null || url.host === \"\" || url.cannotBeABaseURL || url.scheme === \"file\";\r\n}\r\n\r\nfunction isNormalizedWindowsDriveLetter(string) {\r\n  return /^[A-Za-z]:$/.test(string);\r\n}\r\n\r\nfunction URLStateMachine(input, base, encodingOverride, url, stateOverride) {\r\n  this.pointer = 0;\r\n  this.input = input;\r\n  this.base = base || null;\r\n  this.encodingOverride = encodingOverride || \"utf-8\";\r\n  this.stateOverride = stateOverride;\r\n  this.url = url;\r\n  this.failure = false;\r\n  this.parseError = false;\r\n\r\n  if (!this.url) {\r\n    this.url = {\r\n      scheme: \"\",\r\n      username: \"\",\r\n      password: \"\",\r\n      host: null,\r\n      port: null,\r\n      path: [],\r\n      query: null,\r\n      fragment: null,\r\n\r\n      cannotBeABaseURL: false\r\n    };\r\n\r\n    const res = trimControlChars(this.input);\r\n    if (res !== this.input) {\r\n      this.parseError = true;\r\n    }\r\n    this.input = res;\r\n  }\r\n\r\n  const res = trimTabAndNewline(this.input);\r\n  if (res !== this.input) {\r\n    this.parseError = true;\r\n  }\r\n  this.input = res;\r\n\r\n  this.state = stateOverride || \"scheme start\";\r\n\r\n  this.buffer = \"\";\r\n  this.atFlag = false;\r\n  this.arrFlag = false;\r\n  this.passwordTokenSeenFlag = false;\r\n\r\n  this.input = punycode.ucs2.decode(this.input);\r\n\r\n  for (; this.pointer <= this.input.length; ++this.pointer) {\r\n    const c = this.input[this.pointer];\r\n    const cStr = isNaN(c) ? undefined : String.fromCodePoint(c);\r\n\r\n    // exec state machine\r\n    const ret = this[\"parse \" + this.state](c, cStr);\r\n    if (!ret) {\r\n      break; // terminate algorithm\r\n    } else if (ret === failure) {\r\n      this.failure = true;\r\n      break;\r\n    }\r\n  }\r\n}\r\n\r\nURLStateMachine.prototype[\"parse scheme start\"] = function parseSchemeStart(c, cStr) {\r\n  if (isASCIIAlpha(c)) {\r\n    this.buffer += cStr.toLowerCase();\r\n    this.state = \"scheme\";\r\n  } else if (!this.stateOverride) {\r\n    this.state = \"no scheme\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse scheme\"] = function parseScheme(c, cStr) {\r\n  if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {\r\n    this.buffer += cStr.toLowerCase();\r\n  } else if (c === 58) {\r\n    if (this.stateOverride) {\r\n      if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {\r\n        return false;\r\n      }\r\n\r\n      if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {\r\n        return false;\r\n      }\r\n\r\n      if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === \"file\") {\r\n        return false;\r\n      }\r\n\r\n      if (this.url.scheme === \"file\" && (this.url.host === \"\" || this.url.host === null)) {\r\n        return false;\r\n      }\r\n    }\r\n    this.url.scheme = this.buffer;\r\n    this.buffer = \"\";\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n    if (this.url.scheme === \"file\") {\r\n      if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {\r\n        this.parseError = true;\r\n      }\r\n      this.state = \"file\";\r\n    } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {\r\n      this.state = \"special relative or authority\";\r\n    } else if (isSpecial(this.url)) {\r\n      this.state = \"special authority slashes\";\r\n    } else if (this.input[this.pointer + 1] === 47) {\r\n      this.state = \"path or authority\";\r\n      ++this.pointer;\r\n    } else {\r\n      this.url.cannotBeABaseURL = true;\r\n      this.url.path.push(\"\");\r\n      this.state = \"cannot-be-a-base-URL path\";\r\n    }\r\n  } else if (!this.stateOverride) {\r\n    this.buffer = \"\";\r\n    this.state = \"no scheme\";\r\n    this.pointer = -1;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse no scheme\"] = function parseNoScheme(c) {\r\n  if (this.base === null || (this.base.cannotBeABaseURL && c !== 35)) {\r\n    return failure;\r\n  } else if (this.base.cannotBeABaseURL && c === 35) {\r\n    this.url.scheme = this.base.scheme;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n    this.url.fragment = \"\";\r\n    this.url.cannotBeABaseURL = true;\r\n    this.state = \"fragment\";\r\n  } else if (this.base.scheme === \"file\") {\r\n    this.state = \"file\";\r\n    --this.pointer;\r\n  } else {\r\n    this.state = \"relative\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special relative or authority\"] = function parseSpecialRelativeOrAuthority(c) {\r\n  if (c === 47 && this.input[this.pointer + 1] === 47) {\r\n    this.state = \"special authority ignore slashes\";\r\n    ++this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    this.state = \"relative\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path or authority\"] = function parsePathOrAuthority(c) {\r\n  if (c === 47) {\r\n    this.state = \"authority\";\r\n  } else {\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse relative\"] = function parseRelative(c) {\r\n  this.url.scheme = this.base.scheme;\r\n  if (isNaN(c)) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n  } else if (c === 47) {\r\n    this.state = \"relative slash\";\r\n  } else if (c === 63) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (c === 35) {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice();\r\n    this.url.query = this.base.query;\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else if (isSpecial(this.url) && c === 92) {\r\n    this.parseError = true;\r\n    this.state = \"relative slash\";\r\n  } else {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.url.path = this.base.path.slice(0, this.base.path.length - 1);\r\n\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse relative slash\"] = function parseRelativeSlash(c) {\r\n  if (isSpecial(this.url) && (c === 47 || c === 92)) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"special authority ignore slashes\";\r\n  } else if (c === 47) {\r\n    this.state = \"authority\";\r\n  } else {\r\n    this.url.username = this.base.username;\r\n    this.url.password = this.base.password;\r\n    this.url.host = this.base.host;\r\n    this.url.port = this.base.port;\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special authority slashes\"] = function parseSpecialAuthoritySlashes(c) {\r\n  if (c === 47 && this.input[this.pointer + 1] === 47) {\r\n    this.state = \"special authority ignore slashes\";\r\n    ++this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    this.state = \"special authority ignore slashes\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse special authority ignore slashes\"] = function parseSpecialAuthorityIgnoreSlashes(c) {\r\n  if (c !== 47 && c !== 92) {\r\n    this.state = \"authority\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse authority\"] = function parseAuthority(c, cStr) {\r\n  if (c === 64) {\r\n    this.parseError = true;\r\n    if (this.atFlag) {\r\n      this.buffer = \"%40\" + this.buffer;\r\n    }\r\n    this.atFlag = true;\r\n\r\n    // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars\r\n    const len = countSymbols(this.buffer);\r\n    for (let pointer = 0; pointer < len; ++pointer) {\r\n      const codePoint = this.buffer.codePointAt(pointer);\r\n\r\n      if (codePoint === 58 && !this.passwordTokenSeenFlag) {\r\n        this.passwordTokenSeenFlag = true;\r\n        continue;\r\n      }\r\n      const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);\r\n      if (this.passwordTokenSeenFlag) {\r\n        this.url.password += encodedCodePoints;\r\n      } else {\r\n        this.url.username += encodedCodePoints;\r\n      }\r\n    }\r\n    this.buffer = \"\";\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92)) {\r\n    if (this.atFlag && this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    }\r\n    this.pointer -= countSymbols(this.buffer) + 1;\r\n    this.buffer = \"\";\r\n    this.state = \"host\";\r\n  } else {\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse hostname\"] =\r\nURLStateMachine.prototype[\"parse host\"] = function parseHostName(c, cStr) {\r\n  if (this.stateOverride && this.url.scheme === \"file\") {\r\n    --this.pointer;\r\n    this.state = \"file host\";\r\n  } else if (c === 58 && !this.arrFlag) {\r\n    if (this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    }\r\n\r\n    const host = parseHost(this.buffer, isSpecial(this.url));\r\n    if (host === failure) {\r\n      return failure;\r\n    }\r\n\r\n    this.url.host = host;\r\n    this.buffer = \"\";\r\n    this.state = \"port\";\r\n    if (this.stateOverride === \"hostname\") {\r\n      return false;\r\n    }\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92)) {\r\n    --this.pointer;\r\n    if (isSpecial(this.url) && this.buffer === \"\") {\r\n      this.parseError = true;\r\n      return failure;\r\n    } else if (this.stateOverride && this.buffer === \"\" &&\r\n               (includesCredentials(this.url) || this.url.port !== null)) {\r\n      this.parseError = true;\r\n      return false;\r\n    }\r\n\r\n    const host = parseHost(this.buffer, isSpecial(this.url));\r\n    if (host === failure) {\r\n      return failure;\r\n    }\r\n\r\n    this.url.host = host;\r\n    this.buffer = \"\";\r\n    this.state = \"path start\";\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n  } else {\r\n    if (c === 91) {\r\n      this.arrFlag = true;\r\n    } else if (c === 93) {\r\n      this.arrFlag = false;\r\n    }\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse port\"] = function parsePort(c, cStr) {\r\n  if (isASCIIDigit(c)) {\r\n    this.buffer += cStr;\r\n  } else if (isNaN(c) || c === 47 || c === 63 || c === 35 ||\r\n             (isSpecial(this.url) && c === 92) ||\r\n             this.stateOverride) {\r\n    if (this.buffer !== \"\") {\r\n      const port = parseInt(this.buffer);\r\n      if (port > Math.pow(2, 16) - 1) {\r\n        this.parseError = true;\r\n        return failure;\r\n      }\r\n      this.url.port = port === defaultPort(this.url.scheme) ? null : port;\r\n      this.buffer = \"\";\r\n    }\r\n    if (this.stateOverride) {\r\n      return false;\r\n    }\r\n    this.state = \"path start\";\r\n    --this.pointer;\r\n  } else {\r\n    this.parseError = true;\r\n    return failure;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nconst fileOtherwiseCodePoints = new Set([47, 92, 63, 35]);\r\n\r\nURLStateMachine.prototype[\"parse file\"] = function parseFile(c) {\r\n  this.url.scheme = \"file\";\r\n\r\n  if (c === 47 || c === 92) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"file slash\";\r\n  } else if (this.base !== null && this.base.scheme === \"file\") {\r\n    if (isNaN(c)) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = this.base.query;\r\n    } else if (c === 63) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = \"\";\r\n      this.state = \"query\";\r\n    } else if (c === 35) {\r\n      this.url.host = this.base.host;\r\n      this.url.path = this.base.path.slice();\r\n      this.url.query = this.base.query;\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    } else {\r\n      if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points\r\n          !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) ||\r\n          (this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points\r\n           !fileOtherwiseCodePoints.has(this.input[this.pointer + 2]))) {\r\n        this.url.host = this.base.host;\r\n        this.url.path = this.base.path.slice();\r\n        shortenPath(this.url);\r\n      } else {\r\n        this.parseError = true;\r\n      }\r\n\r\n      this.state = \"path\";\r\n      --this.pointer;\r\n    }\r\n  } else {\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse file slash\"] = function parseFileSlash(c) {\r\n  if (c === 47 || c === 92) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"file host\";\r\n  } else {\r\n    if (this.base !== null && this.base.scheme === \"file\") {\r\n      if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {\r\n        this.url.path.push(this.base.path[0]);\r\n      } else {\r\n        this.url.host = this.base.host;\r\n      }\r\n    }\r\n    this.state = \"path\";\r\n    --this.pointer;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse file host\"] = function parseFileHost(c, cStr) {\r\n  if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {\r\n    --this.pointer;\r\n    if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {\r\n      this.parseError = true;\r\n      this.state = \"path\";\r\n    } else if (this.buffer === \"\") {\r\n      this.url.host = \"\";\r\n      if (this.stateOverride) {\r\n        return false;\r\n      }\r\n      this.state = \"path start\";\r\n    } else {\r\n      let host = parseHost(this.buffer, isSpecial(this.url));\r\n      if (host === failure) {\r\n        return failure;\r\n      }\r\n      if (host === \"localhost\") {\r\n        host = \"\";\r\n      }\r\n      this.url.host = host;\r\n\r\n      if (this.stateOverride) {\r\n        return false;\r\n      }\r\n\r\n      this.buffer = \"\";\r\n      this.state = \"path start\";\r\n    }\r\n  } else {\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path start\"] = function parsePathStart(c) {\r\n  if (isSpecial(this.url)) {\r\n    if (c === 92) {\r\n      this.parseError = true;\r\n    }\r\n    this.state = \"path\";\r\n\r\n    if (c !== 47 && c !== 92) {\r\n      --this.pointer;\r\n    }\r\n  } else if (!this.stateOverride && c === 63) {\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (!this.stateOverride && c === 35) {\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else if (c !== undefined) {\r\n    this.state = \"path\";\r\n    if (c !== 47) {\r\n      --this.pointer;\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse path\"] = function parsePath(c) {\r\n  if (isNaN(c) || c === 47 || (isSpecial(this.url) && c === 92) ||\r\n      (!this.stateOverride && (c === 63 || c === 35))) {\r\n    if (isSpecial(this.url) && c === 92) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (isDoubleDot(this.buffer)) {\r\n      shortenPath(this.url);\r\n      if (c !== 47 && !(isSpecial(this.url) && c === 92)) {\r\n        this.url.path.push(\"\");\r\n      }\r\n    } else if (isSingleDot(this.buffer) && c !== 47 &&\r\n               !(isSpecial(this.url) && c === 92)) {\r\n      this.url.path.push(\"\");\r\n    } else if (!isSingleDot(this.buffer)) {\r\n      if (this.url.scheme === \"file\" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {\r\n        if (this.url.host !== \"\" && this.url.host !== null) {\r\n          this.parseError = true;\r\n          this.url.host = \"\";\r\n        }\r\n        this.buffer = this.buffer[0] + \":\";\r\n      }\r\n      this.url.path.push(this.buffer);\r\n    }\r\n    this.buffer = \"\";\r\n    if (this.url.scheme === \"file\" && (c === undefined || c === 63 || c === 35)) {\r\n      while (this.url.path.length > 1 && this.url.path[0] === \"\") {\r\n        this.parseError = true;\r\n        this.url.path.shift();\r\n      }\r\n    }\r\n    if (c === 63) {\r\n      this.url.query = \"\";\r\n      this.state = \"query\";\r\n    }\r\n    if (c === 35) {\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    }\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.buffer += percentEncodeChar(c, isPathPercentEncode);\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse cannot-be-a-base-URL path\"] = function parseCannotBeABaseURLPath(c) {\r\n  if (c === 63) {\r\n    this.url.query = \"\";\r\n    this.state = \"query\";\r\n  } else if (c === 35) {\r\n    this.url.fragment = \"\";\r\n    this.state = \"fragment\";\r\n  } else {\r\n    // TODO: Add: not a URL code point\r\n    if (!isNaN(c) && c !== 37) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (c === 37 &&\r\n        (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n         !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    if (!isNaN(c)) {\r\n      this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);\r\n    }\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse query\"] = function parseQuery(c, cStr) {\r\n  if (isNaN(c) || (!this.stateOverride && c === 35)) {\r\n    if (!isSpecial(this.url) || this.url.scheme === \"ws\" || this.url.scheme === \"wss\") {\r\n      this.encodingOverride = \"utf-8\";\r\n    }\r\n\r\n    const buffer = new Buffer(this.buffer); // TODO: Use encoding override instead\r\n    for (let i = 0; i < buffer.length; ++i) {\r\n      if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 ||\r\n          buffer[i] === 0x3C || buffer[i] === 0x3E) {\r\n        this.url.query += percentEncode(buffer[i]);\r\n      } else {\r\n        this.url.query += String.fromCodePoint(buffer[i]);\r\n      }\r\n    }\r\n\r\n    this.buffer = \"\";\r\n    if (c === 35) {\r\n      this.url.fragment = \"\";\r\n      this.state = \"fragment\";\r\n    }\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.buffer += cStr;\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nURLStateMachine.prototype[\"parse fragment\"] = function parseFragment(c) {\r\n  if (isNaN(c)) { // do nothing\r\n  } else if (c === 0x0) {\r\n    this.parseError = true;\r\n  } else {\r\n    // TODO: If c is not a URL code point and not \"%\", parse error.\r\n    if (c === 37 &&\r\n      (!isASCIIHex(this.input[this.pointer + 1]) ||\r\n        !isASCIIHex(this.input[this.pointer + 2]))) {\r\n      this.parseError = true;\r\n    }\r\n\r\n    this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\nfunction serializeURL(url, excludeFragment) {\r\n  let output = url.scheme + \":\";\r\n  if (url.host !== null) {\r\n    output += \"//\";\r\n\r\n    if (url.username !== \"\" || url.password !== \"\") {\r\n      output += url.username;\r\n      if (url.password !== \"\") {\r\n        output += \":\" + url.password;\r\n      }\r\n      output += \"@\";\r\n    }\r\n\r\n    output += serializeHost(url.host);\r\n\r\n    if (url.port !== null) {\r\n      output += \":\" + url.port;\r\n    }\r\n  } else if (url.host === null && url.scheme === \"file\") {\r\n    output += \"//\";\r\n  }\r\n\r\n  if (url.cannotBeABaseURL) {\r\n    output += url.path[0];\r\n  } else {\r\n    for (const string of url.path) {\r\n      output += \"/\" + string;\r\n    }\r\n  }\r\n\r\n  if (url.query !== null) {\r\n    output += \"?\" + url.query;\r\n  }\r\n\r\n  if (!excludeFragment && url.fragment !== null) {\r\n    output += \"#\" + url.fragment;\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nfunction serializeOrigin(tuple) {\r\n  let result = tuple.scheme + \"://\";\r\n  result += serializeHost(tuple.host);\r\n\r\n  if (tuple.port !== null) {\r\n    result += \":\" + tuple.port;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nmodule.exports.serializeURL = serializeURL;\r\n\r\nmodule.exports.serializeURLOrigin = function (url) {\r\n  // https://url.spec.whatwg.org/#concept-url-origin\r\n  switch (url.scheme) {\r\n    case \"blob\":\r\n      try {\r\n        return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));\r\n      } catch (e) {\r\n        // serializing an opaque origin returns \"null\"\r\n        return \"null\";\r\n      }\r\n    case \"ftp\":\r\n    case \"gopher\":\r\n    case \"http\":\r\n    case \"https\":\r\n    case \"ws\":\r\n    case \"wss\":\r\n      return serializeOrigin({\r\n        scheme: url.scheme,\r\n        host: url.host,\r\n        port: url.port\r\n      });\r\n    case \"file\":\r\n      // spec says \"exercise to the reader\", chrome says \"file://\"\r\n      return \"file://\";\r\n    default:\r\n      // serializing an opaque origin returns \"null\"\r\n      return \"null\";\r\n  }\r\n};\r\n\r\nmodule.exports.basicURLParse = function (input, options) {\r\n  if (options === undefined) {\r\n    options = {};\r\n  }\r\n\r\n  const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);\r\n  if (usm.failure) {\r\n    return \"failure\";\r\n  }\r\n\r\n  return usm.url;\r\n};\r\n\r\nmodule.exports.setTheUsername = function (url, username) {\r\n  url.username = \"\";\r\n  const decoded = punycode.ucs2.decode(username);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);\r\n  }\r\n};\r\n\r\nmodule.exports.setThePassword = function (url, password) {\r\n  url.password = \"\";\r\n  const decoded = punycode.ucs2.decode(password);\r\n  for (let i = 0; i < decoded.length; ++i) {\r\n    url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);\r\n  }\r\n};\r\n\r\nmodule.exports.serializeHost = serializeHost;\r\n\r\nmodule.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;\r\n\r\nmodule.exports.serializeInteger = function (integer) {\r\n  return String(integer);\r\n};\r\n\r\nmodule.exports.parseURL = function (input, options) {\r\n  if (options === undefined) {\r\n    options = {};\r\n  }\r\n\r\n  // We don't handle blobs, so this just delegates:\r\n  return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });\r\n};\r\n","\"use strict\";\n\nmodule.exports.mixin = function mixin(target, source) {\n  const keys = Object.getOwnPropertyNames(source);\n  for (let i = 0; i < keys.length; ++i) {\n    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));\n  }\n};\n\nmodule.exports.wrapperSymbol = Symbol(\"wrapper\");\nmodule.exports.implSymbol = Symbol(\"impl\");\n\nmodule.exports.wrapperForImpl = function (impl) {\n  return impl[module.exports.wrapperSymbol];\n};\n\nmodule.exports.implForWrapper = function (wrapper) {\n  return wrapper[module.exports.implSymbol];\n};\n\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  \"use strict\";\n  exports.stripBOM = function(str) {\n    if (str[0] === '\\uFEFF') {\n      return str.substring(1);\n    } else {\n      return str;\n    }\n  };\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  \"use strict\";\n  var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA,\n    hasProp = {}.hasOwnProperty;\n\n  builder = require('xmlbuilder');\n\n  defaults = require('./defaults').defaults;\n\n  requiresCDATA = function(entry) {\n    return typeof entry === \"string\" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);\n  };\n\n  wrapCDATA = function(entry) {\n    return \"<![CDATA[\" + (escapeCDATA(entry)) + \"]]>\";\n  };\n\n  escapeCDATA = function(entry) {\n    return entry.replace(']]>', ']]]]><![CDATA[>');\n  };\n\n  exports.Builder = (function() {\n    function Builder(opts) {\n      var key, ref, value;\n      this.options = {};\n      ref = defaults[\"0.2\"];\n      for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this.options[key] = value;\n      }\n      for (key in opts) {\n        if (!hasProp.call(opts, key)) continue;\n        value = opts[key];\n        this.options[key] = value;\n      }\n    }\n\n    Builder.prototype.buildObject = function(rootObj) {\n      var attrkey, charkey, render, rootElement, rootName;\n      attrkey = this.options.attrkey;\n      charkey = this.options.charkey;\n      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === defaults['0.2'].rootName)) {\n        rootName = Object.keys(rootObj)[0];\n        rootObj = rootObj[rootName];\n      } else {\n        rootName = this.options.rootName;\n      }\n      render = (function(_this) {\n        return function(element, obj) {\n          var attr, child, entry, index, key, value;\n          if (typeof obj !== 'object') {\n            if (_this.options.cdata && requiresCDATA(obj)) {\n              element.raw(wrapCDATA(obj));\n            } else {\n              element.txt(obj);\n            }\n          } else if (Array.isArray(obj)) {\n            for (index in obj) {\n              if (!hasProp.call(obj, index)) continue;\n              child = obj[index];\n              for (key in child) {\n                entry = child[key];\n                element = render(element.ele(key), entry).up();\n              }\n            }\n          } else {\n            for (key in obj) {\n              if (!hasProp.call(obj, key)) continue;\n              child = obj[key];\n              if (key === attrkey) {\n                if (typeof child === \"object\") {\n                  for (attr in child) {\n                    value = child[attr];\n                    element = element.att(attr, value);\n                  }\n                }\n              } else if (key === charkey) {\n                if (_this.options.cdata && requiresCDATA(child)) {\n                  element = element.raw(wrapCDATA(child));\n                } else {\n                  element = element.txt(child);\n                }\n              } else if (Array.isArray(child)) {\n                for (index in child) {\n                  if (!hasProp.call(child, index)) continue;\n                  entry = child[index];\n                  if (typeof entry === 'string') {\n                    if (_this.options.cdata && requiresCDATA(entry)) {\n                      element = element.ele(key).raw(wrapCDATA(entry)).up();\n                    } else {\n                      element = element.ele(key, entry).up();\n                    }\n                  } else {\n                    element = render(element.ele(key), entry).up();\n                  }\n                }\n              } else if (typeof child === \"object\") {\n                element = render(element.ele(key), child).up();\n              } else {\n                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {\n                  element = element.ele(key).raw(wrapCDATA(child)).up();\n                } else {\n                  if (child == null) {\n                    child = '';\n                  }\n                  element = element.ele(key, child.toString()).up();\n                }\n              }\n            }\n          }\n          return element;\n        };\n      })(this);\n      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {\n        headless: this.options.headless,\n        allowSurrogateChars: this.options.allowSurrogateChars\n      });\n      return render(rootElement, rootObj).end(this.options.renderOpts);\n    };\n\n    return Builder;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  exports.defaults = {\n    \"0.1\": {\n      explicitCharkey: false,\n      trim: true,\n      normalize: true,\n      normalizeTags: false,\n      attrkey: \"@\",\n      charkey: \"#\",\n      explicitArray: false,\n      ignoreAttrs: false,\n      mergeAttrs: false,\n      explicitRoot: false,\n      validator: null,\n      xmlns: false,\n      explicitChildren: false,\n      childkey: '@@',\n      charsAsChildren: false,\n      includeWhiteChars: false,\n      async: false,\n      strict: true,\n      attrNameProcessors: null,\n      attrValueProcessors: null,\n      tagNameProcessors: null,\n      valueProcessors: null,\n      emptyTag: ''\n    },\n    \"0.2\": {\n      explicitCharkey: false,\n      trim: false,\n      normalize: false,\n      normalizeTags: false,\n      attrkey: \"$\",\n      charkey: \"_\",\n      explicitArray: true,\n      ignoreAttrs: false,\n      mergeAttrs: false,\n      explicitRoot: true,\n      validator: null,\n      xmlns: false,\n      explicitChildren: false,\n      preserveChildrenOrder: false,\n      childkey: '$$',\n      charsAsChildren: false,\n      includeWhiteChars: false,\n      async: false,\n      strict: true,\n      attrNameProcessors: null,\n      attrValueProcessors: null,\n      tagNameProcessors: null,\n      valueProcessors: null,\n      rootName: 'root',\n      xmldec: {\n        'version': '1.0',\n        'encoding': 'UTF-8',\n        'standalone': true\n      },\n      doctype: null,\n      renderOpts: {\n        'pretty': true,\n        'indent': '  ',\n        'newline': '\\n'\n      },\n      headless: false,\n      chunkSize: 10000,\n      emptyTag: '',\n      cdata: false\n    }\n  };\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  \"use strict\";\n  var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  sax = require('sax');\n\n  events = require('events');\n\n  bom = require('./bom');\n\n  processors = require('./processors');\n\n  setImmediate = require('timers').setImmediate;\n\n  defaults = require('./defaults').defaults;\n\n  isEmpty = function(thing) {\n    return typeof thing === \"object\" && (thing != null) && Object.keys(thing).length === 0;\n  };\n\n  processItem = function(processors, item, key) {\n    var i, len, process;\n    for (i = 0, len = processors.length; i < len; i++) {\n      process = processors[i];\n      item = process(item, key);\n    }\n    return item;\n  };\n\n  exports.Parser = (function(superClass) {\n    extend(Parser, superClass);\n\n    function Parser(opts) {\n      this.parseStringPromise = bind(this.parseStringPromise, this);\n      this.parseString = bind(this.parseString, this);\n      this.reset = bind(this.reset, this);\n      this.assignOrPush = bind(this.assignOrPush, this);\n      this.processAsync = bind(this.processAsync, this);\n      var key, ref, value;\n      if (!(this instanceof exports.Parser)) {\n        return new exports.Parser(opts);\n      }\n      this.options = {};\n      ref = defaults[\"0.2\"];\n      for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this.options[key] = value;\n      }\n      for (key in opts) {\n        if (!hasProp.call(opts, key)) continue;\n        value = opts[key];\n        this.options[key] = value;\n      }\n      if (this.options.xmlns) {\n        this.options.xmlnskey = this.options.attrkey + \"ns\";\n      }\n      if (this.options.normalizeTags) {\n        if (!this.options.tagNameProcessors) {\n          this.options.tagNameProcessors = [];\n        }\n        this.options.tagNameProcessors.unshift(processors.normalize);\n      }\n      this.reset();\n    }\n\n    Parser.prototype.processAsync = function() {\n      var chunk, err;\n      try {\n        if (this.remaining.length <= this.options.chunkSize) {\n          chunk = this.remaining;\n          this.remaining = '';\n          this.saxParser = this.saxParser.write(chunk);\n          return this.saxParser.close();\n        } else {\n          chunk = this.remaining.substr(0, this.options.chunkSize);\n          this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);\n          this.saxParser = this.saxParser.write(chunk);\n          return setImmediate(this.processAsync);\n        }\n      } catch (error1) {\n        err = error1;\n        if (!this.saxParser.errThrown) {\n          this.saxParser.errThrown = true;\n          return this.emit(err);\n        }\n      }\n    };\n\n    Parser.prototype.assignOrPush = function(obj, key, newValue) {\n      if (!(key in obj)) {\n        if (!this.options.explicitArray) {\n          return obj[key] = newValue;\n        } else {\n          return obj[key] = [newValue];\n        }\n      } else {\n        if (!(obj[key] instanceof Array)) {\n          obj[key] = [obj[key]];\n        }\n        return obj[key].push(newValue);\n      }\n    };\n\n    Parser.prototype.reset = function() {\n      var attrkey, charkey, ontext, stack;\n      this.removeAllListeners();\n      this.saxParser = sax.parser(this.options.strict, {\n        trim: false,\n        normalize: false,\n        xmlns: this.options.xmlns\n      });\n      this.saxParser.errThrown = false;\n      this.saxParser.onerror = (function(_this) {\n        return function(error) {\n          _this.saxParser.resume();\n          if (!_this.saxParser.errThrown) {\n            _this.saxParser.errThrown = true;\n            return _this.emit(\"error\", error);\n          }\n        };\n      })(this);\n      this.saxParser.onend = (function(_this) {\n        return function() {\n          if (!_this.saxParser.ended) {\n            _this.saxParser.ended = true;\n            return _this.emit(\"end\", _this.resultObject);\n          }\n        };\n      })(this);\n      this.saxParser.ended = false;\n      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;\n      this.resultObject = null;\n      stack = [];\n      attrkey = this.options.attrkey;\n      charkey = this.options.charkey;\n      this.saxParser.onopentag = (function(_this) {\n        return function(node) {\n          var key, newValue, obj, processedKey, ref;\n          obj = {};\n          obj[charkey] = \"\";\n          if (!_this.options.ignoreAttrs) {\n            ref = node.attributes;\n            for (key in ref) {\n              if (!hasProp.call(ref, key)) continue;\n              if (!(attrkey in obj) && !_this.options.mergeAttrs) {\n                obj[attrkey] = {};\n              }\n              newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];\n              processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;\n              if (_this.options.mergeAttrs) {\n                _this.assignOrPush(obj, processedKey, newValue);\n              } else {\n                obj[attrkey][processedKey] = newValue;\n              }\n            }\n          }\n          obj[\"#name\"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;\n          if (_this.options.xmlns) {\n            obj[_this.options.xmlnskey] = {\n              uri: node.uri,\n              local: node.local\n            };\n          }\n          return stack.push(obj);\n        };\n      })(this);\n      this.saxParser.onclosetag = (function(_this) {\n        return function() {\n          var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;\n          obj = stack.pop();\n          nodeName = obj[\"#name\"];\n          if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {\n            delete obj[\"#name\"];\n          }\n          if (obj.cdata === true) {\n            cdata = obj.cdata;\n            delete obj.cdata;\n          }\n          s = stack[stack.length - 1];\n          if (obj[charkey].match(/^\\s*$/) && !cdata) {\n            emptyStr = obj[charkey];\n            delete obj[charkey];\n          } else {\n            if (_this.options.trim) {\n              obj[charkey] = obj[charkey].trim();\n            }\n            if (_this.options.normalize) {\n              obj[charkey] = obj[charkey].replace(/\\s{2,}/g, \" \").trim();\n            }\n            obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];\n            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {\n              obj = obj[charkey];\n            }\n          }\n          if (isEmpty(obj)) {\n            obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;\n          }\n          if (_this.options.validator != null) {\n            xpath = \"/\" + ((function() {\n              var i, len, results;\n              results = [];\n              for (i = 0, len = stack.length; i < len; i++) {\n                node = stack[i];\n                results.push(node[\"#name\"]);\n              }\n              return results;\n            })()).concat(nodeName).join(\"/\");\n            (function() {\n              var err;\n              try {\n                return obj = _this.options.validator(xpath, s && s[nodeName], obj);\n              } catch (error1) {\n                err = error1;\n                return _this.emit(\"error\", err);\n              }\n            })();\n          }\n          if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {\n            if (!_this.options.preserveChildrenOrder) {\n              node = {};\n              if (_this.options.attrkey in obj) {\n                node[_this.options.attrkey] = obj[_this.options.attrkey];\n                delete obj[_this.options.attrkey];\n              }\n              if (!_this.options.charsAsChildren && _this.options.charkey in obj) {\n                node[_this.options.charkey] = obj[_this.options.charkey];\n                delete obj[_this.options.charkey];\n              }\n              if (Object.getOwnPropertyNames(obj).length > 0) {\n                node[_this.options.childkey] = obj;\n              }\n              obj = node;\n            } else if (s) {\n              s[_this.options.childkey] = s[_this.options.childkey] || [];\n              objClone = {};\n              for (key in obj) {\n                if (!hasProp.call(obj, key)) continue;\n                objClone[key] = obj[key];\n              }\n              s[_this.options.childkey].push(objClone);\n              delete obj[\"#name\"];\n              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {\n                obj = obj[charkey];\n              }\n            }\n          }\n          if (stack.length > 0) {\n            return _this.assignOrPush(s, nodeName, obj);\n          } else {\n            if (_this.options.explicitRoot) {\n              old = obj;\n              obj = {};\n              obj[nodeName] = old;\n            }\n            _this.resultObject = obj;\n            _this.saxParser.ended = true;\n            return _this.emit(\"end\", _this.resultObject);\n          }\n        };\n      })(this);\n      ontext = (function(_this) {\n        return function(text) {\n          var charChild, s;\n          s = stack[stack.length - 1];\n          if (s) {\n            s[charkey] += text;\n            if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\\\n/g, '').trim() !== '')) {\n              s[_this.options.childkey] = s[_this.options.childkey] || [];\n              charChild = {\n                '#name': '__text__'\n              };\n              charChild[charkey] = text;\n              if (_this.options.normalize) {\n                charChild[charkey] = charChild[charkey].replace(/\\s{2,}/g, \" \").trim();\n              }\n              s[_this.options.childkey].push(charChild);\n            }\n            return s;\n          }\n        };\n      })(this);\n      this.saxParser.ontext = ontext;\n      return this.saxParser.oncdata = (function(_this) {\n        return function(text) {\n          var s;\n          s = ontext(text);\n          if (s) {\n            return s.cdata = true;\n          }\n        };\n      })(this);\n    };\n\n    Parser.prototype.parseString = function(str, cb) {\n      var err;\n      if ((cb != null) && typeof cb === \"function\") {\n        this.on(\"end\", function(result) {\n          this.reset();\n          return cb(null, result);\n        });\n        this.on(\"error\", function(err) {\n          this.reset();\n          return cb(err);\n        });\n      }\n      try {\n        str = str.toString();\n        if (str.trim() === '') {\n          this.emit(\"end\", null);\n          return true;\n        }\n        str = bom.stripBOM(str);\n        if (this.options.async) {\n          this.remaining = str;\n          setImmediate(this.processAsync);\n          return this.saxParser;\n        }\n        return this.saxParser.write(str).close();\n      } catch (error1) {\n        err = error1;\n        if (!(this.saxParser.errThrown || this.saxParser.ended)) {\n          this.emit('error', err);\n          return this.saxParser.errThrown = true;\n        } else if (this.saxParser.ended) {\n          throw err;\n        }\n      }\n    };\n\n    Parser.prototype.parseStringPromise = function(str) {\n      return new Promise((function(_this) {\n        return function(resolve, reject) {\n          return _this.parseString(str, function(err, value) {\n            if (err) {\n              return reject(err);\n            } else {\n              return resolve(value);\n            }\n          });\n        };\n      })(this));\n    };\n\n    return Parser;\n\n  })(events);\n\n  exports.parseString = function(str, a, b) {\n    var cb, options, parser;\n    if (b != null) {\n      if (typeof b === 'function') {\n        cb = b;\n      }\n      if (typeof a === 'object') {\n        options = a;\n      }\n    } else {\n      if (typeof a === 'function') {\n        cb = a;\n      }\n      options = {};\n    }\n    parser = new exports.Parser(options);\n    return parser.parseString(str, cb);\n  };\n\n  exports.parseStringPromise = function(str, a) {\n    var options, parser;\n    if (typeof a === 'object') {\n      options = a;\n    }\n    parser = new exports.Parser(options);\n    return parser.parseStringPromise(str);\n  };\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  \"use strict\";\n  var prefixMatch;\n\n  prefixMatch = new RegExp(/(?!xmlns)^.*:/);\n\n  exports.normalize = function(str) {\n    return str.toLowerCase();\n  };\n\n  exports.firstCharLowerCase = function(str) {\n    return str.charAt(0).toLowerCase() + str.slice(1);\n  };\n\n  exports.stripPrefix = function(str) {\n    return str.replace(prefixMatch, '');\n  };\n\n  exports.parseNumbers = function(str) {\n    if (!isNaN(str)) {\n      str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);\n    }\n    return str;\n  };\n\n  exports.parseBooleans = function(str) {\n    if (/^(?:true|false)$/i.test(str)) {\n      str = str.toLowerCase() === 'true';\n    }\n    return str;\n  };\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  \"use strict\";\n  var builder, defaults, parser, processors,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  defaults = require('./defaults');\n\n  builder = require('./builder');\n\n  parser = require('./parser');\n\n  processors = require('./processors');\n\n  exports.defaults = defaults.defaults;\n\n  exports.processors = processors;\n\n  exports.ValidationError = (function(superClass) {\n    extend(ValidationError, superClass);\n\n    function ValidationError(message) {\n      this.message = message;\n    }\n\n    return ValidationError;\n\n  })(Error);\n\n  exports.Builder = builder.Builder;\n\n  exports.Parser = parser.Parser;\n\n  exports.parseString = parser.parseString;\n\n  exports.parseStringPromise = parser.parseStringPromise;\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  module.exports = {\n    Disconnected: 1,\n    Preceding: 2,\n    Following: 4,\n    Contains: 8,\n    ContainedBy: 16,\n    ImplementationSpecific: 32\n  };\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  module.exports = {\n    Element: 1,\n    Attribute: 2,\n    Text: 3,\n    CData: 4,\n    EntityReference: 5,\n    EntityDeclaration: 6,\n    ProcessingInstruction: 7,\n    Comment: 8,\n    Document: 9,\n    DocType: 10,\n    DocumentFragment: 11,\n    NotationDeclaration: 12,\n    Declaration: 201,\n    Raw: 202,\n    AttributeDeclaration: 203,\n    ElementDeclaration: 204,\n    Dummy: 205\n  };\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var assign, getValue, isArray, isEmpty, isFunction, isObject, isPlainObject,\n    slice = [].slice,\n    hasProp = {}.hasOwnProperty;\n\n  assign = function() {\n    var i, key, len, source, sources, target;\n    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    if (isFunction(Object.assign)) {\n      Object.assign.apply(null, arguments);\n    } else {\n      for (i = 0, len = sources.length; i < len; i++) {\n        source = sources[i];\n        if (source != null) {\n          for (key in source) {\n            if (!hasProp.call(source, key)) continue;\n            target[key] = source[key];\n          }\n        }\n      }\n    }\n    return target;\n  };\n\n  isFunction = function(val) {\n    return !!val && Object.prototype.toString.call(val) === '[object Function]';\n  };\n\n  isObject = function(val) {\n    var ref;\n    return !!val && ((ref = typeof val) === 'function' || ref === 'object');\n  };\n\n  isArray = function(val) {\n    if (isFunction(Array.isArray)) {\n      return Array.isArray(val);\n    } else {\n      return Object.prototype.toString.call(val) === '[object Array]';\n    }\n  };\n\n  isEmpty = function(val) {\n    var key;\n    if (isArray(val)) {\n      return !val.length;\n    } else {\n      for (key in val) {\n        if (!hasProp.call(val, key)) continue;\n        return false;\n      }\n      return true;\n    }\n  };\n\n  isPlainObject = function(val) {\n    var ctor, proto;\n    return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && (typeof ctor === 'function') && (ctor instanceof ctor) && (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));\n  };\n\n  getValue = function(obj) {\n    if (isFunction(obj.valueOf)) {\n      return obj.valueOf();\n    } else {\n      return obj;\n    }\n  };\n\n  module.exports.assign = assign;\n\n  module.exports.isFunction = isFunction;\n\n  module.exports.isObject = isObject;\n\n  module.exports.isArray = isArray;\n\n  module.exports.isEmpty = isEmpty;\n\n  module.exports.isPlainObject = isPlainObject;\n\n  module.exports.getValue = getValue;\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  module.exports = {\n    None: 0,\n    OpenTag: 1,\n    InsideTag: 2,\n    CloseTag: 3\n  };\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLAttribute, XMLNode;\n\n  NodeType = require('./NodeType');\n\n  XMLNode = require('./XMLNode');\n\n  module.exports = XMLAttribute = (function() {\n    function XMLAttribute(parent, name, value) {\n      this.parent = parent;\n      if (this.parent) {\n        this.options = this.parent.options;\n        this.stringify = this.parent.stringify;\n      }\n      if (name == null) {\n        throw new Error(\"Missing attribute name. \" + this.debugInfo(name));\n      }\n      this.name = this.stringify.name(name);\n      this.value = this.stringify.attValue(value);\n      this.type = NodeType.Attribute;\n      this.isId = false;\n      this.schemaTypeInfo = null;\n    }\n\n    Object.defineProperty(XMLAttribute.prototype, 'nodeType', {\n      get: function() {\n        return this.type;\n      }\n    });\n\n    Object.defineProperty(XMLAttribute.prototype, 'ownerElement', {\n      get: function() {\n        return this.parent;\n      }\n    });\n\n    Object.defineProperty(XMLAttribute.prototype, 'textContent', {\n      get: function() {\n        return this.value;\n      },\n      set: function(value) {\n        return this.value = value || '';\n      }\n    });\n\n    Object.defineProperty(XMLAttribute.prototype, 'namespaceURI', {\n      get: function() {\n        return '';\n      }\n    });\n\n    Object.defineProperty(XMLAttribute.prototype, 'prefix', {\n      get: function() {\n        return '';\n      }\n    });\n\n    Object.defineProperty(XMLAttribute.prototype, 'localName', {\n      get: function() {\n        return this.name;\n      }\n    });\n\n    Object.defineProperty(XMLAttribute.prototype, 'specified', {\n      get: function() {\n        return true;\n      }\n    });\n\n    XMLAttribute.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLAttribute.prototype.toString = function(options) {\n      return this.options.writer.attribute(this, this.options.writer.filterOptions(options));\n    };\n\n    XMLAttribute.prototype.debugInfo = function(name) {\n      name = name || this.name;\n      if (name == null) {\n        return \"parent: <\" + this.parent.name + \">\";\n      } else {\n        return \"attribute: {\" + name + \"}, parent: <\" + this.parent.name + \">\";\n      }\n    };\n\n    XMLAttribute.prototype.isEqualNode = function(node) {\n      if (node.namespaceURI !== this.namespaceURI) {\n        return false;\n      }\n      if (node.prefix !== this.prefix) {\n        return false;\n      }\n      if (node.localName !== this.localName) {\n        return false;\n      }\n      if (node.value !== this.value) {\n        return false;\n      }\n      return true;\n    };\n\n    return XMLAttribute;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLCData, XMLCharacterData,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  NodeType = require('./NodeType');\n\n  XMLCharacterData = require('./XMLCharacterData');\n\n  module.exports = XMLCData = (function(superClass) {\n    extend(XMLCData, superClass);\n\n    function XMLCData(parent, text) {\n      XMLCData.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing CDATA text. \" + this.debugInfo());\n      }\n      this.name = \"#cdata-section\";\n      this.type = NodeType.CData;\n      this.value = this.stringify.cdata(text);\n    }\n\n    XMLCData.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLCData.prototype.toString = function(options) {\n      return this.options.writer.cdata(this, this.options.writer.filterOptions(options));\n    };\n\n    return XMLCData;\n\n  })(XMLCharacterData);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLCharacterData, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = require('./XMLNode');\n\n  module.exports = XMLCharacterData = (function(superClass) {\n    extend(XMLCharacterData, superClass);\n\n    function XMLCharacterData(parent) {\n      XMLCharacterData.__super__.constructor.call(this, parent);\n      this.value = '';\n    }\n\n    Object.defineProperty(XMLCharacterData.prototype, 'data', {\n      get: function() {\n        return this.value;\n      },\n      set: function(value) {\n        return this.value = value || '';\n      }\n    });\n\n    Object.defineProperty(XMLCharacterData.prototype, 'length', {\n      get: function() {\n        return this.value.length;\n      }\n    });\n\n    Object.defineProperty(XMLCharacterData.prototype, 'textContent', {\n      get: function() {\n        return this.value;\n      },\n      set: function(value) {\n        return this.value = value || '';\n      }\n    });\n\n    XMLCharacterData.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLCharacterData.prototype.substringData = function(offset, count) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLCharacterData.prototype.appendData = function(arg) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLCharacterData.prototype.insertData = function(offset, arg) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLCharacterData.prototype.deleteData = function(offset, count) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLCharacterData.prototype.replaceData = function(offset, count, arg) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLCharacterData.prototype.isEqualNode = function(node) {\n      if (!XMLCharacterData.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {\n        return false;\n      }\n      if (node.data !== this.data) {\n        return false;\n      }\n      return true;\n    };\n\n    return XMLCharacterData;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLCharacterData, XMLComment,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  NodeType = require('./NodeType');\n\n  XMLCharacterData = require('./XMLCharacterData');\n\n  module.exports = XMLComment = (function(superClass) {\n    extend(XMLComment, superClass);\n\n    function XMLComment(parent, text) {\n      XMLComment.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing comment text. \" + this.debugInfo());\n      }\n      this.name = \"#comment\";\n      this.type = NodeType.Comment;\n      this.value = this.stringify.comment(text);\n    }\n\n    XMLComment.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLComment.prototype.toString = function(options) {\n      return this.options.writer.comment(this, this.options.writer.filterOptions(options));\n    };\n\n    return XMLComment;\n\n  })(XMLCharacterData);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDOMConfiguration, XMLDOMErrorHandler, XMLDOMStringList;\n\n  XMLDOMErrorHandler = require('./XMLDOMErrorHandler');\n\n  XMLDOMStringList = require('./XMLDOMStringList');\n\n  module.exports = XMLDOMConfiguration = (function() {\n    function XMLDOMConfiguration() {\n      var clonedSelf;\n      this.defaultParams = {\n        \"canonical-form\": false,\n        \"cdata-sections\": false,\n        \"comments\": false,\n        \"datatype-normalization\": false,\n        \"element-content-whitespace\": true,\n        \"entities\": true,\n        \"error-handler\": new XMLDOMErrorHandler(),\n        \"infoset\": true,\n        \"validate-if-schema\": false,\n        \"namespaces\": true,\n        \"namespace-declarations\": true,\n        \"normalize-characters\": false,\n        \"schema-location\": '',\n        \"schema-type\": '',\n        \"split-cdata-sections\": true,\n        \"validate\": false,\n        \"well-formed\": true\n      };\n      this.params = clonedSelf = Object.create(this.defaultParams);\n    }\n\n    Object.defineProperty(XMLDOMConfiguration.prototype, 'parameterNames', {\n      get: function() {\n        return new XMLDOMStringList(Object.keys(this.defaultParams));\n      }\n    });\n\n    XMLDOMConfiguration.prototype.getParameter = function(name) {\n      if (this.params.hasOwnProperty(name)) {\n        return this.params[name];\n      } else {\n        return null;\n      }\n    };\n\n    XMLDOMConfiguration.prototype.canSetParameter = function(name, value) {\n      return true;\n    };\n\n    XMLDOMConfiguration.prototype.setParameter = function(name, value) {\n      if (value != null) {\n        return this.params[name] = value;\n      } else {\n        return delete this.params[name];\n      }\n    };\n\n    return XMLDOMConfiguration;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDOMErrorHandler;\n\n  module.exports = XMLDOMErrorHandler = (function() {\n    function XMLDOMErrorHandler() {}\n\n    XMLDOMErrorHandler.prototype.handleError = function(error) {\n      throw new Error(error);\n    };\n\n    return XMLDOMErrorHandler;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDOMImplementation;\n\n  module.exports = XMLDOMImplementation = (function() {\n    function XMLDOMImplementation() {}\n\n    XMLDOMImplementation.prototype.hasFeature = function(feature, version) {\n      return true;\n    };\n\n    XMLDOMImplementation.prototype.createDocumentType = function(qualifiedName, publicId, systemId) {\n      throw new Error(\"This DOM method is not implemented.\");\n    };\n\n    XMLDOMImplementation.prototype.createDocument = function(namespaceURI, qualifiedName, doctype) {\n      throw new Error(\"This DOM method is not implemented.\");\n    };\n\n    XMLDOMImplementation.prototype.createHTMLDocument = function(title) {\n      throw new Error(\"This DOM method is not implemented.\");\n    };\n\n    XMLDOMImplementation.prototype.getFeature = function(feature, version) {\n      throw new Error(\"This DOM method is not implemented.\");\n    };\n\n    return XMLDOMImplementation;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLDOMStringList;\n\n  module.exports = XMLDOMStringList = (function() {\n    function XMLDOMStringList(arr) {\n      this.arr = arr || [];\n    }\n\n    Object.defineProperty(XMLDOMStringList.prototype, 'length', {\n      get: function() {\n        return this.arr.length;\n      }\n    });\n\n    XMLDOMStringList.prototype.item = function(index) {\n      return this.arr[index] || null;\n    };\n\n    XMLDOMStringList.prototype.contains = function(str) {\n      return this.arr.indexOf(str) !== -1;\n    };\n\n    return XMLDOMStringList;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLDTDAttList, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = require('./XMLNode');\n\n  NodeType = require('./NodeType');\n\n  module.exports = XMLDTDAttList = (function(superClass) {\n    extend(XMLDTDAttList, superClass);\n\n    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      XMLDTDAttList.__super__.constructor.call(this, parent);\n      if (elementName == null) {\n        throw new Error(\"Missing DTD element name. \" + this.debugInfo());\n      }\n      if (attributeName == null) {\n        throw new Error(\"Missing DTD attribute name. \" + this.debugInfo(elementName));\n      }\n      if (!attributeType) {\n        throw new Error(\"Missing DTD attribute type. \" + this.debugInfo(elementName));\n      }\n      if (!defaultValueType) {\n        throw new Error(\"Missing DTD attribute default. \" + this.debugInfo(elementName));\n      }\n      if (defaultValueType.indexOf('#') !== 0) {\n        defaultValueType = '#' + defaultValueType;\n      }\n      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {\n        throw new Error(\"Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. \" + this.debugInfo(elementName));\n      }\n      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {\n        throw new Error(\"Default value only applies to #FIXED or #DEFAULT. \" + this.debugInfo(elementName));\n      }\n      this.elementName = this.stringify.name(elementName);\n      this.type = NodeType.AttributeDeclaration;\n      this.attributeName = this.stringify.name(attributeName);\n      this.attributeType = this.stringify.dtdAttType(attributeType);\n      if (defaultValue) {\n        this.defaultValue = this.stringify.dtdAttDefault(defaultValue);\n      }\n      this.defaultValueType = defaultValueType;\n    }\n\n    XMLDTDAttList.prototype.toString = function(options) {\n      return this.options.writer.dtdAttList(this, this.options.writer.filterOptions(options));\n    };\n\n    return XMLDTDAttList;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLDTDElement, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = require('./XMLNode');\n\n  NodeType = require('./NodeType');\n\n  module.exports = XMLDTDElement = (function(superClass) {\n    extend(XMLDTDElement, superClass);\n\n    function XMLDTDElement(parent, name, value) {\n      XMLDTDElement.__super__.constructor.call(this, parent);\n      if (name == null) {\n        throw new Error(\"Missing DTD element name. \" + this.debugInfo());\n      }\n      if (!value) {\n        value = '(#PCDATA)';\n      }\n      if (Array.isArray(value)) {\n        value = '(' + value.join(',') + ')';\n      }\n      this.name = this.stringify.name(name);\n      this.type = NodeType.ElementDeclaration;\n      this.value = this.stringify.dtdElementValue(value);\n    }\n\n    XMLDTDElement.prototype.toString = function(options) {\n      return this.options.writer.dtdElement(this, this.options.writer.filterOptions(options));\n    };\n\n    return XMLDTDElement;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLDTDEntity, XMLNode, isObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  isObject = require('./Utility').isObject;\n\n  XMLNode = require('./XMLNode');\n\n  NodeType = require('./NodeType');\n\n  module.exports = XMLDTDEntity = (function(superClass) {\n    extend(XMLDTDEntity, superClass);\n\n    function XMLDTDEntity(parent, pe, name, value) {\n      XMLDTDEntity.__super__.constructor.call(this, parent);\n      if (name == null) {\n        throw new Error(\"Missing DTD entity name. \" + this.debugInfo(name));\n      }\n      if (value == null) {\n        throw new Error(\"Missing DTD entity value. \" + this.debugInfo(name));\n      }\n      this.pe = !!pe;\n      this.name = this.stringify.name(name);\n      this.type = NodeType.EntityDeclaration;\n      if (!isObject(value)) {\n        this.value = this.stringify.dtdEntityValue(value);\n        this.internal = true;\n      } else {\n        if (!value.pubID && !value.sysID) {\n          throw new Error(\"Public and/or system identifiers are required for an external entity. \" + this.debugInfo(name));\n        }\n        if (value.pubID && !value.sysID) {\n          throw new Error(\"System identifier is required for a public external entity. \" + this.debugInfo(name));\n        }\n        this.internal = false;\n        if (value.pubID != null) {\n          this.pubID = this.stringify.dtdPubID(value.pubID);\n        }\n        if (value.sysID != null) {\n          this.sysID = this.stringify.dtdSysID(value.sysID);\n        }\n        if (value.nData != null) {\n          this.nData = this.stringify.dtdNData(value.nData);\n        }\n        if (this.pe && this.nData) {\n          throw new Error(\"Notation declaration is not allowed in a parameter entity. \" + this.debugInfo(name));\n        }\n      }\n    }\n\n    Object.defineProperty(XMLDTDEntity.prototype, 'publicId', {\n      get: function() {\n        return this.pubID;\n      }\n    });\n\n    Object.defineProperty(XMLDTDEntity.prototype, 'systemId', {\n      get: function() {\n        return this.sysID;\n      }\n    });\n\n    Object.defineProperty(XMLDTDEntity.prototype, 'notationName', {\n      get: function() {\n        return this.nData || null;\n      }\n    });\n\n    Object.defineProperty(XMLDTDEntity.prototype, 'inputEncoding', {\n      get: function() {\n        return null;\n      }\n    });\n\n    Object.defineProperty(XMLDTDEntity.prototype, 'xmlEncoding', {\n      get: function() {\n        return null;\n      }\n    });\n\n    Object.defineProperty(XMLDTDEntity.prototype, 'xmlVersion', {\n      get: function() {\n        return null;\n      }\n    });\n\n    XMLDTDEntity.prototype.toString = function(options) {\n      return this.options.writer.dtdEntity(this, this.options.writer.filterOptions(options));\n    };\n\n    return XMLDTDEntity;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLDTDNotation, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = require('./XMLNode');\n\n  NodeType = require('./NodeType');\n\n  module.exports = XMLDTDNotation = (function(superClass) {\n    extend(XMLDTDNotation, superClass);\n\n    function XMLDTDNotation(parent, name, value) {\n      XMLDTDNotation.__super__.constructor.call(this, parent);\n      if (name == null) {\n        throw new Error(\"Missing DTD notation name. \" + this.debugInfo(name));\n      }\n      if (!value.pubID && !value.sysID) {\n        throw new Error(\"Public or system identifiers are required for an external entity. \" + this.debugInfo(name));\n      }\n      this.name = this.stringify.name(name);\n      this.type = NodeType.NotationDeclaration;\n      if (value.pubID != null) {\n        this.pubID = this.stringify.dtdPubID(value.pubID);\n      }\n      if (value.sysID != null) {\n        this.sysID = this.stringify.dtdSysID(value.sysID);\n      }\n    }\n\n    Object.defineProperty(XMLDTDNotation.prototype, 'publicId', {\n      get: function() {\n        return this.pubID;\n      }\n    });\n\n    Object.defineProperty(XMLDTDNotation.prototype, 'systemId', {\n      get: function() {\n        return this.sysID;\n      }\n    });\n\n    XMLDTDNotation.prototype.toString = function(options) {\n      return this.options.writer.dtdNotation(this, this.options.writer.filterOptions(options));\n    };\n\n    return XMLDTDNotation;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLDeclaration, XMLNode, isObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  isObject = require('./Utility').isObject;\n\n  XMLNode = require('./XMLNode');\n\n  NodeType = require('./NodeType');\n\n  module.exports = XMLDeclaration = (function(superClass) {\n    extend(XMLDeclaration, superClass);\n\n    function XMLDeclaration(parent, version, encoding, standalone) {\n      var ref;\n      XMLDeclaration.__super__.constructor.call(this, parent);\n      if (isObject(version)) {\n        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;\n      }\n      if (!version) {\n        version = '1.0';\n      }\n      this.type = NodeType.Declaration;\n      this.version = this.stringify.xmlVersion(version);\n      if (encoding != null) {\n        this.encoding = this.stringify.xmlEncoding(encoding);\n      }\n      if (standalone != null) {\n        this.standalone = this.stringify.xmlStandalone(standalone);\n      }\n    }\n\n    XMLDeclaration.prototype.toString = function(options) {\n      return this.options.writer.declaration(this, this.options.writer.filterOptions(options));\n    };\n\n    return XMLDeclaration;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNamedNodeMap, XMLNode, isObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  isObject = require('./Utility').isObject;\n\n  XMLNode = require('./XMLNode');\n\n  NodeType = require('./NodeType');\n\n  XMLDTDAttList = require('./XMLDTDAttList');\n\n  XMLDTDEntity = require('./XMLDTDEntity');\n\n  XMLDTDElement = require('./XMLDTDElement');\n\n  XMLDTDNotation = require('./XMLDTDNotation');\n\n  XMLNamedNodeMap = require('./XMLNamedNodeMap');\n\n  module.exports = XMLDocType = (function(superClass) {\n    extend(XMLDocType, superClass);\n\n    function XMLDocType(parent, pubID, sysID) {\n      var child, i, len, ref, ref1, ref2;\n      XMLDocType.__super__.constructor.call(this, parent);\n      this.type = NodeType.DocType;\n      if (parent.children) {\n        ref = parent.children;\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          if (child.type === NodeType.Element) {\n            this.name = child.name;\n            break;\n          }\n        }\n      }\n      this.documentObject = parent;\n      if (isObject(pubID)) {\n        ref1 = pubID, pubID = ref1.pubID, sysID = ref1.sysID;\n      }\n      if (sysID == null) {\n        ref2 = [pubID, sysID], sysID = ref2[0], pubID = ref2[1];\n      }\n      if (pubID != null) {\n        this.pubID = this.stringify.dtdPubID(pubID);\n      }\n      if (sysID != null) {\n        this.sysID = this.stringify.dtdSysID(sysID);\n      }\n    }\n\n    Object.defineProperty(XMLDocType.prototype, 'entities', {\n      get: function() {\n        var child, i, len, nodes, ref;\n        nodes = {};\n        ref = this.children;\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          if ((child.type === NodeType.EntityDeclaration) && !child.pe) {\n            nodes[child.name] = child;\n          }\n        }\n        return new XMLNamedNodeMap(nodes);\n      }\n    });\n\n    Object.defineProperty(XMLDocType.prototype, 'notations', {\n      get: function() {\n        var child, i, len, nodes, ref;\n        nodes = {};\n        ref = this.children;\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          if (child.type === NodeType.NotationDeclaration) {\n            nodes[child.name] = child;\n          }\n        }\n        return new XMLNamedNodeMap(nodes);\n      }\n    });\n\n    Object.defineProperty(XMLDocType.prototype, 'publicId', {\n      get: function() {\n        return this.pubID;\n      }\n    });\n\n    Object.defineProperty(XMLDocType.prototype, 'systemId', {\n      get: function() {\n        return this.sysID;\n      }\n    });\n\n    Object.defineProperty(XMLDocType.prototype, 'internalSubset', {\n      get: function() {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n\n    XMLDocType.prototype.element = function(name, value) {\n      var child;\n      child = new XMLDTDElement(this, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      var child;\n      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.entity = function(name, value) {\n      var child;\n      child = new XMLDTDEntity(this, false, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.pEntity = function(name, value) {\n      var child;\n      child = new XMLDTDEntity(this, true, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.notation = function(name, value) {\n      var child;\n      child = new XMLDTDNotation(this, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.toString = function(options) {\n      return this.options.writer.docType(this, this.options.writer.filterOptions(options));\n    };\n\n    XMLDocType.prototype.ele = function(name, value) {\n      return this.element(name, value);\n    };\n\n    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);\n    };\n\n    XMLDocType.prototype.ent = function(name, value) {\n      return this.entity(name, value);\n    };\n\n    XMLDocType.prototype.pent = function(name, value) {\n      return this.pEntity(name, value);\n    };\n\n    XMLDocType.prototype.not = function(name, value) {\n      return this.notation(name, value);\n    };\n\n    XMLDocType.prototype.up = function() {\n      return this.root() || this.documentObject;\n    };\n\n    XMLDocType.prototype.isEqualNode = function(node) {\n      if (!XMLDocType.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {\n        return false;\n      }\n      if (node.name !== this.name) {\n        return false;\n      }\n      if (node.publicId !== this.publicId) {\n        return false;\n      }\n      if (node.systemId !== this.systemId) {\n        return false;\n      }\n      return true;\n    };\n\n    return XMLDocType;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLDOMConfiguration, XMLDOMImplementation, XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  isPlainObject = require('./Utility').isPlainObject;\n\n  XMLDOMImplementation = require('./XMLDOMImplementation');\n\n  XMLDOMConfiguration = require('./XMLDOMConfiguration');\n\n  XMLNode = require('./XMLNode');\n\n  NodeType = require('./NodeType');\n\n  XMLStringifier = require('./XMLStringifier');\n\n  XMLStringWriter = require('./XMLStringWriter');\n\n  module.exports = XMLDocument = (function(superClass) {\n    extend(XMLDocument, superClass);\n\n    function XMLDocument(options) {\n      XMLDocument.__super__.constructor.call(this, null);\n      this.name = \"#document\";\n      this.type = NodeType.Document;\n      this.documentURI = null;\n      this.domConfig = new XMLDOMConfiguration();\n      options || (options = {});\n      if (!options.writer) {\n        options.writer = new XMLStringWriter();\n      }\n      this.options = options;\n      this.stringify = new XMLStringifier(options);\n    }\n\n    Object.defineProperty(XMLDocument.prototype, 'implementation', {\n      value: new XMLDOMImplementation()\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'doctype', {\n      get: function() {\n        var child, i, len, ref;\n        ref = this.children;\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          if (child.type === NodeType.DocType) {\n            return child;\n          }\n        }\n        return null;\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'documentElement', {\n      get: function() {\n        return this.rootObject || null;\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'inputEncoding', {\n      get: function() {\n        return null;\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'strictErrorChecking', {\n      get: function() {\n        return false;\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'xmlEncoding', {\n      get: function() {\n        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {\n          return this.children[0].encoding;\n        } else {\n          return null;\n        }\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'xmlStandalone', {\n      get: function() {\n        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {\n          return this.children[0].standalone === 'yes';\n        } else {\n          return false;\n        }\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'xmlVersion', {\n      get: function() {\n        if (this.children.length !== 0 && this.children[0].type === NodeType.Declaration) {\n          return this.children[0].version;\n        } else {\n          return \"1.0\";\n        }\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'URL', {\n      get: function() {\n        return this.documentURI;\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'origin', {\n      get: function() {\n        return null;\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'compatMode', {\n      get: function() {\n        return null;\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'characterSet', {\n      get: function() {\n        return null;\n      }\n    });\n\n    Object.defineProperty(XMLDocument.prototype, 'contentType', {\n      get: function() {\n        return null;\n      }\n    });\n\n    XMLDocument.prototype.end = function(writer) {\n      var writerOptions;\n      writerOptions = {};\n      if (!writer) {\n        writer = this.options.writer;\n      } else if (isPlainObject(writer)) {\n        writerOptions = writer;\n        writer = this.options.writer;\n      }\n      return writer.document(this, writer.filterOptions(writerOptions));\n    };\n\n    XMLDocument.prototype.toString = function(options) {\n      return this.options.writer.document(this, this.options.writer.filterOptions(options));\n    };\n\n    XMLDocument.prototype.createElement = function(tagName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createDocumentFragment = function() {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createTextNode = function(data) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createComment = function(data) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createCDATASection = function(data) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createProcessingInstruction = function(target, data) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createAttribute = function(name) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createEntityReference = function(name) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.getElementsByTagName = function(tagname) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.importNode = function(importedNode, deep) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createElementNS = function(namespaceURI, qualifiedName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createAttributeNS = function(namespaceURI, qualifiedName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.getElementById = function(elementId) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.adoptNode = function(source) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.normalizeDocument = function() {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.renameNode = function(node, namespaceURI, qualifiedName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.getElementsByClassName = function(classNames) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createEvent = function(eventInterface) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createRange = function() {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createNodeIterator = function(root, whatToShow, filter) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLDocument.prototype.createTreeWalker = function(root, whatToShow, filter) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    return XMLDocument;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject, ref,\n    hasProp = {}.hasOwnProperty;\n\n  ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;\n\n  NodeType = require('./NodeType');\n\n  XMLDocument = require('./XMLDocument');\n\n  XMLElement = require('./XMLElement');\n\n  XMLCData = require('./XMLCData');\n\n  XMLComment = require('./XMLComment');\n\n  XMLRaw = require('./XMLRaw');\n\n  XMLText = require('./XMLText');\n\n  XMLProcessingInstruction = require('./XMLProcessingInstruction');\n\n  XMLDeclaration = require('./XMLDeclaration');\n\n  XMLDocType = require('./XMLDocType');\n\n  XMLDTDAttList = require('./XMLDTDAttList');\n\n  XMLDTDEntity = require('./XMLDTDEntity');\n\n  XMLDTDElement = require('./XMLDTDElement');\n\n  XMLDTDNotation = require('./XMLDTDNotation');\n\n  XMLAttribute = require('./XMLAttribute');\n\n  XMLStringifier = require('./XMLStringifier');\n\n  XMLStringWriter = require('./XMLStringWriter');\n\n  WriterState = require('./WriterState');\n\n  module.exports = XMLDocumentCB = (function() {\n    function XMLDocumentCB(options, onData, onEnd) {\n      var writerOptions;\n      this.name = \"?xml\";\n      this.type = NodeType.Document;\n      options || (options = {});\n      writerOptions = {};\n      if (!options.writer) {\n        options.writer = new XMLStringWriter();\n      } else if (isPlainObject(options.writer)) {\n        writerOptions = options.writer;\n        options.writer = new XMLStringWriter();\n      }\n      this.options = options;\n      this.writer = options.writer;\n      this.writerOptions = this.writer.filterOptions(writerOptions);\n      this.stringify = new XMLStringifier(options);\n      this.onDataCallback = onData || function() {};\n      this.onEndCallback = onEnd || function() {};\n      this.currentNode = null;\n      this.currentLevel = -1;\n      this.openTags = {};\n      this.documentStarted = false;\n      this.documentCompleted = false;\n      this.root = null;\n    }\n\n    XMLDocumentCB.prototype.createChildNode = function(node) {\n      var att, attName, attributes, child, i, len, ref1, ref2;\n      switch (node.type) {\n        case NodeType.CData:\n          this.cdata(node.value);\n          break;\n        case NodeType.Comment:\n          this.comment(node.value);\n          break;\n        case NodeType.Element:\n          attributes = {};\n          ref1 = node.attribs;\n          for (attName in ref1) {\n            if (!hasProp.call(ref1, attName)) continue;\n            att = ref1[attName];\n            attributes[attName] = att.value;\n          }\n          this.node(node.name, attributes);\n          break;\n        case NodeType.Dummy:\n          this.dummy();\n          break;\n        case NodeType.Raw:\n          this.raw(node.value);\n          break;\n        case NodeType.Text:\n          this.text(node.value);\n          break;\n        case NodeType.ProcessingInstruction:\n          this.instruction(node.target, node.value);\n          break;\n        default:\n          throw new Error(\"This XML node type is not supported in a JS object: \" + node.constructor.name);\n      }\n      ref2 = node.children;\n      for (i = 0, len = ref2.length; i < len; i++) {\n        child = ref2[i];\n        this.createChildNode(child);\n        if (child.type === NodeType.Element) {\n          this.up();\n        }\n      }\n      return this;\n    };\n\n    XMLDocumentCB.prototype.dummy = function() {\n      return this;\n    };\n\n    XMLDocumentCB.prototype.node = function(name, attributes, text) {\n      var ref1;\n      if (name == null) {\n        throw new Error(\"Missing node name.\");\n      }\n      if (this.root && this.currentLevel === -1) {\n        throw new Error(\"Document can only have one root node. \" + this.debugInfo(name));\n      }\n      this.openCurrent();\n      name = getValue(name);\n      if (attributes == null) {\n        attributes = {};\n      }\n      attributes = getValue(attributes);\n      if (!isObject(attributes)) {\n        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];\n      }\n      this.currentNode = new XMLElement(this, name, attributes);\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      if (text != null) {\n        this.text(text);\n      }\n      return this;\n    };\n\n    XMLDocumentCB.prototype.element = function(name, attributes, text) {\n      var child, i, len, oldValidationFlag, ref1, root;\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        this.dtdElement.apply(this, arguments);\n      } else {\n        if (Array.isArray(name) || isObject(name) || isFunction(name)) {\n          oldValidationFlag = this.options.noValidation;\n          this.options.noValidation = true;\n          root = new XMLDocument(this.options).element('TEMP_ROOT');\n          root.element(name);\n          this.options.noValidation = oldValidationFlag;\n          ref1 = root.children;\n          for (i = 0, len = ref1.length; i < len; i++) {\n            child = ref1[i];\n            this.createChildNode(child);\n            if (child.type === NodeType.Element) {\n              this.up();\n            }\n          }\n        } else {\n          this.node(name, attributes, text);\n        }\n      }\n      return this;\n    };\n\n    XMLDocumentCB.prototype.attribute = function(name, value) {\n      var attName, attValue;\n      if (!this.currentNode || this.currentNode.children) {\n        throw new Error(\"att() can only be used immediately after an ele() call in callback mode. \" + this.debugInfo(name));\n      }\n      if (name != null) {\n        name = getValue(name);\n      }\n      if (isObject(name)) {\n        for (attName in name) {\n          if (!hasProp.call(name, attName)) continue;\n          attValue = name[attName];\n          this.attribute(attName, attValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        if (this.options.keepNullAttributes && (value == null)) {\n          this.currentNode.attribs[name] = new XMLAttribute(this, name, \"\");\n        } else if (value != null) {\n          this.currentNode.attribs[name] = new XMLAttribute(this, name, value);\n        }\n      }\n      return this;\n    };\n\n    XMLDocumentCB.prototype.text = function(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLText(this, value);\n      this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.cdata = function(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLCData(this, value);\n      this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.comment = function(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLComment(this, value);\n      this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.raw = function(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLRaw(this, value);\n      this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.instruction = function(target, value) {\n      var i, insTarget, insValue, len, node;\n      this.openCurrent();\n      if (target != null) {\n        target = getValue(target);\n      }\n      if (value != null) {\n        value = getValue(value);\n      }\n      if (Array.isArray(target)) {\n        for (i = 0, len = target.length; i < len; i++) {\n          insTarget = target[i];\n          this.instruction(insTarget);\n        }\n      } else if (isObject(target)) {\n        for (insTarget in target) {\n          if (!hasProp.call(target, insTarget)) continue;\n          insValue = target[insTarget];\n          this.instruction(insTarget, insValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        node = new XMLProcessingInstruction(this, target, value);\n        this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      }\n      return this;\n    };\n\n    XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {\n      var node;\n      this.openCurrent();\n      if (this.documentStarted) {\n        throw new Error(\"declaration() must be the first node.\");\n      }\n      node = new XMLDeclaration(this, version, encoding, standalone);\n      this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {\n      this.openCurrent();\n      if (root == null) {\n        throw new Error(\"Missing root node name.\");\n      }\n      if (this.root) {\n        throw new Error(\"dtd() must come before the root node.\");\n      }\n      this.currentNode = new XMLDocType(this, pubID, sysID);\n      this.currentNode.rootNodeName = root;\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      return this;\n    };\n\n    XMLDocumentCB.prototype.dtdElement = function(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDElement(this, name, value);\n      this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n      this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.entity = function(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, false, name, value);\n      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.pEntity = function(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, true, name, value);\n      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.notation = function(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDNotation(this, name, value);\n      this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    };\n\n    XMLDocumentCB.prototype.up = function() {\n      if (this.currentLevel < 0) {\n        throw new Error(\"The document node has no parent.\");\n      }\n      if (this.currentNode) {\n        if (this.currentNode.children) {\n          this.closeNode(this.currentNode);\n        } else {\n          this.openNode(this.currentNode);\n        }\n        this.currentNode = null;\n      } else {\n        this.closeNode(this.openTags[this.currentLevel]);\n      }\n      delete this.openTags[this.currentLevel];\n      this.currentLevel--;\n      return this;\n    };\n\n    XMLDocumentCB.prototype.end = function() {\n      while (this.currentLevel >= 0) {\n        this.up();\n      }\n      return this.onEnd();\n    };\n\n    XMLDocumentCB.prototype.openCurrent = function() {\n      if (this.currentNode) {\n        this.currentNode.children = true;\n        return this.openNode(this.currentNode);\n      }\n    };\n\n    XMLDocumentCB.prototype.openNode = function(node) {\n      var att, chunk, name, ref1;\n      if (!node.isOpen) {\n        if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {\n          this.root = node;\n        }\n        chunk = '';\n        if (node.type === NodeType.Element) {\n          this.writerOptions.state = WriterState.OpenTag;\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;\n          ref1 = node.attribs;\n          for (name in ref1) {\n            if (!hasProp.call(ref1, name)) continue;\n            att = ref1[name];\n            chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);\n          }\n          chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);\n          this.writerOptions.state = WriterState.InsideTag;\n        } else {\n          this.writerOptions.state = WriterState.OpenTag;\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName;\n          if (node.pubID && node.sysID) {\n            chunk += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n          } else if (node.sysID) {\n            chunk += ' SYSTEM \"' + node.sysID + '\"';\n          }\n          if (node.children) {\n            chunk += ' [';\n            this.writerOptions.state = WriterState.InsideTag;\n          } else {\n            this.writerOptions.state = WriterState.CloseTag;\n            chunk += '>';\n          }\n          chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);\n        }\n        this.onData(chunk, this.currentLevel);\n        return node.isOpen = true;\n      }\n    };\n\n    XMLDocumentCB.prototype.closeNode = function(node) {\n      var chunk;\n      if (!node.isClosed) {\n        chunk = '';\n        this.writerOptions.state = WriterState.CloseTag;\n        if (node.type === NodeType.Element) {\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel);\n        } else {\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);\n        }\n        this.writerOptions.state = WriterState.None;\n        this.onData(chunk, this.currentLevel);\n        return node.isClosed = true;\n      }\n    };\n\n    XMLDocumentCB.prototype.onData = function(chunk, level) {\n      this.documentStarted = true;\n      return this.onDataCallback(chunk, level + 1);\n    };\n\n    XMLDocumentCB.prototype.onEnd = function() {\n      this.documentCompleted = true;\n      return this.onEndCallback();\n    };\n\n    XMLDocumentCB.prototype.debugInfo = function(name) {\n      if (name == null) {\n        return \"\";\n      } else {\n        return \"node: <\" + name + \">\";\n      }\n    };\n\n    XMLDocumentCB.prototype.ele = function() {\n      return this.element.apply(this, arguments);\n    };\n\n    XMLDocumentCB.prototype.nod = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLDocumentCB.prototype.txt = function(value) {\n      return this.text(value);\n    };\n\n    XMLDocumentCB.prototype.dat = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLDocumentCB.prototype.com = function(value) {\n      return this.comment(value);\n    };\n\n    XMLDocumentCB.prototype.ins = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {\n      return this.declaration(version, encoding, standalone);\n    };\n\n    XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {\n      return this.doctype(root, pubID, sysID);\n    };\n\n    XMLDocumentCB.prototype.e = function(name, attributes, text) {\n      return this.element(name, attributes, text);\n    };\n\n    XMLDocumentCB.prototype.n = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLDocumentCB.prototype.t = function(value) {\n      return this.text(value);\n    };\n\n    XMLDocumentCB.prototype.d = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLDocumentCB.prototype.c = function(value) {\n      return this.comment(value);\n    };\n\n    XMLDocumentCB.prototype.r = function(value) {\n      return this.raw(value);\n    };\n\n    XMLDocumentCB.prototype.i = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLDocumentCB.prototype.att = function() {\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        return this.attList.apply(this, arguments);\n      } else {\n        return this.attribute.apply(this, arguments);\n      }\n    };\n\n    XMLDocumentCB.prototype.a = function() {\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        return this.attList.apply(this, arguments);\n      } else {\n        return this.attribute.apply(this, arguments);\n      }\n    };\n\n    XMLDocumentCB.prototype.ent = function(name, value) {\n      return this.entity(name, value);\n    };\n\n    XMLDocumentCB.prototype.pent = function(name, value) {\n      return this.pEntity(name, value);\n    };\n\n    XMLDocumentCB.prototype.not = function(name, value) {\n      return this.notation(name, value);\n    };\n\n    return XMLDocumentCB;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLDummy, XMLNode,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLNode = require('./XMLNode');\n\n  NodeType = require('./NodeType');\n\n  module.exports = XMLDummy = (function(superClass) {\n    extend(XMLDummy, superClass);\n\n    function XMLDummy(parent) {\n      XMLDummy.__super__.constructor.call(this, parent);\n      this.type = NodeType.Dummy;\n    }\n\n    XMLDummy.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLDummy.prototype.toString = function(options) {\n      return '';\n    };\n\n    return XMLDummy;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLAttribute, XMLElement, XMLNamedNodeMap, XMLNode, getValue, isFunction, isObject, ref,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  ref = require('./Utility'), isObject = ref.isObject, isFunction = ref.isFunction, getValue = ref.getValue;\n\n  XMLNode = require('./XMLNode');\n\n  NodeType = require('./NodeType');\n\n  XMLAttribute = require('./XMLAttribute');\n\n  XMLNamedNodeMap = require('./XMLNamedNodeMap');\n\n  module.exports = XMLElement = (function(superClass) {\n    extend(XMLElement, superClass);\n\n    function XMLElement(parent, name, attributes) {\n      var child, j, len, ref1;\n      XMLElement.__super__.constructor.call(this, parent);\n      if (name == null) {\n        throw new Error(\"Missing element name. \" + this.debugInfo());\n      }\n      this.name = this.stringify.name(name);\n      this.type = NodeType.Element;\n      this.attribs = {};\n      this.schemaTypeInfo = null;\n      if (attributes != null) {\n        this.attribute(attributes);\n      }\n      if (parent.type === NodeType.Document) {\n        this.isRoot = true;\n        this.documentObject = parent;\n        parent.rootObject = this;\n        if (parent.children) {\n          ref1 = parent.children;\n          for (j = 0, len = ref1.length; j < len; j++) {\n            child = ref1[j];\n            if (child.type === NodeType.DocType) {\n              child.name = this.name;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    Object.defineProperty(XMLElement.prototype, 'tagName', {\n      get: function() {\n        return this.name;\n      }\n    });\n\n    Object.defineProperty(XMLElement.prototype, 'namespaceURI', {\n      get: function() {\n        return '';\n      }\n    });\n\n    Object.defineProperty(XMLElement.prototype, 'prefix', {\n      get: function() {\n        return '';\n      }\n    });\n\n    Object.defineProperty(XMLElement.prototype, 'localName', {\n      get: function() {\n        return this.name;\n      }\n    });\n\n    Object.defineProperty(XMLElement.prototype, 'id', {\n      get: function() {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n\n    Object.defineProperty(XMLElement.prototype, 'className', {\n      get: function() {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n\n    Object.defineProperty(XMLElement.prototype, 'classList', {\n      get: function() {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n\n    Object.defineProperty(XMLElement.prototype, 'attributes', {\n      get: function() {\n        if (!this.attributeMap || !this.attributeMap.nodes) {\n          this.attributeMap = new XMLNamedNodeMap(this.attribs);\n        }\n        return this.attributeMap;\n      }\n    });\n\n    XMLElement.prototype.clone = function() {\n      var att, attName, clonedSelf, ref1;\n      clonedSelf = Object.create(this);\n      if (clonedSelf.isRoot) {\n        clonedSelf.documentObject = null;\n      }\n      clonedSelf.attribs = {};\n      ref1 = this.attribs;\n      for (attName in ref1) {\n        if (!hasProp.call(ref1, attName)) continue;\n        att = ref1[attName];\n        clonedSelf.attribs[attName] = att.clone();\n      }\n      clonedSelf.children = [];\n      this.children.forEach(function(child) {\n        var clonedChild;\n        clonedChild = child.clone();\n        clonedChild.parent = clonedSelf;\n        return clonedSelf.children.push(clonedChild);\n      });\n      return clonedSelf;\n    };\n\n    XMLElement.prototype.attribute = function(name, value) {\n      var attName, attValue;\n      if (name != null) {\n        name = getValue(name);\n      }\n      if (isObject(name)) {\n        for (attName in name) {\n          if (!hasProp.call(name, attName)) continue;\n          attValue = name[attName];\n          this.attribute(attName, attValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        if (this.options.keepNullAttributes && (value == null)) {\n          this.attribs[name] = new XMLAttribute(this, name, \"\");\n        } else if (value != null) {\n          this.attribs[name] = new XMLAttribute(this, name, value);\n        }\n      }\n      return this;\n    };\n\n    XMLElement.prototype.removeAttribute = function(name) {\n      var attName, j, len;\n      if (name == null) {\n        throw new Error(\"Missing attribute name. \" + this.debugInfo());\n      }\n      name = getValue(name);\n      if (Array.isArray(name)) {\n        for (j = 0, len = name.length; j < len; j++) {\n          attName = name[j];\n          delete this.attribs[attName];\n        }\n      } else {\n        delete this.attribs[name];\n      }\n      return this;\n    };\n\n    XMLElement.prototype.toString = function(options) {\n      return this.options.writer.element(this, this.options.writer.filterOptions(options));\n    };\n\n    XMLElement.prototype.att = function(name, value) {\n      return this.attribute(name, value);\n    };\n\n    XMLElement.prototype.a = function(name, value) {\n      return this.attribute(name, value);\n    };\n\n    XMLElement.prototype.getAttribute = function(name) {\n      if (this.attribs.hasOwnProperty(name)) {\n        return this.attribs[name].value;\n      } else {\n        return null;\n      }\n    };\n\n    XMLElement.prototype.setAttribute = function(name, value) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.getAttributeNode = function(name) {\n      if (this.attribs.hasOwnProperty(name)) {\n        return this.attribs[name];\n      } else {\n        return null;\n      }\n    };\n\n    XMLElement.prototype.setAttributeNode = function(newAttr) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.removeAttributeNode = function(oldAttr) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.getElementsByTagName = function(name) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.getAttributeNS = function(namespaceURI, localName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.setAttributeNS = function(namespaceURI, qualifiedName, value) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.removeAttributeNS = function(namespaceURI, localName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.getAttributeNodeNS = function(namespaceURI, localName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.setAttributeNodeNS = function(newAttr) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.hasAttribute = function(name) {\n      return this.attribs.hasOwnProperty(name);\n    };\n\n    XMLElement.prototype.hasAttributeNS = function(namespaceURI, localName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.setIdAttribute = function(name, isId) {\n      if (this.attribs.hasOwnProperty(name)) {\n        return this.attribs[name].isId;\n      } else {\n        return isId;\n      }\n    };\n\n    XMLElement.prototype.setIdAttributeNS = function(namespaceURI, localName, isId) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.setIdAttributeNode = function(idAttr, isId) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.getElementsByTagName = function(tagname) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.getElementsByTagNameNS = function(namespaceURI, localName) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.getElementsByClassName = function(classNames) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLElement.prototype.isEqualNode = function(node) {\n      var i, j, ref1;\n      if (!XMLElement.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {\n        return false;\n      }\n      if (node.namespaceURI !== this.namespaceURI) {\n        return false;\n      }\n      if (node.prefix !== this.prefix) {\n        return false;\n      }\n      if (node.localName !== this.localName) {\n        return false;\n      }\n      if (node.attribs.length !== this.attribs.length) {\n        return false;\n      }\n      for (i = j = 0, ref1 = this.attribs.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {\n        if (!this.attribs[i].isEqualNode(node.attribs[i])) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    return XMLElement;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLNamedNodeMap;\n\n  module.exports = XMLNamedNodeMap = (function() {\n    function XMLNamedNodeMap(nodes) {\n      this.nodes = nodes;\n    }\n\n    Object.defineProperty(XMLNamedNodeMap.prototype, 'length', {\n      get: function() {\n        return Object.keys(this.nodes).length || 0;\n      }\n    });\n\n    XMLNamedNodeMap.prototype.clone = function() {\n      return this.nodes = null;\n    };\n\n    XMLNamedNodeMap.prototype.getNamedItem = function(name) {\n      return this.nodes[name];\n    };\n\n    XMLNamedNodeMap.prototype.setNamedItem = function(node) {\n      var oldNode;\n      oldNode = this.nodes[node.nodeName];\n      this.nodes[node.nodeName] = node;\n      return oldNode || null;\n    };\n\n    XMLNamedNodeMap.prototype.removeNamedItem = function(name) {\n      var oldNode;\n      oldNode = this.nodes[name];\n      delete this.nodes[name];\n      return oldNode || null;\n    };\n\n    XMLNamedNodeMap.prototype.item = function(index) {\n      return this.nodes[Object.keys(this.nodes)[index]] || null;\n    };\n\n    XMLNamedNodeMap.prototype.getNamedItemNS = function(namespaceURI, localName) {\n      throw new Error(\"This DOM method is not implemented.\");\n    };\n\n    XMLNamedNodeMap.prototype.setNamedItemNS = function(node) {\n      throw new Error(\"This DOM method is not implemented.\");\n    };\n\n    XMLNamedNodeMap.prototype.removeNamedItemNS = function(namespaceURI, localName) {\n      throw new Error(\"This DOM method is not implemented.\");\n    };\n\n    return XMLNamedNodeMap;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject, ref1,\n    hasProp = {}.hasOwnProperty;\n\n  ref1 = require('./Utility'), isObject = ref1.isObject, isFunction = ref1.isFunction, isEmpty = ref1.isEmpty, getValue = ref1.getValue;\n\n  XMLElement = null;\n\n  XMLCData = null;\n\n  XMLComment = null;\n\n  XMLDeclaration = null;\n\n  XMLDocType = null;\n\n  XMLRaw = null;\n\n  XMLText = null;\n\n  XMLProcessingInstruction = null;\n\n  XMLDummy = null;\n\n  NodeType = null;\n\n  XMLNodeList = null;\n\n  XMLNamedNodeMap = null;\n\n  DocumentPosition = null;\n\n  module.exports = XMLNode = (function() {\n    function XMLNode(parent1) {\n      this.parent = parent1;\n      if (this.parent) {\n        this.options = this.parent.options;\n        this.stringify = this.parent.stringify;\n      }\n      this.value = null;\n      this.children = [];\n      this.baseURI = null;\n      if (!XMLElement) {\n        XMLElement = require('./XMLElement');\n        XMLCData = require('./XMLCData');\n        XMLComment = require('./XMLComment');\n        XMLDeclaration = require('./XMLDeclaration');\n        XMLDocType = require('./XMLDocType');\n        XMLRaw = require('./XMLRaw');\n        XMLText = require('./XMLText');\n        XMLProcessingInstruction = require('./XMLProcessingInstruction');\n        XMLDummy = require('./XMLDummy');\n        NodeType = require('./NodeType');\n        XMLNodeList = require('./XMLNodeList');\n        XMLNamedNodeMap = require('./XMLNamedNodeMap');\n        DocumentPosition = require('./DocumentPosition');\n      }\n    }\n\n    Object.defineProperty(XMLNode.prototype, 'nodeName', {\n      get: function() {\n        return this.name;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'nodeType', {\n      get: function() {\n        return this.type;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'nodeValue', {\n      get: function() {\n        return this.value;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'parentNode', {\n      get: function() {\n        return this.parent;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'childNodes', {\n      get: function() {\n        if (!this.childNodeList || !this.childNodeList.nodes) {\n          this.childNodeList = new XMLNodeList(this.children);\n        }\n        return this.childNodeList;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'firstChild', {\n      get: function() {\n        return this.children[0] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'lastChild', {\n      get: function() {\n        return this.children[this.children.length - 1] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'previousSibling', {\n      get: function() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i - 1] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'nextSibling', {\n      get: function() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i + 1] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'ownerDocument', {\n      get: function() {\n        return this.document() || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'textContent', {\n      get: function() {\n        var child, j, len, ref2, str;\n        if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {\n          str = '';\n          ref2 = this.children;\n          for (j = 0, len = ref2.length; j < len; j++) {\n            child = ref2[j];\n            if (child.textContent) {\n              str += child.textContent;\n            }\n          }\n          return str;\n        } else {\n          return null;\n        }\n      },\n      set: function(value) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n\n    XMLNode.prototype.setParent = function(parent) {\n      var child, j, len, ref2, results;\n      this.parent = parent;\n      if (parent) {\n        this.options = parent.options;\n        this.stringify = parent.stringify;\n      }\n      ref2 = this.children;\n      results = [];\n      for (j = 0, len = ref2.length; j < len; j++) {\n        child = ref2[j];\n        results.push(child.setParent(this));\n      }\n      return results;\n    };\n\n    XMLNode.prototype.element = function(name, attributes, text) {\n      var childNode, item, j, k, key, lastChild, len, len1, ref2, ref3, val;\n      lastChild = null;\n      if (attributes === null && (text == null)) {\n        ref2 = [{}, null], attributes = ref2[0], text = ref2[1];\n      }\n      if (attributes == null) {\n        attributes = {};\n      }\n      attributes = getValue(attributes);\n      if (!isObject(attributes)) {\n        ref3 = [attributes, text], text = ref3[0], attributes = ref3[1];\n      }\n      if (name != null) {\n        name = getValue(name);\n      }\n      if (Array.isArray(name)) {\n        for (j = 0, len = name.length; j < len; j++) {\n          item = name[j];\n          lastChild = this.element(item);\n        }\n      } else if (isFunction(name)) {\n        lastChild = this.element(name.apply());\n      } else if (isObject(name)) {\n        for (key in name) {\n          if (!hasProp.call(name, key)) continue;\n          val = name[key];\n          if (isFunction(val)) {\n            val = val.apply();\n          }\n          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {\n            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);\n          } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {\n            lastChild = this.dummy();\n          } else if (isObject(val) && isEmpty(val)) {\n            lastChild = this.element(key);\n          } else if (!this.options.keepNullNodes && (val == null)) {\n            lastChild = this.dummy();\n          } else if (!this.options.separateArrayItems && Array.isArray(val)) {\n            for (k = 0, len1 = val.length; k < len1; k++) {\n              item = val[k];\n              childNode = {};\n              childNode[key] = item;\n              lastChild = this.element(childNode);\n            }\n          } else if (isObject(val)) {\n            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {\n              lastChild = this.element(val);\n            } else {\n              lastChild = this.element(key);\n              lastChild.element(val);\n            }\n          } else {\n            lastChild = this.element(key, val);\n          }\n        }\n      } else if (!this.options.keepNullNodes && text === null) {\n        lastChild = this.dummy();\n      } else {\n        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {\n          lastChild = this.text(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {\n          lastChild = this.cdata(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {\n          lastChild = this.comment(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {\n          lastChild = this.raw(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {\n          lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);\n        } else {\n          lastChild = this.node(name, attributes, text);\n        }\n      }\n      if (lastChild == null) {\n        throw new Error(\"Could not create any elements with: \" + name + \". \" + this.debugInfo());\n      }\n      return lastChild;\n    };\n\n    XMLNode.prototype.insertBefore = function(name, attributes, text) {\n      var child, i, newChild, refChild, removed;\n      if (name != null ? name.type : void 0) {\n        newChild = name;\n        refChild = attributes;\n        newChild.setParent(this);\n        if (refChild) {\n          i = children.indexOf(refChild);\n          removed = children.splice(i);\n          children.push(newChild);\n          Array.prototype.push.apply(children, removed);\n        } else {\n          children.push(newChild);\n        }\n        return newChild;\n      } else {\n        if (this.isRoot) {\n          throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n        }\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i);\n        child = this.parent.element(name, attributes, text);\n        Array.prototype.push.apply(this.parent.children, removed);\n        return child;\n      }\n    };\n\n    XMLNode.prototype.insertAfter = function(name, attributes, text) {\n      var child, i, removed;\n      if (this.isRoot) {\n        throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n      }\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i + 1);\n      child = this.parent.element(name, attributes, text);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return child;\n    };\n\n    XMLNode.prototype.remove = function() {\n      var i, ref2;\n      if (this.isRoot) {\n        throw new Error(\"Cannot remove the root element. \" + this.debugInfo());\n      }\n      i = this.parent.children.indexOf(this);\n      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref2 = [])), ref2;\n      return this.parent;\n    };\n\n    XMLNode.prototype.node = function(name, attributes, text) {\n      var child, ref2;\n      if (name != null) {\n        name = getValue(name);\n      }\n      attributes || (attributes = {});\n      attributes = getValue(attributes);\n      if (!isObject(attributes)) {\n        ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];\n      }\n      child = new XMLElement(this, name, attributes);\n      if (text != null) {\n        child.text(text);\n      }\n      this.children.push(child);\n      return child;\n    };\n\n    XMLNode.prototype.text = function(value) {\n      var child;\n      if (isObject(value)) {\n        this.element(value);\n      }\n      child = new XMLText(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.cdata = function(value) {\n      var child;\n      child = new XMLCData(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.comment = function(value) {\n      var child;\n      child = new XMLComment(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.commentBefore = function(value) {\n      var child, i, removed;\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i);\n      child = this.parent.comment(value);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return this;\n    };\n\n    XMLNode.prototype.commentAfter = function(value) {\n      var child, i, removed;\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i + 1);\n      child = this.parent.comment(value);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return this;\n    };\n\n    XMLNode.prototype.raw = function(value) {\n      var child;\n      child = new XMLRaw(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.dummy = function() {\n      var child;\n      child = new XMLDummy(this);\n      return child;\n    };\n\n    XMLNode.prototype.instruction = function(target, value) {\n      var insTarget, insValue, instruction, j, len;\n      if (target != null) {\n        target = getValue(target);\n      }\n      if (value != null) {\n        value = getValue(value);\n      }\n      if (Array.isArray(target)) {\n        for (j = 0, len = target.length; j < len; j++) {\n          insTarget = target[j];\n          this.instruction(insTarget);\n        }\n      } else if (isObject(target)) {\n        for (insTarget in target) {\n          if (!hasProp.call(target, insTarget)) continue;\n          insValue = target[insTarget];\n          this.instruction(insTarget, insValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        instruction = new XMLProcessingInstruction(this, target, value);\n        this.children.push(instruction);\n      }\n      return this;\n    };\n\n    XMLNode.prototype.instructionBefore = function(target, value) {\n      var child, i, removed;\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i);\n      child = this.parent.instruction(target, value);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return this;\n    };\n\n    XMLNode.prototype.instructionAfter = function(target, value) {\n      var child, i, removed;\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i + 1);\n      child = this.parent.instruction(target, value);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return this;\n    };\n\n    XMLNode.prototype.declaration = function(version, encoding, standalone) {\n      var doc, xmldec;\n      doc = this.document();\n      xmldec = new XMLDeclaration(doc, version, encoding, standalone);\n      if (doc.children.length === 0) {\n        doc.children.unshift(xmldec);\n      } else if (doc.children[0].type === NodeType.Declaration) {\n        doc.children[0] = xmldec;\n      } else {\n        doc.children.unshift(xmldec);\n      }\n      return doc.root() || doc;\n    };\n\n    XMLNode.prototype.dtd = function(pubID, sysID) {\n      var child, doc, doctype, i, j, k, len, len1, ref2, ref3;\n      doc = this.document();\n      doctype = new XMLDocType(doc, pubID, sysID);\n      ref2 = doc.children;\n      for (i = j = 0, len = ref2.length; j < len; i = ++j) {\n        child = ref2[i];\n        if (child.type === NodeType.DocType) {\n          doc.children[i] = doctype;\n          return doctype;\n        }\n      }\n      ref3 = doc.children;\n      for (i = k = 0, len1 = ref3.length; k < len1; i = ++k) {\n        child = ref3[i];\n        if (child.isRoot) {\n          doc.children.splice(i, 0, doctype);\n          return doctype;\n        }\n      }\n      doc.children.push(doctype);\n      return doctype;\n    };\n\n    XMLNode.prototype.up = function() {\n      if (this.isRoot) {\n        throw new Error(\"The root node has no parent. Use doc() if you need to get the document object.\");\n      }\n      return this.parent;\n    };\n\n    XMLNode.prototype.root = function() {\n      var node;\n      node = this;\n      while (node) {\n        if (node.type === NodeType.Document) {\n          return node.rootObject;\n        } else if (node.isRoot) {\n          return node;\n        } else {\n          node = node.parent;\n        }\n      }\n    };\n\n    XMLNode.prototype.document = function() {\n      var node;\n      node = this;\n      while (node) {\n        if (node.type === NodeType.Document) {\n          return node;\n        } else {\n          node = node.parent;\n        }\n      }\n    };\n\n    XMLNode.prototype.end = function(options) {\n      return this.document().end(options);\n    };\n\n    XMLNode.prototype.prev = function() {\n      var i;\n      i = this.parent.children.indexOf(this);\n      if (i < 1) {\n        throw new Error(\"Already at the first node. \" + this.debugInfo());\n      }\n      return this.parent.children[i - 1];\n    };\n\n    XMLNode.prototype.next = function() {\n      var i;\n      i = this.parent.children.indexOf(this);\n      if (i === -1 || i === this.parent.children.length - 1) {\n        throw new Error(\"Already at the last node. \" + this.debugInfo());\n      }\n      return this.parent.children[i + 1];\n    };\n\n    XMLNode.prototype.importDocument = function(doc) {\n      var clonedRoot;\n      clonedRoot = doc.root().clone();\n      clonedRoot.parent = this;\n      clonedRoot.isRoot = false;\n      this.children.push(clonedRoot);\n      return this;\n    };\n\n    XMLNode.prototype.debugInfo = function(name) {\n      var ref2, ref3;\n      name = name || this.name;\n      if ((name == null) && !((ref2 = this.parent) != null ? ref2.name : void 0)) {\n        return \"\";\n      } else if (name == null) {\n        return \"parent: <\" + this.parent.name + \">\";\n      } else if (!((ref3 = this.parent) != null ? ref3.name : void 0)) {\n        return \"node: <\" + name + \">\";\n      } else {\n        return \"node: <\" + name + \">, parent: <\" + this.parent.name + \">\";\n      }\n    };\n\n    XMLNode.prototype.ele = function(name, attributes, text) {\n      return this.element(name, attributes, text);\n    };\n\n    XMLNode.prototype.nod = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLNode.prototype.txt = function(value) {\n      return this.text(value);\n    };\n\n    XMLNode.prototype.dat = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLNode.prototype.com = function(value) {\n      return this.comment(value);\n    };\n\n    XMLNode.prototype.ins = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLNode.prototype.doc = function() {\n      return this.document();\n    };\n\n    XMLNode.prototype.dec = function(version, encoding, standalone) {\n      return this.declaration(version, encoding, standalone);\n    };\n\n    XMLNode.prototype.e = function(name, attributes, text) {\n      return this.element(name, attributes, text);\n    };\n\n    XMLNode.prototype.n = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLNode.prototype.t = function(value) {\n      return this.text(value);\n    };\n\n    XMLNode.prototype.d = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLNode.prototype.c = function(value) {\n      return this.comment(value);\n    };\n\n    XMLNode.prototype.r = function(value) {\n      return this.raw(value);\n    };\n\n    XMLNode.prototype.i = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLNode.prototype.u = function() {\n      return this.up();\n    };\n\n    XMLNode.prototype.importXMLBuilder = function(doc) {\n      return this.importDocument(doc);\n    };\n\n    XMLNode.prototype.replaceChild = function(newChild, oldChild) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.removeChild = function(oldChild) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.appendChild = function(newChild) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.hasChildNodes = function() {\n      return this.children.length !== 0;\n    };\n\n    XMLNode.prototype.cloneNode = function(deep) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.normalize = function() {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.isSupported = function(feature, version) {\n      return true;\n    };\n\n    XMLNode.prototype.hasAttributes = function() {\n      return this.attribs.length !== 0;\n    };\n\n    XMLNode.prototype.compareDocumentPosition = function(other) {\n      var ref, res;\n      ref = this;\n      if (ref === other) {\n        return 0;\n      } else if (this.document() !== other.document()) {\n        res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;\n        if (Math.random() < 0.5) {\n          res |= DocumentPosition.Preceding;\n        } else {\n          res |= DocumentPosition.Following;\n        }\n        return res;\n      } else if (ref.isAncestor(other)) {\n        return DocumentPosition.Contains | DocumentPosition.Preceding;\n      } else if (ref.isDescendant(other)) {\n        return DocumentPosition.Contains | DocumentPosition.Following;\n      } else if (ref.isPreceding(other)) {\n        return DocumentPosition.Preceding;\n      } else {\n        return DocumentPosition.Following;\n      }\n    };\n\n    XMLNode.prototype.isSameNode = function(other) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.lookupPrefix = function(namespaceURI) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.isDefaultNamespace = function(namespaceURI) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.lookupNamespaceURI = function(prefix) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.isEqualNode = function(node) {\n      var i, j, ref2;\n      if (node.nodeType !== this.nodeType) {\n        return false;\n      }\n      if (node.children.length !== this.children.length) {\n        return false;\n      }\n      for (i = j = 0, ref2 = this.children.length - 1; 0 <= ref2 ? j <= ref2 : j >= ref2; i = 0 <= ref2 ? ++j : --j) {\n        if (!this.children[i].isEqualNode(node.children[i])) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    XMLNode.prototype.getFeature = function(feature, version) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.setUserData = function(key, data, handler) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.getUserData = function(key) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLNode.prototype.contains = function(other) {\n      if (!other) {\n        return false;\n      }\n      return other === this || this.isDescendant(other);\n    };\n\n    XMLNode.prototype.isDescendant = function(node) {\n      var child, isDescendantChild, j, len, ref2;\n      ref2 = this.children;\n      for (j = 0, len = ref2.length; j < len; j++) {\n        child = ref2[j];\n        if (node === child) {\n          return true;\n        }\n        isDescendantChild = child.isDescendant(node);\n        if (isDescendantChild) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    XMLNode.prototype.isAncestor = function(node) {\n      return node.isDescendant(this);\n    };\n\n    XMLNode.prototype.isPreceding = function(node) {\n      var nodePos, thisPos;\n      nodePos = this.treePosition(node);\n      thisPos = this.treePosition(this);\n      if (nodePos === -1 || thisPos === -1) {\n        return false;\n      } else {\n        return nodePos < thisPos;\n      }\n    };\n\n    XMLNode.prototype.isFollowing = function(node) {\n      var nodePos, thisPos;\n      nodePos = this.treePosition(node);\n      thisPos = this.treePosition(this);\n      if (nodePos === -1 || thisPos === -1) {\n        return false;\n      } else {\n        return nodePos > thisPos;\n      }\n    };\n\n    XMLNode.prototype.treePosition = function(node) {\n      var found, pos;\n      pos = 0;\n      found = false;\n      this.foreachTreeNode(this.document(), function(childNode) {\n        pos++;\n        if (!found && childNode === node) {\n          return found = true;\n        }\n      });\n      if (found) {\n        return pos;\n      } else {\n        return -1;\n      }\n    };\n\n    XMLNode.prototype.foreachTreeNode = function(node, func) {\n      var child, j, len, ref2, res;\n      node || (node = this.document());\n      ref2 = node.children;\n      for (j = 0, len = ref2.length; j < len; j++) {\n        child = ref2[j];\n        if (res = func(child)) {\n          return res;\n        } else {\n          res = this.foreachTreeNode(child, func);\n          if (res) {\n            return res;\n          }\n        }\n      }\n    };\n\n    return XMLNode;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLNodeList;\n\n  module.exports = XMLNodeList = (function() {\n    function XMLNodeList(nodes) {\n      this.nodes = nodes;\n    }\n\n    Object.defineProperty(XMLNodeList.prototype, 'length', {\n      get: function() {\n        return this.nodes.length || 0;\n      }\n    });\n\n    XMLNodeList.prototype.clone = function() {\n      return this.nodes = null;\n    };\n\n    XMLNodeList.prototype.item = function(index) {\n      return this.nodes[index] || null;\n    };\n\n    return XMLNodeList;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLCharacterData, XMLProcessingInstruction,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  NodeType = require('./NodeType');\n\n  XMLCharacterData = require('./XMLCharacterData');\n\n  module.exports = XMLProcessingInstruction = (function(superClass) {\n    extend(XMLProcessingInstruction, superClass);\n\n    function XMLProcessingInstruction(parent, target, value) {\n      XMLProcessingInstruction.__super__.constructor.call(this, parent);\n      if (target == null) {\n        throw new Error(\"Missing instruction target. \" + this.debugInfo());\n      }\n      this.type = NodeType.ProcessingInstruction;\n      this.target = this.stringify.insTarget(target);\n      this.name = this.target;\n      if (value) {\n        this.value = this.stringify.insValue(value);\n      }\n    }\n\n    XMLProcessingInstruction.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLProcessingInstruction.prototype.toString = function(options) {\n      return this.options.writer.processingInstruction(this, this.options.writer.filterOptions(options));\n    };\n\n    XMLProcessingInstruction.prototype.isEqualNode = function(node) {\n      if (!XMLProcessingInstruction.__super__.isEqualNode.apply(this, arguments).isEqualNode(node)) {\n        return false;\n      }\n      if (node.target !== this.target) {\n        return false;\n      }\n      return true;\n    };\n\n    return XMLProcessingInstruction;\n\n  })(XMLCharacterData);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLNode, XMLRaw,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  NodeType = require('./NodeType');\n\n  XMLNode = require('./XMLNode');\n\n  module.exports = XMLRaw = (function(superClass) {\n    extend(XMLRaw, superClass);\n\n    function XMLRaw(parent, text) {\n      XMLRaw.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing raw text. \" + this.debugInfo());\n      }\n      this.type = NodeType.Raw;\n      this.value = this.stringify.raw(text);\n    }\n\n    XMLRaw.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLRaw.prototype.toString = function(options) {\n      return this.options.writer.raw(this, this.options.writer.filterOptions(options));\n    };\n\n    return XMLRaw;\n\n  })(XMLNode);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, WriterState, XMLStreamWriter, XMLWriterBase,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  NodeType = require('./NodeType');\n\n  XMLWriterBase = require('./XMLWriterBase');\n\n  WriterState = require('./WriterState');\n\n  module.exports = XMLStreamWriter = (function(superClass) {\n    extend(XMLStreamWriter, superClass);\n\n    function XMLStreamWriter(stream, options) {\n      this.stream = stream;\n      XMLStreamWriter.__super__.constructor.call(this, options);\n    }\n\n    XMLStreamWriter.prototype.endline = function(node, options, level) {\n      if (node.isLastRootNode && options.state === WriterState.CloseTag) {\n        return '';\n      } else {\n        return XMLStreamWriter.__super__.endline.call(this, node, options, level);\n      }\n    };\n\n    XMLStreamWriter.prototype.document = function(doc, options) {\n      var child, i, j, k, len, len1, ref, ref1, results;\n      ref = doc.children;\n      for (i = j = 0, len = ref.length; j < len; i = ++j) {\n        child = ref[i];\n        child.isLastRootNode = i === doc.children.length - 1;\n      }\n      options = this.filterOptions(options);\n      ref1 = doc.children;\n      results = [];\n      for (k = 0, len1 = ref1.length; k < len1; k++) {\n        child = ref1[k];\n        results.push(this.writeChildNode(child, options, 0));\n      }\n      return results;\n    };\n\n    XMLStreamWriter.prototype.attribute = function(att, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.attribute.call(this, att, options, level));\n    };\n\n    XMLStreamWriter.prototype.cdata = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.cdata.call(this, node, options, level));\n    };\n\n    XMLStreamWriter.prototype.comment = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.comment.call(this, node, options, level));\n    };\n\n    XMLStreamWriter.prototype.declaration = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.declaration.call(this, node, options, level));\n    };\n\n    XMLStreamWriter.prototype.docType = function(node, options, level) {\n      var child, j, len, ref;\n      level || (level = 0);\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      this.stream.write(this.indent(node, options, level));\n      this.stream.write('<!DOCTYPE ' + node.root().name);\n      if (node.pubID && node.sysID) {\n        this.stream.write(' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"');\n      } else if (node.sysID) {\n        this.stream.write(' SYSTEM \"' + node.sysID + '\"');\n      }\n      if (node.children.length > 0) {\n        this.stream.write(' [');\n        this.stream.write(this.endline(node, options, level));\n        options.state = WriterState.InsideTag;\n        ref = node.children;\n        for (j = 0, len = ref.length; j < len; j++) {\n          child = ref[j];\n          this.writeChildNode(child, options, level + 1);\n        }\n        options.state = WriterState.CloseTag;\n        this.stream.write(']');\n      }\n      options.state = WriterState.CloseTag;\n      this.stream.write(options.spaceBeforeSlash + '>');\n      this.stream.write(this.endline(node, options, level));\n      options.state = WriterState.None;\n      return this.closeNode(node, options, level);\n    };\n\n    XMLStreamWriter.prototype.element = function(node, options, level) {\n      var att, child, childNodeCount, firstChildNode, j, len, name, prettySuppressed, ref, ref1;\n      level || (level = 0);\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      this.stream.write(this.indent(node, options, level) + '<' + node.name);\n      ref = node.attribs;\n      for (name in ref) {\n        if (!hasProp.call(ref, name)) continue;\n        att = ref[name];\n        this.attribute(att, options, level);\n      }\n      childNodeCount = node.children.length;\n      firstChildNode = childNodeCount === 0 ? null : node.children[0];\n      if (childNodeCount === 0 || node.children.every(function(e) {\n        return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';\n      })) {\n        if (options.allowEmpty) {\n          this.stream.write('>');\n          options.state = WriterState.CloseTag;\n          this.stream.write('</' + node.name + '>');\n        } else {\n          options.state = WriterState.CloseTag;\n          this.stream.write(options.spaceBeforeSlash + '/>');\n        }\n      } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && (firstChildNode.value != null)) {\n        this.stream.write('>');\n        options.state = WriterState.InsideTag;\n        options.suppressPrettyCount++;\n        prettySuppressed = true;\n        this.writeChildNode(firstChildNode, options, level + 1);\n        options.suppressPrettyCount--;\n        prettySuppressed = false;\n        options.state = WriterState.CloseTag;\n        this.stream.write('</' + node.name + '>');\n      } else {\n        this.stream.write('>' + this.endline(node, options, level));\n        options.state = WriterState.InsideTag;\n        ref1 = node.children;\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          this.writeChildNode(child, options, level + 1);\n        }\n        options.state = WriterState.CloseTag;\n        this.stream.write(this.indent(node, options, level) + '</' + node.name + '>');\n      }\n      this.stream.write(this.endline(node, options, level));\n      options.state = WriterState.None;\n      return this.closeNode(node, options, level);\n    };\n\n    XMLStreamWriter.prototype.processingInstruction = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.processingInstruction.call(this, node, options, level));\n    };\n\n    XMLStreamWriter.prototype.raw = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.raw.call(this, node, options, level));\n    };\n\n    XMLStreamWriter.prototype.text = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.text.call(this, node, options, level));\n    };\n\n    XMLStreamWriter.prototype.dtdAttList = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.dtdAttList.call(this, node, options, level));\n    };\n\n    XMLStreamWriter.prototype.dtdElement = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.dtdElement.call(this, node, options, level));\n    };\n\n    XMLStreamWriter.prototype.dtdEntity = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.dtdEntity.call(this, node, options, level));\n    };\n\n    XMLStreamWriter.prototype.dtdNotation = function(node, options, level) {\n      return this.stream.write(XMLStreamWriter.__super__.dtdNotation.call(this, node, options, level));\n    };\n\n    return XMLStreamWriter;\n\n  })(XMLWriterBase);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLStringWriter, XMLWriterBase,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  XMLWriterBase = require('./XMLWriterBase');\n\n  module.exports = XMLStringWriter = (function(superClass) {\n    extend(XMLStringWriter, superClass);\n\n    function XMLStringWriter(options) {\n      XMLStringWriter.__super__.constructor.call(this, options);\n    }\n\n    XMLStringWriter.prototype.document = function(doc, options) {\n      var child, i, len, r, ref;\n      options = this.filterOptions(options);\n      r = '';\n      ref = doc.children;\n      for (i = 0, len = ref.length; i < len; i++) {\n        child = ref[i];\n        r += this.writeChildNode(child, options, 0);\n      }\n      if (options.pretty && r.slice(-options.newline.length) === options.newline) {\n        r = r.slice(0, -options.newline.length);\n      }\n      return r;\n    };\n\n    return XMLStringWriter;\n\n  })(XMLWriterBase);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var XMLStringifier,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    hasProp = {}.hasOwnProperty;\n\n  module.exports = XMLStringifier = (function() {\n    function XMLStringifier(options) {\n      this.assertLegalName = bind(this.assertLegalName, this);\n      this.assertLegalChar = bind(this.assertLegalChar, this);\n      var key, ref, value;\n      options || (options = {});\n      this.options = options;\n      if (!this.options.version) {\n        this.options.version = '1.0';\n      }\n      ref = options.stringify || {};\n      for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this[key] = value;\n      }\n    }\n\n    XMLStringifier.prototype.name = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalName('' + val || '');\n    };\n\n    XMLStringifier.prototype.text = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar(this.textEscape('' + val || ''));\n    };\n\n    XMLStringifier.prototype.cdata = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      val = '' + val || '';\n      val = val.replace(']]>', ']]]]><![CDATA[>');\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.comment = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      val = '' + val || '';\n      if (val.match(/--/)) {\n        throw new Error(\"Comment text cannot contain double-hypen: \" + val);\n      }\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.raw = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return '' + val || '';\n    };\n\n    XMLStringifier.prototype.attValue = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar(this.attEscape(val = '' + val || ''));\n    };\n\n    XMLStringifier.prototype.insTarget = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar('' + val || '');\n    };\n\n    XMLStringifier.prototype.insValue = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      val = '' + val || '';\n      if (val.match(/\\?>/)) {\n        throw new Error(\"Invalid processing instruction value: \" + val);\n      }\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.xmlVersion = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      val = '' + val || '';\n      if (!val.match(/1\\.[0-9]+/)) {\n        throw new Error(\"Invalid version number: \" + val);\n      }\n      return val;\n    };\n\n    XMLStringifier.prototype.xmlEncoding = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      val = '' + val || '';\n      if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {\n        throw new Error(\"Invalid encoding: \" + val);\n      }\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.xmlStandalone = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      if (val) {\n        return \"yes\";\n      } else {\n        return \"no\";\n      }\n    };\n\n    XMLStringifier.prototype.dtdPubID = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar('' + val || '');\n    };\n\n    XMLStringifier.prototype.dtdSysID = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar('' + val || '');\n    };\n\n    XMLStringifier.prototype.dtdElementValue = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar('' + val || '');\n    };\n\n    XMLStringifier.prototype.dtdAttType = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar('' + val || '');\n    };\n\n    XMLStringifier.prototype.dtdAttDefault = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar('' + val || '');\n    };\n\n    XMLStringifier.prototype.dtdEntityValue = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar('' + val || '');\n    };\n\n    XMLStringifier.prototype.dtdNData = function(val) {\n      if (this.options.noValidation) {\n        return val;\n      }\n      return this.assertLegalChar('' + val || '');\n    };\n\n    XMLStringifier.prototype.convertAttKey = '@';\n\n    XMLStringifier.prototype.convertPIKey = '?';\n\n    XMLStringifier.prototype.convertTextKey = '#text';\n\n    XMLStringifier.prototype.convertCDataKey = '#cdata';\n\n    XMLStringifier.prototype.convertCommentKey = '#comment';\n\n    XMLStringifier.prototype.convertRawKey = '#raw';\n\n    XMLStringifier.prototype.assertLegalChar = function(str) {\n      var regex, res;\n      if (this.options.noValidation) {\n        return str;\n      }\n      regex = '';\n      if (this.options.version === '1.0') {\n        regex = /[\\0-\\x08\\x0B\\f\\x0E-\\x1F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n        if (res = str.match(regex)) {\n          throw new Error(\"Invalid character in string: \" + str + \" at index \" + res.index);\n        }\n      } else if (this.options.version === '1.1') {\n        regex = /[\\0\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n        if (res = str.match(regex)) {\n          throw new Error(\"Invalid character in string: \" + str + \" at index \" + res.index);\n        }\n      }\n      return str;\n    };\n\n    XMLStringifier.prototype.assertLegalName = function(str) {\n      var regex;\n      if (this.options.noValidation) {\n        return str;\n      }\n      this.assertLegalChar(str);\n      regex = /^([:A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])([\\x2D\\.0-:A-Z_a-z\\xB7\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u203F\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])*$/;\n      if (!str.match(regex)) {\n        throw new Error(\"Invalid character in name\");\n      }\n      return str;\n    };\n\n    XMLStringifier.prototype.textEscape = function(str) {\n      var ampregex;\n      if (this.options.noValidation) {\n        return str;\n      }\n      ampregex = this.options.noDoubleEncoding ? /(?!&\\S+;)&/g : /&/g;\n      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\\r/g, '&#xD;');\n    };\n\n    XMLStringifier.prototype.attEscape = function(str) {\n      var ampregex;\n      if (this.options.noValidation) {\n        return str;\n      }\n      ampregex = this.options.noDoubleEncoding ? /(?!&\\S+;)&/g : /&/g;\n      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/\"/g, '&quot;').replace(/\\t/g, '&#x9;').replace(/\\n/g, '&#xA;').replace(/\\r/g, '&#xD;');\n    };\n\n    return XMLStringifier;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, XMLCharacterData, XMLText,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  NodeType = require('./NodeType');\n\n  XMLCharacterData = require('./XMLCharacterData');\n\n  module.exports = XMLText = (function(superClass) {\n    extend(XMLText, superClass);\n\n    function XMLText(parent, text) {\n      XMLText.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error(\"Missing element text. \" + this.debugInfo());\n      }\n      this.name = \"#text\";\n      this.type = NodeType.Text;\n      this.value = this.stringify.text(text);\n    }\n\n    Object.defineProperty(XMLText.prototype, 'isElementContentWhitespace', {\n      get: function() {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n\n    Object.defineProperty(XMLText.prototype, 'wholeText', {\n      get: function() {\n        var next, prev, str;\n        str = '';\n        prev = this.previousSibling;\n        while (prev) {\n          str = prev.data + str;\n          prev = prev.previousSibling;\n        }\n        str += this.data;\n        next = this.nextSibling;\n        while (next) {\n          str = str + next.data;\n          next = next.nextSibling;\n        }\n        return str;\n      }\n    });\n\n    XMLText.prototype.clone = function() {\n      return Object.create(this);\n    };\n\n    XMLText.prototype.toString = function(options) {\n      return this.options.writer.text(this, this.options.writer.filterOptions(options));\n    };\n\n    XMLText.prototype.splitText = function(offset) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    XMLText.prototype.replaceWholeText = function(content) {\n      throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n    };\n\n    return XMLText;\n\n  })(XMLCharacterData);\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, WriterState, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, assign,\n    hasProp = {}.hasOwnProperty;\n\n  assign = require('./Utility').assign;\n\n  NodeType = require('./NodeType');\n\n  XMLDeclaration = require('./XMLDeclaration');\n\n  XMLDocType = require('./XMLDocType');\n\n  XMLCData = require('./XMLCData');\n\n  XMLComment = require('./XMLComment');\n\n  XMLElement = require('./XMLElement');\n\n  XMLRaw = require('./XMLRaw');\n\n  XMLText = require('./XMLText');\n\n  XMLProcessingInstruction = require('./XMLProcessingInstruction');\n\n  XMLDummy = require('./XMLDummy');\n\n  XMLDTDAttList = require('./XMLDTDAttList');\n\n  XMLDTDElement = require('./XMLDTDElement');\n\n  XMLDTDEntity = require('./XMLDTDEntity');\n\n  XMLDTDNotation = require('./XMLDTDNotation');\n\n  WriterState = require('./WriterState');\n\n  module.exports = XMLWriterBase = (function() {\n    function XMLWriterBase(options) {\n      var key, ref, value;\n      options || (options = {});\n      this.options = options;\n      ref = options.writer || {};\n      for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this[\"_\" + key] = this[key];\n        this[key] = value;\n      }\n    }\n\n    XMLWriterBase.prototype.filterOptions = function(options) {\n      var filteredOptions, ref, ref1, ref2, ref3, ref4, ref5, ref6;\n      options || (options = {});\n      options = assign({}, this.options, options);\n      filteredOptions = {\n        writer: this\n      };\n      filteredOptions.pretty = options.pretty || false;\n      filteredOptions.allowEmpty = options.allowEmpty || false;\n      filteredOptions.indent = (ref = options.indent) != null ? ref : '  ';\n      filteredOptions.newline = (ref1 = options.newline) != null ? ref1 : '\\n';\n      filteredOptions.offset = (ref2 = options.offset) != null ? ref2 : 0;\n      filteredOptions.dontPrettyTextNodes = (ref3 = (ref4 = options.dontPrettyTextNodes) != null ? ref4 : options.dontprettytextnodes) != null ? ref3 : 0;\n      filteredOptions.spaceBeforeSlash = (ref5 = (ref6 = options.spaceBeforeSlash) != null ? ref6 : options.spacebeforeslash) != null ? ref5 : '';\n      if (filteredOptions.spaceBeforeSlash === true) {\n        filteredOptions.spaceBeforeSlash = ' ';\n      }\n      filteredOptions.suppressPrettyCount = 0;\n      filteredOptions.user = {};\n      filteredOptions.state = WriterState.None;\n      return filteredOptions;\n    };\n\n    XMLWriterBase.prototype.indent = function(node, options, level) {\n      var indentLevel;\n      if (!options.pretty || options.suppressPrettyCount) {\n        return '';\n      } else if (options.pretty) {\n        indentLevel = (level || 0) + options.offset + 1;\n        if (indentLevel > 0) {\n          return new Array(indentLevel).join(options.indent);\n        }\n      }\n      return '';\n    };\n\n    XMLWriterBase.prototype.endline = function(node, options, level) {\n      if (!options.pretty || options.suppressPrettyCount) {\n        return '';\n      } else {\n        return options.newline;\n      }\n    };\n\n    XMLWriterBase.prototype.attribute = function(att, options, level) {\n      var r;\n      this.openAttribute(att, options, level);\n      r = ' ' + att.name + '=\"' + att.value + '\"';\n      this.closeAttribute(att, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.cdata = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<![CDATA[';\n      options.state = WriterState.InsideTag;\n      r += node.value;\n      options.state = WriterState.CloseTag;\n      r += ']]>' + this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.comment = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<!-- ';\n      options.state = WriterState.InsideTag;\n      r += node.value;\n      options.state = WriterState.CloseTag;\n      r += ' -->' + this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.declaration = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<?xml';\n      options.state = WriterState.InsideTag;\n      r += ' version=\"' + node.version + '\"';\n      if (node.encoding != null) {\n        r += ' encoding=\"' + node.encoding + '\"';\n      }\n      if (node.standalone != null) {\n        r += ' standalone=\"' + node.standalone + '\"';\n      }\n      options.state = WriterState.CloseTag;\n      r += options.spaceBeforeSlash + '?>';\n      r += this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.docType = function(node, options, level) {\n      var child, i, len, r, ref;\n      level || (level = 0);\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level);\n      r += '<!DOCTYPE ' + node.root().name;\n      if (node.pubID && node.sysID) {\n        r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n      } else if (node.sysID) {\n        r += ' SYSTEM \"' + node.sysID + '\"';\n      }\n      if (node.children.length > 0) {\n        r += ' [';\n        r += this.endline(node, options, level);\n        options.state = WriterState.InsideTag;\n        ref = node.children;\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          r += this.writeChildNode(child, options, level + 1);\n        }\n        options.state = WriterState.CloseTag;\n        r += ']';\n      }\n      options.state = WriterState.CloseTag;\n      r += options.spaceBeforeSlash + '>';\n      r += this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.element = function(node, options, level) {\n      var att, child, childNodeCount, firstChildNode, i, j, len, len1, name, prettySuppressed, r, ref, ref1, ref2;\n      level || (level = 0);\n      prettySuppressed = false;\n      r = '';\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r += this.indent(node, options, level) + '<' + node.name;\n      ref = node.attribs;\n      for (name in ref) {\n        if (!hasProp.call(ref, name)) continue;\n        att = ref[name];\n        r += this.attribute(att, options, level);\n      }\n      childNodeCount = node.children.length;\n      firstChildNode = childNodeCount === 0 ? null : node.children[0];\n      if (childNodeCount === 0 || node.children.every(function(e) {\n        return (e.type === NodeType.Text || e.type === NodeType.Raw) && e.value === '';\n      })) {\n        if (options.allowEmpty) {\n          r += '>';\n          options.state = WriterState.CloseTag;\n          r += '</' + node.name + '>' + this.endline(node, options, level);\n        } else {\n          options.state = WriterState.CloseTag;\n          r += options.spaceBeforeSlash + '/>' + this.endline(node, options, level);\n        }\n      } else if (options.pretty && childNodeCount === 1 && (firstChildNode.type === NodeType.Text || firstChildNode.type === NodeType.Raw) && (firstChildNode.value != null)) {\n        r += '>';\n        options.state = WriterState.InsideTag;\n        options.suppressPrettyCount++;\n        prettySuppressed = true;\n        r += this.writeChildNode(firstChildNode, options, level + 1);\n        options.suppressPrettyCount--;\n        prettySuppressed = false;\n        options.state = WriterState.CloseTag;\n        r += '</' + node.name + '>' + this.endline(node, options, level);\n      } else {\n        if (options.dontPrettyTextNodes) {\n          ref1 = node.children;\n          for (i = 0, len = ref1.length; i < len; i++) {\n            child = ref1[i];\n            if ((child.type === NodeType.Text || child.type === NodeType.Raw) && (child.value != null)) {\n              options.suppressPrettyCount++;\n              prettySuppressed = true;\n              break;\n            }\n          }\n        }\n        r += '>' + this.endline(node, options, level);\n        options.state = WriterState.InsideTag;\n        ref2 = node.children;\n        for (j = 0, len1 = ref2.length; j < len1; j++) {\n          child = ref2[j];\n          r += this.writeChildNode(child, options, level + 1);\n        }\n        options.state = WriterState.CloseTag;\n        r += this.indent(node, options, level) + '</' + node.name + '>';\n        if (prettySuppressed) {\n          options.suppressPrettyCount--;\n        }\n        r += this.endline(node, options, level);\n        options.state = WriterState.None;\n      }\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.writeChildNode = function(node, options, level) {\n      switch (node.type) {\n        case NodeType.CData:\n          return this.cdata(node, options, level);\n        case NodeType.Comment:\n          return this.comment(node, options, level);\n        case NodeType.Element:\n          return this.element(node, options, level);\n        case NodeType.Raw:\n          return this.raw(node, options, level);\n        case NodeType.Text:\n          return this.text(node, options, level);\n        case NodeType.ProcessingInstruction:\n          return this.processingInstruction(node, options, level);\n        case NodeType.Dummy:\n          return '';\n        case NodeType.Declaration:\n          return this.declaration(node, options, level);\n        case NodeType.DocType:\n          return this.docType(node, options, level);\n        case NodeType.AttributeDeclaration:\n          return this.dtdAttList(node, options, level);\n        case NodeType.ElementDeclaration:\n          return this.dtdElement(node, options, level);\n        case NodeType.EntityDeclaration:\n          return this.dtdEntity(node, options, level);\n        case NodeType.NotationDeclaration:\n          return this.dtdNotation(node, options, level);\n        default:\n          throw new Error(\"Unknown XML node type: \" + node.constructor.name);\n      }\n    };\n\n    XMLWriterBase.prototype.processingInstruction = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<?';\n      options.state = WriterState.InsideTag;\n      r += node.target;\n      if (node.value) {\n        r += ' ' + node.value;\n      }\n      options.state = WriterState.CloseTag;\n      r += options.spaceBeforeSlash + '?>';\n      r += this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.raw = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level);\n      options.state = WriterState.InsideTag;\n      r += node.value;\n      options.state = WriterState.CloseTag;\n      r += this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.text = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level);\n      options.state = WriterState.InsideTag;\n      r += node.value;\n      options.state = WriterState.CloseTag;\n      r += this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.dtdAttList = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<!ATTLIST';\n      options.state = WriterState.InsideTag;\n      r += ' ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;\n      if (node.defaultValueType !== '#DEFAULT') {\n        r += ' ' + node.defaultValueType;\n      }\n      if (node.defaultValue) {\n        r += ' \"' + node.defaultValue + '\"';\n      }\n      options.state = WriterState.CloseTag;\n      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.dtdElement = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<!ELEMENT';\n      options.state = WriterState.InsideTag;\n      r += ' ' + node.name + ' ' + node.value;\n      options.state = WriterState.CloseTag;\n      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.dtdEntity = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<!ENTITY';\n      options.state = WriterState.InsideTag;\n      if (node.pe) {\n        r += ' %';\n      }\n      r += ' ' + node.name;\n      if (node.value) {\n        r += ' \"' + node.value + '\"';\n      } else {\n        if (node.pubID && node.sysID) {\n          r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n        } else if (node.sysID) {\n          r += ' SYSTEM \"' + node.sysID + '\"';\n        }\n        if (node.nData) {\n          r += ' NDATA ' + node.nData;\n        }\n      }\n      options.state = WriterState.CloseTag;\n      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.dtdNotation = function(node, options, level) {\n      var r;\n      this.openNode(node, options, level);\n      options.state = WriterState.OpenTag;\n      r = this.indent(node, options, level) + '<!NOTATION';\n      options.state = WriterState.InsideTag;\n      r += ' ' + node.name;\n      if (node.pubID && node.sysID) {\n        r += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n      } else if (node.pubID) {\n        r += ' PUBLIC \"' + node.pubID + '\"';\n      } else if (node.sysID) {\n        r += ' SYSTEM \"' + node.sysID + '\"';\n      }\n      options.state = WriterState.CloseTag;\n      r += options.spaceBeforeSlash + '>' + this.endline(node, options, level);\n      options.state = WriterState.None;\n      this.closeNode(node, options, level);\n      return r;\n    };\n\n    XMLWriterBase.prototype.openNode = function(node, options, level) {};\n\n    XMLWriterBase.prototype.closeNode = function(node, options, level) {};\n\n    XMLWriterBase.prototype.openAttribute = function(att, options, level) {};\n\n    XMLWriterBase.prototype.closeAttribute = function(att, options, level) {};\n\n    return XMLWriterBase;\n\n  })();\n\n}).call(this);\n","// Generated by CoffeeScript 1.12.7\n(function() {\n  var NodeType, WriterState, XMLDOMImplementation, XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;\n\n  ref = require('./Utility'), assign = ref.assign, isFunction = ref.isFunction;\n\n  XMLDOMImplementation = require('./XMLDOMImplementation');\n\n  XMLDocument = require('./XMLDocument');\n\n  XMLDocumentCB = require('./XMLDocumentCB');\n\n  XMLStringWriter = require('./XMLStringWriter');\n\n  XMLStreamWriter = require('./XMLStreamWriter');\n\n  NodeType = require('./NodeType');\n\n  WriterState = require('./WriterState');\n\n  module.exports.create = function(name, xmldec, doctype, options) {\n    var doc, root;\n    if (name == null) {\n      throw new Error(\"Root element needs a name.\");\n    }\n    options = assign({}, xmldec, doctype, options);\n    doc = new XMLDocument(options);\n    root = doc.element(name);\n    if (!options.headless) {\n      doc.declaration(options);\n      if ((options.pubID != null) || (options.sysID != null)) {\n        doc.dtd(options);\n      }\n    }\n    return root;\n  };\n\n  module.exports.begin = function(options, onData, onEnd) {\n    var ref1;\n    if (isFunction(options)) {\n      ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];\n      options = {};\n    }\n    if (onData) {\n      return new XMLDocumentCB(options, onData, onEnd);\n    } else {\n      return new XMLDocument(options);\n    }\n  };\n\n  module.exports.stringWriter = function(options) {\n    return new XMLStringWriter(options);\n  };\n\n  module.exports.streamWriter = function(stream, options) {\n    return new XMLStreamWriter(stream, options);\n  };\n\n  module.exports.implementation = new XMLDOMImplementation();\n\n  module.exports.nodeType = NodeType;\n\n  module.exports.writerState = WriterState;\n\n}).call(this);\n","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"punycode\");","module.exports = require(\"stream\");","module.exports = require(\"string_decoder\");","module.exports = require(\"timers\");","module.exports = require(\"url\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"zlib\");","import Stream from 'stream';\nimport http from 'http';\nimport Url from 'url';\nimport whatwgUrl from 'whatwg-url';\nimport https from 'https';\nimport zlib from 'zlib';\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n\n// fix for \"Readable\" isn't a named export issue\nconst Readable = Stream.Readable;\n\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\n\nclass Blob {\n\tconstructor() {\n\t\tthis[TYPE] = '';\n\n\t\tconst blobParts = arguments[0];\n\t\tconst options = arguments[1];\n\n\t\tconst buffers = [];\n\t\tlet size = 0;\n\n\t\tif (blobParts) {\n\t\t\tconst a = blobParts;\n\t\t\tconst length = Number(a.length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst element = a[i];\n\t\t\t\tlet buffer;\n\t\t\t\tif (element instanceof Buffer) {\n\t\t\t\t\tbuffer = element;\n\t\t\t\t} else if (ArrayBuffer.isView(element)) {\n\t\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n\t\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\t\tbuffer = Buffer.from(element);\n\t\t\t\t} else if (element instanceof Blob) {\n\t\t\t\t\tbuffer = element[BUFFER];\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\n\t\t\t\t}\n\t\t\t\tsize += buffer.length;\n\t\t\t\tbuffers.push(buffer);\n\t\t\t}\n\t\t}\n\n\t\tthis[BUFFER] = Buffer.concat(buffers);\n\n\t\tlet type = options && options.type !== undefined && String(options.type).toLowerCase();\n\t\tif (type && !/[^\\u0020-\\u007E]/.test(type)) {\n\t\t\tthis[TYPE] = type;\n\t\t}\n\t}\n\tget size() {\n\t\treturn this[BUFFER].length;\n\t}\n\tget type() {\n\t\treturn this[TYPE];\n\t}\n\ttext() {\n\t\treturn Promise.resolve(this[BUFFER].toString());\n\t}\n\tarrayBuffer() {\n\t\tconst buf = this[BUFFER];\n\t\tconst ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\treturn Promise.resolve(ab);\n\t}\n\tstream() {\n\t\tconst readable = new Readable();\n\t\treadable._read = function () {};\n\t\treadable.push(this[BUFFER]);\n\t\treadable.push(null);\n\t\treturn readable;\n\t}\n\ttoString() {\n\t\treturn '[object Blob]';\n\t}\n\tslice() {\n\t\tconst size = this.size;\n\n\t\tconst start = arguments[0];\n\t\tconst end = arguments[1];\n\t\tlet relativeStart, relativeEnd;\n\t\tif (start === undefined) {\n\t\t\trelativeStart = 0;\n\t\t} else if (start < 0) {\n\t\t\trelativeStart = Math.max(size + start, 0);\n\t\t} else {\n\t\t\trelativeStart = Math.min(start, size);\n\t\t}\n\t\tif (end === undefined) {\n\t\t\trelativeEnd = size;\n\t\t} else if (end < 0) {\n\t\t\trelativeEnd = Math.max(size + end, 0);\n\t\t} else {\n\t\t\trelativeEnd = Math.min(end, size);\n\t\t}\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\n\t\tconst buffer = this[BUFFER];\n\t\tconst slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n\t\tconst blob = new Blob([], { type: arguments[2] });\n\t\tblob[BUFFER] = slicedBuffer;\n\t\treturn blob;\n\t}\n}\n\nObject.defineProperties(Blob.prototype, {\n\tsize: { enumerable: true },\n\ttype: { enumerable: true },\n\tslice: { enumerable: true }\n});\n\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n\tvalue: 'Blob',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n\n  this.message = message;\n  this.type = type;\n\n  // when err.type is `system`, err.code contains system error code\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  }\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\n\nlet convert;\ntry {\n\tconvert = require('encoding').convert;\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals');\n\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = Stream.PassThrough;\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nfunction Body(body) {\n\tvar _this = this;\n\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$size = _ref.size;\n\n\tlet size = _ref$size === undefined ? 0 : _ref$size;\n\tvar _ref$timeout = _ref.timeout;\n\tlet timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n\tif (body == null) {\n\t\t// body is undefined or null\n\t\tbody = null;\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\tbody = Buffer.from(body.toString());\n\t} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\tbody = Buffer.from(body);\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t} else if (body instanceof Stream) ; else {\n\t\t// none of the above\n\t\t// coerce to string then buffer\n\t\tbody = Buffer.from(String(body));\n\t}\n\tthis[INTERNALS] = {\n\t\tbody,\n\t\tdisturbed: false,\n\t\terror: null\n\t};\n\tthis.size = size;\n\tthis.timeout = timeout;\n\n\tif (body instanceof Stream) {\n\t\tbody.on('error', function (err) {\n\t\t\tconst error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\n\t\t\t_this[INTERNALS].error = error;\n\t\t});\n\t}\n}\n\nBody.prototype = {\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t},\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t},\n\n\t/**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */\n\tarrayBuffer() {\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\t});\n\t},\n\n\t/**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */\n\tblob() {\n\t\tlet ct = this.headers && this.headers.get('content-type') || '';\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn Object.assign(\n\t\t\t// Prevent copying\n\t\t\tnew Blob([], {\n\t\t\t\ttype: ct.toLowerCase()\n\t\t\t}), {\n\t\t\t\t[BUFFER]: buf\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n  * Decode response as json\n  *\n  * @return  Promise\n  */\n\tjson() {\n\t\tvar _this2 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(buffer.toString());\n\t\t\t} catch (err) {\n\t\t\t\treturn Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n  * Decode response as text\n  *\n  * @return  Promise\n  */\n\ttext() {\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn buffer.toString();\n\t\t});\n\t},\n\n\t/**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */\n\tbuffer() {\n\t\treturn consumeBody.call(this);\n\t},\n\n\t/**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */\n\ttextConverted() {\n\t\tvar _this3 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn convertBody(buffer, _this3.headers);\n\t\t});\n\t}\n};\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: { enumerable: true },\n\tbodyUsed: { enumerable: true },\n\tarrayBuffer: { enumerable: true },\n\tblob: { enumerable: true },\n\tjson: { enumerable: true },\n\ttext: { enumerable: true }\n});\n\nBody.mixIn = function (proto) {\n\tfor (const name of Object.getOwnPropertyNames(Body.prototype)) {\n\t\t// istanbul ignore else: future proof\n\t\tif (!(name in proto)) {\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n\t\t\tObject.defineProperty(proto, name, desc);\n\t\t}\n\t}\n};\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */\nfunction consumeBody() {\n\tvar _this4 = this;\n\n\tif (this[INTERNALS].disturbed) {\n\t\treturn Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n\t}\n\n\tthis[INTERNALS].disturbed = true;\n\n\tif (this[INTERNALS].error) {\n\t\treturn Body.Promise.reject(this[INTERNALS].error);\n\t}\n\n\tlet body = this.body;\n\n\t// body is null\n\tif (body === null) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is blob\n\tif (isBlob(body)) {\n\t\tbody = body.stream();\n\t}\n\n\t// body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn Body.Promise.resolve(body);\n\t}\n\n\t// istanbul ignore if: should never happen\n\tif (!(body instanceof Stream)) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is stream\n\t// get ready to actually consume the body\n\tlet accum = [];\n\tlet accumBytes = 0;\n\tlet abort = false;\n\n\treturn new Body.Promise(function (resolve, reject) {\n\t\tlet resTimeout;\n\n\t\t// allow timeout on slow response body\n\t\tif (_this4.timeout) {\n\t\t\tresTimeout = setTimeout(function () {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\n\t\t\t}, _this4.timeout);\n\t\t}\n\n\t\t// handle stream errors\n\t\tbody.on('error', function (err) {\n\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t// if the request was aborted, reject with this Error\n\t\t\t\tabort = true;\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\t// other errors, such as incorrect content-encoding\n\t\t\t\treject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\n\t\tbody.on('data', function (chunk) {\n\t\t\tif (abort || chunk === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_this4.size && accumBytes + chunk.length > _this4.size) {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t});\n\n\t\tbody.on('end', function () {\n\t\t\tif (abort) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearTimeout(resTimeout);\n\n\t\t\ttry {\n\t\t\t\tresolve(Buffer.concat(accum, accumBytes));\n\t\t\t} catch (err) {\n\t\t\t\t// handle streams that have accumulated too much data (issue #414)\n\t\t\t\treject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n\tif (typeof convert !== 'function') {\n\t\tthrow new Error('The package `encoding` must be installed to use the textConverted() function');\n\t}\n\n\tconst ct = headers.get('content-type');\n\tlet charset = 'utf-8';\n\tlet res, str;\n\n\t// header\n\tif (ct) {\n\t\tres = /charset=([^;]*)/i.exec(ct);\n\t}\n\n\t// no charset in content type, peek at response body for at most 1024 bytes\n\tstr = buffer.slice(0, 1024).toString();\n\n\t// html5\n\tif (!res && str) {\n\t\tres = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// html4\n\tif (!res && str) {\n\t\tres = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\t\tif (!res) {\n\t\t\tres = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n\t\t\tif (res) {\n\t\t\t\tres.pop(); // drop last quote\n\t\t\t}\n\t\t}\n\n\t\tif (res) {\n\t\t\tres = /charset=(.*)/i.exec(res.pop());\n\t\t}\n\t}\n\n\t// xml\n\tif (!res && str) {\n\t\tres = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// found charset\n\tif (res) {\n\t\tcharset = res.pop();\n\n\t\t// prevent decode issues when sites use incorrect encoding\n\t\t// ref: https://hsivonen.fi/encoding-menu/\n\t\tif (charset === 'gb2312' || charset === 'gbk') {\n\t\t\tcharset = 'gb18030';\n\t\t}\n\t}\n\n\t// turn raw buffers into a single utf-8 buffer\n\treturn convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */\nfunction isURLSearchParams(obj) {\n\t// Duck-typing as a necessary condition.\n\tif (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\n\t\treturn false;\n\t}\n\n\t// Brand-checking and more duck-typing as optional condition.\n\treturn obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n}\n\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isBlob(obj) {\n\treturn typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nfunction clone(instance) {\n\tlet p1, p2;\n\tlet body = instance.body;\n\n\t// don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif (body instanceof Stream && typeof body.getBoundary !== 'function') {\n\t\t// tee instance body\n\t\tp1 = new PassThrough();\n\t\tp2 = new PassThrough();\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */\nfunction extractContentType(body) {\n\tif (body === null) {\n\t\t// body is null\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\t// body is string\n\t\treturn 'text/plain;charset=UTF-8';\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t} else if (isBlob(body)) {\n\t\t// body is blob\n\t\treturn body.type || null;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn null;\n\t} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\treturn null;\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\treturn null;\n\t} else if (typeof body.getBoundary === 'function') {\n\t\t// detect form data input from form-data module\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t} else if (body instanceof Stream) {\n\t\t// body is stream\n\t\t// can't really do much about this\n\t\treturn null;\n\t} else {\n\t\t// Body constructor defaults other things to string\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n}\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */\nfunction getTotalBytes(instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\treturn 0;\n\t} else if (isBlob(body)) {\n\t\treturn body.size;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn body.length;\n\t} else if (body && typeof body.getLengthSync === 'function') {\n\t\t// detect form data input from form-data module\n\t\tif (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n\t\tbody.hasKnownLength && body.hasKnownLength()) {\n\t\t\t// 2.x\n\t\t\treturn body.getLengthSync();\n\t\t}\n\t\treturn null;\n\t} else {\n\t\t// body is stream\n\t\treturn null;\n\t}\n}\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */\nfunction writeToStream(dest, instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\tbody.stream().pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// body is stream\n\t\tbody.pipe(dest);\n\t}\n}\n\n// expose Promise\nBody.Promise = global.Promise;\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nfunction validateName(name) {\n\tname = `${name}`;\n\tif (invalidTokenRegex.test(name) || name === '') {\n\t\tthrow new TypeError(`${name} is not a legal HTTP header name`);\n\t}\n}\n\nfunction validateValue(value) {\n\tvalue = `${value}`;\n\tif (invalidHeaderCharRegex.test(value)) {\n\t\tthrow new TypeError(`${value} is not a legal HTTP header value`);\n\t}\n}\n\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */\nfunction find(map, name) {\n\tname = name.toLowerCase();\n\tfor (const key in map) {\n\t\tif (key.toLowerCase() === name) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst MAP = Symbol('map');\nclass Headers {\n\t/**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */\n\tconstructor() {\n\t\tlet init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n\t\tthis[MAP] = Object.create(null);\n\n\t\tif (init instanceof Headers) {\n\t\t\tconst rawHeaders = init.raw();\n\t\t\tconst headerNames = Object.keys(rawHeaders);\n\n\t\t\tfor (const headerName of headerNames) {\n\t\t\t\tfor (const value of rawHeaders[headerName]) {\n\t\t\t\t\tthis.append(headerName, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't worry about converting prop to ByteString here as append()\n\t\t// will handle it.\n\t\tif (init == null) ; else if (typeof init === 'object') {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\tif (method != null) {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tconst pairs = [];\n\t\t\t\tfor (const pair of init) {\n\t\t\t\t\tif (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be iterable');\n\t\t\t\t\t}\n\t\t\t\t\tpairs.push(Array.from(pair));\n\t\t\t\t}\n\n\t\t\t\tfor (const pair of pairs) {\n\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t}\n\t\t\t\t\tthis.append(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// record<ByteString, ByteString>\n\t\t\t\tfor (const key of Object.keys(init)) {\n\t\t\t\t\tconst value = init[key];\n\t\t\t\t\tthis.append(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Provided initializer must be an object');\n\t\t}\n\t}\n\n\t/**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */\n\tget(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[MAP][key].join(', ');\n\t}\n\n\t/**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */\n\tforEach(callback) {\n\t\tlet thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n\t\tlet pairs = getHeaders(this);\n\t\tlet i = 0;\n\t\twhile (i < pairs.length) {\n\t\t\tvar _pairs$i = pairs[i];\n\t\t\tconst name = _pairs$i[0],\n\t\t\t      value = _pairs$i[1];\n\n\t\t\tcallback.call(thisArg, value, name, this);\n\t\t\tpairs = getHeaders(this);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tset(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tthis[MAP][key !== undefined ? key : name] = [value];\n\t}\n\n\t/**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tappend(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tthis[MAP][key].push(value);\n\t\t} else {\n\t\t\tthis[MAP][name] = [value];\n\t\t}\n\t}\n\n\t/**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */\n\thas(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\treturn find(this[MAP], name) !== undefined;\n\t}\n\n\t/**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */\n\tdelete(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tdelete this[MAP][key];\n\t\t}\n\t}\n\n\t/**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */\n\traw() {\n\t\treturn this[MAP];\n\t}\n\n\t/**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */\n\tkeys() {\n\t\treturn createHeadersIterator(this, 'key');\n\t}\n\n\t/**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */\n\tvalues() {\n\t\treturn createHeadersIterator(this, 'value');\n\t}\n\n\t/**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */\n\t[Symbol.iterator]() {\n\t\treturn createHeadersIterator(this, 'key+value');\n\t}\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n\tvalue: 'Headers',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Headers.prototype, {\n\tget: { enumerable: true },\n\tforEach: { enumerable: true },\n\tset: { enumerable: true },\n\tappend: { enumerable: true },\n\thas: { enumerable: true },\n\tdelete: { enumerable: true },\n\tkeys: { enumerable: true },\n\tvalues: { enumerable: true },\n\tentries: { enumerable: true }\n});\n\nfunction getHeaders(headers) {\n\tlet kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n\n\tconst keys = Object.keys(headers[MAP]).sort();\n\treturn keys.map(kind === 'key' ? function (k) {\n\t\treturn k.toLowerCase();\n\t} : kind === 'value' ? function (k) {\n\t\treturn headers[MAP][k].join(', ');\n\t} : function (k) {\n\t\treturn [k.toLowerCase(), headers[MAP][k].join(', ')];\n\t});\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n\tconst iterator = Object.create(HeadersIteratorPrototype);\n\titerator[INTERNAL] = {\n\t\ttarget,\n\t\tkind,\n\t\tindex: 0\n\t};\n\treturn iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n\tnext() {\n\t\t// istanbul ignore if\n\t\tif (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n\t\t\tthrow new TypeError('Value of `this` is not a HeadersIterator');\n\t\t}\n\n\t\tvar _INTERNAL = this[INTERNAL];\n\t\tconst target = _INTERNAL.target,\n\t\t      kind = _INTERNAL.kind,\n\t\t      index = _INTERNAL.index;\n\n\t\tconst values = getHeaders(target, kind);\n\t\tconst len = values.length;\n\t\tif (index >= len) {\n\t\t\treturn {\n\t\t\t\tvalue: undefined,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\n\t\tthis[INTERNAL].index = index + 1;\n\n\t\treturn {\n\t\t\tvalue: values[index],\n\t\t\tdone: false\n\t\t};\n\t}\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n\tvalue: 'HeadersIterator',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */\nfunction exportNodeCompatibleHeaders(headers) {\n\tconst obj = Object.assign({ __proto__: null }, headers[MAP]);\n\n\t// http.request() only supports string as Host header. This hack makes\n\t// specifying custom Host header possible.\n\tconst hostHeaderKey = find(headers[MAP], 'Host');\n\tif (hostHeaderKey !== undefined) {\n\t\tobj[hostHeaderKey] = obj[hostHeaderKey][0];\n\t}\n\n\treturn obj;\n}\n\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */\nfunction createHeadersLenient(obj) {\n\tconst headers = new Headers();\n\tfor (const name of Object.keys(obj)) {\n\t\tif (invalidTokenRegex.test(name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Array.isArray(obj[name])) {\n\t\t\tfor (const val of obj[name]) {\n\t\t\t\tif (invalidHeaderCharRegex.test(val)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (headers[MAP][name] === undefined) {\n\t\t\t\t\theaders[MAP][name] = [val];\n\t\t\t\t} else {\n\t\t\t\t\theaders[MAP][name].push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!invalidHeaderCharRegex.test(obj[name])) {\n\t\t\theaders[MAP][name] = [obj[name]];\n\t\t}\n\t}\n\treturn headers;\n}\n\nconst INTERNALS$1 = Symbol('Response internals');\n\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http.STATUS_CODES;\n\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nclass Response {\n\tconstructor() {\n\t\tlet body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\tlet opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tBody.call(this, body, opts);\n\n\t\tconst status = opts.status || 200;\n\t\tconst headers = new Headers(opts.headers);\n\n\t\tif (body != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS$1] = {\n\t\t\turl: opts.url,\n\t\t\tstatus,\n\t\t\tstatusText: opts.statusText || STATUS_CODES[status],\n\t\t\theaders,\n\t\t\tcounter: opts.counter\n\t\t};\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS$1].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS$1].status;\n\t}\n\n\t/**\n  * Convenience property representing if the request ended normally\n  */\n\tget ok() {\n\t\treturn this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS$1].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS$1].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$1].headers;\n\t}\n\n\t/**\n  * Clone this response\n  *\n  * @return  Response\n  */\n\tclone() {\n\t\treturn new Response(clone(this), {\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected\n\t\t});\n\t}\n}\n\nBody.mixIn(Response.prototype);\n\nObject.defineProperties(Response.prototype, {\n\turl: { enumerable: true },\n\tstatus: { enumerable: true },\n\tok: { enumerable: true },\n\tredirected: { enumerable: true },\n\tstatusText: { enumerable: true },\n\theaders: { enumerable: true },\n\tclone: { enumerable: true }\n});\n\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n\tvalue: 'Response',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nconst INTERNALS$2 = Symbol('Request internals');\nconst URL = Url.URL || whatwgUrl.URL;\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse;\nconst format_url = Url.format;\n\n/**\n * Wrapper around `new URL` to handle arbitrary URLs\n *\n * @param  {string} urlStr\n * @return {void}\n */\nfunction parseURL(urlStr) {\n\t/*\n \tCheck whether the URL is absolute or not\n \t\tScheme: https://tools.ietf.org/html/rfc3986#section-3.1\n \tAbsolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\n */\n\tif (/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.exec(urlStr)) {\n\t\turlStr = new URL(urlStr).toString();\n\t}\n\n\t// Fallback to old implementation for arbitrary URLs\n\treturn parse_url(urlStr);\n}\n\nconst streamDestructionSupported = 'destroy' in Stream.Readable.prototype;\n\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */\nfunction isRequest(input) {\n\treturn typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\n}\n\nfunction isAbortSignal(signal) {\n\tconst proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n\treturn !!(proto && proto.constructor.name === 'AbortSignal');\n}\n\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nclass Request {\n\tconstructor(input) {\n\t\tlet init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tlet parsedURL;\n\n\t\t// normalize input\n\t\tif (!isRequest(input)) {\n\t\t\tif (input && input.href) {\n\t\t\t\t// in order to support Node.js' Url objects; though WHATWG's URL objects\n\t\t\t\t// will fall into this branch also (since their `toString()` will return\n\t\t\t\t// `href` property anyway)\n\t\t\t\tparsedURL = parseURL(input.href);\n\t\t\t} else {\n\t\t\t\t// coerce input to a string before attempting to parse\n\t\t\t\tparsedURL = parseURL(`${input}`);\n\t\t\t}\n\t\t\tinput = {};\n\t\t} else {\n\t\t\tparsedURL = parseURL(input.url);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tmethod = method.toUpperCase();\n\n\t\tif ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tlet inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n\n\t\tBody.call(this, inputBody, {\n\t\t\ttimeout: init.timeout || input.timeout || 0,\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ? input.signal : null;\n\t\tif ('signal' in init) signal = init.signal;\n\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal');\n\t\t}\n\n\t\tthis[INTERNALS$2] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal\n\t\t};\n\n\t\t// node-fetch-only options\n\t\tthis.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n\t\tthis.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t}\n\n\tget method() {\n\t\treturn this[INTERNALS$2].method;\n\t}\n\n\tget url() {\n\t\treturn format_url(this[INTERNALS$2].parsedURL);\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$2].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS$2].redirect;\n\t}\n\n\tget signal() {\n\t\treturn this[INTERNALS$2].signal;\n\t}\n\n\t/**\n  * Clone this request\n  *\n  * @return  Request\n  */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n}\n\nBody.mixIn(Request.prototype);\n\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n\tvalue: 'Request',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Request.prototype, {\n\tmethod: { enumerable: true },\n\turl: { enumerable: true },\n\theaders: { enumerable: true },\n\tredirect: { enumerable: true },\n\tclone: { enumerable: true },\n\tsignal: { enumerable: true }\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nfunction getNodeRequestOptions(request) {\n\tconst parsedURL = request[INTERNALS$2].parsedURL;\n\tconst headers = new Headers(request[INTERNALS$2].headers);\n\n\t// fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// Basic fetch\n\tif (!parsedURL.protocol || !parsedURL.hostname) {\n\t\tthrow new TypeError('Only absolute URLs are supported');\n\t}\n\n\tif (!/^https?:$/.test(parsedURL.protocol)) {\n\t\tthrow new TypeError('Only HTTP(S) protocols are supported');\n\t}\n\n\tif (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {\n\t\tthrow new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\tif (request.body != null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\tif (typeof totalBytes === 'number') {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip,deflate');\n\t}\n\n\tlet agent = request.agent;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\tif (!headers.has('Connection') && !agent) {\n\t\theaders.set('Connection', 'close');\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\treturn Object.assign({}, parsedURL, {\n\t\tmethod: request.method,\n\t\theaders: exportNodeCompatibleHeaders(headers),\n\t\tagent\n\t});\n}\n\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */\n\n/**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */\nfunction AbortError(message) {\n  Error.call(this, message);\n\n  this.type = 'aborted';\n  this.message = message;\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = 'AbortError';\n\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = Stream.PassThrough;\nconst resolve_url = Url.resolve;\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction fetch(url, opts) {\n\n\t// allow custom promise\n\tif (!fetch.Promise) {\n\t\tthrow new Error('native promise missing, set fetch.Promise to your favorite alternative');\n\t}\n\n\tBody.Promise = fetch.Promise;\n\n\t// wrap http.request into fetch\n\treturn new fetch.Promise(function (resolve, reject) {\n\t\t// build request object\n\t\tconst request = new Request(url, opts);\n\t\tconst options = getNodeRequestOptions(request);\n\n\t\tconst send = (options.protocol === 'https:' ? https : http).request;\n\t\tconst signal = request.signal;\n\n\t\tlet response = null;\n\n\t\tconst abort = function abort() {\n\t\t\tlet error = new AbortError('The user aborted a request.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof Stream.Readable) {\n\t\t\t\trequest.body.destroy(error);\n\t\t\t}\n\t\t\tif (!response || !response.body) return;\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = function abortAndFinalize() {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// send request\n\t\tconst req = send(options);\n\t\tlet reqTimeout;\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tfunction finalize() {\n\t\t\treq.abort();\n\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\tclearTimeout(reqTimeout);\n\t\t}\n\n\t\tif (request.timeout) {\n\t\t\treq.once('socket', function (socket) {\n\t\t\t\treqTimeout = setTimeout(function () {\n\t\t\t\t\treject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n\t\t\t\t\tfinalize();\n\t\t\t\t}, request.timeout);\n\t\t\t});\n\t\t}\n\n\t\treq.on('error', function (err) {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n\t\t\tfinalize();\n\t\t});\n\n\t\treq.on('response', function (res) {\n\t\t\tclearTimeout(reqTimeout);\n\n\t\t\tconst headers = createHeadersLenient(res.headers);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (fetch.isRedirect(res.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tconst locationURL = location === null ? null : resolve_url(request.url, location);\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n\t\t\t\t\t\tif (locationURL !== null) {\n\t\t\t\t\t\t\t// handle corrupted header\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\theaders.set('Location', locationURL);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOpts = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\ttimeout: request.timeout,\n\t\t\t\t\t\t\tsize: request.size\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n\t\t\t\t\t\t\trequestOpts.method = 'GET';\n\t\t\t\t\t\t\trequestOpts.body = undefined;\n\t\t\t\t\t\t\trequestOpts.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOpts)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// prepare response\n\t\t\tres.once('end', function () {\n\t\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\t});\n\t\t\tlet body = res.pipe(new PassThrough$1());\n\n\t\t\tconst response_options = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: res.statusCode,\n\t\t\t\tstatusText: res.statusMessage,\n\t\t\t\theaders: headers,\n\t\t\t\tsize: request.size,\n\t\t\t\ttimeout: request.timeout,\n\t\t\t\tcounter: request.counter\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// for gzip\n\t\t\tif (codings == 'gzip' || codings == 'x-gzip') {\n\t\t\t\tbody = body.pipe(zlib.createGunzip(zlibOptions));\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for deflate\n\t\t\tif (codings == 'deflate' || codings == 'x-deflate') {\n\t\t\t\t// handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = res.pipe(new PassThrough$1());\n\t\t\t\traw.once('data', function (chunk) {\n\t\t\t\t\t// see http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflate());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = body.pipe(zlib.createInflateRaw());\n\t\t\t\t\t}\n\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for br\n\t\t\tif (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {\n\t\t\t\tbody = body.pipe(zlib.createBrotliDecompress());\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// otherwise, use response as-is\n\t\t\tresponse = new Response(body, response_options);\n\t\t\tresolve(response);\n\t\t});\n\n\t\twriteToStream(req, request);\n\t});\n}\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = function (code) {\n\treturn code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nfetch.Promise = global.Promise;\n\nexport default fetch;\nexport { Headers, Request, Response, FetchError };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export default function timeDifference(date1, date2) {\n  const difference = Math.floor(date1) - Math.floor(date2);\n\n  const diffInDays = Math.floor(difference / 60 / 60 / 24);\n  const diffInHours = Math.floor(difference / 60 / 60);\n  const diffInMinutes = Math.floor(difference / 60);\n  const diffInSeconds = Math.floor(difference);\n\n  return {\n    date1,\n    date2,\n    diffInDays,\n    diffInHours,\n    diffInMinutes,\n    diffInSeconds,\n  };\n}\n","import dotenv from 'dotenv';\nimport { Client, LogLevel } from '@notionhq/client';\n\ndotenv.config();\n\nconst {\n  NOTION_API_TOKEN,\n  NOTION_READER_DATABASE_ID,\n  NOTION_FEEDS_DATABASE_ID,\n  CI,\n} = process.env;\n\nconst logLevel = CI ? LogLevel.INFO : LogLevel.DEBUG;\n\nexport async function getFeedUrlsFromNotion() {\n  const notion = new Client({\n    auth: NOTION_API_TOKEN,\n    logLevel,\n  });\n\n  let response;\n  try {\n    response = await notion.databases.query({\n      database_id: NOTION_FEEDS_DATABASE_ID,\n      filter: {\n        or: [\n          {\n            property: 'Enabled',\n            checkbox: {\n              equals: true,\n            },\n          },\n        ],\n      },\n    });\n  } catch (err) {\n    console.error(err);\n    return [];\n  }\n\n  const feeds = response.results.map((item) => ({\n    title: item.properties.Title.title[0].plain_text,\n    feedUrl: item.properties.Link.url,\n    feedId: item.id,\n  }));\n\n  return feeds;\n}\n\nexport async function addFeedItemToNotion(notionItem) {\n  const { title, link, content, contentSnippet, feedId } = notionItem;\n\n  const parsedContent = [...`${title} ${contentSnippet}`.matchAll(/\\w{3,}/g)]\n    .join(' ')\n    .toLowerCase();\n\n  const notion = new Client({\n    auth: NOTION_API_TOKEN,\n    logLevel,\n  });\n\n  try {\n    await notion.pages.create({\n      parent: {\n        database_id: NOTION_READER_DATABASE_ID,\n      },\n      properties: {\n        Title: {\n          title: [\n            {\n              text: {\n                content: title,\n              },\n            },\n          ],\n        },\n        Link: {\n          url: link,\n        },\n        Source: {\n          relation: [\n            {\n              id: feedId,\n            },\n          ],\n        },\n        _parsedContent: {\n          rich_text: [\n            {\n              text: {\n                content: parsedContent,\n              },\n            },\n          ],\n        },\n      },\n      children: content,\n    });\n  } catch (err) {\n    console.error(err);\n  }\n}\n\nexport async function deleteOldUnreadFeedItemsFromNotion() {\n  const notion = new Client({\n    auth: NOTION_API_TOKEN,\n    logLevel,\n  });\n\n  // Create a datetime which is 30 days earlier than the current time\n  const fetchBeforeDate = new Date();\n  fetchBeforeDate.setDate(fetchBeforeDate.getDate() - 30);\n\n  // Query the feed reader database\n  // and fetch only those items that are unread or created before last 30 days\n  let response;\n  try {\n    response = await notion.databases.query({\n      database_id: NOTION_READER_DATABASE_ID,\n      filter: {\n        and: [\n          {\n            property: 'Created At',\n            date: {\n              on_or_before: fetchBeforeDate.toJSON(),\n            },\n          },\n          {\n            property: 'Read',\n            checkbox: {\n              equals: false,\n            },\n          },\n        ],\n      },\n    });\n  } catch (err) {\n    console.error(err);\n    return;\n  }\n\n  // Get the page IDs from the response\n  const feedItemsIds = response.results.map((item) => item.id);\n\n  for (let i = 0; i < feedItemsIds.length; i++) {\n    const id = feedItemsIds[i];\n    try {\n      await notion.pages.update({\n        page_id: id,\n        archived: true,\n      });\n    } catch (err) {\n      console.error(err);\n    }\n  }\n}\n","import Parser from 'rss-parser';\nimport timeDifference from './helpers';\nimport { getFeedUrlsFromNotion } from './notion';\n\nasync function getNewFeedItemsFrom(feedUrl) {\n  const parser = new Parser({\n    customFields: {\n      item: [['media:group', 'mediaGroup', { includeSnippet: true }]],\n    },\n  });\n  let rss;\n  try {\n    rss = await parser.parseURL(feedUrl);\n  } catch (error) {\n    console.error(error);\n    return [];\n  }\n  const todaysDate = new Date().getTime() / 1000;\n  return rss.items.filter((item) => {\n    const blogPublishedDate = new Date(item.pubDate).getTime() / 1000;\n    const { diffInDays } = timeDifference(todaysDate, blogPublishedDate);\n    return diffInDays === 0;\n  });\n}\n\nexport default async function* getNewFeedItems() {\n  const allNewFeedItems = [];\n  const feeds = await getFeedUrlsFromNotion();\n\n  for (let i = 0; i < feeds.length; i++) {\n    const { feedUrl, feedId } = feeds[i];\n    const feedItems = await getNewFeedItemsFrom(feedUrl);\n    const itemsContext = {\n      feedId,\n      feedUrl,\n      feedItems,\n    };\n\n    yield itemsContext;\n  }\n}\n","function extend (destination) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) destination[key] = source[key];\n    }\n  }\n  return destination\n}\n\nfunction repeat (character, count) {\n  return Array(count + 1).join(character)\n}\n\nfunction trimLeadingNewlines (string) {\n  return string.replace(/^\\n*/, '')\n}\n\nfunction trimTrailingNewlines (string) {\n  // avoid match-at-end regexp bottleneck, see #370\n  var indexEnd = string.length;\n  while (indexEnd > 0 && string[indexEnd - 1] === '\\n') indexEnd--;\n  return string.substring(0, indexEnd)\n}\n\nvar blockElements = [\n  'ADDRESS', 'ARTICLE', 'ASIDE', 'AUDIO', 'BLOCKQUOTE', 'BODY', 'CANVAS',\n  'CENTER', 'DD', 'DIR', 'DIV', 'DL', 'DT', 'FIELDSET', 'FIGCAPTION', 'FIGURE',\n  'FOOTER', 'FORM', 'FRAMESET', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HEADER',\n  'HGROUP', 'HR', 'HTML', 'ISINDEX', 'LI', 'MAIN', 'MENU', 'NAV', 'NOFRAMES',\n  'NOSCRIPT', 'OL', 'OUTPUT', 'P', 'PRE', 'SECTION', 'TABLE', 'TBODY', 'TD',\n  'TFOOT', 'TH', 'THEAD', 'TR', 'UL'\n];\n\nfunction isBlock (node) {\n  return is(node, blockElements)\n}\n\nvar voidElements = [\n  'AREA', 'BASE', 'BR', 'COL', 'COMMAND', 'EMBED', 'HR', 'IMG', 'INPUT',\n  'KEYGEN', 'LINK', 'META', 'PARAM', 'SOURCE', 'TRACK', 'WBR'\n];\n\nfunction isVoid (node) {\n  return is(node, voidElements)\n}\n\nfunction hasVoid (node) {\n  return has(node, voidElements)\n}\n\nvar meaningfulWhenBlankElements = [\n  'A', 'TABLE', 'THEAD', 'TBODY', 'TFOOT', 'TH', 'TD', 'IFRAME', 'SCRIPT',\n  'AUDIO', 'VIDEO'\n];\n\nfunction isMeaningfulWhenBlank (node) {\n  return is(node, meaningfulWhenBlankElements)\n}\n\nfunction hasMeaningfulWhenBlank (node) {\n  return has(node, meaningfulWhenBlankElements)\n}\n\nfunction is (node, tagNames) {\n  return tagNames.indexOf(node.nodeName) >= 0\n}\n\nfunction has (node, tagNames) {\n  return (\n    node.getElementsByTagName &&\n    tagNames.some(function (tagName) {\n      return node.getElementsByTagName(tagName).length\n    })\n  )\n}\n\nvar rules = {};\n\nrules.paragraph = {\n  filter: 'p',\n\n  replacement: function (content) {\n    return '\\n\\n' + content + '\\n\\n'\n  }\n};\n\nrules.lineBreak = {\n  filter: 'br',\n\n  replacement: function (content, node, options) {\n    return options.br + '\\n'\n  }\n};\n\nrules.heading = {\n  filter: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n\n  replacement: function (content, node, options) {\n    var hLevel = Number(node.nodeName.charAt(1));\n\n    if (options.headingStyle === 'setext' && hLevel < 3) {\n      var underline = repeat((hLevel === 1 ? '=' : '-'), content.length);\n      return (\n        '\\n\\n' + content + '\\n' + underline + '\\n\\n'\n      )\n    } else {\n      return '\\n\\n' + repeat('#', hLevel) + ' ' + content + '\\n\\n'\n    }\n  }\n};\n\nrules.blockquote = {\n  filter: 'blockquote',\n\n  replacement: function (content) {\n    content = content.replace(/^\\n+|\\n+$/g, '');\n    content = content.replace(/^/gm, '> ');\n    return '\\n\\n' + content + '\\n\\n'\n  }\n};\n\nrules.list = {\n  filter: ['ul', 'ol'],\n\n  replacement: function (content, node) {\n    var parent = node.parentNode;\n    if (parent.nodeName === 'LI' && parent.lastElementChild === node) {\n      return '\\n' + content\n    } else {\n      return '\\n\\n' + content + '\\n\\n'\n    }\n  }\n};\n\nrules.listItem = {\n  filter: 'li',\n\n  replacement: function (content, node, options) {\n    content = content\n      .replace(/^\\n+/, '') // remove leading newlines\n      .replace(/\\n+$/, '\\n') // replace trailing newlines with just a single one\n      .replace(/\\n/gm, '\\n    '); // indent\n    var prefix = options.bulletListMarker + '   ';\n    var parent = node.parentNode;\n    if (parent.nodeName === 'OL') {\n      var start = parent.getAttribute('start');\n      var index = Array.prototype.indexOf.call(parent.children, node);\n      prefix = (start ? Number(start) + index : index + 1) + '.  ';\n    }\n    return (\n      prefix + content + (node.nextSibling && !/\\n$/.test(content) ? '\\n' : '')\n    )\n  }\n};\n\nrules.indentedCodeBlock = {\n  filter: function (node, options) {\n    return (\n      options.codeBlockStyle === 'indented' &&\n      node.nodeName === 'PRE' &&\n      node.firstChild &&\n      node.firstChild.nodeName === 'CODE'\n    )\n  },\n\n  replacement: function (content, node, options) {\n    return (\n      '\\n\\n    ' +\n      node.firstChild.textContent.replace(/\\n/g, '\\n    ') +\n      '\\n\\n'\n    )\n  }\n};\n\nrules.fencedCodeBlock = {\n  filter: function (node, options) {\n    return (\n      options.codeBlockStyle === 'fenced' &&\n      node.nodeName === 'PRE' &&\n      node.firstChild &&\n      node.firstChild.nodeName === 'CODE'\n    )\n  },\n\n  replacement: function (content, node, options) {\n    var className = node.firstChild.getAttribute('class') || '';\n    var language = (className.match(/language-(\\S+)/) || [null, ''])[1];\n    var code = node.firstChild.textContent;\n\n    var fenceChar = options.fence.charAt(0);\n    var fenceSize = 3;\n    var fenceInCodeRegex = new RegExp('^' + fenceChar + '{3,}', 'gm');\n\n    var match;\n    while ((match = fenceInCodeRegex.exec(code))) {\n      if (match[0].length >= fenceSize) {\n        fenceSize = match[0].length + 1;\n      }\n    }\n\n    var fence = repeat(fenceChar, fenceSize);\n\n    return (\n      '\\n\\n' + fence + language + '\\n' +\n      code.replace(/\\n$/, '') +\n      '\\n' + fence + '\\n\\n'\n    )\n  }\n};\n\nrules.horizontalRule = {\n  filter: 'hr',\n\n  replacement: function (content, node, options) {\n    return '\\n\\n' + options.hr + '\\n\\n'\n  }\n};\n\nrules.inlineLink = {\n  filter: function (node, options) {\n    return (\n      options.linkStyle === 'inlined' &&\n      node.nodeName === 'A' &&\n      node.getAttribute('href')\n    )\n  },\n\n  replacement: function (content, node) {\n    var href = node.getAttribute('href');\n    var title = cleanAttribute(node.getAttribute('title'));\n    if (title) title = ' \"' + title + '\"';\n    return '[' + content + '](' + href + title + ')'\n  }\n};\n\nrules.referenceLink = {\n  filter: function (node, options) {\n    return (\n      options.linkStyle === 'referenced' &&\n      node.nodeName === 'A' &&\n      node.getAttribute('href')\n    )\n  },\n\n  replacement: function (content, node, options) {\n    var href = node.getAttribute('href');\n    var title = cleanAttribute(node.getAttribute('title'));\n    if (title) title = ' \"' + title + '\"';\n    var replacement;\n    var reference;\n\n    switch (options.linkReferenceStyle) {\n      case 'collapsed':\n        replacement = '[' + content + '][]';\n        reference = '[' + content + ']: ' + href + title;\n        break\n      case 'shortcut':\n        replacement = '[' + content + ']';\n        reference = '[' + content + ']: ' + href + title;\n        break\n      default:\n        var id = this.references.length + 1;\n        replacement = '[' + content + '][' + id + ']';\n        reference = '[' + id + ']: ' + href + title;\n    }\n\n    this.references.push(reference);\n    return replacement\n  },\n\n  references: [],\n\n  append: function (options) {\n    var references = '';\n    if (this.references.length) {\n      references = '\\n\\n' + this.references.join('\\n') + '\\n\\n';\n      this.references = []; // Reset references\n    }\n    return references\n  }\n};\n\nrules.emphasis = {\n  filter: ['em', 'i'],\n\n  replacement: function (content, node, options) {\n    if (!content.trim()) return ''\n    return options.emDelimiter + content + options.emDelimiter\n  }\n};\n\nrules.strong = {\n  filter: ['strong', 'b'],\n\n  replacement: function (content, node, options) {\n    if (!content.trim()) return ''\n    return options.strongDelimiter + content + options.strongDelimiter\n  }\n};\n\nrules.code = {\n  filter: function (node) {\n    var hasSiblings = node.previousSibling || node.nextSibling;\n    var isCodeBlock = node.parentNode.nodeName === 'PRE' && !hasSiblings;\n\n    return node.nodeName === 'CODE' && !isCodeBlock\n  },\n\n  replacement: function (content) {\n    if (!content) return ''\n    content = content.replace(/\\r?\\n|\\r/g, ' ');\n\n    var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? ' ' : '';\n    var delimiter = '`';\n    var matches = content.match(/`+/gm) || [];\n    while (matches.indexOf(delimiter) !== -1) delimiter = delimiter + '`';\n\n    return delimiter + extraSpace + content + extraSpace + delimiter\n  }\n};\n\nrules.image = {\n  filter: 'img',\n\n  replacement: function (content, node) {\n    var alt = cleanAttribute(node.getAttribute('alt'));\n    var src = node.getAttribute('src') || '';\n    var title = cleanAttribute(node.getAttribute('title'));\n    var titlePart = title ? ' \"' + title + '\"' : '';\n    return src ? '![' + alt + ']' + '(' + src + titlePart + ')' : ''\n  }\n};\n\nfunction cleanAttribute (attribute) {\n  return attribute ? attribute.replace(/(\\n+\\s*)+/g, '\\n') : ''\n}\n\n/**\n * Manages a collection of rules used to convert HTML to Markdown\n */\n\nfunction Rules (options) {\n  this.options = options;\n  this._keep = [];\n  this._remove = [];\n\n  this.blankRule = {\n    replacement: options.blankReplacement\n  };\n\n  this.keepReplacement = options.keepReplacement;\n\n  this.defaultRule = {\n    replacement: options.defaultReplacement\n  };\n\n  this.array = [];\n  for (var key in options.rules) this.array.push(options.rules[key]);\n}\n\nRules.prototype = {\n  add: function (key, rule) {\n    this.array.unshift(rule);\n  },\n\n  keep: function (filter) {\n    this._keep.unshift({\n      filter: filter,\n      replacement: this.keepReplacement\n    });\n  },\n\n  remove: function (filter) {\n    this._remove.unshift({\n      filter: filter,\n      replacement: function () {\n        return ''\n      }\n    });\n  },\n\n  forNode: function (node) {\n    if (node.isBlank) return this.blankRule\n    var rule;\n\n    if ((rule = findRule(this.array, node, this.options))) return rule\n    if ((rule = findRule(this._keep, node, this.options))) return rule\n    if ((rule = findRule(this._remove, node, this.options))) return rule\n\n    return this.defaultRule\n  },\n\n  forEach: function (fn) {\n    for (var i = 0; i < this.array.length; i++) fn(this.array[i], i);\n  }\n};\n\nfunction findRule (rules, node, options) {\n  for (var i = 0; i < rules.length; i++) {\n    var rule = rules[i];\n    if (filterValue(rule, node, options)) return rule\n  }\n  return void 0\n}\n\nfunction filterValue (rule, node, options) {\n  var filter = rule.filter;\n  if (typeof filter === 'string') {\n    if (filter === node.nodeName.toLowerCase()) return true\n  } else if (Array.isArray(filter)) {\n    if (filter.indexOf(node.nodeName.toLowerCase()) > -1) return true\n  } else if (typeof filter === 'function') {\n    if (filter.call(rule, node, options)) return true\n  } else {\n    throw new TypeError('`filter` needs to be a string, array, or function')\n  }\n}\n\n/**\n * The collapseWhitespace function is adapted from collapse-whitespace\n * by Luc Thevenard.\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Luc Thevenard <lucthevenard@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * collapseWhitespace(options) removes extraneous whitespace from an the given element.\n *\n * @param {Object} options\n */\nfunction collapseWhitespace (options) {\n  var element = options.element;\n  var isBlock = options.isBlock;\n  var isVoid = options.isVoid;\n  var isPre = options.isPre || function (node) {\n    return node.nodeName === 'PRE'\n  };\n\n  if (!element.firstChild || isPre(element)) return\n\n  var prevText = null;\n  var keepLeadingWs = false;\n\n  var prev = null;\n  var node = next(prev, element, isPre);\n\n  while (node !== element) {\n    if (node.nodeType === 3 || node.nodeType === 4) { // Node.TEXT_NODE or Node.CDATA_SECTION_NODE\n      var text = node.data.replace(/[ \\r\\n\\t]+/g, ' ');\n\n      if ((!prevText || / $/.test(prevText.data)) &&\n          !keepLeadingWs && text[0] === ' ') {\n        text = text.substr(1);\n      }\n\n      // `text` might be empty at this point.\n      if (!text) {\n        node = remove(node);\n        continue\n      }\n\n      node.data = text;\n\n      prevText = node;\n    } else if (node.nodeType === 1) { // Node.ELEMENT_NODE\n      if (isBlock(node) || node.nodeName === 'BR') {\n        if (prevText) {\n          prevText.data = prevText.data.replace(/ $/, '');\n        }\n\n        prevText = null;\n        keepLeadingWs = false;\n      } else if (isVoid(node) || isPre(node)) {\n        // Avoid trimming space around non-block, non-BR void elements and inline PRE.\n        prevText = null;\n        keepLeadingWs = true;\n      } else if (prevText) {\n        // Drop protection if set previously.\n        keepLeadingWs = false;\n      }\n    } else {\n      node = remove(node);\n      continue\n    }\n\n    var nextNode = next(prev, node, isPre);\n    prev = node;\n    node = nextNode;\n  }\n\n  if (prevText) {\n    prevText.data = prevText.data.replace(/ $/, '');\n    if (!prevText.data) {\n      remove(prevText);\n    }\n  }\n}\n\n/**\n * remove(node) removes the given node from the DOM and returns the\n * next node in the sequence.\n *\n * @param {Node} node\n * @return {Node} node\n */\nfunction remove (node) {\n  var next = node.nextSibling || node.parentNode;\n\n  node.parentNode.removeChild(node);\n\n  return next\n}\n\n/**\n * next(prev, current, isPre) returns the next node in the sequence, given the\n * current and previous nodes.\n *\n * @param {Node} prev\n * @param {Node} current\n * @param {Function} isPre\n * @return {Node}\n */\nfunction next (prev, current, isPre) {\n  if ((prev && prev.parentNode === current) || isPre(current)) {\n    return current.nextSibling || current.parentNode\n  }\n\n  return current.firstChild || current.nextSibling || current.parentNode\n}\n\n/*\n * Set up window for Node.js\n */\n\nvar root = (typeof window !== 'undefined' ? window : {});\n\n/*\n * Parsing HTML strings\n */\n\nfunction canParseHTMLNatively () {\n  var Parser = root.DOMParser;\n  var canParse = false;\n\n  // Adapted from https://gist.github.com/1129031\n  // Firefox/Opera/IE throw errors on unsupported types\n  try {\n    // WebKit returns null on unsupported types\n    if (new Parser().parseFromString('', 'text/html')) {\n      canParse = true;\n    }\n  } catch (e) {}\n\n  return canParse\n}\n\nfunction createHTMLParser () {\n  var Parser = function () {};\n\n  {\n    var domino = require('domino');\n    Parser.prototype.parseFromString = function (string) {\n      return domino.createDocument(string)\n    };\n  }\n  return Parser\n}\n\nvar HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();\n\nfunction RootNode (input, options) {\n  var root;\n  if (typeof input === 'string') {\n    var doc = htmlParser().parseFromString(\n      // DOM parsers arrange elements in the <head> and <body>.\n      // Wrapping in a custom element ensures elements are reliably arranged in\n      // a single element.\n      '<x-turndown id=\"turndown-root\">' + input + '</x-turndown>',\n      'text/html'\n    );\n    root = doc.getElementById('turndown-root');\n  } else {\n    root = input.cloneNode(true);\n  }\n  collapseWhitespace({\n    element: root,\n    isBlock: isBlock,\n    isVoid: isVoid,\n    isPre: options.preformattedCode ? isPreOrCode : null\n  });\n\n  return root\n}\n\nvar _htmlParser;\nfunction htmlParser () {\n  _htmlParser = _htmlParser || new HTMLParser();\n  return _htmlParser\n}\n\nfunction isPreOrCode (node) {\n  return node.nodeName === 'PRE' || node.nodeName === 'CODE'\n}\n\nfunction Node (node, options) {\n  node.isBlock = isBlock(node);\n  node.isCode = node.nodeName === 'CODE' || node.parentNode.isCode;\n  node.isBlank = isBlank(node);\n  node.flankingWhitespace = flankingWhitespace(node, options);\n  return node\n}\n\nfunction isBlank (node) {\n  return (\n    !isVoid(node) &&\n    !isMeaningfulWhenBlank(node) &&\n    /^\\s*$/i.test(node.textContent) &&\n    !hasVoid(node) &&\n    !hasMeaningfulWhenBlank(node)\n  )\n}\n\nfunction flankingWhitespace (node, options) {\n  if (node.isBlock || (options.preformattedCode && node.isCode)) {\n    return { leading: '', trailing: '' }\n  }\n\n  var edges = edgeWhitespace(node.textContent);\n\n  // abandon leading ASCII WS if left-flanked by ASCII WS\n  if (edges.leadingAscii && isFlankedByWhitespace('left', node, options)) {\n    edges.leading = edges.leadingNonAscii;\n  }\n\n  // abandon trailing ASCII WS if right-flanked by ASCII WS\n  if (edges.trailingAscii && isFlankedByWhitespace('right', node, options)) {\n    edges.trailing = edges.trailingNonAscii;\n  }\n\n  return { leading: edges.leading, trailing: edges.trailing }\n}\n\nfunction edgeWhitespace (string) {\n  var m = string.match(/^(([ \\t\\r\\n]*)(\\s*))[\\s\\S]*?((\\s*?)([ \\t\\r\\n]*))$/);\n  return {\n    leading: m[1], // whole string for whitespace-only strings\n    leadingAscii: m[2],\n    leadingNonAscii: m[3],\n    trailing: m[4], // empty for whitespace-only strings\n    trailingNonAscii: m[5],\n    trailingAscii: m[6]\n  }\n}\n\nfunction isFlankedByWhitespace (side, node, options) {\n  var sibling;\n  var regExp;\n  var isFlanked;\n\n  if (side === 'left') {\n    sibling = node.previousSibling;\n    regExp = / $/;\n  } else {\n    sibling = node.nextSibling;\n    regExp = /^ /;\n  }\n\n  if (sibling) {\n    if (sibling.nodeType === 3) {\n      isFlanked = regExp.test(sibling.nodeValue);\n    } else if (options.preformattedCode && sibling.nodeName === 'CODE') {\n      isFlanked = false;\n    } else if (sibling.nodeType === 1 && !isBlock(sibling)) {\n      isFlanked = regExp.test(sibling.textContent);\n    }\n  }\n  return isFlanked\n}\n\nvar reduce = Array.prototype.reduce;\nvar escapes = [\n  [/\\\\/g, '\\\\\\\\'],\n  [/\\*/g, '\\\\*'],\n  [/^-/g, '\\\\-'],\n  [/^\\+ /g, '\\\\+ '],\n  [/^(=+)/g, '\\\\$1'],\n  [/^(#{1,6}) /g, '\\\\$1 '],\n  [/`/g, '\\\\`'],\n  [/^~~~/g, '\\\\~~~'],\n  [/\\[/g, '\\\\['],\n  [/\\]/g, '\\\\]'],\n  [/^>/g, '\\\\>'],\n  [/_/g, '\\\\_'],\n  [/^(\\d+)\\. /g, '$1\\\\. ']\n];\n\nfunction TurndownService (options) {\n  if (!(this instanceof TurndownService)) return new TurndownService(options)\n\n  var defaults = {\n    rules: rules,\n    headingStyle: 'setext',\n    hr: '* * *',\n    bulletListMarker: '*',\n    codeBlockStyle: 'indented',\n    fence: '```',\n    emDelimiter: '_',\n    strongDelimiter: '**',\n    linkStyle: 'inlined',\n    linkReferenceStyle: 'full',\n    br: '  ',\n    preformattedCode: false,\n    blankReplacement: function (content, node) {\n      return node.isBlock ? '\\n\\n' : ''\n    },\n    keepReplacement: function (content, node) {\n      return node.isBlock ? '\\n\\n' + node.outerHTML + '\\n\\n' : node.outerHTML\n    },\n    defaultReplacement: function (content, node) {\n      return node.isBlock ? '\\n\\n' + content + '\\n\\n' : content\n    }\n  };\n  this.options = extend({}, defaults, options);\n  this.rules = new Rules(this.options);\n}\n\nTurndownService.prototype = {\n  /**\n   * The entry point for converting a string or DOM node to Markdown\n   * @public\n   * @param {String|HTMLElement} input The string or DOM node to convert\n   * @returns A Markdown representation of the input\n   * @type String\n   */\n\n  turndown: function (input) {\n    if (!canConvert(input)) {\n      throw new TypeError(\n        input + ' is not a string, or an element/document/fragment node.'\n      )\n    }\n\n    if (input === '') return ''\n\n    var output = process.call(this, new RootNode(input, this.options));\n    return postProcess.call(this, output)\n  },\n\n  /**\n   * Add one or more plugins\n   * @public\n   * @param {Function|Array} plugin The plugin or array of plugins to add\n   * @returns The Turndown instance for chaining\n   * @type Object\n   */\n\n  use: function (plugin) {\n    if (Array.isArray(plugin)) {\n      for (var i = 0; i < plugin.length; i++) this.use(plugin[i]);\n    } else if (typeof plugin === 'function') {\n      plugin(this);\n    } else {\n      throw new TypeError('plugin must be a Function or an Array of Functions')\n    }\n    return this\n  },\n\n  /**\n   * Adds a rule\n   * @public\n   * @param {String} key The unique key of the rule\n   * @param {Object} rule The rule\n   * @returns The Turndown instance for chaining\n   * @type Object\n   */\n\n  addRule: function (key, rule) {\n    this.rules.add(key, rule);\n    return this\n  },\n\n  /**\n   * Keep a node (as HTML) that matches the filter\n   * @public\n   * @param {String|Array|Function} filter The unique key of the rule\n   * @returns The Turndown instance for chaining\n   * @type Object\n   */\n\n  keep: function (filter) {\n    this.rules.keep(filter);\n    return this\n  },\n\n  /**\n   * Remove a node that matches the filter\n   * @public\n   * @param {String|Array|Function} filter The unique key of the rule\n   * @returns The Turndown instance for chaining\n   * @type Object\n   */\n\n  remove: function (filter) {\n    this.rules.remove(filter);\n    return this\n  },\n\n  /**\n   * Escapes Markdown syntax\n   * @public\n   * @param {String} string The string to escape\n   * @returns A string with Markdown syntax escaped\n   * @type String\n   */\n\n  escape: function (string) {\n    return escapes.reduce(function (accumulator, escape) {\n      return accumulator.replace(escape[0], escape[1])\n    }, string)\n  }\n};\n\n/**\n * Reduces a DOM node down to its Markdown string equivalent\n * @private\n * @param {HTMLElement} parentNode The node to convert\n * @returns A Markdown representation of the node\n * @type String\n */\n\nfunction process (parentNode) {\n  var self = this;\n  return reduce.call(parentNode.childNodes, function (output, node) {\n    node = new Node(node, self.options);\n\n    var replacement = '';\n    if (node.nodeType === 3) {\n      replacement = node.isCode ? node.nodeValue : self.escape(node.nodeValue);\n    } else if (node.nodeType === 1) {\n      replacement = replacementForNode.call(self, node);\n    }\n\n    return join(output, replacement)\n  }, '')\n}\n\n/**\n * Appends strings as each rule requires and trims the output\n * @private\n * @param {String} output The conversion output\n * @returns A trimmed version of the ouput\n * @type String\n */\n\nfunction postProcess (output) {\n  var self = this;\n  this.rules.forEach(function (rule) {\n    if (typeof rule.append === 'function') {\n      output = join(output, rule.append(self.options));\n    }\n  });\n\n  return output.replace(/^[\\t\\r\\n]+/, '').replace(/[\\t\\r\\n\\s]+$/, '')\n}\n\n/**\n * Converts an element node to its Markdown equivalent\n * @private\n * @param {HTMLElement} node The node to convert\n * @returns A Markdown representation of the node\n * @type String\n */\n\nfunction replacementForNode (node) {\n  var rule = this.rules.forNode(node);\n  var content = process.call(this, node);\n  var whitespace = node.flankingWhitespace;\n  if (whitespace.leading || whitespace.trailing) content = content.trim();\n  return (\n    whitespace.leading +\n    rule.replacement(content, node, this.options) +\n    whitespace.trailing\n  )\n}\n\n/**\n * Joins replacement to the current output with appropriate number of new lines\n * @private\n * @param {String} output The current conversion output\n * @param {String} replacement The string to append to the output\n * @returns Joined output\n * @type String\n */\n\nfunction join (output, replacement) {\n  var s1 = trimTrailingNewlines(output);\n  var s2 = trimLeadingNewlines(replacement);\n  var nls = Math.max(output.length - s1.length, replacement.length - s2.length);\n  var separator = '\\n\\n'.substring(0, nls);\n\n  return s1 + separator + s2\n}\n\n/**\n * Determines whether an input can be converted\n * @private\n * @param {String|HTMLElement} input Describe this parameter\n * @returns Describe what it returns\n * @type String|Object|Array|Boolean|Number\n */\n\nfunction canConvert (input) {\n  return (\n    input != null && (\n      typeof input === 'string' ||\n      (input.nodeType && (\n        input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11\n      ))\n    )\n  )\n}\n\nexport default TurndownService;\n","import { markdownToBlocks } from '@tryfabric/martian';\nimport TurndownService from 'turndown';\n\nfunction htmlToMarkdownJSON(htmlContent) {\n  try {\n    const turndownService = new TurndownService();\n    return turndownService.turndown(htmlContent);\n  } catch (error) {\n    console.error(error);\n    return {};\n  }\n}\n\nfunction jsonToNotionBlocks(markdownContent) {\n  return markdownToBlocks(markdownContent);\n}\n\nexport default function htmlToNotionBlocks(htmlContent) {\n  const markdownJson = htmlToMarkdownJSON(htmlContent);\n  return jsonToNotionBlocks(markdownJson);\n}\n","import getNewFeedItems from './feed';\nimport {\n  addFeedItemToNotion,\n  deleteOldUnreadFeedItemsFromNotion,\n} from './notion';\nimport htmlToNotionBlocks from './parser';\n\nasync function index() {\n  const generator = getNewFeedItems();\n  let i;\n  do {\n    i = await generator.next();\n    const feed = i.value;\n    feed.feedItems.forEach(async (item) => {\n      const content =\n        item.content || item.mediaGroup['media:description'].join() || '';\n\n      const notionItem = {\n        feedId: feed.feedId,\n        title: item.title,\n        link: item.link,\n        content: content.length ? htmlToNotionBlocks(content) : null,\n        contentSnippet: content.length ? content : null,\n      };\n      await addFeedItemToNotion(notionItem);\n    });\n  } while (!i.done);\n\n  await deleteOldUnreadFeedItemsFromNotion();\n}\n\nindex();\n"],"names":["timeDifference","date1","date2","difference","Math","floor","diffInDays","diffInHours","diffInMinutes","diffInSeconds","dotenv","Client","LogLevel","config","NOTION_API_TOKEN","NOTION_READER_DATABASE_ID","NOTION_FEEDS_DATABASE_ID","CI","process","env","logLevel","INFO","DEBUG","getFeedUrlsFromNotion","notion","auth","response","databases","query","database_id","filter","or","property","checkbox","equals","err","console","error","feeds","results","map","item","title","properties","Title","plain_text","feedUrl","Link","url","feedId","id","addFeedItemToNotion","notionItem","link","content","contentSnippet","parsedContent","matchAll","join","toLowerCase","pages","create","parent","text","Source","relation","_parsedContent","rich_text","children","deleteOldUnreadFeedItemsFromNotion","fetchBeforeDate","Date","setDate","getDate","and","date","on_or_before","toJSON","feedItemsIds","i","length","update","page_id","archived","Parser","getNewFeedItemsFrom","parser","customFields","includeSnippet","rss","parseURL","todaysDate","getTime","items","blogPublishedDate","pubDate","getNewFeedItems","allNewFeedItems","feedItems","itemsContext","markdownToBlocks","TurndownService","htmlToMarkdownJSON","htmlContent","turndownService","turndown","jsonToNotionBlocks","markdownContent","htmlToNotionBlocks","markdownJson","index","generator","next","feed","value","forEach","mediaGroup","done"],"sourceRoot":""}